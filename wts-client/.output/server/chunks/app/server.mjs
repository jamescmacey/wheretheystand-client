import { v as vue_cjs_prod, s as serverRenderer } from '../handlers/renderer.mjs';
import { hasProtocol, isEqual as isEqual$1, withBase, withQuery, joinURL } from 'ufo';
import { format, parse as parse$2, formatDistanceToNow, parseISO } from 'date-fns';
import { defineStore, createPinia, setActivePinia } from 'pinia/dist/pinia.mjs';
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome';
import require$$2$1 from 'fs';
import require$$0$3 from 'url';
import require$$1 from 'util';
import require$$0$2__default from 'stream';
import require$$4 from 'http';
import require$$1$3 from 'https';
import require$$0$1 from 'dns';
import require$$2 from 'os';
import require$$1$1 from 'zlib';
import require$$0$4 from 'http2';
import require$$1$2 from 'tls';
import require$$0$5 from 'net';
import require$$1$4 from 'path';
import require$$0$6 from 'crypto';
import * as Chartjs from 'chart.js';
import { cloneDeep, isEqual, isEmpty } from 'lodash-es';
import { Harmonizer } from 'color-harmony';
import { u as useRuntimeConfig$1 } from '../nitro/node-server.mjs';
import 'h3';
import 'unenv/runtime/mock/proxy';
import 'node-fetch-native/polyfill';
import 'destr';
import 'ohmyfetch';
import 'radix3';
import 'unenv/runtime/fetch/index';
import 'hookable';
import 'scule';
import 'ohash';
import 'unstorage';
import 'pathe';

var vueRouter_cjs = {};

/*!
  * vue-router v4.0.16
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */

(function (exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	var vue = vue_cjs_prod;

	const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	const PolySymbol = (name) => 
	// vr = vue router
	hasSymbol
	    ? Symbol('[vue-router]: ' + name )
	    : ('[vue-router]: ' ) + name;
	// rvlm = Router View Location Matched
	/**
	 * RouteRecord being rendered by the closest ancestor Router View. Used for
	 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
	 * Location Matched
	 *
	 * @internal
	 */
	const matchedRouteKey = /*#__PURE__*/ PolySymbol('router view location matched' );
	/**
	 * Allows overriding the router view depth to control which component in
	 * `matched` is rendered. rvd stands for Router View Depth
	 *
	 * @internal
	 */
	const viewDepthKey = /*#__PURE__*/ PolySymbol('router view depth' );
	/**
	 * Allows overriding the router instance returned by `useRouter` in tests. r
	 * stands for router
	 *
	 * @internal
	 */
	const routerKey = /*#__PURE__*/ PolySymbol('router' );
	/**
	 * Allows overriding the current route returned by `useRoute` in tests. rl
	 * stands for route location
	 *
	 * @internal
	 */
	const routeLocationKey = /*#__PURE__*/ PolySymbol('route location' );
	/**
	 * Allows overriding the current route used by router-view. Internally this is
	 * used when the `route` prop is passed.
	 *
	 * @internal
	 */
	const routerViewLocationKey = /*#__PURE__*/ PolySymbol('router view location' );

	function isESModule(obj) {
	    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');
	}
	const assign = Object.assign;
	function applyToParams(fn, params) {
	    const newParams = {};
	    for (const key in params) {
	        const value = params[key];
	        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
	    }
	    return newParams;
	}
	const noop = () => { };

	function warn(msg) {
	    // avoid using ...args as it breaks in older Edge builds
	    const args = Array.from(arguments).slice(1);
	    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
	}

	const TRAILING_SLASH_RE = /\/$/;
	const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');
	/**
	 * Transforms an URI into a normalized history location
	 *
	 * @param parseQuery
	 * @param location - URI to normalize
	 * @param currentLocation - current absolute location. Allows resolving relative
	 * paths. Must start with `/`. Defaults to `/`
	 * @returns a normalized history location
	 */
	function parseURL(parseQuery, location, currentLocation = '/') {
	    let path, query = {}, searchString = '', hash = '';
	    // Could use URL and URLSearchParams but IE 11 doesn't support it
	    const searchPos = location.indexOf('?');
	    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);
	    if (searchPos > -1) {
	        path = location.slice(0, searchPos);
	        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
	        query = parseQuery(searchString);
	    }
	    if (hashPos > -1) {
	        path = path || location.slice(0, hashPos);
	        // keep the # character
	        hash = location.slice(hashPos, location.length);
	    }
	    // no search and no query
	    path = resolveRelativePath(path != null ? path : location, currentLocation);
	    // empty path means a relative query or hash `?foo=f`, `#thing`
	    return {
	        fullPath: path + (searchString && '?') + searchString + hash,
	        path,
	        query,
	        hash,
	    };
	}
	/**
	 * Stringifies a URL object
	 *
	 * @param stringifyQuery
	 * @param location
	 */
	function stringifyURL(stringifyQuery, location) {
	    const query = location.query ? stringifyQuery(location.query) : '';
	    return location.path + (query && '?') + query + (location.hash || '');
	}
	/**
	 * Strips off the base from the beginning of a location.pathname in a non
	 * case-sensitive way.
	 *
	 * @param pathname - location.pathname
	 * @param base - base to strip off
	 */
	function stripBase(pathname, base) {
	    // no base or base is not found at the beginning
	    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
	        return pathname;
	    return pathname.slice(base.length) || '/';
	}
	/**
	 * Checks if two RouteLocation are equal. This means that both locations are
	 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
	 * parameters and `hash` are the same
	 *
	 * @param a - first {@link RouteLocation}
	 * @param b - second {@link RouteLocation}
	 */
	function isSameRouteLocation(stringifyQuery, a, b) {
	    const aLastIndex = a.matched.length - 1;
	    const bLastIndex = b.matched.length - 1;
	    return (aLastIndex > -1 &&
	        aLastIndex === bLastIndex &&
	        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
	        isSameRouteLocationParams(a.params, b.params) &&
	        stringifyQuery(a.query) === stringifyQuery(b.query) &&
	        a.hash === b.hash);
	}
	/**
	 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
	 * considered equal to the `RouteRecord` they are aliasing.
	 *
	 * @param a - first {@link RouteRecord}
	 * @param b - second {@link RouteRecord}
	 */
	function isSameRouteRecord(a, b) {
	    // since the original record has an undefined value for aliasOf
	    // but all aliases point to the original record, this will always compare
	    // the original record
	    return (a.aliasOf || a) === (b.aliasOf || b);
	}
	function isSameRouteLocationParams(a, b) {
	    if (Object.keys(a).length !== Object.keys(b).length)
	        return false;
	    for (const key in a) {
	        if (!isSameRouteLocationParamsValue(a[key], b[key]))
	            return false;
	    }
	    return true;
	}
	function isSameRouteLocationParamsValue(a, b) {
	    return Array.isArray(a)
	        ? isEquivalentArray(a, b)
	        : Array.isArray(b)
	            ? isEquivalentArray(b, a)
	            : a === b;
	}
	/**
	 * Check if two arrays are the same or if an array with one single entry is the
	 * same as another primitive value. Used to check query and parameters
	 *
	 * @param a - array of values
	 * @param b - array of values or a single value
	 */
	function isEquivalentArray(a, b) {
	    return Array.isArray(b)
	        ? a.length === b.length && a.every((value, i) => value === b[i])
	        : a.length === 1 && a[0] === b;
	}
	/**
	 * Resolves a relative path that starts with `.`.
	 *
	 * @param to - path location we are resolving
	 * @param from - currentLocation.path, should start with `/`
	 */
	function resolveRelativePath(to, from) {
	    if (to.startsWith('/'))
	        return to;
	    if (!from.startsWith('/')) {
	        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
	        return to;
	    }
	    if (!to)
	        return from;
	    const fromSegments = from.split('/');
	    const toSegments = to.split('/');
	    let position = fromSegments.length - 1;
	    let toPosition;
	    let segment;
	    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
	        segment = toSegments[toPosition];
	        // can't go below zero
	        if (position === 1 || segment === '.')
	            continue;
	        if (segment === '..')
	            position--;
	        // found something that is not relative path
	        else
	            break;
	    }
	    return (fromSegments.slice(0, position).join('/') +
	        '/' +
	        toSegments
	            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
	            .join('/'));
	}

	var NavigationType;
	(function (NavigationType) {
	    NavigationType["pop"] = "pop";
	    NavigationType["push"] = "push";
	})(NavigationType || (NavigationType = {}));
	var NavigationDirection;
	(function (NavigationDirection) {
	    NavigationDirection["back"] = "back";
	    NavigationDirection["forward"] = "forward";
	    NavigationDirection["unknown"] = "";
	})(NavigationDirection || (NavigationDirection = {}));
	/**
	 * Starting location for Histories
	 */
	const START = '';
	// Generic utils
	/**
	 * Normalizes a base by removing any trailing slash and reading the base tag if
	 * present.
	 *
	 * @param base - base to normalize
	 */
	function normalizeBase(base) {
	    if (!base) {
	        {
	            base = '/';
	        }
	    }
	    // ensure leading slash when it was removed by the regex above avoid leading
	    // slash with hash because the file could be read from the disk like file://
	    // and the leading slash would cause problems
	    if (base[0] !== '/' && base[0] !== '#')
	        base = '/' + base;
	    // remove the trailing slash so all other method can just do `base + fullPath`
	    // to build an href
	    return removeTrailingSlash(base);
	}
	// remove any character before the hash
	const BEFORE_HASH_RE = /^[^#]+#/;
	function createHref(base, location) {
	    return base.replace(BEFORE_HASH_RE, '#') + location;
	}
	const computeScrollPosition = () => ({
	    left: window.pageXOffset,
	    top: window.pageYOffset,
	});
	// TODO: RFC about how to save scroll position
	/**
	 * ScrollBehavior instance used by the router to compute and restore the scroll
	 * position when navigating.
	 */
	// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
	//   // returns a scroll position that can be saved in history
	//   compute(): ScrollPositionEntry
	//   // can take an extended ScrollPositionEntry
	//   scroll(position: ScrollPosition): void
	// }
	// export const scrollHandler: ScrollHandler<ScrollPosition> = {
	//   compute: computeScroll,
	//   scroll: scrollToPosition,
	// }

	let createBaseLocation = () => location.protocol + '//' + location.host;
	/**
	 * Creates a normalized history location from a window.location object
	 * @param location -
	 */
	function createCurrentLocation(base, location) {
	    const { pathname, search, hash } = location;
	    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
	    const hashPos = base.indexOf('#');
	    if (hashPos > -1) {
	        let slicePos = hash.includes(base.slice(hashPos))
	            ? base.slice(hashPos).length
	            : 1;
	        let pathFromHash = hash.slice(slicePos);
	        // prepend the starting slash to hash so the url starts with /#
	        if (pathFromHash[0] !== '/')
	            pathFromHash = '/' + pathFromHash;
	        return stripBase(pathFromHash, '');
	    }
	    const path = stripBase(pathname, base);
	    return path + search + hash;
	}
	function useHistoryListeners(base, historyState, currentLocation, replace) {
	    let listeners = [];
	    let teardowns = [];
	    // TODO: should it be a stack? a Dict. Check if the popstate listener
	    // can trigger twice
	    let pauseState = null;
	    const popStateHandler = ({ state, }) => {
	        const to = createCurrentLocation(base, location);
	        const from = currentLocation.value;
	        const fromState = historyState.value;
	        let delta = 0;
	        if (state) {
	            currentLocation.value = to;
	            historyState.value = state;
	            // ignore the popstate and reset the pauseState
	            if (pauseState && pauseState === from) {
	                pauseState = null;
	                return;
	            }
	            delta = fromState ? state.position - fromState.position : 0;
	        }
	        else {
	            replace(to);
	        }
	        // console.log({ deltaFromCurrent })
	        // Here we could also revert the navigation by calling history.go(-delta)
	        // this listener will have to be adapted to not trigger again and to wait for the url
	        // to be updated before triggering the listeners. Some kind of validation function would also
	        // need to be passed to the listeners so the navigation can be accepted
	        // call all listeners
	        listeners.forEach(listener => {
	            listener(currentLocation.value, from, {
	                delta,
	                type: NavigationType.pop,
	                direction: delta
	                    ? delta > 0
	                        ? NavigationDirection.forward
	                        : NavigationDirection.back
	                    : NavigationDirection.unknown,
	            });
	        });
	    };
	    function pauseListeners() {
	        pauseState = currentLocation.value;
	    }
	    function listen(callback) {
	        // setup the listener and prepare teardown callbacks
	        listeners.push(callback);
	        const teardown = () => {
	            const index = listeners.indexOf(callback);
	            if (index > -1)
	                listeners.splice(index, 1);
	        };
	        teardowns.push(teardown);
	        return teardown;
	    }
	    function beforeUnloadListener() {
	        const { history } = window;
	        if (!history.state)
	            return;
	        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');
	    }
	    function destroy() {
	        for (const teardown of teardowns)
	            teardown();
	        teardowns = [];
	        window.removeEventListener('popstate', popStateHandler);
	        window.removeEventListener('beforeunload', beforeUnloadListener);
	    }
	    // setup the listeners and prepare teardown callbacks
	    window.addEventListener('popstate', popStateHandler);
	    window.addEventListener('beforeunload', beforeUnloadListener);
	    return {
	        pauseListeners,
	        listen,
	        destroy,
	    };
	}
	/**
	 * Creates a state object
	 */
	function buildState(back, current, forward, replaced = false, computeScroll = false) {
	    return {
	        back,
	        current,
	        forward,
	        replaced,
	        position: window.history.length,
	        scroll: computeScroll ? computeScrollPosition() : null,
	    };
	}
	function useHistoryStateNavigation(base) {
	    const { history, location } = window;
	    // private variables
	    const currentLocation = {
	        value: createCurrentLocation(base, location),
	    };
	    const historyState = { value: history.state };
	    // build current history entry as this is a fresh navigation
	    if (!historyState.value) {
	        changeLocation(currentLocation.value, {
	            back: null,
	            current: currentLocation.value,
	            forward: null,
	            // the length is off by one, we need to decrease it
	            position: history.length - 1,
	            replaced: true,
	            // don't add a scroll as the user may have an anchor and we want
	            // scrollBehavior to be triggered without a saved position
	            scroll: null,
	        }, true);
	    }
	    function changeLocation(to, state, replace) {
	        /**
	         * if a base tag is provided and we are on a normal domain, we have to
	         * respect the provided `base` attribute because pushState() will use it and
	         * potentially erase anything before the `#` like at
	         * https://github.com/vuejs/router/issues/685 where a base of
	         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
	         * there is no host, the `<base>` tag makes no sense and if there isn't a
	         * base tag we can just use everything after the `#`.
	         */
	        const hashIndex = base.indexOf('#');
	        const url = hashIndex > -1
	            ? (location.host && document.querySelector('base')
	                ? base
	                : base.slice(hashIndex)) + to
	            : createBaseLocation() + base + to;
	        try {
	            // BROWSER QUIRK
	            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
	            history[replace ? 'replaceState' : 'pushState'](state, '', url);
	            historyState.value = state;
	        }
	        catch (err) {
	            {
	                warn('Error with push/replace State', err);
	            }
	            // Force the navigation, this also resets the call count
	            location[replace ? 'replace' : 'assign'](url);
	        }
	    }
	    function replace(to, data) {
	        const state = assign({}, history.state, buildState(historyState.value.back, 
	        // keep back and forward entries but override current position
	        to, historyState.value.forward, true), data, { position: historyState.value.position });
	        changeLocation(to, state, true);
	        currentLocation.value = to;
	    }
	    function push(to, data) {
	        // Add to current entry the information of where we are going
	        // as well as saving the current position
	        const currentState = assign({}, 
	        // use current history state to gracefully handle a wrong call to
	        // history.replaceState
	        // https://github.com/vuejs/router/issues/366
	        historyState.value, history.state, {
	            forward: to,
	            scroll: computeScrollPosition(),
	        });
	        if (!history.state) {
	            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` +
	                `history.replaceState(history.state, '', url)\n\n` +
	                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
	        }
	        changeLocation(currentState.current, currentState, true);
	        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
	        changeLocation(to, state, false);
	        currentLocation.value = to;
	    }
	    return {
	        location: currentLocation,
	        state: historyState,
	        push,
	        replace,
	    };
	}
	/**
	 * Creates an HTML5 history. Most common history for single page applications.
	 *
	 * @param base -
	 */
	function createWebHistory(base) {
	    base = normalizeBase(base);
	    const historyNavigation = useHistoryStateNavigation(base);
	    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
	    function go(delta, triggerListeners = true) {
	        if (!triggerListeners)
	            historyListeners.pauseListeners();
	        history.go(delta);
	    }
	    const routerHistory = assign({
	        // it's overridden right after
	        location: '',
	        base,
	        go,
	        createHref: createHref.bind(null, base),
	    }, historyNavigation, historyListeners);
	    Object.defineProperty(routerHistory, 'location', {
	        enumerable: true,
	        get: () => historyNavigation.location.value,
	    });
	    Object.defineProperty(routerHistory, 'state', {
	        enumerable: true,
	        get: () => historyNavigation.state.value,
	    });
	    return routerHistory;
	}

	/**
	 * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
	 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
	 *
	 * @param base - Base applied to all urls, defaults to '/'
	 * @returns a history object that can be passed to the router constructor
	 */
	function createMemoryHistory(base = '') {
	    let listeners = [];
	    let queue = [START];
	    let position = 0;
	    base = normalizeBase(base);
	    function setLocation(location) {
	        position++;
	        if (position === queue.length) {
	            // we are at the end, we can simply append a new entry
	            queue.push(location);
	        }
	        else {
	            // we are in the middle, we remove everything from here in the queue
	            queue.splice(position);
	            queue.push(location);
	        }
	    }
	    function triggerListeners(to, from, { direction, delta }) {
	        const info = {
	            direction,
	            delta,
	            type: NavigationType.pop,
	        };
	        for (const callback of listeners) {
	            callback(to, from, info);
	        }
	    }
	    const routerHistory = {
	        // rewritten by Object.defineProperty
	        location: START,
	        // TODO: should be kept in queue
	        state: {},
	        base,
	        createHref: createHref.bind(null, base),
	        replace(to) {
	            // remove current entry and decrement position
	            queue.splice(position--, 1);
	            setLocation(to);
	        },
	        push(to, data) {
	            setLocation(to);
	        },
	        listen(callback) {
	            listeners.push(callback);
	            return () => {
	                const index = listeners.indexOf(callback);
	                if (index > -1)
	                    listeners.splice(index, 1);
	            };
	        },
	        destroy() {
	            listeners = [];
	            queue = [START];
	            position = 0;
	        },
	        go(delta, shouldTrigger = true) {
	            const from = this.location;
	            const direction = 
	            // we are considering delta === 0 going forward, but in abstract mode
	            // using 0 for the delta doesn't make sense like it does in html5 where
	            // it reloads the page
	            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
	            position = Math.max(0, Math.min(position + delta, queue.length - 1));
	            if (shouldTrigger) {
	                triggerListeners(this.location, from, {
	                    direction,
	                    delta,
	                });
	            }
	        },
	    };
	    Object.defineProperty(routerHistory, 'location', {
	        enumerable: true,
	        get: () => queue[position],
	    });
	    return routerHistory;
	}

	/**
	 * Creates a hash history. Useful for web applications with no host (e.g.
	 * `file://`) or when configuring a server to handle any URL is not possible.
	 *
	 * @param base - optional base to provide. Defaults to `location.pathname +
	 * location.search` If there is a `<base>` tag in the `head`, its value will be
	 * ignored in favor of this parameter **but note it affects all the
	 * history.pushState() calls**, meaning that if you use a `<base>` tag, it's
	 * `href` value **has to match this parameter** (ignoring anything after the
	 * `#`).
	 *
	 * @example
	 * ```js
	 * // at https://example.com/folder
	 * createWebHashHistory() // gives a url of `https://example.com/folder#`
	 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
	 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
	 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
	 * // you should avoid doing this because it changes the original url and breaks copying urls
	 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
	 *
	 * // at file:///usr/etc/folder/index.html
	 * // for locations with no `host`, the base is ignored
	 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
	 * ```
	 */
	function createWebHashHistory(base) {
	    // Make sure this implementation is fine in terms of encoding, specially for IE11
	    // for `file://`, directly use the pathname and ignore the base
	    // location.pathname contains an initial `/` even at the root: `https://example.com`
	    base = location.host ? base || location.pathname + location.search : '';
	    // allow the user to provide a `#` in the middle: `/base/#/app`
	    if (!base.includes('#'))
	        base += '#';
	    if (!base.endsWith('#/') && !base.endsWith('#')) {
	        warn(`A hash base must end with a "#":\n"${base}" should be "${base.replace(/#.*$/, '#')}".`);
	    }
	    return createWebHistory(base);
	}

	function isRouteLocation(route) {
	    return typeof route === 'string' || (route && typeof route === 'object');
	}
	function isRouteName(name) {
	    return typeof name === 'string' || typeof name === 'symbol';
	}

	/**
	 * Initial route location where the router is. Can be used in navigation guards
	 * to differentiate the initial navigation.
	 *
	 * @example
	 * ```js
	 * import { START_LOCATION } from 'vue-router'
	 *
	 * router.beforeEach((to, from) => {
	 *   if (from === START_LOCATION) {
	 *     // initial navigation
	 *   }
	 * })
	 * ```
	 */
	const START_LOCATION_NORMALIZED = {
	    path: '/',
	    name: undefined,
	    params: {},
	    query: {},
	    hash: '',
	    fullPath: '/',
	    matched: [],
	    meta: {},
	    redirectedFrom: undefined,
	};

	const NavigationFailureSymbol = /*#__PURE__*/ PolySymbol('navigation failure' );
	/**
	 * Enumeration with all possible types for navigation failures. Can be passed to
	 * {@link isNavigationFailure} to check for specific failures.
	 */
	exports.NavigationFailureType = void 0;
	(function (NavigationFailureType) {
	    /**
	     * An aborted navigation is a navigation that failed because a navigation
	     * guard returned `false` or called `next(false)`
	     */
	    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
	    /**
	     * A cancelled navigation is a navigation that failed because a more recent
	     * navigation finished started (not necessarily finished).
	     */
	    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
	    /**
	     * A duplicated navigation is a navigation that failed because it was
	     * initiated while already being at the exact same location.
	     */
	    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
	})(exports.NavigationFailureType || (exports.NavigationFailureType = {}));
	// DEV only debug messages
	const ErrorTypeMessages = {
	    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {
	        return `No match for\n ${JSON.stringify(location)}${currentLocation
	            ? '\nwhile being at\n' + JSON.stringify(currentLocation)
	            : ''}`;
	    },
	    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {
	        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
	    },
	    [4 /* NAVIGATION_ABORTED */]({ from, to }) {
	        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
	    },
	    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {
	        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
	    },
	    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {
	        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
	    },
	};
	function createRouterError(type, params) {
	    // keep full error messages in cjs versions
	    {
	        return assign(new Error(ErrorTypeMessages[type](params)), {
	            type,
	            [NavigationFailureSymbol]: true,
	        }, params);
	    }
	}
	function isNavigationFailure(error, type) {
	    return (error instanceof Error &&
	        NavigationFailureSymbol in error &&
	        (type == null || !!(error.type & type)));
	}
	const propertiesToLog = ['params', 'query', 'hash'];
	function stringifyRoute(to) {
	    if (typeof to === 'string')
	        return to;
	    if ('path' in to)
	        return to.path;
	    const location = {};
	    for (const key of propertiesToLog) {
	        if (key in to)
	            location[key] = to[key];
	    }
	    return JSON.stringify(location, null, 2);
	}

	// default pattern for a param: non greedy everything but /
	const BASE_PARAM_PATTERN = '[^/]+?';
	const BASE_PATH_PARSER_OPTIONS = {
	    sensitive: false,
	    strict: false,
	    start: true,
	    end: true,
	};
	// Special Regex characters that must be escaped in static tokens
	const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
	/**
	 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
	 *
	 * @param segments - array of segments returned by tokenizePath
	 * @param extraOptions - optional options for the regexp
	 * @returns a PathParser
	 */
	function tokensToParser(segments, extraOptions) {
	    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
	    // the amount of scores is the same as the length of segments except for the root segment "/"
	    const score = [];
	    // the regexp as a string
	    let pattern = options.start ? '^' : '';
	    // extracted keys
	    const keys = [];
	    for (const segment of segments) {
	        // the root segment needs special treatment
	        const segmentScores = segment.length ? [] : [90 /* Root */];
	        // allow trailing slash
	        if (options.strict && !segment.length)
	            pattern += '/';
	        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
	            const token = segment[tokenIndex];
	            // resets the score if we are inside a sub segment /:a-other-:b
	            let subSegmentScore = 40 /* Segment */ +
	                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);
	            if (token.type === 0 /* Static */) {
	                // prepend the slash if we are starting a new segment
	                if (!tokenIndex)
	                    pattern += '/';
	                pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
	                subSegmentScore += 40 /* Static */;
	            }
	            else if (token.type === 1 /* Param */) {
	                const { value, repeatable, optional, regexp } = token;
	                keys.push({
	                    name: value,
	                    repeatable,
	                    optional,
	                });
	                const re = regexp ? regexp : BASE_PARAM_PATTERN;
	                // the user provided a custom regexp /:id(\\d+)
	                if (re !== BASE_PARAM_PATTERN) {
	                    subSegmentScore += 10 /* BonusCustomRegExp */;
	                    // make sure the regexp is valid before using it
	                    try {
	                        new RegExp(`(${re})`);
	                    }
	                    catch (err) {
	                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +
	                            err.message);
	                    }
	                }
	                // when we repeat we must take care of the repeating leading slash
	                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;
	                // prepend the slash if we are starting a new segment
	                if (!tokenIndex)
	                    subPattern =
	                        // avoid an optional / if there are more segments e.g. /:p?-static
	                        // or /:p?-:p2
	                        optional && segment.length < 2
	                            ? `(?:/${subPattern})`
	                            : '/' + subPattern;
	                if (optional)
	                    subPattern += '?';
	                pattern += subPattern;
	                subSegmentScore += 20 /* Dynamic */;
	                if (optional)
	                    subSegmentScore += -8 /* BonusOptional */;
	                if (repeatable)
	                    subSegmentScore += -20 /* BonusRepeatable */;
	                if (re === '.*')
	                    subSegmentScore += -50 /* BonusWildcard */;
	            }
	            segmentScores.push(subSegmentScore);
	        }
	        // an empty array like /home/ -> [[{home}], []]
	        // if (!segment.length) pattern += '/'
	        score.push(segmentScores);
	    }
	    // only apply the strict bonus to the last score
	    if (options.strict && options.end) {
	        const i = score.length - 1;
	        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;
	    }
	    // TODO: dev only warn double trailing slash
	    if (!options.strict)
	        pattern += '/?';
	    if (options.end)
	        pattern += '$';
	    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
	    else if (options.strict)
	        pattern += '(?:/|$)';
	    const re = new RegExp(pattern, options.sensitive ? '' : 'i');
	    function parse(path) {
	        const match = path.match(re);
	        const params = {};
	        if (!match)
	            return null;
	        for (let i = 1; i < match.length; i++) {
	            const value = match[i] || '';
	            const key = keys[i - 1];
	            params[key.name] = value && key.repeatable ? value.split('/') : value;
	        }
	        return params;
	    }
	    function stringify(params) {
	        let path = '';
	        // for optional parameters to allow to be empty
	        let avoidDuplicatedSlash = false;
	        for (const segment of segments) {
	            if (!avoidDuplicatedSlash || !path.endsWith('/'))
	                path += '/';
	            avoidDuplicatedSlash = false;
	            for (const token of segment) {
	                if (token.type === 0 /* Static */) {
	                    path += token.value;
	                }
	                else if (token.type === 1 /* Param */) {
	                    const { value, repeatable, optional } = token;
	                    const param = value in params ? params[value] : '';
	                    if (Array.isArray(param) && !repeatable)
	                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
	                    const text = Array.isArray(param) ? param.join('/') : param;
	                    if (!text) {
	                        if (optional) {
	                            // if we have more than one optional param like /:a?-static and there are more segments, we don't need to
	                            // care about the optional param
	                            if (segment.length < 2 && segments.length > 1) {
	                                // remove the last slash as we could be at the end
	                                if (path.endsWith('/'))
	                                    path = path.slice(0, -1);
	                                // do not append a slash on the next iteration
	                                else
	                                    avoidDuplicatedSlash = true;
	                            }
	                        }
	                        else
	                            throw new Error(`Missing required param "${value}"`);
	                    }
	                    path += text;
	                }
	            }
	        }
	        return path;
	    }
	    return {
	        re,
	        score,
	        keys,
	        parse,
	        stringify,
	    };
	}
	/**
	 * Compares an array of numbers as used in PathParser.score and returns a
	 * number. This function can be used to `sort` an array
	 *
	 * @param a - first array of numbers
	 * @param b - second array of numbers
	 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
	 * should be sorted first
	 */
	function compareScoreArray(a, b) {
	    let i = 0;
	    while (i < a.length && i < b.length) {
	        const diff = b[i] - a[i];
	        // only keep going if diff === 0
	        if (diff)
	            return diff;
	        i++;
	    }
	    // if the last subsegment was Static, the shorter segments should be sorted first
	    // otherwise sort the longest segment first
	    if (a.length < b.length) {
	        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */
	            ? -1
	            : 1;
	    }
	    else if (a.length > b.length) {
	        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */
	            ? 1
	            : -1;
	    }
	    return 0;
	}
	/**
	 * Compare function that can be used with `sort` to sort an array of PathParser
	 *
	 * @param a - first PathParser
	 * @param b - second PathParser
	 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
	 */
	function comparePathParserScore(a, b) {
	    let i = 0;
	    const aScore = a.score;
	    const bScore = b.score;
	    while (i < aScore.length && i < bScore.length) {
	        const comp = compareScoreArray(aScore[i], bScore[i]);
	        // do not return if both are equal
	        if (comp)
	            return comp;
	        i++;
	    }
	    if (Math.abs(bScore.length - aScore.length) === 1) {
	        if (isLastScoreNegative(aScore))
	            return 1;
	        if (isLastScoreNegative(bScore))
	            return -1;
	    }
	    // if a and b share the same score entries but b has more, sort b first
	    return bScore.length - aScore.length;
	    // this is the ternary version
	    // return aScore.length < bScore.length
	    //   ? 1
	    //   : aScore.length > bScore.length
	    //   ? -1
	    //   : 0
	}
	/**
	 * This allows detecting splats at the end of a path: /home/:id(.*)*
	 *
	 * @param score - score to check
	 * @returns true if the last entry is negative
	 */
	function isLastScoreNegative(score) {
	    const last = score[score.length - 1];
	    return score.length > 0 && last[last.length - 1] < 0;
	}

	const ROOT_TOKEN = {
	    type: 0 /* Static */,
	    value: '',
	};
	const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
	// After some profiling, the cache seems to be unnecessary because tokenizePath
	// (the slowest part of adding a route) is very fast
	// const tokenCache = new Map<string, Token[][]>()
	function tokenizePath(path) {
	    if (!path)
	        return [[]];
	    if (path === '/')
	        return [[ROOT_TOKEN]];
	    if (!path.startsWith('/')) {
	        throw new Error(`Route paths should start with a "/": "${path}" should be "/${path}".`
	            );
	    }
	    // if (tokenCache.has(path)) return tokenCache.get(path)!
	    function crash(message) {
	        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
	    }
	    let state = 0 /* Static */;
	    let previousState = state;
	    const tokens = [];
	    // the segment will always be valid because we get into the initial state
	    // with the leading /
	    let segment;
	    function finalizeSegment() {
	        if (segment)
	            tokens.push(segment);
	        segment = [];
	    }
	    // index on the path
	    let i = 0;
	    // char at index
	    let char;
	    // buffer of the value read
	    let buffer = '';
	    // custom regexp for a param
	    let customRe = '';
	    function consumeBuffer() {
	        if (!buffer)
	            return;
	        if (state === 0 /* Static */) {
	            segment.push({
	                type: 0 /* Static */,
	                value: buffer,
	            });
	        }
	        else if (state === 1 /* Param */ ||
	            state === 2 /* ParamRegExp */ ||
	            state === 3 /* ParamRegExpEnd */) {
	            if (segment.length > 1 && (char === '*' || char === '+'))
	                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
	            segment.push({
	                type: 1 /* Param */,
	                value: buffer,
	                regexp: customRe,
	                repeatable: char === '*' || char === '+',
	                optional: char === '*' || char === '?',
	            });
	        }
	        else {
	            crash('Invalid state to consume buffer');
	        }
	        buffer = '';
	    }
	    function addCharToBuffer() {
	        buffer += char;
	    }
	    while (i < path.length) {
	        char = path[i++];
	        if (char === '\\' && state !== 2 /* ParamRegExp */) {
	            previousState = state;
	            state = 4 /* EscapeNext */;
	            continue;
	        }
	        switch (state) {
	            case 0 /* Static */:
	                if (char === '/') {
	                    if (buffer) {
	                        consumeBuffer();
	                    }
	                    finalizeSegment();
	                }
	                else if (char === ':') {
	                    consumeBuffer();
	                    state = 1 /* Param */;
	                }
	                else {
	                    addCharToBuffer();
	                }
	                break;
	            case 4 /* EscapeNext */:
	                addCharToBuffer();
	                state = previousState;
	                break;
	            case 1 /* Param */:
	                if (char === '(') {
	                    state = 2 /* ParamRegExp */;
	                }
	                else if (VALID_PARAM_RE.test(char)) {
	                    addCharToBuffer();
	                }
	                else {
	                    consumeBuffer();
	                    state = 0 /* Static */;
	                    // go back one character if we were not modifying
	                    if (char !== '*' && char !== '?' && char !== '+')
	                        i--;
	                }
	                break;
	            case 2 /* ParamRegExp */:
	                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
	                // it already works by escaping the closing )
	                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
	                // is this really something people need since you can also write
	                // /prefix_:p()_suffix
	                if (char === ')') {
	                    // handle the escaped )
	                    if (customRe[customRe.length - 1] == '\\')
	                        customRe = customRe.slice(0, -1) + char;
	                    else
	                        state = 3 /* ParamRegExpEnd */;
	                }
	                else {
	                    customRe += char;
	                }
	                break;
	            case 3 /* ParamRegExpEnd */:
	                // same as finalizing a param
	                consumeBuffer();
	                state = 0 /* Static */;
	                // go back one character if we were not modifying
	                if (char !== '*' && char !== '?' && char !== '+')
	                    i--;
	                customRe = '';
	                break;
	            default:
	                crash('Unknown state');
	                break;
	        }
	    }
	    if (state === 2 /* ParamRegExp */)
	        crash(`Unfinished custom RegExp for param "${buffer}"`);
	    consumeBuffer();
	    finalizeSegment();
	    // tokenCache.set(path, tokens)
	    return tokens;
	}

	function createRouteRecordMatcher(record, parent, options) {
	    const parser = tokensToParser(tokenizePath(record.path), options);
	    // warn against params with the same name
	    {
	        const existingKeys = new Set();
	        for (const key of parser.keys) {
	            if (existingKeys.has(key.name))
	                warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
	            existingKeys.add(key.name);
	        }
	    }
	    const matcher = assign(parser, {
	        record,
	        parent,
	        // these needs to be populated by the parent
	        children: [],
	        alias: [],
	    });
	    if (parent) {
	        // both are aliases or both are not aliases
	        // we don't want to mix them because the order is used when
	        // passing originalRecord in Matcher.addRoute
	        if (!matcher.record.aliasOf === !parent.record.aliasOf)
	            parent.children.push(matcher);
	    }
	    return matcher;
	}

	/**
	 * Creates a Router Matcher.
	 *
	 * @internal
	 * @param routes - array of initial routes
	 * @param globalOptions - global route options
	 */
	function createRouterMatcher(routes, globalOptions) {
	    // normalized ordered array of matchers
	    const matchers = [];
	    const matcherMap = new Map();
	    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
	    function getRecordMatcher(name) {
	        return matcherMap.get(name);
	    }
	    function addRoute(record, parent, originalRecord) {
	        // used later on to remove by name
	        const isRootAdd = !originalRecord;
	        const mainNormalizedRecord = normalizeRouteRecord(record);
	        // we might be the child of an alias
	        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
	        const options = mergeOptions(globalOptions, record);
	        // generate an array of records to correctly handle aliases
	        const normalizedRecords = [
	            mainNormalizedRecord,
	        ];
	        if ('alias' in record) {
	            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;
	            for (const alias of aliases) {
	                normalizedRecords.push(assign({}, mainNormalizedRecord, {
	                    // this allows us to hold a copy of the `components` option
	                    // so that async components cache is hold on the original record
	                    components: originalRecord
	                        ? originalRecord.record.components
	                        : mainNormalizedRecord.components,
	                    path: alias,
	                    // we might be the child of an alias
	                    aliasOf: originalRecord
	                        ? originalRecord.record
	                        : mainNormalizedRecord,
	                    // the aliases are always of the same kind as the original since they
	                    // are defined on the same record
	                }));
	            }
	        }
	        let matcher;
	        let originalMatcher;
	        for (const normalizedRecord of normalizedRecords) {
	            const { path } = normalizedRecord;
	            // Build up the path for nested routes if the child isn't an absolute
	            // route. Only add the / delimiter if the child path isn't empty and if the
	            // parent path doesn't have a trailing slash
	            if (parent && path[0] !== '/') {
	                const parentPath = parent.record.path;
	                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
	                normalizedRecord.path =
	                    parent.record.path + (path && connectingSlash + path);
	            }
	            if (normalizedRecord.path === '*') {
	                throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
	                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
	            }
	            // create the object before hand so it can be passed to children
	            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
	            if (parent && path[0] === '/')
	                checkMissingParamsInAbsolutePath(matcher, parent);
	            // if we are an alias we must tell the original record that we exist
	            // so we can be removed
	            if (originalRecord) {
	                originalRecord.alias.push(matcher);
	                {
	                    checkSameParams(originalRecord, matcher);
	                }
	            }
	            else {
	                // otherwise, the first record is the original and others are aliases
	                originalMatcher = originalMatcher || matcher;
	                if (originalMatcher !== matcher)
	                    originalMatcher.alias.push(matcher);
	                // remove the route if named and only for the top record (avoid in nested calls)
	                // this works because the original record is the first one
	                if (isRootAdd && record.name && !isAliasRecord(matcher))
	                    removeRoute(record.name);
	            }
	            if ('children' in mainNormalizedRecord) {
	                const children = mainNormalizedRecord.children;
	                for (let i = 0; i < children.length; i++) {
	                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
	                }
	            }
	            // if there was no original record, then the first one was not an alias and all
	            // other alias (if any) need to reference this record when adding children
	            originalRecord = originalRecord || matcher;
	            // TODO: add normalized records for more flexibility
	            // if (parent && isAliasRecord(originalRecord)) {
	            //   parent.children.push(originalRecord)
	            // }
	            insertMatcher(matcher);
	        }
	        return originalMatcher
	            ? () => {
	                // since other matchers are aliases, they should be removed by the original matcher
	                removeRoute(originalMatcher);
	            }
	            : noop;
	    }
	    function removeRoute(matcherRef) {
	        if (isRouteName(matcherRef)) {
	            const matcher = matcherMap.get(matcherRef);
	            if (matcher) {
	                matcherMap.delete(matcherRef);
	                matchers.splice(matchers.indexOf(matcher), 1);
	                matcher.children.forEach(removeRoute);
	                matcher.alias.forEach(removeRoute);
	            }
	        }
	        else {
	            const index = matchers.indexOf(matcherRef);
	            if (index > -1) {
	                matchers.splice(index, 1);
	                if (matcherRef.record.name)
	                    matcherMap.delete(matcherRef.record.name);
	                matcherRef.children.forEach(removeRoute);
	                matcherRef.alias.forEach(removeRoute);
	            }
	        }
	    }
	    function getRoutes() {
	        return matchers;
	    }
	    function insertMatcher(matcher) {
	        let i = 0;
	        while (i < matchers.length &&
	            comparePathParserScore(matcher, matchers[i]) >= 0 &&
	            // Adding children with empty path should still appear before the parent
	            // https://github.com/vuejs/router/issues/1124
	            (matcher.record.path !== matchers[i].record.path ||
	                !isRecordChildOf(matcher, matchers[i])))
	            i++;
	        matchers.splice(i, 0, matcher);
	        // only add the original record to the name map
	        if (matcher.record.name && !isAliasRecord(matcher))
	            matcherMap.set(matcher.record.name, matcher);
	    }
	    function resolve(location, currentLocation) {
	        let matcher;
	        let params = {};
	        let path;
	        let name;
	        if ('name' in location && location.name) {
	            matcher = matcherMap.get(location.name);
	            if (!matcher)
	                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
	                    location,
	                });
	            name = matcher.record.name;
	            params = assign(
	            // paramsFromLocation is a new object
	            paramsFromLocation(currentLocation.params, 
	            // only keep params that exist in the resolved location
	            // TODO: only keep optional params coming from a parent record
	            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);
	            // throws if cannot be stringified
	            path = matcher.stringify(params);
	        }
	        else if ('path' in location) {
	            // no need to resolve the path with the matcher as it was provided
	            // this also allows the user to control the encoding
	            path = location.path;
	            if (!path.startsWith('/')) {
	                warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);
	            }
	            matcher = matchers.find(m => m.re.test(path));
	            // matcher should have a value after the loop
	            if (matcher) {
	                // TODO: dev warning of unused params if provided
	                // we know the matcher works because we tested the regexp
	                params = matcher.parse(path);
	                name = matcher.record.name;
	            }
	            // location is a relative path
	        }
	        else {
	            // match by name or path of current route
	            matcher = currentLocation.name
	                ? matcherMap.get(currentLocation.name)
	                : matchers.find(m => m.re.test(currentLocation.path));
	            if (!matcher)
	                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
	                    location,
	                    currentLocation,
	                });
	            name = matcher.record.name;
	            // since we are navigating to the same location, we don't need to pick the
	            // params like when `name` is provided
	            params = assign({}, currentLocation.params, location.params);
	            path = matcher.stringify(params);
	        }
	        const matched = [];
	        let parentMatcher = matcher;
	        while (parentMatcher) {
	            // reversed order so parents are at the beginning
	            matched.unshift(parentMatcher.record);
	            parentMatcher = parentMatcher.parent;
	        }
	        return {
	            name,
	            path,
	            params,
	            matched,
	            meta: mergeMetaFields(matched),
	        };
	    }
	    // add initial routes
	    routes.forEach(route => addRoute(route));
	    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
	}
	function paramsFromLocation(params, keys) {
	    const newParams = {};
	    for (const key of keys) {
	        if (key in params)
	            newParams[key] = params[key];
	    }
	    return newParams;
	}
	/**
	 * Normalizes a RouteRecordRaw. Creates a copy
	 *
	 * @param record
	 * @returns the normalized version
	 */
	function normalizeRouteRecord(record) {
	    return {
	        path: record.path,
	        redirect: record.redirect,
	        name: record.name,
	        meta: record.meta || {},
	        aliasOf: undefined,
	        beforeEnter: record.beforeEnter,
	        props: normalizeRecordProps(record),
	        children: record.children || [],
	        instances: {},
	        leaveGuards: new Set(),
	        updateGuards: new Set(),
	        enterCallbacks: {},
	        components: 'components' in record
	            ? record.components || {}
	            : { default: record.component },
	    };
	}
	/**
	 * Normalize the optional `props` in a record to always be an object similar to
	 * components. Also accept a boolean for components.
	 * @param record
	 */
	function normalizeRecordProps(record) {
	    const propsObject = {};
	    // props does not exist on redirect records but we can set false directly
	    const props = record.props || false;
	    if ('component' in record) {
	        propsObject.default = props;
	    }
	    else {
	        // NOTE: we could also allow a function to be applied to every component.
	        // Would need user feedback for use cases
	        for (const name in record.components)
	            propsObject[name] = typeof props === 'boolean' ? props : props[name];
	    }
	    return propsObject;
	}
	/**
	 * Checks if a record or any of its parent is an alias
	 * @param record
	 */
	function isAliasRecord(record) {
	    while (record) {
	        if (record.record.aliasOf)
	            return true;
	        record = record.parent;
	    }
	    return false;
	}
	/**
	 * Merge meta fields of an array of records
	 *
	 * @param matched - array of matched records
	 */
	function mergeMetaFields(matched) {
	    return matched.reduce((meta, record) => assign(meta, record.meta), {});
	}
	function mergeOptions(defaults, partialOptions) {
	    const options = {};
	    for (const key in defaults) {
	        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
	    }
	    return options;
	}
	function isSameParam(a, b) {
	    return (a.name === b.name &&
	        a.optional === b.optional &&
	        a.repeatable === b.repeatable);
	}
	/**
	 * Check if a path and its alias have the same required params
	 *
	 * @param a - original record
	 * @param b - alias record
	 */
	function checkSameParams(a, b) {
	    for (const key of a.keys) {
	        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
	            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
	    }
	    for (const key of b.keys) {
	        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
	            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
	    }
	}
	function checkMissingParamsInAbsolutePath(record, parent) {
	    for (const key of parent.keys) {
	        if (!record.keys.find(isSameParam.bind(null, key)))
	            return warn(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
	    }
	}
	function isRecordChildOf(record, parent) {
	    return parent.children.some(child => child === record || isRecordChildOf(record, child));
	}

	/**
	 * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "
	 * < > `
	 *
	 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
	 * defines some extra characters to be encoded. Most browsers do not encode them
	 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
	 * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)
	 * plus `-._~`. This extra safety should be applied to query by patching the
	 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
	 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
	 * into a `/` if directly typed in. The _backtick_ (`````) should also be
	 * encoded everywhere because some browsers like FF encode it when directly
	 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
	 */
	// const EXTRA_RESERVED_RE = /[!'()*]/g
	// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
	const HASH_RE = /#/g; // %23
	const AMPERSAND_RE = /&/g; // %26
	const SLASH_RE = /\//g; // %2F
	const EQUAL_RE = /=/g; // %3D
	const IM_RE = /\?/g; // %3F
	const PLUS_RE = /\+/g; // %2B
	/**
	 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
	 * seems to be less flexible than not doing so and I can't find out the legacy
	 * systems requiring this for regular requests like text/html. In the standard,
	 * the encoding of the plus character is only mentioned for
	 * application/x-www-form-urlencoded
	 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
	 * leave the plus character as is in queries. To be more flexible, we allow the
	 * plus character on the query but it can also be manually encoded by the user.
	 *
	 * Resources:
	 * - https://url.spec.whatwg.org/#urlencoded-parsing
	 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
	 */
	const ENC_BRACKET_OPEN_RE = /%5B/g; // [
	const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]
	const ENC_CARET_RE = /%5E/g; // ^
	const ENC_BACKTICK_RE = /%60/g; // `
	const ENC_CURLY_OPEN_RE = /%7B/g; // {
	const ENC_PIPE_RE = /%7C/g; // |
	const ENC_CURLY_CLOSE_RE = /%7D/g; // }
	const ENC_SPACE_RE = /%20/g; // }
	/**
	 * Encode characters that need to be encoded on the path, search and hash
	 * sections of the URL.
	 *
	 * @internal
	 * @param text - string to encode
	 * @returns encoded string
	 */
	function commonEncode(text) {
	    return encodeURI('' + text)
	        .replace(ENC_PIPE_RE, '|')
	        .replace(ENC_BRACKET_OPEN_RE, '[')
	        .replace(ENC_BRACKET_CLOSE_RE, ']');
	}
	/**
	 * Encode characters that need to be encoded on the hash section of the URL.
	 *
	 * @param text - string to encode
	 * @returns encoded string
	 */
	function encodeHash(text) {
	    return commonEncode(text)
	        .replace(ENC_CURLY_OPEN_RE, '{')
	        .replace(ENC_CURLY_CLOSE_RE, '}')
	        .replace(ENC_CARET_RE, '^');
	}
	/**
	 * Encode characters that need to be encoded query values on the query
	 * section of the URL.
	 *
	 * @param text - string to encode
	 * @returns encoded string
	 */
	function encodeQueryValue(text) {
	    return (commonEncode(text)
	        // Encode the space as +, encode the + to differentiate it from the space
	        .replace(PLUS_RE, '%2B')
	        .replace(ENC_SPACE_RE, '+')
	        .replace(HASH_RE, '%23')
	        .replace(AMPERSAND_RE, '%26')
	        .replace(ENC_BACKTICK_RE, '`')
	        .replace(ENC_CURLY_OPEN_RE, '{')
	        .replace(ENC_CURLY_CLOSE_RE, '}')
	        .replace(ENC_CARET_RE, '^'));
	}
	/**
	 * Like `encodeQueryValue` but also encodes the `=` character.
	 *
	 * @param text - string to encode
	 */
	function encodeQueryKey(text) {
	    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
	}
	/**
	 * Encode characters that need to be encoded on the path section of the URL.
	 *
	 * @param text - string to encode
	 * @returns encoded string
	 */
	function encodePath(text) {
	    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
	}
	/**
	 * Encode characters that need to be encoded on the path section of the URL as a
	 * param. This function encodes everything {@link encodePath} does plus the
	 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
	 * string instead.
	 *
	 * @param text - string to encode
	 * @returns encoded string
	 */
	function encodeParam(text) {
	    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');
	}
	/**
	 * Decode text using `decodeURIComponent`. Returns the original text if it
	 * fails.
	 *
	 * @param text - string to decode
	 * @returns decoded string
	 */
	function decode(text) {
	    try {
	        return decodeURIComponent('' + text);
	    }
	    catch (err) {
	        warn(`Error decoding "${text}". Using original value`);
	    }
	    return '' + text;
	}

	/**
	 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
	 * version with the leading `?` and without Should work as URLSearchParams

	 * @internal
	 *
	 * @param search - search string to parse
	 * @returns a query object
	 */
	function parseQuery(search) {
	    const query = {};
	    // avoid creating an object with an empty key and empty value
	    // because of split('&')
	    if (search === '' || search === '?')
	        return query;
	    const hasLeadingIM = search[0] === '?';
	    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
	    for (let i = 0; i < searchParams.length; ++i) {
	        // pre decode the + into space
	        const searchParam = searchParams[i].replace(PLUS_RE, ' ');
	        // allow the = character
	        const eqPos = searchParam.indexOf('=');
	        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
	        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
	        if (key in query) {
	            // an extra variable for ts types
	            let currentValue = query[key];
	            if (!Array.isArray(currentValue)) {
	                currentValue = query[key] = [currentValue];
	            }
	            currentValue.push(value);
	        }
	        else {
	            query[key] = value;
	        }
	    }
	    return query;
	}
	/**
	 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
	 * doesn't prepend a `?`
	 *
	 * @internal
	 *
	 * @param query - query object to stringify
	 * @returns string version of the query without the leading `?`
	 */
	function stringifyQuery(query) {
	    let search = '';
	    for (let key in query) {
	        const value = query[key];
	        key = encodeQueryKey(key);
	        if (value == null) {
	            // only null adds the value
	            if (value !== undefined) {
	                search += (search.length ? '&' : '') + key;
	            }
	            continue;
	        }
	        // keep null values
	        const values = Array.isArray(value)
	            ? value.map(v => v && encodeQueryValue(v))
	            : [value && encodeQueryValue(value)];
	        values.forEach(value => {
	            // skip undefined values in arrays as if they were not present
	            // smaller code than using filter
	            if (value !== undefined) {
	                // only append & with non-empty search
	                search += (search.length ? '&' : '') + key;
	                if (value != null)
	                    search += '=' + value;
	            }
	        });
	    }
	    return search;
	}
	/**
	 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
	 * numbers into strings, removing keys with an undefined value and replacing
	 * undefined with null in arrays
	 *
	 * @param query - query object to normalize
	 * @returns a normalized query object
	 */
	function normalizeQuery(query) {
	    const normalizedQuery = {};
	    for (const key in query) {
	        const value = query[key];
	        if (value !== undefined) {
	            normalizedQuery[key] = Array.isArray(value)
	                ? value.map(v => (v == null ? null : '' + v))
	                : value == null
	                    ? value
	                    : '' + value;
	        }
	    }
	    return normalizedQuery;
	}

	/**
	 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
	 */
	function useCallbacks() {
	    let handlers = [];
	    function add(handler) {
	        handlers.push(handler);
	        return () => {
	            const i = handlers.indexOf(handler);
	            if (i > -1)
	                handlers.splice(i, 1);
	        };
	    }
	    function reset() {
	        handlers = [];
	    }
	    return {
	        add,
	        list: () => handlers,
	        reset,
	    };
	}

	function registerGuard(record, name, guard) {
	    const removeFromList = () => {
	        record[name].delete(guard);
	    };
	    vue.onUnmounted(removeFromList);
	    vue.onDeactivated(removeFromList);
	    vue.onActivated(() => {
	        record[name].add(guard);
	    });
	    record[name].add(guard);
	}
	/**
	 * Add a navigation guard that triggers whenever the component for the current
	 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
	 * used in any component. The guard is removed when the component is unmounted.
	 *
	 * @param leaveGuard - {@link NavigationGuard}
	 */
	function onBeforeRouteLeave(leaveGuard) {
	    if (!vue.getCurrentInstance()) {
	        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');
	        return;
	    }
	    const activeRecord = vue.inject(matchedRouteKey, 
	    // to avoid warning
	    {}).value;
	    if (!activeRecord) {
	        warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');
	        return;
	    }
	    registerGuard(activeRecord, 'leaveGuards', leaveGuard);
	}
	/**
	 * Add a navigation guard that triggers whenever the current location is about
	 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
	 * component. The guard is removed when the component is unmounted.
	 *
	 * @param updateGuard - {@link NavigationGuard}
	 */
	function onBeforeRouteUpdate(updateGuard) {
	    if (!vue.getCurrentInstance()) {
	        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');
	        return;
	    }
	    const activeRecord = vue.inject(matchedRouteKey, 
	    // to avoid warning
	    {}).value;
	    if (!activeRecord) {
	        warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');
	        return;
	    }
	    registerGuard(activeRecord, 'updateGuards', updateGuard);
	}
	function guardToPromiseFn(guard, to, from, record, name) {
	    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
	    const enterCallbackArray = record &&
	        // name is defined if record is because of the function overload
	        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
	    return () => new Promise((resolve, reject) => {
	        const next = (valid) => {
	            if (valid === false)
	                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {
	                    from,
	                    to,
	                }));
	            else if (valid instanceof Error) {
	                reject(valid);
	            }
	            else if (isRouteLocation(valid)) {
	                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {
	                    from: to,
	                    to: valid,
	                }));
	            }
	            else {
	                if (enterCallbackArray &&
	                    // since enterCallbackArray is truthy, both record and name also are
	                    record.enterCallbacks[name] === enterCallbackArray &&
	                    typeof valid === 'function')
	                    enterCallbackArray.push(valid);
	                resolve();
	            }
	        };
	        // wrapping with Promise.resolve allows it to work with both async and sync guards
	        const guardReturn = guard.call(record && record.instances[name], to, from, canOnlyBeCalledOnce(next, to, from) );
	        let guardCall = Promise.resolve(guardReturn);
	        if (guard.length < 3)
	            guardCall = guardCall.then(next);
	        if (guard.length > 2) {
	            const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ''}:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
	            if (typeof guardReturn === 'object' && 'then' in guardReturn) {
	                guardCall = guardCall.then(resolvedValue => {
	                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce
	                    if (!next._called) {
	                        warn(message);
	                        return Promise.reject(new Error('Invalid navigation guard'));
	                    }
	                    return resolvedValue;
	                });
	                // TODO: test me!
	            }
	            else if (guardReturn !== undefined) {
	                // @ts-expect-error: _called is added at canOnlyBeCalledOnce
	                if (!next._called) {
	                    warn(message);
	                    reject(new Error('Invalid navigation guard'));
	                    return;
	                }
	            }
	        }
	        guardCall.catch(err => reject(err));
	    });
	}
	function canOnlyBeCalledOnce(next, to, from) {
	    let called = 0;
	    return function () {
	        if (called++ === 1)
	            warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
	        // @ts-expect-error: we put it in the original one because it's easier to check
	        next._called = true;
	        if (called === 1)
	            next.apply(null, arguments);
	    };
	}
	function extractComponentsGuards(matched, guardType, to, from) {
	    const guards = [];
	    for (const record of matched) {
	        for (const name in record.components) {
	            let rawComponent = record.components[name];
	            {
	                if (!rawComponent ||
	                    (typeof rawComponent !== 'object' &&
	                        typeof rawComponent !== 'function')) {
	                    warn(`Component "${name}" in record with path "${record.path}" is not` +
	                        ` a valid component. Received "${String(rawComponent)}".`);
	                    // throw to ensure we stop here but warn to ensure the message isn't
	                    // missed by the user
	                    throw new Error('Invalid route component');
	                }
	                else if ('then' in rawComponent) {
	                    // warn if user wrote import('/component.vue') instead of () =>
	                    // import('./component.vue')
	                    warn(`Component "${name}" in record with path "${record.path}" is a ` +
	                        `Promise instead of a function that returns a Promise. Did you ` +
	                        `write "import('./MyPage.vue')" instead of ` +
	                        `"() => import('./MyPage.vue')" ? This will break in ` +
	                        `production if not fixed.`);
	                    const promise = rawComponent;
	                    rawComponent = () => promise;
	                }
	                else if (rawComponent.__asyncLoader &&
	                    // warn only once per component
	                    !rawComponent.__warnedDefineAsync) {
	                    rawComponent.__warnedDefineAsync = true;
	                    warn(`Component "${name}" in record with path "${record.path}" is defined ` +
	                        `using "defineAsyncComponent()". ` +
	                        `Write "() => import('./MyPage.vue')" instead of ` +
	                        `"defineAsyncComponent(() => import('./MyPage.vue'))".`);
	                }
	            }
	            // skip update and leave guards if the route component is not mounted
	            if (guardType !== 'beforeRouteEnter' && !record.instances[name])
	                continue;
	            if (isRouteComponent(rawComponent)) {
	                // __vccOpts is added by vue-class-component and contain the regular options
	                const options = rawComponent.__vccOpts || rawComponent;
	                const guard = options[guardType];
	                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
	            }
	            else {
	                // start requesting the chunk already
	                let componentPromise = rawComponent();
	                if (!('catch' in componentPromise)) {
	                    warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
	                    componentPromise = Promise.resolve(componentPromise);
	                }
	                guards.push(() => componentPromise.then(resolved => {
	                    if (!resolved)
	                        return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
	                    const resolvedComponent = isESModule(resolved)
	                        ? resolved.default
	                        : resolved;
	                    // replace the function with the resolved component
	                    record.components[name] = resolvedComponent;
	                    // __vccOpts is added by vue-class-component and contain the regular options
	                    const options = resolvedComponent.__vccOpts || resolvedComponent;
	                    const guard = options[guardType];
	                    return guard && guardToPromiseFn(guard, to, from, record, name)();
	                }));
	            }
	        }
	    }
	    return guards;
	}
	/**
	 * Allows differentiating lazy components from functional components and vue-class-component
	 *
	 * @param component
	 */
	function isRouteComponent(component) {
	    return (typeof component === 'object' ||
	        'displayName' in component ||
	        'props' in component ||
	        '__vccOpts' in component);
	}

	// TODO: we could allow currentRoute as a prop to expose `isActive` and
	// `isExactActive` behavior should go through an RFC
	function useLink(props) {
	    const router = vue.inject(routerKey);
	    const currentRoute = vue.inject(routeLocationKey);
	    const route = vue.computed(() => router.resolve(vue.unref(props.to)));
	    const activeRecordIndex = vue.computed(() => {
	        const { matched } = route.value;
	        const { length } = matched;
	        const routeMatched = matched[length - 1];
	        const currentMatched = currentRoute.matched;
	        if (!routeMatched || !currentMatched.length)
	            return -1;
	        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
	        if (index > -1)
	            return index;
	        // possible parent record
	        const parentRecordPath = getOriginalPath(matched[length - 2]);
	        return (
	        // we are dealing with nested routes
	        length > 1 &&
	            // if the parent and matched route have the same path, this link is
	            // referring to the empty child. Or we currently are on a different
	            // child of the same parent
	            getOriginalPath(routeMatched) === parentRecordPath &&
	            // avoid comparing the child with its parent
	            currentMatched[currentMatched.length - 1].path !== parentRecordPath
	            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))
	            : index);
	    });
	    const isActive = vue.computed(() => activeRecordIndex.value > -1 &&
	        includesParams(currentRoute.params, route.value.params));
	    const isExactActive = vue.computed(() => activeRecordIndex.value > -1 &&
	        activeRecordIndex.value === currentRoute.matched.length - 1 &&
	        isSameRouteLocationParams(currentRoute.params, route.value.params));
	    function navigate(e = {}) {
	        if (guardEvent(e)) {
	            return router[vue.unref(props.replace) ? 'replace' : 'push'](vue.unref(props.to)
	            // avoid uncaught errors are they are logged anyway
	            ).catch(noop);
	        }
	        return Promise.resolve();
	    }
	    return {
	        route,
	        href: vue.computed(() => route.value.href),
	        isActive,
	        isExactActive,
	        navigate,
	    };
	}
	const RouterLinkImpl = /*#__PURE__*/ vue.defineComponent({
	    name: 'RouterLink',
	    compatConfig: { MODE: 3 },
	    props: {
	        to: {
	            type: [String, Object],
	            required: true,
	        },
	        replace: Boolean,
	        activeClass: String,
	        // inactiveClass: String,
	        exactActiveClass: String,
	        custom: Boolean,
	        ariaCurrentValue: {
	            type: String,
	            default: 'page',
	        },
	    },
	    useLink,
	    setup(props, { slots }) {
	        const link = vue.reactive(useLink(props));
	        const { options } = vue.inject(routerKey);
	        const elClass = vue.computed(() => ({
	            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
	            // [getLinkClass(
	            //   props.inactiveClass,
	            //   options.linkInactiveClass,
	            //   'router-link-inactive'
	            // )]: !link.isExactActive,
	            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,
	        }));
	        return () => {
	            const children = slots.default && slots.default(link);
	            return props.custom
	                ? children
	                : vue.h('a', {
	                    'aria-current': link.isExactActive
	                        ? props.ariaCurrentValue
	                        : null,
	                    href: link.href,
	                    // this would override user added attrs but Vue will still add
	                    // the listener so we end up triggering both
	                    onClick: link.navigate,
	                    class: elClass.value,
	                }, children);
	        };
	    },
	});
	// export the public type for h/tsx inference
	// also to avoid inline import() in generated d.ts files
	/**
	 * Component to render a link that triggers a navigation on click.
	 */
	const RouterLink = RouterLinkImpl;
	function guardEvent(e) {
	    // don't redirect with control keys
	    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
	        return;
	    // don't redirect when preventDefault called
	    if (e.defaultPrevented)
	        return;
	    // don't redirect on right click
	    if (e.button !== undefined && e.button !== 0)
	        return;
	    // don't redirect if `target="_blank"`
	    // @ts-expect-error getAttribute does exist
	    if (e.currentTarget && e.currentTarget.getAttribute) {
	        // @ts-expect-error getAttribute exists
	        const target = e.currentTarget.getAttribute('target');
	        if (/\b_blank\b/i.test(target))
	            return;
	    }
	    // this may be a Weex event which doesn't have this method
	    if (e.preventDefault)
	        e.preventDefault();
	    return true;
	}
	function includesParams(outer, inner) {
	    for (const key in inner) {
	        const innerValue = inner[key];
	        const outerValue = outer[key];
	        if (typeof innerValue === 'string') {
	            if (innerValue !== outerValue)
	                return false;
	        }
	        else {
	            if (!Array.isArray(outerValue) ||
	                outerValue.length !== innerValue.length ||
	                innerValue.some((value, i) => value !== outerValue[i]))
	                return false;
	        }
	    }
	    return true;
	}
	/**
	 * Get the original path value of a record by following its aliasOf
	 * @param record
	 */
	function getOriginalPath(record) {
	    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';
	}
	/**
	 * Utility class to get the active class based on defaults.
	 * @param propClass
	 * @param globalClass
	 * @param defaultClass
	 */
	const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null
	    ? propClass
	    : globalClass != null
	        ? globalClass
	        : defaultClass;

	const RouterViewImpl = /*#__PURE__*/ vue.defineComponent({
	    name: 'RouterView',
	    // #674 we manually inherit them
	    inheritAttrs: false,
	    props: {
	        name: {
	            type: String,
	            default: 'default',
	        },
	        route: Object,
	    },
	    // Better compat for @vue/compat users
	    // https://github.com/vuejs/router/issues/1315
	    compatConfig: { MODE: 3 },
	    setup(props, { attrs, slots }) {
	        warnDeprecatedUsage();
	        const injectedRoute = vue.inject(routerViewLocationKey);
	        const routeToDisplay = vue.computed(() => props.route || injectedRoute.value);
	        const depth = vue.inject(viewDepthKey, 0);
	        const matchedRouteRef = vue.computed(() => routeToDisplay.value.matched[depth]);
	        vue.provide(viewDepthKey, depth + 1);
	        vue.provide(matchedRouteKey, matchedRouteRef);
	        vue.provide(routerViewLocationKey, routeToDisplay);
	        const viewRef = vue.ref();
	        // watch at the same time the component instance, the route record we are
	        // rendering, and the name
	        vue.watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
	            // copy reused instances
	            if (to) {
	                // this will update the instance for new instances as well as reused
	                // instances when navigating to a new route
	                to.instances[name] = instance;
	                // the component instance is reused for a different route or name so
	                // we copy any saved update or leave guards. With async setup, the
	                // mounting component will mount before the matchedRoute changes,
	                // making instance === oldInstance, so we check if guards have been
	                // added before. This works because we remove guards when
	                // unmounting/deactivating components
	                if (from && from !== to && instance && instance === oldInstance) {
	                    if (!to.leaveGuards.size) {
	                        to.leaveGuards = from.leaveGuards;
	                    }
	                    if (!to.updateGuards.size) {
	                        to.updateGuards = from.updateGuards;
	                    }
	                }
	            }
	            // trigger beforeRouteEnter next callbacks
	            if (instance &&
	                to &&
	                // if there is no instance but to and from are the same this might be
	                // the first visit
	                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
	                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
	            }
	        }, { flush: 'post' });
	        return () => {
	            const route = routeToDisplay.value;
	            const matchedRoute = matchedRouteRef.value;
	            const ViewComponent = matchedRoute && matchedRoute.components[props.name];
	            // we need the value at the time we render because when we unmount, we
	            // navigated to a different location so the value is different
	            const currentName = props.name;
	            if (!ViewComponent) {
	                return normalizeSlot(slots.default, { Component: ViewComponent, route });
	            }
	            // props from route configuration
	            const routePropsOption = matchedRoute.props[props.name];
	            const routeProps = routePropsOption
	                ? routePropsOption === true
	                    ? route.params
	                    : typeof routePropsOption === 'function'
	                        ? routePropsOption(route)
	                        : routePropsOption
	                : null;
	            const onVnodeUnmounted = vnode => {
	                // remove the instance reference to prevent leak
	                if (vnode.component.isUnmounted) {
	                    matchedRoute.instances[currentName] = null;
	                }
	            };
	            const component = vue.h(ViewComponent, assign({}, routeProps, attrs, {
	                onVnodeUnmounted,
	                ref: viewRef,
	            }));
	            return (
	            // pass the vnode to the slot as a prop.
	            // h and <component :is="..."> both accept vnodes
	            normalizeSlot(slots.default, { Component: component, route }) ||
	                component);
	        };
	    },
	});
	function normalizeSlot(slot, data) {
	    if (!slot)
	        return null;
	    const slotContent = slot(data);
	    return slotContent.length === 1 ? slotContent[0] : slotContent;
	}
	// export the public type for h/tsx inference
	// also to avoid inline import() in generated d.ts files
	/**
	 * Component to display the current route the user is at.
	 */
	const RouterView = RouterViewImpl;
	// warn against deprecated usage with <transition> & <keep-alive>
	// due to functional component being no longer eager in Vue 3
	function warnDeprecatedUsage() {
	    const instance = vue.getCurrentInstance();
	    const parentName = instance.parent && instance.parent.type.name;
	    if (parentName &&
	        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {
	        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
	        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` +
	            `Use slot props instead:\n\n` +
	            `<router-view v-slot="{ Component }">\n` +
	            `  <${comp}>\n` +
	            `    <component :is="Component" />\n` +
	            `  </${comp}>\n` +
	            `</router-view>`);
	    }
	}

	/**
	 * Creates a Router instance that can be used by a Vue app.
	 *
	 * @param options - {@link RouterOptions}
	 */
	function createRouter(options) {
	    const matcher = createRouterMatcher(options.routes, options);
	    const parseQuery$1 = options.parseQuery || parseQuery;
	    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
	    const routerHistory = options.history;
	    if (!routerHistory)
	        throw new Error('Provide the "history" option when calling "createRouter()":' +
	            ' https://next.router.vuejs.org/api/#history.');
	    const beforeGuards = useCallbacks();
	    const beforeResolveGuards = useCallbacks();
	    const afterGuards = useCallbacks();
	    const currentRoute = vue.shallowRef(START_LOCATION_NORMALIZED);
	    let pendingLocation = START_LOCATION_NORMALIZED;
	    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
	    const encodeParams = applyToParams.bind(null, encodeParam);
	    const decodeParams = 
	    // @ts-expect-error: intentionally avoid the type check
	    applyToParams.bind(null, decode);
	    function addRoute(parentOrRoute, route) {
	        let parent;
	        let record;
	        if (isRouteName(parentOrRoute)) {
	            parent = matcher.getRecordMatcher(parentOrRoute);
	            record = route;
	        }
	        else {
	            record = parentOrRoute;
	        }
	        return matcher.addRoute(record, parent);
	    }
	    function removeRoute(name) {
	        const recordMatcher = matcher.getRecordMatcher(name);
	        if (recordMatcher) {
	            matcher.removeRoute(recordMatcher);
	        }
	        else {
	            warn(`Cannot remove non-existent route "${String(name)}"`);
	        }
	    }
	    function getRoutes() {
	        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
	    }
	    function hasRoute(name) {
	        return !!matcher.getRecordMatcher(name);
	    }
	    function resolve(rawLocation, currentLocation) {
	        // const objectLocation = routerLocationAsObject(rawLocation)
	        // we create a copy to modify it later
	        currentLocation = assign({}, currentLocation || currentRoute.value);
	        if (typeof rawLocation === 'string') {
	            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
	            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);
	            const href = routerHistory.createHref(locationNormalized.fullPath);
	            {
	                if (href.startsWith('//'))
	                    warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
	                else if (!matchedRoute.matched.length) {
	                    warn(`No match found for location with path "${rawLocation}"`);
	                }
	            }
	            // locationNormalized is always a new object
	            return assign(locationNormalized, matchedRoute, {
	                params: decodeParams(matchedRoute.params),
	                hash: decode(locationNormalized.hash),
	                redirectedFrom: undefined,
	                href,
	            });
	        }
	        let matcherLocation;
	        // path could be relative in object as well
	        if ('path' in rawLocation) {
	            if ('params' in rawLocation &&
	                !('name' in rawLocation) &&
	                // @ts-expect-error: the type is never
	                Object.keys(rawLocation.params).length) {
	                warn(`Path "${
	                // @ts-expect-error: the type is never
	                rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
	            }
	            matcherLocation = assign({}, rawLocation, {
	                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,
	            });
	        }
	        else {
	            // remove any nullish param
	            const targetParams = assign({}, rawLocation.params);
	            for (const key in targetParams) {
	                if (targetParams[key] == null) {
	                    delete targetParams[key];
	                }
	            }
	            // pass encoded values to the matcher so it can produce encoded path and fullPath
	            matcherLocation = assign({}, rawLocation, {
	                params: encodeParams(rawLocation.params),
	            });
	            // current location params are decoded, we need to encode them in case the
	            // matcher merges the params
	            currentLocation.params = encodeParams(currentLocation.params);
	        }
	        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
	        const hash = rawLocation.hash || '';
	        if (hash && !hash.startsWith('#')) {
	            warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
	        }
	        // decoding them) the matcher might have merged current location params so
	        // we need to run the decoding again
	        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
	        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
	            hash: encodeHash(hash),
	            path: matchedRoute.path,
	        }));
	        const href = routerHistory.createHref(fullPath);
	        {
	            if (href.startsWith('//')) {
	                warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
	            }
	            else if (!matchedRoute.matched.length) {
	                warn(`No match found for location with path "${'path' in rawLocation ? rawLocation.path : rawLocation}"`);
	            }
	        }
	        return assign({
	            fullPath,
	            // keep the hash encoded so fullPath is effectively path + encodedQuery +
	            // hash
	            hash,
	            query: 
	            // if the user is using a custom query lib like qs, we might have
	            // nested objects, so we keep the query as is, meaning it can contain
	            // numbers at `$route.query`, but at the point, the user will have to
	            // use their own type anyway.
	            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
	            stringifyQuery$1 === stringifyQuery
	                ? normalizeQuery(rawLocation.query)
	                : (rawLocation.query || {}),
	        }, matchedRoute, {
	            redirectedFrom: undefined,
	            href,
	        });
	    }
	    function locationAsObject(to) {
	        return typeof to === 'string'
	            ? parseURL(parseQuery$1, to, currentRoute.value.path)
	            : assign({}, to);
	    }
	    function checkCanceledNavigation(to, from) {
	        if (pendingLocation !== to) {
	            return createRouterError(8 /* NAVIGATION_CANCELLED */, {
	                from,
	                to,
	            });
	        }
	    }
	    function push(to) {
	        return pushWithRedirect(to);
	    }
	    function replace(to) {
	        return push(assign(locationAsObject(to), { replace: true }));
	    }
	    function handleRedirectRecord(to) {
	        const lastMatched = to.matched[to.matched.length - 1];
	        if (lastMatched && lastMatched.redirect) {
	            const { redirect } = lastMatched;
	            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;
	            if (typeof newTargetLocation === 'string') {
	                newTargetLocation =
	                    newTargetLocation.includes('?') || newTargetLocation.includes('#')
	                        ? (newTargetLocation = locationAsObject(newTargetLocation))
	                        : // force empty params
	                            { path: newTargetLocation };
	                // @ts-expect-error: force empty params when a string is passed to let
	                // the router parse them again
	                newTargetLocation.params = {};
	            }
	            if (!('path' in newTargetLocation) &&
	                !('name' in newTargetLocation)) {
	                warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
	                throw new Error('Invalid redirect');
	            }
	            return assign({
	                query: to.query,
	                hash: to.hash,
	                params: to.params,
	            }, newTargetLocation);
	        }
	    }
	    function pushWithRedirect(to, redirectedFrom) {
	        const targetLocation = (pendingLocation = resolve(to));
	        const from = currentRoute.value;
	        const data = to.state;
	        const force = to.force;
	        // to could be a string where `replace` is a function
	        const replace = to.replace === true;
	        const shouldRedirect = handleRedirectRecord(targetLocation);
	        if (shouldRedirect)
	            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
	                state: data,
	                force,
	                replace,
	            }), 
	            // keep original redirectedFrom if it exists
	            redirectedFrom || targetLocation);
	        // if it was a redirect we already called `pushWithRedirect` above
	        const toLocation = targetLocation;
	        toLocation.redirectedFrom = redirectedFrom;
	        let failure;
	        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
	            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });
	            // trigger scroll to allow scrolling to the same anchor
	            handleScroll();
	        }
	        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
	            .catch((error) => isNavigationFailure(error)
	            ? // navigation redirects still mark the router as ready
	                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)
	                    ? error
	                    : markAsReady(error) // also returns the error
	            : // reject any unknown error
	                triggerError(error, toLocation, from))
	            .then((failure) => {
	            if (failure) {
	                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
	                    if (// we are redirecting to the same location we were already at
	                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&
	                        // and we have done it a couple of times
	                        redirectedFrom &&
	                        // @ts-expect-error: added only in dev
	                        (redirectedFrom._count = redirectedFrom._count
	                            ? // @ts-expect-error
	                                redirectedFrom._count + 1
	                            : 1) > 10) {
	                        warn(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
	                        return Promise.reject(new Error('Infinite redirect in navigation guard'));
	                    }
	                    return pushWithRedirect(
	                    // keep options
	                    assign(locationAsObject(failure.to), {
	                        state: data,
	                        force,
	                        replace,
	                    }), 
	                    // preserve the original redirectedFrom if any
	                    redirectedFrom || toLocation);
	                }
	            }
	            else {
	                // if we fail we don't finalize the navigation
	                failure = finalizeNavigation(toLocation, from, true, replace, data);
	            }
	            triggerAfterEach(toLocation, from, failure);
	            return failure;
	        });
	    }
	    /**
	     * Helper to reject and skip all navigation guards if a new navigation happened
	     * @param to
	     * @param from
	     */
	    function checkCanceledNavigationAndReject(to, from) {
	        const error = checkCanceledNavigation(to, from);
	        return error ? Promise.reject(error) : Promise.resolve();
	    }
	    // TODO: refactor the whole before guards by internally using router.beforeEach
	    function navigate(to, from) {
	        let guards;
	        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
	        // all components here have been resolved once because we are leaving
	        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);
	        // leavingRecords is already reversed
	        for (const record of leavingRecords) {
	            record.leaveGuards.forEach(guard => {
	                guards.push(guardToPromiseFn(guard, to, from));
	            });
	        }
	        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
	        guards.push(canceledNavigationCheck);
	        // run the queue of per route beforeRouteLeave guards
	        return (runGuardQueue(guards)
	            .then(() => {
	            // check global guards beforeEach
	            guards = [];
	            for (const guard of beforeGuards.list()) {
	                guards.push(guardToPromiseFn(guard, to, from));
	            }
	            guards.push(canceledNavigationCheck);
	            return runGuardQueue(guards);
	        })
	            .then(() => {
	            // check in components beforeRouteUpdate
	            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);
	            for (const record of updatingRecords) {
	                record.updateGuards.forEach(guard => {
	                    guards.push(guardToPromiseFn(guard, to, from));
	                });
	            }
	            guards.push(canceledNavigationCheck);
	            // run the queue of per route beforeEnter guards
	            return runGuardQueue(guards);
	        })
	            .then(() => {
	            // check the route beforeEnter
	            guards = [];
	            for (const record of to.matched) {
	                // do not trigger beforeEnter on reused views
	                if (record.beforeEnter && !from.matched.includes(record)) {
	                    if (Array.isArray(record.beforeEnter)) {
	                        for (const beforeEnter of record.beforeEnter)
	                            guards.push(guardToPromiseFn(beforeEnter, to, from));
	                    }
	                    else {
	                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));
	                    }
	                }
	            }
	            guards.push(canceledNavigationCheck);
	            // run the queue of per route beforeEnter guards
	            return runGuardQueue(guards);
	        })
	            .then(() => {
	            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
	            // clear existing enterCallbacks, these are added by extractComponentsGuards
	            to.matched.forEach(record => (record.enterCallbacks = {}));
	            // check in-component beforeRouteEnter
	            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
	            guards.push(canceledNavigationCheck);
	            // run the queue of per route beforeEnter guards
	            return runGuardQueue(guards);
	        })
	            .then(() => {
	            // check global guards beforeResolve
	            guards = [];
	            for (const guard of beforeResolveGuards.list()) {
	                guards.push(guardToPromiseFn(guard, to, from));
	            }
	            guards.push(canceledNavigationCheck);
	            return runGuardQueue(guards);
	        })
	            // catch any navigation canceled
	            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)
	            ? err
	            : Promise.reject(err)));
	    }
	    function triggerAfterEach(to, from, failure) {
	        // navigation is confirmed, call afterGuards
	        // TODO: wrap with error handlers
	        for (const guard of afterGuards.list())
	            guard(to, from, failure);
	    }
	    /**
	     * - Cleans up any navigation guards
	     * - Changes the url if necessary
	     * - Calls the scrollBehavior
	     */
	    function finalizeNavigation(toLocation, from, isPush, replace, data) {
	        // a more recent navigation took place
	        const error = checkCanceledNavigation(toLocation, from);
	        if (error)
	            return error;
	        // only consider as push if it's not the first navigation
	        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
	        const state = {} ;
	        // change URL only if the user did a push/replace and if it's not the initial navigation because
	        // it's just reflecting the url
	        if (isPush) {
	            // on the initial navigation, we want to reuse the scroll position from
	            // history state if it exists
	            if (replace || isFirstNavigation)
	                routerHistory.replace(toLocation.fullPath, assign({
	                    scroll: isFirstNavigation && state && state.scroll,
	                }, data));
	            else
	                routerHistory.push(toLocation.fullPath, data);
	        }
	        // accept current navigation
	        currentRoute.value = toLocation;
	        handleScroll();
	        markAsReady();
	    }
	    let removeHistoryListener;
	    // attach listener to history to trigger navigations
	    function setupListeners() {
	        // avoid setting up listeners twice due to an invalid first navigation
	        if (removeHistoryListener)
	            return;
	        removeHistoryListener = routerHistory.listen((to, _from, info) => {
	            // cannot be a redirect route because it was in history
	            const toLocation = resolve(to);
	            // due to dynamic routing, and to hash history with manual navigation
	            // (manually changing the url or calling history.hash = '#/somewhere'),
	            // there could be a redirect record in history
	            const shouldRedirect = handleRedirectRecord(toLocation);
	            if (shouldRedirect) {
	                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
	                return;
	            }
	            pendingLocation = toLocation;
	            const from = currentRoute.value;
	            navigate(toLocation, from)
	                .catch((error) => {
	                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {
	                    return error;
	                }
	                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
	                    // Here we could call if (info.delta) routerHistory.go(-info.delta,
	                    // false) but this is bug prone as we have no way to wait the
	                    // navigation to be finished before calling pushWithRedirect. Using
	                    // a setTimeout of 16ms seems to work but there is not guarantee for
	                    // it to work on every browser. So Instead we do not restore the
	                    // history entry and trigger a new navigation as requested by the
	                    // navigation guard.
	                    // the error is already handled by router.push we just want to avoid
	                    // logging the error
	                    pushWithRedirect(error.to, toLocation
	                    // avoid an uncaught rejection, let push call triggerError
	                    )
	                        .then(failure => {
	                        // manual change in hash history #916 ending up in the URL not
	                        // changing but it was changed by the manual url change, so we
	                        // need to manually change it ourselves
	                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |
	                            16 /* NAVIGATION_DUPLICATED */) &&
	                            !info.delta &&
	                            info.type === NavigationType.pop) {
	                            routerHistory.go(-1, false);
	                        }
	                    })
	                        .catch(noop);
	                    // avoid the then branch
	                    return Promise.reject();
	                }
	                // do not restore history on unknown direction
	                if (info.delta)
	                    routerHistory.go(-info.delta, false);
	                // unrecognized error, transfer to the global handler
	                return triggerError(error, toLocation, from);
	            })
	                .then((failure) => {
	                failure =
	                    failure ||
	                        finalizeNavigation(
	                        // after navigation, all matched components are resolved
	                        toLocation, from, false);
	                // revert the navigation
	                if (failure) {
	                    if (info.delta) {
	                        routerHistory.go(-info.delta, false);
	                    }
	                    else if (info.type === NavigationType.pop &&
	                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {
	                        // manual change in hash history #916
	                        // it's like a push but lacks the information of the direction
	                        routerHistory.go(-1, false);
	                    }
	                }
	                triggerAfterEach(toLocation, from, failure);
	            })
	                .catch(noop);
	        });
	    }
	    // Initialization and Errors
	    let readyHandlers = useCallbacks();
	    let errorHandlers = useCallbacks();
	    let ready;
	    /**
	     * Trigger errorHandlers added via onError and throws the error as well
	     *
	     * @param error - error to throw
	     * @param to - location we were navigating to when the error happened
	     * @param from - location we were navigating from when the error happened
	     * @returns the error as a rejected promise
	     */
	    function triggerError(error, to, from) {
	        markAsReady(error);
	        const list = errorHandlers.list();
	        if (list.length) {
	            list.forEach(handler => handler(error, to, from));
	        }
	        else {
	            {
	                warn('uncaught error during route navigation:');
	            }
	            console.error(error);
	        }
	        return Promise.reject(error);
	    }
	    function isReady() {
	        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
	            return Promise.resolve();
	        return new Promise((resolve, reject) => {
	            readyHandlers.add([resolve, reject]);
	        });
	    }
	    function markAsReady(err) {
	        if (!ready) {
	            // still not ready if an error happened
	            ready = !err;
	            setupListeners();
	            readyHandlers
	                .list()
	                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));
	            readyHandlers.reset();
	        }
	        return err;
	    }
	    // Scroll behavior
	    function handleScroll(to, from, isPush, isFirstNavigation) {
	        return Promise.resolve();
	    }
	    const go = (delta) => routerHistory.go(delta);
	    const installedApps = new Set();
	    const router = {
	        currentRoute,
	        addRoute,
	        removeRoute,
	        hasRoute,
	        getRoutes,
	        resolve,
	        options,
	        push,
	        replace,
	        go,
	        back: () => go(-1),
	        forward: () => go(1),
	        beforeEach: beforeGuards.add,
	        beforeResolve: beforeResolveGuards.add,
	        afterEach: afterGuards.add,
	        onError: errorHandlers.add,
	        isReady,
	        install(app) {
	            const router = this;
	            app.component('RouterLink', RouterLink);
	            app.component('RouterView', RouterView);
	            app.config.globalProperties.$router = router;
	            Object.defineProperty(app.config.globalProperties, '$route', {
	                enumerable: true,
	                get: () => vue.unref(currentRoute),
	            });
	            const reactiveRoute = {};
	            for (const key in START_LOCATION_NORMALIZED) {
	                // @ts-expect-error: the key matches
	                reactiveRoute[key] = vue.computed(() => currentRoute.value[key]);
	            }
	            app.provide(routerKey, router);
	            app.provide(routeLocationKey, vue.reactive(reactiveRoute));
	            app.provide(routerViewLocationKey, currentRoute);
	            const unmountApp = app.unmount;
	            installedApps.add(app);
	            app.unmount = function () {
	                installedApps.delete(app);
	                // the router is not attached to an app anymore
	                if (installedApps.size < 1) {
	                    // invalidate the current navigation
	                    pendingLocation = START_LOCATION_NORMALIZED;
	                    removeHistoryListener && removeHistoryListener();
	                    removeHistoryListener = null;
	                    currentRoute.value = START_LOCATION_NORMALIZED;
	                    ready = false;
	                }
	                unmountApp();
	            };
	        },
	    };
	    return router;
	}
	function runGuardQueue(guards) {
	    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
	}
	function extractChangingRecords(to, from) {
	    const leavingRecords = [];
	    const updatingRecords = [];
	    const enteringRecords = [];
	    const len = Math.max(from.matched.length, to.matched.length);
	    for (let i = 0; i < len; i++) {
	        const recordFrom = from.matched[i];
	        if (recordFrom) {
	            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
	                updatingRecords.push(recordFrom);
	            else
	                leavingRecords.push(recordFrom);
	        }
	        const recordTo = to.matched[i];
	        if (recordTo) {
	            // the type doesn't matter because we are comparing per reference
	            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
	                enteringRecords.push(recordTo);
	            }
	        }
	    }
	    return [leavingRecords, updatingRecords, enteringRecords];
	}

	/**
	 * Returns the router instance. Equivalent to using `$router` inside
	 * templates.
	 */
	function useRouter() {
	    return vue.inject(routerKey);
	}
	/**
	 * Returns the current route location. Equivalent to using `$route` inside
	 * templates.
	 */
	function useRoute() {
	    return vue.inject(routeLocationKey);
	}

	exports.RouterLink = RouterLink;
	exports.RouterView = RouterView;
	exports.START_LOCATION = START_LOCATION_NORMALIZED;
	exports.createMemoryHistory = createMemoryHistory;
	exports.createRouter = createRouter;
	exports.createRouterMatcher = createRouterMatcher;
	exports.createWebHashHistory = createWebHashHistory;
	exports.createWebHistory = createWebHistory;
	exports.isNavigationFailure = isNavigationFailure;
	exports.matchedRouteKey = matchedRouteKey;
	exports.onBeforeRouteLeave = onBeforeRouteLeave;
	exports.onBeforeRouteUpdate = onBeforeRouteUpdate;
	exports.parseQuery = parseQuery;
	exports.routeLocationKey = routeLocationKey;
	exports.routerKey = routerKey;
	exports.routerViewLocationKey = routerViewLocationKey;
	exports.stringifyQuery = stringifyQuery;
	exports.useLink = useLink;
	exports.useRoute = useRoute;
	exports.useRouter = useRouter;
	exports.viewDepthKey = viewDepthKey;
} (vueRouter_cjs));

/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var noop$4 = function noop() {};

var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop$4,
  measure: noop$4
};

try {
  if ("undefined" !== 'undefined') ;
  if (typeof document !== 'undefined') _DOCUMENT = document;
  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== 'undefined') _PERFORMANCE = performance;
} catch (e) {}

var _ref = _WINDOW.navigator || {},
    _ref$userAgent = _ref.userAgent,
    userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
var IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

var NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';
var UNITS_IN_GRID = 16;
var DEFAULT_FAMILY_PREFIX = 'fa';
var DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';
var DATA_FA_I2SVG = 'data-fa-i2svg';
var DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';
var DATA_FA_PSEUDO_ELEMENT_PENDING = 'data-fa-pseudo-element-pending';
var DATA_PREFIX = 'data-prefix';
var DATA_ICON = 'data-icon';
var HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';
var MUTATION_APPROACH_ASYNC = 'async';
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'];
var PRODUCTION = function () {
  try {
    return "production" === 'production';
  } catch (e) {
    return false;
  }
}();
var PREFIX_TO_STYLE = {
  'fas': 'solid',
  'fa-solid': 'solid',
  'far': 'regular',
  'fa-regular': 'regular',
  'fal': 'light',
  'fa-light': 'light',
  'fat': 'thin',
  'fa-thin': 'thin',
  'fad': 'duotone',
  'fa-duotone': 'duotone',
  'fab': 'brands',
  'fa-brands': 'brands',
  'fak': 'kit',
  'fa-kit': 'kit',
  'fa': 'solid'
};
var STYLE_TO_PREFIX = {
  'solid': 'fas',
  'regular': 'far',
  'light': 'fal',
  'thin': 'fat',
  'duotone': 'fad',
  'brands': 'fab',
  'kit': 'fak'
};
var PREFIX_TO_LONG_STYLE = {
  'fab': 'fa-brands',
  'fad': 'fa-duotone',
  'fak': 'fa-kit',
  'fal': 'fa-light',
  'far': 'fa-regular',
  'fas': 'fa-solid',
  'fat': 'fa-thin'
};
var LONG_STYLE_TO_PREFIX = {
  'fa-brands': 'fab',
  'fa-duotone': 'fad',
  'fa-kit': 'fak',
  'fa-light': 'fal',
  'fa-regular': 'far',
  'fa-solid': 'fas',
  'fa-thin': 'fat'
};
var ICON_SELECTION_SYNTAX_PATTERN = /fa[srltdbk\-\ ]/; // eslint-disable-line no-useless-escape

var LAYERS_TEXT_CLASSNAME = 'fa-layers-text';
var FONT_FAMILY_PATTERN = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Kit)?.*/i; // TODO: do we need to handle font-weight for kit SVG pseudo-elements?

var FONT_WEIGHT_TO_PREFIX = {
  '900': 'fas',
  '400': 'far',
  'normal': 'far',
  '300': 'fal',
  '100': 'fat'
};
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];
var DUOTONE_CLASSES = {
  GROUP: 'duotone-group',
  SWAP_OPACITY: 'swap-opacity',
  PRIMARY: 'primary',
  SECONDARY: 'secondary'
};
var RESERVED_CLASSES = [].concat(_toConsumableArray(Object.keys(STYLE_TO_PREFIX)), ['2xs', 'xs', 'sm', 'lg', 'xl', '2xl', 'beat', 'border', 'fade', 'beat-fade', 'bounce', 'flip-both', 'flip-horizontal', 'flip-vertical', 'flip', 'fw', 'inverse', 'layers-counter', 'layers-text', 'layers', 'li', 'pull-left', 'pull-right', 'pulse', 'rotate-180', 'rotate-270', 'rotate-90', 'rotate-by', 'shake', 'spin-pulse', 'spin-reverse', 'spin', 'stack-1x', 'stack-2x', 'stack', 'ul', DUOTONE_CLASSES.GROUP, DUOTONE_CLASSES.SWAP_OPACITY, DUOTONE_CLASSES.PRIMARY, DUOTONE_CLASSES.SECONDARY]).concat(oneToTen.map(function (n) {
  return "".concat(n, "x");
})).concat(oneToTwenty.map(function (n) {
  return "w-".concat(n);
}));

var initial = WINDOW.FontAwesomeConfig || {};

function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector('script[' + attr + ']');

  if (element) {
    return element.getAttribute(attr);
  }
}

function coerce(val) {
  // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
  // We'll assume that this is an indication that it should be toggled to true
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'true') return true;
  return val;
}

if (DOCUMENT && typeof DOCUMENT.querySelector === 'function') {
  var attrs = [['data-family-prefix', 'familyPrefix'], ['data-style-default', 'styleDefault'], ['data-replacement-class', 'replacementClass'], ['data-auto-replace-svg', 'autoReplaceSvg'], ['data-auto-add-css', 'autoAddCss'], ['data-auto-a11y', 'autoA11y'], ['data-search-pseudo-elements', 'searchPseudoElements'], ['data-observe-mutations', 'observeMutations'], ['data-mutate-approach', 'mutateApproach'], ['data-keep-original-source', 'keepOriginalSource'], ['data-measure-performance', 'measurePerformance'], ['data-show-missing-icons', 'showMissingIcons']];
  attrs.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        attr = _ref2[0],
        key = _ref2[1];

    var val = coerce(getAttrConfig(attr));

    if (val !== undefined && val !== null) {
      initial[key] = val;
    }
  });
}

var _default$2 = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  styleDefault: 'solid',
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: 'async',
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};

var _config = _objectSpread2(_objectSpread2({}, _default$2), initial);

if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = {};
Object.keys(_config).forEach(function (key) {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function set(val) {
      _config[key] = val;

      _onChangeCb.forEach(function (cb) {
        return cb(config);
      });
    },
    get: function get() {
      return _config[key];
    }
  });
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);

  return function () {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}

var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }

  var style = DOCUMENT.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;

  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || '').toUpperCase();

    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }

  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
var idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function nextUniqueId() {
  var size = 12;
  var id = '';

  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }

  return id;
}
function toArray(obj) {
  var array = [];

  for (var i = (obj || []).length >>> 0; i--;) {
    array[i] = obj[i];
  }

  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute('class') || '').split(' ').filter(function (i) {
      return i;
    });
  }
}
function htmlEscape$1(str) {
  return "".concat(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function (acc, attributeName) {
    return acc + "".concat(attributeName, "=\"").concat(htmlEscape$1(attributes[attributeName]), "\" ");
  }, '').trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce(function (acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles[styleName].trim(), ";");
  }, '');
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  var transform = _ref.transform,
      containerWidth = _ref.containerWidth,
      iconWidth = _ref.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer: outer,
    inner: inner,
    path: path
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform,
      _ref2$width = _ref2.width,
      width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width,
      _ref2$height = _ref2.height,
      height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height,
      _ref2$startCentered = _ref2.startCentered,
      startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = '';

  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d - width / 2, "em, ").concat(transform.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d, "em), calc(-50% + ").concat(transform.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d, "em, ").concat(transform.y / d, "em) ");
  }

  val += "scale(".concat(transform.size / d * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}

var baseStyles = ":root, :host {\n  --fa-font-solid: normal 900 1em/1 \"Font Awesome 6 Solid\";\n  --fa-font-regular: normal 400 1em/1 \"Font Awesome 6 Regular\";\n  --fa-font-light: normal 300 1em/1 \"Font Awesome 6 Light\";\n  --fa-font-thin: normal 100 1em/1 \"Font Awesome 6 Thin\";\n  --fa-font-duotone: normal 900 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-brands: normal 400 1em/1 \"Font Awesome 6 Brands\";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}";

function css() {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;

  if (fp !== dfp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), 'g');
    var customPropPatt = new RegExp("\\--".concat(dfp, "\\-"), 'g');
    var rPatt = new RegExp("\\.".concat(drc), 'g');
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }

  return s;
}

var _cssInserted = false;

function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}

var InjectCSS = {
  mixout: function mixout() {
    return {
      dom: {
        css: css,
        insertCss: ensureCss
      }
    };
  },
  hooks: function hooks() {
    return {
      beforeDOMElementCreation: function beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg: function beforeI2svg() {
        ensureCss();
      }
    };
  }
};

var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];

var functions = [];

var listener = function listener() {
  DOCUMENT.removeEventListener('DOMContentLoaded', listener);
  loaded = 1;
  functions.map(function (fn) {
    return fn();
  });
};

var loaded = false;

if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
}

function domready (fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}

function toHtml(abstractNodes) {
  var tag = abstractNodes.tag,
      _abstractNodes$attrib = abstractNodes.attributes,
      attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib,
      _abstractNodes$childr = abstractNodes.children,
      children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;

  if (typeof abstractNodes === 'string') {
    return htmlEscape$1(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(''), "</").concat(tag, ">");
  }
}

function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix: prefix,
      iconName: iconName,
      icon: mapping[prefix][iconName]
    };
  }
}

/**
 * Internal helper to bind a function known to have 4 arguments
 * to a given context.
 */

var bindInternal4 = function bindInternal4(func, thisContext) {
  return function (a, b, c, d) {
    return func.call(thisContext, a, b, c, d);
  };
};

/**
 * # Reduce
 *
 * A fast object `.reduce()` implementation.
 *
 * @param  {Object}   subject      The object to reduce over.
 * @param  {Function} fn           The reducer function.
 * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
 * @param  {Object}   thisContext  The context for the reducer.
 * @return {mixed}                 The final result.
 */


var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject),
      length = keys.length,
      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,
      i,
      key,
      result;

  if (initialValue === undefined) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }

  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }

  return result;
};

/**
 * ucs2decode() and codePointAt() are both works of Mathias Bynens and licensed under MIT
 *
 * Copyright Mathias Bynens <https://mathiasbynens.be/>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:

 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      var extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // eslint-disable-line eqeqeq
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
}

function toHex(unicode) {
  var decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index) {
  var size = string.length;
  var first = string.charCodeAt(index);
  var second;

  if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
    second = string.charCodeAt(index + 1);

    if (second >= 0xDC00 && second <= 0xDFFF) {
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }

  return first;
}

function normalizeIcons(icons) {
  return Object.keys(icons).reduce(function (acc, iconName) {
    var icon = icons[iconName];
    var expanded = !!icon.icon;

    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }

    return acc;
  }, {});
}

function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks,
      skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = normalizeIcons(icons);

  if (typeof namespace.hooks.addPack === 'function' && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
  }
  /**
   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
   * for `fas` so we'll ease the upgrade process for our users by automatically defining
   * this as well.
   */


  if (prefix === 'fas') {
    defineIcons('fa', icons);
  }
}

var styles = namespace.styles,
    shims = namespace.shims;
var LONG_STYLE = Object.values(PREFIX_TO_LONG_STYLE);
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = Object.keys(PREFIX_TO_STYLE);

function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}

function getIconName(familyPrefix, cls) {
  var parts = cls.split('-');
  var prefix = parts[0];
  var iconName = parts.slice(1).join('-');

  if (prefix === familyPrefix && iconName !== '' && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = function build() {
  var lookup = function lookup(reducer) {
    return reduce(styles, function (o, style, prefix) {
      o[prefix] = reduce(style, reducer, {});
      return o;
    }, {});
  };

  _byUnicode = lookup(function (acc, icon, iconName) {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }

    if (icon[2]) {
      var aliases = icon[2].filter(function (a) {
        return typeof a === 'number';
      });
      aliases.forEach(function (alias) {
        acc[alias.toString(16)] = iconName;
      });
    }

    return acc;
  });
  _byLigature = lookup(function (acc, icon, iconName) {
    acc[iconName] = iconName;

    if (icon[2]) {
      var aliases = icon[2].filter(function (a) {
        return typeof a === 'string';
      });
      aliases.forEach(function (alias) {
        acc[alias] = iconName;
      });
    }

    return acc;
  });
  _byAlias = lookup(function (acc, icon, iconName) {
    var aliases = icon[2];
    acc[iconName] = iconName;
    aliases.forEach(function (alias) {
      acc[alias] = iconName;
    });
    return acc;
  }); // If we have a Kit, we can't determine if regular is available since we
  // could be auto-fetching it. We'll have to assume that it is available.

  var hasRegular = 'far' in styles || config.autoFetchSvg;
  var shimLookups = reduce(shims, function (acc, shim) {
    var maybeNameMaybeUnicode = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];

    if (prefix === 'far' && !hasRegular) {
      prefix = 'fas';
    }

    if (typeof maybeNameMaybeUnicode === 'string') {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix,
        iconName: iconName
      };
    }

    if (typeof maybeNameMaybeUnicode === 'number') {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix,
        iconName: iconName
      };
    }

    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault);
};
onChange(function (c) {
  _defaultUsablePrefix = getCanonicalPrefix(c.styleDefault);
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  var oldUnicode = _byOldUnicode[unicode];
  var newUnicode = byUnicode('fas', unicode);
  return oldUnicode || (newUnicode ? {
    prefix: 'fas',
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = function emptyCanonicalIcon() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  var style = PREFIX_TO_STYLE[styleOrPrefix];
  var prefix = STYLE_TO_PREFIX[styleOrPrefix] || STYLE_TO_PREFIX[style];
  var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  return prefix || defined || null;
}
function getCanonicalIcon(values) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$skipLookups = params.skipLookups,
      skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
  var givenPrefix = null;
  var canonical = values.reduce(function (acc, cls) {
    var iconName = getIconName(config.familyPrefix, cls);

    if (styles[cls]) {
      cls = LONG_STYLE.includes(cls) ? LONG_STYLE_TO_PREFIX[cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES.indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls);
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass) {
      acc.rest.push(cls);
    }

    if (!skipLookups && acc.prefix && acc.iconName) {
      var shim = givenPrefix === 'fa' ? byOldName(acc.iconName) : {};
      var aliasIconName = byAlias(acc.prefix, acc.iconName);

      if (shim.prefix) {
        givenPrefix = null;
      }

      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;

      if (acc.prefix === 'far' && !styles['far'] && styles['fas'] && !config.autoFetchSvg) {
        // Allow a fallback from the regular style to solid if regular is not available
        // but only if we aren't auto-fetching SVGs
        acc.prefix = 'fas';
      }
    }

    return acc;
  }, emptyCanonicalIcon());

  if (canonical.prefix === 'fa' || givenPrefix === 'fa') {
    // The fa prefix is not canonical. So if it has made it through until this point
    // we will shift it to the correct prefix.
    canonical.prefix = getDefaultUsablePrefix() || 'fas';
  }

  return canonical;
}

var Library = /*#__PURE__*/function () {
  function Library() {
    _classCallCheck(this, Library);

    this.definitions = {};
  }

  _createClass(Library, [{
    key: "add",
    value: function add() {
      var _this = this;

      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }

      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function (key) {
        _this.definitions[key] = _objectSpread2(_objectSpread2({}, _this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);
        var longPrefix = PREFIX_TO_LONG_STYLE[key];
        if (longPrefix) defineIcons(longPrefix, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function (key) {
        var _normalized$key = normalized[key],
            prefix = _normalized$key.prefix,
            iconName = _normalized$key.iconName,
            icon = _normalized$key.icon;
        var aliases = icon[2];
        if (!additions[prefix]) additions[prefix] = {};

        if (aliases.length > 0) {
          aliases.forEach(function (alias) {
            if (typeof alias === 'string') {
              additions[prefix][alias] = icon;
            }
          });
        }

        additions[prefix][iconName] = icon;
      });
      return additions;
    }
  }]);

  return Library;
}();

var _plugins$1 = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  var obj = _ref.mixoutsTo;
  _plugins$1 = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(function (k) {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });

  _plugins$1.forEach(function (plugin) {
    var mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach(function (tk) {
      if (typeof mixout[tk] === 'function') {
        obj[tk] = mixout[tk];
      }

      if (_typeof(mixout[tk]) === 'object') {
        Object.keys(mixout[tk]).forEach(function (sk) {
          if (!obj[tk]) {
            obj[tk] = {};
          }

          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });

    if (plugin.hooks) {
      var hooks = plugin.hooks();
      Object.keys(hooks).forEach(function (hook) {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }

        _hooks[hook].push(hooks[hook]);
      });
    }

    if (plugin.provides) {
      plugin.provides(providers);
    }
  });

  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function (hookFn) {
    accumulator = hookFn.apply(null, [accumulator].concat(args)); // eslint-disable-line no-useless-call
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function (hookFn) {
    hookFn.apply(null, args);
  });
  return undefined;
}
function callProvided() {
  var hook = arguments[0];
  var args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : undefined;
}

function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === 'fa') {
    iconLookup.prefix = 'fas';
  }

  var iconName = iconLookup.iconName;
  var prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
var library = new Library();
var noAuto = function noAuto() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks('noAuto');
};
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (IS_DOM) {
      callHooks('beforeI2svg', params);
      callProvided('pseudoElements2svg', params);
      return callProvided('i2svg', params);
    } else {
      return Promise.reject('Operation requires a DOM of some kind.');
    }
  },
  watch: function watch() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot;

    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }

    config.observeMutations = true;
    domready(function () {
      autoReplace({
        autoReplaceSvgRoot: autoReplaceSvgRoot
      });
      callHooks('watch', params);
    });
  }
};
var parse$1 = {
  icon: function icon(_icon) {
    if (_icon === null) {
      return null;
    }

    if (_typeof(_icon) === 'object' && _icon.prefix && _icon.iconName) {
      return {
        prefix: _icon.prefix,
        iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
      };
    }

    if (Array.isArray(_icon) && _icon.length === 2) {
      var iconName = _icon[1].indexOf('fa-') === 0 ? _icon[1].slice(3) : _icon[1];
      var prefix = getCanonicalPrefix(_icon[0]);
      return {
        prefix: prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }

    if (typeof _icon === 'string' && (_icon.indexOf("".concat(config.familyPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      var canonicalIcon = getCanonicalIcon(_icon.split(' '), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }

    if (typeof _icon === 'string') {
      var _prefix = getDefaultUsablePrefix();

      return {
        prefix: _prefix,
        iconName: byAlias(_prefix, _icon) || _icon
      };
    }
  }
};
var api = {
  noAuto: noAuto,
  config: config,
  dom: dom,
  parse: parse$1,
  library: library,
  findIconDefinition: findIconDefinition,
  toHtml: toHtml
};

var autoReplace = function autoReplace() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot,
      autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};

function domVariants(val, abstractCreator) {
  Object.defineProperty(val, 'abstract', {
    get: abstractCreator
  });
  Object.defineProperty(val, 'html', {
    get: function get() {
      return val.abstract.map(function (a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, 'node', {
    get: function get() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement('div');
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}

function asIcon (_ref) {
  var children = _ref.children,
      main = _ref.main,
      mask = _ref.mask,
      attributes = _ref.attributes,
      styles = _ref.styles,
      transform = _ref.transform;

  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width,
        height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes['style'] = joinStyles(_objectSpread2(_objectSpread2({}, styles), {}, {
      'transform-origin': "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }

  return [{
    tag: 'svg',
    attributes: attributes,
    children: children
  }];
}

function asSymbol (_ref) {
  var prefix = _ref.prefix,
      iconName = _ref.iconName,
      children = _ref.children,
      attributes = _ref.attributes,
      symbol = _ref.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: 'svg',
    attributes: {
      style: 'display: none;'
    },
    children: [{
      tag: 'symbol',
      attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
        id: id
      }),
      children: children
    }]
  }];
}

function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons,
      main = _params$icons.main,
      mask = _params$icons.mask,
      prefix = params.prefix,
      iconName = params.iconName,
      transform = params.transform,
      symbol = params.symbol,
      title = params.title,
      maskId = params.maskId,
      titleId = params.titleId,
      extra = params.extra,
      _params$watchable = params.watchable,
      watchable = _params$watchable === void 0 ? false : _params$watchable;

  var _ref = mask.found ? mask : main,
      width = _ref.width,
      height = _ref.height;

  var isUploadedIcon = prefix === 'fak';
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : ''].filter(function (c) {
    return extra.classes.indexOf(c) === -1;
  }).filter(function (c) {
    return c !== '' || !!c;
  }).concat(extra.classes).join(' ');
  var content = {
    children: [],
    attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      'data-prefix': prefix,
      'data-icon': iconName,
      'class': attrClass,
      'role': extra.attributes.role || 'img',
      'xmlns': 'http://www.w3.org/2000/svg',
      'viewBox': "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf('fa-fw') ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};

  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = '';
  }

  if (title) {
    content.children.push({
      tag: 'title',
      attributes: {
        id: content.attributes['aria-labelledby'] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }

  var args = _objectSpread2(_objectSpread2({}, content), {}, {
    prefix: prefix,
    iconName: iconName,
    main: main,
    mask: mask,
    maskId: maskId,
    transform: transform,
    symbol: symbol,
    styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
  });

  var _ref2 = mask.found && main.found ? callProvided('generateAbstractMask', args) || {
    children: [],
    attributes: {}
  } : callProvided('generateAbstractIcon', args) || {
    children: [],
    attributes: {}
  },
      children = _ref2.children,
      attributes = _ref2.attributes;

  args.children = children;
  args.attributes = attributes;

  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content,
      width = params.width,
      height = params.height,
      transform = params.transform,
      title = params.title,
      extra = params.extra,
      _params$watchable2 = params.watchable,
      watchable = _params$watchable2 === void 0 ? false : _params$watchable2;

  var attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });

  if (watchable) {
    attributes[DATA_FA_I2SVG] = '';
  }

  var styles = _objectSpread2({}, extra.styles);

  if (transformIsMeaningful(transform)) {
    styles['transform'] = transformForCss({
      transform: transform,
      startCentered: true,
      width: width,
      height: height
    });
    styles['-webkit-transform'] = styles['transform'];
  }

  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content,
      title = params.title,
      extra = params.extra;

  var attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });

  var styleString = joinStyles(extra.styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}

var styles$1 = namespace.styles;
function asFoundIcon(icon) {
  var width = icon[0];
  var height = icon[1];

  var _icon$slice = icon.slice(4),
      _icon$slice2 = _slicedToArray(_icon$slice, 1),
      vectorData = _icon$slice2[0];

  var element = null;

  if (Array.isArray(vectorData)) {
    element = {
      tag: 'g',
      attributes: {
        class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: 'path',
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: 'currentColor',
          d: vectorData[0]
        }
      }, {
        tag: 'path',
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: 'currentColor',
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: 'path',
      attributes: {
        fill: 'currentColor',
        d: vectorData
      }
    };
  }

  return {
    found: true,
    width: width,
    height: height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};

function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION && !config.showMissingIcons && iconName) {
    console.error("Icon with name \"".concat(iconName, "\" and prefix \"").concat(prefix, "\" is missing."));
  }
}

function findIcon(iconName, prefix) {
  var givenPrefix = prefix;

  if (prefix === 'fa' && config.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }

  return new Promise(function (resolve, reject) {
    ({
      found: false,
      width: 512,
      height: 512,
      icon: callProvided('missingIconAbstract') || {}
    });

    if (givenPrefix === 'fa') {
      var shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }

    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      var icon = styles$1[prefix][iconName];
      return resolve(asFoundIcon(icon));
    }

    maybeNotifyMissing(iconName, prefix);
    resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided('missingIconAbstract') || {} : {}
    }));
  });
}

var noop$1$1 = function noop() {};

var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1$1,
  measure: noop$1$1
};
var preamble = "FA \"6.1.1\"";

var begin = function begin(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function () {
    return end(name);
  };
};

var end = function end(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};

var perf = {
  begin: begin,
  end: end
};

var noop$2$1 = function noop() {};

function isWatched(node) {
  var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === 'string';
}

function hasPrefixAndIcon(node) {
  var prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  var icon = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon;
}

function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}

function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }

  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}

function createElementNS(tag) {
  return DOCUMENT.createElementNS('http://www.w3.org/2000/svg', tag);
}

function createElement$1(tag) {
  return DOCUMENT.createElement(tag);
}

function convertSVG(abstractObj) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$ceFn = params.ceFn,
      ceFn = _params$ceFn === void 0 ? abstractObj.tag === 'svg' ? createElementNS : createElement$1 : _params$ceFn;

  if (typeof abstractObj === 'string') {
    return DOCUMENT.createTextNode(abstractObj);
  }

  var tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function (key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  var children = abstractObj.children || [];
  children.forEach(function (child) {
    tag.appendChild(convertSVG(child, {
      ceFn: ceFn
    }));
  });
  return tag;
}

function nodeAsComment(node) {
  var comment = " ".concat(node.outerHTML, " ");
  /* BEGIN.ATTRIBUTION */

  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  /* END.ATTRIBUTION */

  return comment;
}

var mutators = {
  replace: function replace(mutation) {
    var node = mutation[0];

    if (node.parentNode) {
      mutation[1].forEach(function (abstract) {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });

      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        var comment = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1]; // If we already have a replaced node we do not want to continue nesting within it.
    // Short-circuit to the standard replacement

    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }

    var forSvg = new RegExp("".concat(config.familyPrefix, "-.*"));
    delete abstract[0].attributes.id;

    if (abstract[0].attributes.class) {
      var splitClasses = abstract[0].attributes.class.split(' ').reduce(function (acc, cls) {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }

        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(' ');

      if (splitClasses.toNode.length === 0) {
        node.removeAttribute('class');
      } else {
        node.setAttribute('class', splitClasses.toNode.join(' '));
      }
    }

    var newInnerHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');
    node.setAttribute(DATA_FA_I2SVG, '');
    node.innerHTML = newInnerHTML;
  }
};

function performOperationSync(op) {
  op();
}

function perform(mutations, callback) {
  var callbackFunction = typeof callback === 'function' ? callback : noop$2$1;

  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;

    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }

    frame(function () {
      var mutator = getMutator();
      var mark = perf.begin('mutate');
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }

  if (!config.observeMutations) {
    return;
  }

  var _options$treeCallback = options.treeCallback,
      treeCallback = _options$treeCallback === void 0 ? noop$2$1 : _options$treeCallback,
      _options$nodeCallback = options.nodeCallback,
      nodeCallback = _options$nodeCallback === void 0 ? noop$2$1 : _options$nodeCallback,
      _options$pseudoElemen = options.pseudoElementsCallback,
      pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2$1 : _options$pseudoElemen,
      _options$observeMutat = options.observeMutationsRoot,
      observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function (objects) {
    if (disabled) return;
    var defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach(function (mutationRecord) {
      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }

        treeCallback(mutationRecord.target);
      }

      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }

      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === 'class' && hasPrefixAndIcon(mutationRecord.target)) {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)),
              prefix = _getCanonicalIcon.prefix,
              iconName = _getCanonicalIcon.iconName;

          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}

function styleParser (node) {
  var style = node.getAttribute('style');
  var val = [];

  if (style) {
    val = style.split(';').reduce(function (acc, style) {
      var styles = style.split(':');
      var prop = styles[0];
      var value = styles.slice(1);

      if (prop && value.length > 0) {
        acc[prop] = value.join(':').trim();
      }

      return acc;
    }, {});
  }

  return val;
}

function classParser (node) {
  var existingPrefix = node.getAttribute('data-prefix');
  var existingIconName = node.getAttribute('data-icon');
  var innerText = node.innerText !== undefined ? node.innerText.trim() : '';
  var val = getCanonicalIcon(classArray(node));

  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }

  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }

  if (val.iconName && val.prefix) {
    return val;
  }

  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }

  return val;
}

function attributesParser (node) {
  var extraAttributes = toArray(node.attributes).reduce(function (acc, attr) {
    if (acc.name !== 'class' && acc.name !== 'style') {
      acc[attr.name] = attr.value;
    }

    return acc;
  }, {});
  var title = node.getAttribute('title');
  var titleId = node.getAttribute('data-fa-title-id');

  if (config.autoA11y) {
    if (title) {
      extraAttributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes['aria-hidden'] = 'true';
      extraAttributes['focusable'] = 'false';
    }
  }

  return extraAttributes;
}

function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    styleParser: true
  };

  var _classParser = classParser(node),
      iconName = _classParser.iconName,
      prefix = _classParser.prefix,
      extraClasses = _classParser.rest;

  var extraAttributes = attributesParser(node);
  var pluginMeta = chainHooks('parseNodeAttributes', {}, node);
  var extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2({
    iconName: iconName,
    title: node.getAttribute('title'),
    titleId: node.getAttribute('data-fa-title-id'),
    prefix: prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}

var styles$2 = namespace.styles;

function generateMutation(node) {
  var nodeMeta = config.autoReplaceSvg === 'nest' ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);

  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided('generateLayersText', node, nodeMeta);
  } else {
    return callProvided('generateSvgReplacementMutation', node, nodeMeta);
  }
}

function onTree(root) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  var htmlClassList = DOCUMENT.documentElement.classList;

  var hclAdd = function hclAdd(suffix) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var hclRemove = function hclRemove(suffix) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var prefixes = config.autoFetchSvg ? Object.keys(PREFIX_TO_STYLE) : Object.keys(styles$2);
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map(function (p) {
    return ".".concat(p, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(', ');

  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }

  var candidates = [];

  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e) {// noop
  }

  if (candidates.length > 0) {
    hclAdd('pending');
    hclRemove('complete');
  } else {
    return Promise.resolve();
  }

  var mark = perf.begin('onTree');
  var mutations = candidates.reduce(function (acc, node) {
    try {
      var mutation = generateMutation(node);

      if (mutation) {
        acc.push(mutation);
      }
    } catch (e) {
      if (!PRODUCTION) {
        if (e.name === 'MissingIcon') {
          console.error(e);
        }
      }
    }

    return acc;
  }, []);
  return new Promise(function (resolve, reject) {
    Promise.all(mutations).then(function (resolvedMutations) {
      perform(resolvedMutations, function () {
        hclAdd('active');
        hclAdd('complete');
        hclRemove('pending');
        if (typeof callback === 'function') callback();
        mark();
        resolve();
      });
    }).catch(function (e) {
      mark();
      reject(e);
    });
  });
}

function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then(function (mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}

function resolveIcons(next) {
  return function (maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;

    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }

    return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
      mask: mask
    }));
  };
}

var render$h = function render(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform = params.transform,
      transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
      _params$symbol = params.symbol,
      symbol = _params$symbol === void 0 ? false : _params$symbol,
      _params$mask = params.mask,
      mask = _params$mask === void 0 ? null : _params$mask,
      _params$maskId = params.maskId,
      maskId = _params$maskId === void 0 ? null : _params$maskId,
      _params$title = params.title,
      title = _params$title === void 0 ? null : _params$title,
      _params$titleId = params.titleId,
      titleId = _params$titleId === void 0 ? null : _params$titleId,
      _params$classes = params.classes,
      classes = _params$classes === void 0 ? [] : _params$classes,
      _params$attributes = params.attributes,
      attributes = _params$attributes === void 0 ? {} : _params$attributes,
      _params$styles = params.styles,
      styles = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix = iconDefinition.prefix,
      iconName = iconDefinition.iconName,
      icon = iconDefinition.icon;
  return domVariants(_objectSpread2({
    type: 'icon'
  }, iconDefinition), function () {
    callHooks('beforeDOMElementCreation', {
      iconDefinition: iconDefinition,
      params: params
    });

    if (config.autoA11y) {
      if (title) {
        attributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes['aria-hidden'] = 'true';
        attributes['focusable'] = 'false';
      }
    }

    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix,
      iconName: iconName,
      transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
      symbol: symbol,
      title: title,
      maskId: maskId,
      titleId: titleId,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: classes
      }
    });
  });
};
var ReplaceElements = {
  mixout: function mixout() {
    return {
      icon: resolveIcons(render$h)
    };
  },
  hooks: function hooks() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.i2svg = function (params) {
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node,
          _params$callback = params.callback,
          callback = _params$callback === void 0 ? function () {} : _params$callback;
      return onTree(node, callback);
    };

    providers$$1.generateSvgReplacementMutation = function (node, nodeMeta) {
      var iconName = nodeMeta.iconName,
          title = nodeMeta.title,
          titleId = nodeMeta.titleId,
          prefix = nodeMeta.prefix,
          transform = nodeMeta.transform,
          symbol = nodeMeta.symbol,
          mask = nodeMeta.mask,
          maskId = nodeMeta.maskId,
          extra = nodeMeta.extra;
      return new Promise(function (resolve, reject) {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              main = _ref2[0],
              mask = _ref2[1];

          resolve([node, makeInlineSvgAbstract({
            icons: {
              main: main,
              mask: mask
            },
            prefix: prefix,
            iconName: iconName,
            transform: transform,
            symbol: symbol,
            maskId: maskId,
            title: title,
            titleId: titleId,
            extra: extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };

    providers$$1.generateAbstractIcon = function (_ref3) {
      var children = _ref3.children,
          attributes = _ref3.attributes,
          main = _ref3.main,
          transform = _ref3.transform,
          styles = _ref3.styles;
      var styleString = joinStyles(styles);

      if (styleString.length > 0) {
        attributes['style'] = styleString;
      }

      var nextChild;

      if (transformIsMeaningful(transform)) {
        nextChild = callProvided('generateAbstractTransformGrouping', {
          main: main,
          transform: transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }

      children.push(nextChild || main.icon);
      return {
        children: children,
        attributes: attributes
      };
    };
  }
};

var Layers = {
  mixout: function mixout() {
    return {
      layer: function layer(assembler) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes;
        return domVariants({
          type: 'layer'
        }, function () {
          callHooks('beforeDOMElementCreation', {
            assembler: assembler,
            params: params
          });
          var children = [];
          assembler(function (args) {
            Array.isArray(args) ? args.map(function (a) {
              children = children.concat(a.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: 'span',
            attributes: {
              class: ["".concat(config.familyPrefix, "-layers")].concat(_toConsumableArray(classes)).join(' ')
            },
            children: children
          }];
        });
      }
    };
  }
};

var LayersCounter = {
  mixout: function mixout() {
    return {
      counter: function counter(content) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$title = params.title,
            title = _params$title === void 0 ? null : _params$title,
            _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes,
            _params$attributes = params.attributes,
            attributes = _params$attributes === void 0 ? {} : _params$attributes,
            _params$styles = params.styles,
            styles = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: 'counter',
          content: content
        }, function () {
          callHooks('beforeDOMElementCreation', {
            content: content,
            params: params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title: title,
            extra: {
              attributes: attributes,
              styles: styles,
              classes: ["".concat(config.familyPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  }
};

var LayersText = {
  mixout: function mixout() {
    return {
      text: function text(content) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$transform = params.transform,
            transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
            _params$title = params.title,
            title = _params$title === void 0 ? null : _params$title,
            _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes,
            _params$attributes = params.attributes,
            attributes = _params$attributes === void 0 ? {} : _params$attributes,
            _params$styles = params.styles,
            styles = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: 'text',
          content: content
        }, function () {
          callHooks('beforeDOMElementCreation', {
            content: content,
            params: params
          });
          return makeLayersTextAbstract({
            content: content,
            transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
            title: title,
            extra: {
              attributes: attributes,
              styles: styles,
              classes: ["".concat(config.familyPrefix, "-layers-text")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.generateLayersText = function (node, nodeMeta) {
      var title = nodeMeta.title,
          transform = nodeMeta.transform,
          extra = nodeMeta.extra;
      var width = null;
      var height = null;

      if (IS_IE) {
        var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        var boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }

      if (config.autoA11y && !title) {
        extra.attributes['aria-hidden'] = 'true';
      }

      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width: width,
        height: height,
        transform: transform,
        title: title,
        extra: extra,
        watchable: true
      })]);
    };
  }
};

var CLEAN_CONTENT_PATTERN = new RegExp("\"", 'ug');
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
function hexValueFromContent(content) {
  var cleaned = content.replace(CLEAN_CONTENT_PATTERN, '');
  var codePoint = codePointAt(cleaned, 0);
  var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}

function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(':', '-'));
  return new Promise(function (resolve, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      // This node is already being processed
      return resolve();
    }

    var children = toArray(node.children);
    var alreadyProcessedPseudoElement = children.filter(function (c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles.getPropertyValue('font-family').match(FONT_FAMILY_PATTERN);
    var fontWeight = styles.getPropertyValue('font-weight');
    var content = styles.getPropertyValue('content');

    if (alreadyProcessedPseudoElement && !fontFamily) {
      // If we've already processed it but the current computed style does not result in a font-family,
      // that probably means that a class name that was previously present to make the icon has been
      // removed. So we now should delete the icon.
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamily && content !== 'none' && content !== '') {
      var _content = styles.getPropertyValue('content');

      var prefix = ~['Solid', 'Regular', 'Light', 'Thin', 'Duotone', 'Brands', 'Kit'].indexOf(fontFamily[2]) ? STYLE_TO_PREFIX[fontFamily[2].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[fontWeight];

      var _hexValueFromContent = hexValueFromContent(_content),
          hexValue = _hexValueFromContent.value,
          isSecondary = _hexValueFromContent.isSecondary;

      var isV4 = fontFamily[0].startsWith('FontAwesome');
      var iconName = byUnicode(prefix, hexValue);
      var iconIdentifier = iconName;

      if (isV4) {
        var iconName4 = byOldUnicode(hexValue);

        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      } // Only convert the pseudo element in this ::before/::after position into an icon if we haven't
      // already done so with the same prefix and iconName


      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);

        if (alreadyProcessedPseudoElement) {
          // Delete the old one, since we're replacing it with a new one
          node.removeChild(alreadyProcessedPseudoElement);
        }

        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(function (main) {
          var abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
            icons: {
              main: main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix,
            iconName: iconIdentifier,
            extra: extra,
            watchable: true
          }));
          var element = DOCUMENT.createElement('svg');

          if (position === '::before') {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }

          element.outerHTML = abstract.map(function (a) {
            return toHtml(a);
          }).join('\n');
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}

function replace(node) {
  return Promise.all([replaceForPosition(node, '::before'), replaceForPosition(node, '::after')]);
}

function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== 'svg');
}

function searchPseudoElements(root) {
  if (!IS_DOM) return;
  return new Promise(function (resolve, reject) {
    var operations = toArray(root.querySelectorAll('*')).filter(processable).map(replace);
    var end = perf.begin('searchPseudoElements');
    disableObservation();
    Promise.all(operations).then(function () {
      end();
      enableObservation();
      resolve();
    }).catch(function () {
      end();
      enableObservation();
      reject();
    });
  });
}

var PseudoElements = {
  hooks: function hooks() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.pseudoElements2svg = function (params) {
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node;

      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};

var _unwatched = false;
var MutationObserver$1 = {
  mixout: function mixout() {
    return {
      dom: {
        unwatch: function unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks: function hooks() {
    return {
      bootstrap: function bootstrap() {
        observe(chainHooks('mutationObserverCallbacks', {}));
      },
      noAuto: function noAuto() {
        disconnect();
      },
      watch: function watch(params) {
        var observeMutationsRoot = params.observeMutationsRoot;

        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks('mutationObserverCallbacks', {
            observeMutationsRoot: observeMutationsRoot
          }));
        }
      }
    };
  }
};

var parseTransformString = function parseTransformString(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(' ').reduce(function (acc, n) {
    var parts = n.toLowerCase().split('-');
    var first = parts[0];
    var rest = parts.slice(1).join('-');

    if (first && rest === 'h') {
      acc.flipX = true;
      return acc;
    }

    if (first && rest === 'v') {
      acc.flipY = true;
      return acc;
    }

    rest = parseFloat(rest);

    if (isNaN(rest)) {
      return acc;
    }

    switch (first) {
      case 'grow':
        acc.size = acc.size + rest;
        break;

      case 'shrink':
        acc.size = acc.size - rest;
        break;

      case 'left':
        acc.x = acc.x - rest;
        break;

      case 'right':
        acc.x = acc.x + rest;
        break;

      case 'up':
        acc.y = acc.y - rest;
        break;

      case 'down':
        acc.y = acc.y + rest;
        break;

      case 'rotate':
        acc.rotate = acc.rotate + rest;
        break;
    }

    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout: function mixout() {
    return {
      parse: {
        transform: function transform(transformString) {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var transformString = node.getAttribute('data-fa-transform');

        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }

        return accumulator;
      }
    };
  },
  provides: function provides(providers) {
    providers.generateAbstractTransformGrouping = function (_ref) {
      var main = _ref.main,
          transform = _ref.transform,
          containerWidth = _ref.containerWidth,
          iconWidth = _ref.iconWidth;
      var outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      var inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      var path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      var operations = {
        outer: outer,
        inner: inner,
        path: path
      };
      return {
        tag: 'g',
        attributes: _objectSpread2({}, operations.outer),
        children: [{
          tag: 'g',
          attributes: _objectSpread2({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};

var ALL_SPACE = {
  x: 0,
  y: 0,
  width: '100%',
  height: '100%'
};

function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = 'black';
  }

  return abstract;
}

function deGroup(abstract) {
  if (abstract.tag === 'g') {
    return abstract.children;
  } else {
    return [abstract];
  }
}

var Masks = {
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var maskData = node.getAttribute('data-fa-mask');
        var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(' ').map(function (i) {
          return i.trim();
        }));

        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }

        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute('data-fa-mask-id');
        return accumulator;
      }
    };
  },
  provides: function provides(providers) {
    providers.generateAbstractMask = function (_ref) {
      var children = _ref.children,
          attributes = _ref.attributes,
          main = _ref.main,
          mask = _ref.mask,
          explicitMaskId = _ref.maskId,
          transform = _ref.transform;
      var mainWidth = main.width,
          mainPath = main.icon;
      var maskWidth = mask.width,
          maskPath = mask.icon;
      var trans = transformForSvg({
        transform: transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      var maskRect = {
        tag: 'rect',
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          fill: 'white'
        })
      };
      var maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      var maskInnerGroup = {
        tag: 'g',
        attributes: _objectSpread2({}, trans.inner),
        children: [fillBlack(_objectSpread2({
          tag: mainPath.tag,
          attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      var maskOuterGroup = {
        tag: 'g',
        attributes: _objectSpread2({}, trans.outer),
        children: [maskInnerGroup]
      };
      var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      var maskTag = {
        tag: 'mask',
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: 'userSpaceOnUse',
          maskContentUnits: 'userSpaceOnUse'
        }),
        children: [maskRect, maskOuterGroup]
      };
      var defs = {
        tag: 'defs',
        children: [{
          tag: 'clipPath',
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: 'rect',
        attributes: _objectSpread2({
          fill: 'currentColor',
          'clip-path': "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children: children,
        attributes: attributes
      };
    };
  }
};

var MissingIconIndicator = {
  provides: function provides(providers) {
    var reduceMotion = false;

    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }

    providers.missingIconAbstract = function () {
      var gChildren = [];
      var FILL = {
        fill: 'currentColor'
      };
      var ANIMATION_BASE = {
        attributeType: 'XML',
        repeatCount: 'indefinite',
        dur: '2s'
      }; // Ring

      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
        })
      });

      var OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
        attributeName: 'opacity'
      });

      var dot = {
        tag: 'circle',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          cx: '256',
          cy: '364',
          r: '28'
        }),
        children: []
      };

      if (!reduceMotion) {
        dot.children.push({
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
            attributeName: 'r',
            values: '28;14;28;28;14;28;'
          })
        }, {
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: '1;0;1;1;0;1;'
          })
        });
      }

      gChildren.push(dot);
      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          opacity: '1',
          d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
        }),
        children: reduceMotion ? [] : [{
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: '1;0;0;0;0;1;'
          })
        }]
      });

      if (!reduceMotion) {
        // Exclamation
        gChildren.push({
          tag: 'path',
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: '0',
            d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
          }),
          children: [{
            tag: 'animate',
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: '0;0;1;1;0;0;'
            })
          }]
        });
      }

      return {
        tag: 'g',
        attributes: {
          'class': 'missing'
        },
        children: gChildren
      };
    };
  }
};

var SvgSymbols = {
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var symbolData = node.getAttribute('data-fa-symbol');
        var symbol = symbolData === null ? false : symbolData === '' ? true : symbolData;
        accumulator['symbol'] = symbol;
        return accumulator;
      }
    };
  }
};

var plugins$2 = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];

registerPlugins(plugins$2, {
  mixoutsTo: api
});
api.noAuto;
api.config;
var library$1 = api.library;
api.dom;
api.parse;
api.findIconDefinition;
api.toHtml;
api.icon;
api.layer;
api.text;
api.counter;

/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
var faArrowLeft = {
  prefix: 'fas',
  iconName: 'arrow-left',
  icon: [448, 512, [8592], "f060", "M447.1 256C447.1 273.7 433.7 288 416 288H109.3l105.4 105.4c12.5 12.5 12.5 32.75 0 45.25C208.4 444.9 200.2 448 192 448s-16.38-3.125-22.62-9.375l-160-160c-12.5-12.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25L109.3 224H416C433.7 224 447.1 238.3 447.1 256z"]
};
var faArrowRight = {
  prefix: 'fas',
  iconName: 'arrow-right',
  icon: [448, 512, [8594], "f061", "M438.6 278.6l-160 160C272.4 444.9 264.2 448 256 448s-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-32.75 0-45.25L338.8 288H32C14.33 288 .0016 273.7 .0016 256S14.33 224 32 224h306.8l-105.4-105.4c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0l160 160C451.1 245.9 451.1 266.1 438.6 278.6z"]
};
var faBook = {
  prefix: 'fas',
  iconName: 'book',
  icon: [448, 512, [128212], "f02d", "M448 336v-288C448 21.49 426.5 0 400 0H96C42.98 0 0 42.98 0 96v320c0 53.02 42.98 96 96 96h320c17.67 0 32-14.33 32-31.1c0-11.72-6.607-21.52-16-27.1v-81.36C441.8 362.8 448 350.2 448 336zM143.1 128h192C344.8 128 352 135.2 352 144C352 152.8 344.8 160 336 160H143.1C135.2 160 128 152.8 128 144C128 135.2 135.2 128 143.1 128zM143.1 192h192C344.8 192 352 199.2 352 208C352 216.8 344.8 224 336 224H143.1C135.2 224 128 216.8 128 208C128 199.2 135.2 192 143.1 192zM384 448H96c-17.67 0-32-14.33-32-32c0-17.67 14.33-32 32-32h288V448z"]
};
var faCalendar = {
  prefix: 'fas',
  iconName: 'calendar',
  icon: [448, 512, [128198, 128197], "f133", "M96 32C96 14.33 110.3 0 128 0C145.7 0 160 14.33 160 32V64H288V32C288 14.33 302.3 0 320 0C337.7 0 352 14.33 352 32V64H400C426.5 64 448 85.49 448 112V160H0V112C0 85.49 21.49 64 48 64H96V32zM448 464C448 490.5 426.5 512 400 512H48C21.49 512 0 490.5 0 464V192H448V464z"]
};
var faCheck = {
  prefix: 'fas',
  iconName: 'check',
  icon: [448, 512, [10004, 10003], "f00c", "M438.6 105.4C451.1 117.9 451.1 138.1 438.6 150.6L182.6 406.6C170.1 419.1 149.9 419.1 137.4 406.6L9.372 278.6C-3.124 266.1-3.124 245.9 9.372 233.4C21.87 220.9 42.13 220.9 54.63 233.4L159.1 338.7L393.4 105.4C405.9 92.88 426.1 92.88 438.6 105.4H438.6z"]
};
var faChevronDown = {
  prefix: 'fas',
  iconName: 'chevron-down',
  icon: [448, 512, [], "f078", "M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"]
};
var faChevronUp = {
  prefix: 'fas',
  iconName: 'chevron-up',
  icon: [448, 512, [], "f077", "M416 352c-8.188 0-16.38-3.125-22.62-9.375L224 173.3l-169.4 169.4c-12.5 12.5-32.75 12.5-45.25 0s-12.5-32.75 0-45.25l192-192c12.5-12.5 32.75-12.5 45.25 0l192 192c12.5 12.5 12.5 32.75 0 45.25C432.4 348.9 424.2 352 416 352z"]
};
var faCircleInfo = {
  prefix: 'fas',
  iconName: 'circle-info',
  icon: [512, 512, ["info-circle"], "f05a", "M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z"]
};
var faInfoCircle = faCircleInfo;
var faClockRotateLeft = {
  prefix: 'fas',
  iconName: 'clock-rotate-left',
  icon: [512, 512, ["history"], "f1da", "M256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C201.7 512 151.2 495 109.7 466.1C95.2 455.1 91.64 436 101.8 421.5C111.9 407 131.8 403.5 146.3 413.6C177.4 435.3 215.2 448 256 448C362 448 448 362 448 256C448 149.1 362 64 256 64C202.1 64 155 85.46 120.2 120.2L151 151C166.1 166.1 155.4 192 134.1 192H24C10.75 192 0 181.3 0 168V57.94C0 36.56 25.85 25.85 40.97 40.97L74.98 74.98C121.3 28.69 185.3 0 255.1 0L256 0zM256 128C269.3 128 280 138.7 280 152V246.1L344.1 311C354.3 320.4 354.3 335.6 344.1 344.1C335.6 354.3 320.4 354.3 311 344.1L239 272.1C234.5 268.5 232 262.4 232 256V152C232 138.7 242.7 128 256 128V128z"]
};
var faHistory = faClockRotateLeft;
var faFileCode = {
  prefix: 'fas',
  iconName: 'file-code',
  icon: [384, 512, [], "f1c9", "M224 128L224 0H48C21.49 0 0 21.49 0 48v416C0 490.5 21.49 512 48 512h288c26.51 0 48-21.49 48-48V160h-127.1C238.3 160 224 145.7 224 128zM154.1 353.8c7.812 7.812 7.812 20.5 0 28.31C150.2 386.1 145.1 388 140 388s-10.23-1.938-14.14-5.844l-48-48c-7.812-7.812-7.812-20.5 0-28.31l48-48c7.812-7.812 20.47-7.812 28.28 0s7.812 20.5 0 28.31L120.3 320L154.1 353.8zM306.1 305.8c7.812 7.812 7.812 20.5 0 28.31l-48 48C254.2 386.1 249.1 388 244 388s-10.23-1.938-14.14-5.844c-7.812-7.812-7.812-20.5 0-28.31L263.7 320l-33.86-33.84c-7.812-7.812-7.812-20.5 0-28.31s20.47-7.812 28.28 0L306.1 305.8zM256 0v128h128L256 0z"]
};
var faFileCsv = {
  prefix: 'fas',
  iconName: 'file-csv',
  icon: [384, 512, [], "f6dd", "M224 0V128C224 145.7 238.3 160 256 160H384V448C384 483.3 355.3 512 320 512H64C28.65 512 0 483.3 0 448V64C0 28.65 28.65 0 64 0H224zM80 224C57.91 224 40 241.9 40 264V344C40 366.1 57.91 384 80 384H96C118.1 384 136 366.1 136 344V336C136 327.2 128.8 320 120 320C111.2 320 104 327.2 104 336V344C104 348.4 100.4 352 96 352H80C75.58 352 72 348.4 72 344V264C72 259.6 75.58 256 80 256H96C100.4 256 104 259.6 104 264V272C104 280.8 111.2 288 120 288C128.8 288 136 280.8 136 272V264C136 241.9 118.1 224 96 224H80zM175.4 310.6L200.8 325.1C205.2 327.7 208 332.5 208 337.6C208 345.6 201.6 352 193.6 352H168C159.2 352 152 359.2 152 368C152 376.8 159.2 384 168 384H193.6C219.2 384 240 363.2 240 337.6C240 320.1 231.1 305.6 216.6 297.4L191.2 282.9C186.8 280.3 184 275.5 184 270.4C184 262.4 190.4 256 198.4 256H216C224.8 256 232 248.8 232 240C232 231.2 224.8 224 216 224H198.4C172.8 224 152 244.8 152 270.4C152 287 160.9 302.4 175.4 310.6zM280 240C280 231.2 272.8 224 264 224C255.2 224 248 231.2 248 240V271.6C248 306.3 258.3 340.3 277.6 369.2L282.7 376.9C285.7 381.3 290.6 384 296 384C301.4 384 306.3 381.3 309.3 376.9L314.4 369.2C333.7 340.3 344 306.3 344 271.6V240C344 231.2 336.8 224 328 224C319.2 224 312 231.2 312 240V271.6C312 294.6 306.5 317.2 296 337.5C285.5 317.2 280 294.6 280 271.6V240zM256 0L384 128H256V0z"]
};
var faFileExcel = {
  prefix: 'fas',
  iconName: 'file-excel',
  icon: [384, 512, [], "f1c3", "M224 128L224 0H48C21.49 0 0 21.49 0 48v416C0 490.5 21.49 512 48 512h288c26.51 0 48-21.49 48-48V160h-127.1C238.3 160 224 145.7 224 128zM272.1 264.4L224 344l48.99 79.61C279.6 434.3 271.9 448 259.4 448h-26.43c-5.557 0-10.71-2.883-13.63-7.617L192 396l-27.31 44.38C161.8 445.1 156.6 448 151.1 448H124.6c-12.52 0-20.19-13.73-13.63-24.39L160 344L111 264.4C104.4 253.7 112.1 240 124.6 240h26.43c5.557 0 10.71 2.883 13.63 7.613L192 292l27.31-44.39C222.2 242.9 227.4 240 232.9 240h26.43C271.9 240 279.6 253.7 272.1 264.4zM256 0v128h128L256 0z"]
};
var faFileLines = {
  prefix: 'fas',
  iconName: 'file-lines',
  icon: [384, 512, [128462, 61686, 128441, "file-alt", "file-text"], "f15c", "M256 0v128h128L256 0zM224 128L224 0H48C21.49 0 0 21.49 0 48v416C0 490.5 21.49 512 48 512h288c26.51 0 48-21.49 48-48V160h-127.1C238.3 160 224 145.7 224 128zM272 416h-160C103.2 416 96 408.8 96 400C96 391.2 103.2 384 112 384h160c8.836 0 16 7.162 16 16C288 408.8 280.8 416 272 416zM272 352h-160C103.2 352 96 344.8 96 336C96 327.2 103.2 320 112 320h160c8.836 0 16 7.162 16 16C288 344.8 280.8 352 272 352zM288 272C288 280.8 280.8 288 272 288h-160C103.2 288 96 280.8 96 272C96 263.2 103.2 256 112 256h160C280.8 256 288 263.2 288 272z"]
};
var faForwardFast = {
  prefix: 'fas',
  iconName: 'forward-fast',
  icon: [512, 512, [9197, "fast-forward"], "f050", "M512 96.03v319.9c0 17.67-14.33 31.1-31.1 31.1C462.3 447.1 448 433.6 448 415.1V284.1l-171.5 156.5C255.9 457.7 224 443.3 224 415.1V284.1l-171.5 156.5C31.88 457.7 0 443.3 0 415.1V96.03c0-27.37 31.88-41.74 52.5-24.62L224 226.8V96.03c0-27.37 31.88-41.74 52.5-24.62L448 226.8V96.03c0-17.67 14.33-31.1 31.1-31.1C497.7 64.03 512 78.36 512 96.03z"]
};
var faMicrophoneLines = {
  prefix: 'fas',
  iconName: 'microphone-lines',
  icon: [384, 512, [127897, "microphone-alt"], "f3c9", "M192 352c53.03 0 96-42.97 96-96h-80C199.2 256 192 248.8 192 240S199.2 224 208 224H288V192h-80C199.2 192 192 184.8 192 176S199.2 160 208 160H288V127.1h-80c-8.836 0-16-7.164-16-16s7.164-16 16-16L288 96c0-53.03-42.97-96-96-96s-96 42.97-96 96v160C96 309 138.1 352 192 352zM344 192C330.7 192 320 202.7 320 215.1V256c0 73.33-61.97 132.4-136.3 127.7c-66.08-4.169-119.7-66.59-119.7-132.8L64 215.1C64 202.7 53.25 192 40 192S16 202.7 16 215.1v32.15c0 89.66 63.97 169.6 152 181.7V464H128c-18.19 0-32.84 15.18-31.96 33.57C96.43 505.8 103.8 512 112 512h160c8.222 0 15.57-6.216 15.96-14.43C288.8 479.2 274.2 464 256 464h-40v-33.77C301.7 418.5 368 344.9 368 256V215.1C368 202.7 357.3 192 344 192z"]
};
var faPenNib = {
  prefix: 'fas',
  iconName: 'pen-nib',
  icon: [512, 512, [10001], "f5ad", "M368.4 18.34C390.3-3.526 425.7-3.526 447.6 18.34L493.7 64.4C515.5 86.27 515.5 121.7 493.7 143.6L437.9 199.3L312.7 74.06L368.4 18.34zM417.4 224L371.4 377.3C365.4 397.2 350.2 413 330.5 419.6L66.17 508.2C54.83 512 42.32 509.2 33.74 500.9L187.3 347.3C193.6 350.3 200.6 352 207.1 352C234.5 352 255.1 330.5 255.1 304C255.1 277.5 234.5 256 207.1 256C181.5 256 159.1 277.5 159.1 304C159.1 311.4 161.7 318.4 164.7 324.7L11.11 478.3C2.809 469.7-.04 457.2 3.765 445.8L92.39 181.5C98.1 161.8 114.8 146.6 134.7 140.6L287.1 94.6L417.4 224z"]
};
var faPeopleGroup = {
  prefix: 'fas',
  iconName: 'people-group',
  icon: [640, 512, [], "e533", "M184 88C184 118.9 158.9 144 128 144C97.07 144 72 118.9 72 88C72 57.07 97.07 32 128 32C158.9 32 184 57.07 184 88zM208.4 196.3C178.7 222.7 160 261.2 160 304C160 338.3 171.1 369.8 192 394.5V416C192 433.7 177.7 448 160 448H96C78.33 448 64 433.7 64 416V389.2C26.16 371.2 0 332.7 0 288C0 226.1 50.14 176 112 176H144C167.1 176 190.2 183.5 208.4 196.3V196.3zM64 245.7C54.04 256.9 48 271.8 48 288C48 304.2 54.04 319.1 64 330.3V245.7zM448 416V394.5C468 369.8 480 338.3 480 304C480 261.2 461.3 222.7 431.6 196.3C449.8 183.5 472 176 496 176H528C589.9 176 640 226.1 640 288C640 332.7 613.8 371.2 576 389.2V416C576 433.7 561.7 448 544 448H480C462.3 448 448 433.7 448 416zM576 330.3C585.1 319.1 592 304.2 592 288C592 271.8 585.1 256.9 576 245.7V330.3zM568 88C568 118.9 542.9 144 512 144C481.1 144 456 118.9 456 88C456 57.07 481.1 32 512 32C542.9 32 568 57.07 568 88zM256 96C256 60.65 284.7 32 320 32C355.3 32 384 60.65 384 96C384 131.3 355.3 160 320 160C284.7 160 256 131.3 256 96zM448 304C448 348.7 421.8 387.2 384 405.2V448C384 465.7 369.7 480 352 480H288C270.3 480 256 465.7 256 448V405.2C218.2 387.2 192 348.7 192 304C192 242.1 242.1 192 304 192H336C397.9 192 448 242.1 448 304zM256 346.3V261.7C246 272.9 240 287.8 240 304C240 320.2 246 335.1 256 346.3zM384 261.7V346.3C393.1 335 400 320.2 400 304C400 287.8 393.1 272.9 384 261.7z"]
};
var faPerson = {
  prefix: 'fas',
  iconName: 'person',
  icon: [320, 512, [129485, "male"], "f183", "M208 48C208 74.51 186.5 96 160 96C133.5 96 112 74.51 112 48C112 21.49 133.5 0 160 0C186.5 0 208 21.49 208 48zM152 352V480C152 497.7 137.7 512 120 512C102.3 512 88 497.7 88 480V256.9L59.43 304.5C50.33 319.6 30.67 324.5 15.52 315.4C.3696 306.3-4.531 286.7 4.573 271.5L62.85 174.6C80.2 145.7 111.4 128 145.1 128H174.9C208.6 128 239.8 145.7 257.2 174.6L315.4 271.5C324.5 286.7 319.6 306.3 304.5 315.4C289.3 324.5 269.7 319.6 260.6 304.5L232 256.9V480C232 497.7 217.7 512 200 512C182.3 512 168 497.7 168 480V352L152 352z"]
};
var faQuestion = {
  prefix: 'fas',
  iconName: 'question',
  icon: [320, 512, [10067, 10068, 61736], "3f", "M204.3 32.01H96c-52.94 0-96 43.06-96 96c0 17.67 14.31 31.1 32 31.1s32-14.32 32-31.1c0-17.64 14.34-32 32-32h108.3C232.8 96.01 256 119.2 256 147.8c0 19.72-10.97 37.47-30.5 47.33L127.8 252.4C117.1 258.2 112 268.7 112 280v40c0 17.67 14.31 31.99 32 31.99s32-14.32 32-31.99V298.3L256 251.3c39.47-19.75 64-59.42 64-103.5C320 83.95 268.1 32.01 204.3 32.01zM144 400c-22.09 0-40 17.91-40 40s17.91 39.1 40 39.1s40-17.9 40-39.1S166.1 400 144 400z"]
};
var faSignsPost = {
  prefix: 'fas',
  iconName: 'signs-post',
  icon: [512, 512, ["map-signs"], "f277", "M223.1 32C223.1 14.33 238.3 0 255.1 0C273.7 0 288 14.33 288 32H441.4C445.6 32 449.7 33.69 452.7 36.69L500.7 84.69C506.9 90.93 506.9 101.1 500.7 107.3L452.7 155.3C449.7 158.3 445.6 160 441.4 160H63.1C46.33 160 31.1 145.7 31.1 128V64C31.1 46.33 46.33 32 63.1 32L223.1 32zM480 320C480 337.7 465.7 352 448 352H70.63C66.38 352 62.31 350.3 59.31 347.3L11.31 299.3C5.065 293.1 5.065 282.9 11.31 276.7L59.31 228.7C62.31 225.7 66.38 223.1 70.63 223.1H223.1V191.1H288V223.1H448C465.7 223.1 480 238.3 480 255.1V320zM255.1 512C238.3 512 223.1 497.7 223.1 480V384H288V480C288 497.7 273.7 512 255.1 512z"]
};
var faMapSigns = faSignsPost;
var faUpRightFromSquare = {
  prefix: 'fas',
  iconName: 'up-right-from-square',
  icon: [512, 512, ["external-link-alt"], "f35d", "M384 320c-17.67 0-32 14.33-32 32v96H64V160h96c17.67 0 32-14.32 32-32s-14.33-32-32-32L64 96c-35.35 0-64 28.65-64 64V448c0 35.34 28.65 64 64 64h288c35.35 0 64-28.66 64-64v-96C416 334.3 401.7 320 384 320zM488 0H352c-12.94 0-24.62 7.797-29.56 19.75c-4.969 11.97-2.219 25.72 6.938 34.88L370.8 96L169.4 297.4c-12.5 12.5-12.5 32.75 0 45.25C175.6 348.9 183.8 352 192 352s16.38-3.125 22.62-9.375L416 141.3l41.38 41.38c9.156 9.141 22.88 11.84 34.88 6.938C504.2 184.6 512 172.9 512 160V24C512 10.74 501.3 0 488 0z"]
};
var faExternalLinkAlt = faUpRightFromSquare;
var faXmark = {
  prefix: 'fas',
  iconName: 'xmark',
  icon: [320, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"]
};
var faTimes = faXmark;

/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
var faFacebook = {
  prefix: 'fab',
  iconName: 'facebook',
  icon: [512, 512, [62000], "f09a", "M504 256C504 119 393 8 256 8S8 119 8 256c0 123.8 90.69 226.4 209.3 245V327.7h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.3 482.4 504 379.8 504 256z"]
};
var faInstagram = {
  prefix: 'fab',
  iconName: 'instagram',
  icon: [448, 512, [], "f16d", "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"]
};
var faSnapchat = {
  prefix: 'fab',
  iconName: 'snapchat',
  icon: [512, 512, [62124, "snapchat-ghost"], "f2ab", "M496.9 366.6c-3.373-9.176-9.8-14.09-17.11-18.15-1.376-.806-2.641-1.451-3.72-1.947-2.182-1.128-4.414-2.22-6.634-3.373-22.8-12.09-40.61-27.34-52.96-45.42a102.9 102.9 0 0 1 -9.089-16.12c-1.054-3.013-1-4.724-.248-6.287a10.22 10.22 0 0 1 2.914-3.038c3.918-2.591 7.96-5.22 10.7-6.993 4.885-3.162 8.754-5.667 11.25-7.44 9.362-6.547 15.91-13.5 20-21.28a42.37 42.37 0 0 0 2.1-35.19c-6.2-16.32-21.61-26.45-40.29-26.45a55.54 55.54 0 0 0 -11.72 1.24c-1.029 .224-2.059 .459-3.063 .72 .174-11.16-.074-22.94-1.066-34.53-3.522-40.76-17.79-62.12-32.67-79.16A130.2 130.2 0 0 0 332.1 36.44C309.5 23.55 283.9 17 256 17S202.6 23.55 180 36.44a129.7 129.7 0 0 0 -33.28 26.78c-14.88 17.04-29.15 38.44-32.67 79.16-.992 11.59-1.24 23.43-1.079 34.53-1-.26-2.021-.5-3.051-.719a55.46 55.46 0 0 0 -11.72-1.24c-18.69 0-34.13 10.13-40.3 26.45a42.42 42.42 0 0 0 2.046 35.23c4.105 7.774 10.65 14.73 20.01 21.28 2.48 1.736 6.361 4.24 11.25 7.44 2.641 1.711 6.5 4.216 10.28 6.72a11.05 11.05 0 0 1 3.3 3.311c.794 1.624 .818 3.373-.36 6.6a102 102 0 0 1 -8.94 15.78c-12.08 17.67-29.36 32.65-51.43 44.64C32.35 348.6 20.2 352.8 15.07 366.7c-3.868 10.53-1.339 22.51 8.494 32.6a49.14 49.14 0 0 0 12.4 9.387 134.3 134.3 0 0 0 30.34 12.14 20.02 20.02 0 0 1 6.126 2.741c3.583 3.137 3.075 7.861 7.849 14.78a34.47 34.47 0 0 0 8.977 9.127c10.02 6.919 21.28 7.353 33.21 7.811 10.78 .41 22.99 .881 36.94 5.481 5.778 1.91 11.78 5.605 18.74 9.92C194.8 480.1 217.7 495 255.1 495s61.29-14.12 78.12-24.43c6.907-4.24 12.87-7.9 18.49-9.758 13.95-4.613 26.16-5.072 36.94-5.481 11.93-.459 23.19-.893 33.21-7.812a34.58 34.58 0 0 0 10.22-11.16c3.434-5.84 3.348-9.919 6.572-12.77a18.97 18.97 0 0 1 5.753-2.629A134.9 134.9 0 0 0 476 408.7a48.34 48.34 0 0 0 13.02-10.19l.124-.149C498.4 388.5 500.7 376.9 496.9 366.6zm-34.01 18.28c-20.75 11.46-34.53 10.23-45.26 17.14-9.114 5.865-3.72 18.51-10.34 23.08-8.134 5.617-32.18-.4-63.24 9.858-25.62 8.469-41.96 32.82-88.04 32.82s-62.04-24.3-88.08-32.88c-31-10.26-55.09-4.241-63.24-9.858-6.609-4.563-1.24-17.21-10.34-23.08-10.74-6.907-24.53-5.679-45.26-17.08-13.21-7.291-5.716-11.8-1.314-13.94 75.14-36.38 87.13-92.55 87.67-96.72 .645-5.046 1.364-9.014-4.191-14.15-5.369-4.96-29.19-19.7-35.8-24.32-10.94-7.638-15.75-15.26-12.2-24.64 2.48-6.485 8.531-8.928 14.88-8.928a27.64 27.64 0 0 1 5.965 .67c12 2.6 23.66 8.617 30.39 10.24a10.75 10.75 0 0 0 2.48 .335c3.6 0 4.86-1.811 4.612-5.927-.768-13.13-2.628-38.72-.558-62.64 2.84-32.91 13.44-49.22 26.04-63.64 6.051-6.932 34.48-36.98 88.86-36.98s82.88 29.92 88.93 36.83c12.61 14.42 23.23 30.73 26.04 63.64 2.071 23.92 .285 49.53-.558 62.64-.285 4.327 1.017 5.927 4.613 5.927a10.65 10.65 0 0 0 2.48-.335c6.745-1.624 18.4-7.638 30.4-10.24a27.64 27.64 0 0 1 5.964-.67c6.386 0 12.4 2.48 14.88 8.928 3.546 9.374-1.24 17-12.19 24.64-6.609 4.612-30.43 19.34-35.8 24.32-5.568 5.134-4.836 9.1-4.191 14.15 .533 4.228 12.51 60.4 87.67 96.72C468.6 373 476.1 377.5 462.9 384.9z"]
};
var faTwitter = {
  prefix: 'fab',
  iconName: 'twitter',
  icon: [512, 512, [], "f099", "M459.4 151.7c.325 4.548 .325 9.097 .325 13.65 0 138.7-105.6 298.6-298.6 298.6-59.45 0-114.7-17.22-161.1-47.11 8.447 .974 16.57 1.299 25.34 1.299 49.06 0 94.21-16.57 130.3-44.83-46.13-.975-84.79-31.19-98.11-72.77 6.498 .974 12.99 1.624 19.82 1.624 9.421 0 18.84-1.3 27.61-3.573-48.08-9.747-84.14-51.98-84.14-102.1v-1.299c13.97 7.797 30.21 12.67 47.43 13.32-28.26-18.84-46.78-51.01-46.78-87.39 0-19.49 5.197-37.36 14.29-52.95 51.65 63.67 129.3 105.3 216.4 109.8-1.624-7.797-2.599-15.92-2.599-24.04 0-57.83 46.78-104.9 104.9-104.9 30.21 0 57.5 12.67 76.67 33.14 23.72-4.548 46.46-13.32 66.6-25.34-7.798 24.37-24.37 44.83-46.13 57.83 21.12-2.273 41.58-8.122 60.43-16.24-14.29 20.79-32.16 39.31-52.63 54.25z"]
};
var faWikipediaW = {
  prefix: 'fab',
  iconName: 'wikipedia-w',
  icon: [640, 512, [], "f266", "M640 51.2l-.3 12.2c-28.1 .8-45 15.8-55.8 40.3-25 57.8-103.3 240-155.3 358.6H415l-81.9-193.1c-32.5 63.6-68.3 130-99.2 193.1-.3 .3-15 0-15-.3C172 352.3 122.8 243.4 75.8 133.4 64.4 106.7 26.4 63.4 .2 63.7c0-3.1-.3-10-.3-14.2h161.9v13.9c-19.2 1.1-52.8 13.3-43.3 34.2 21.9 49.7 103.6 240.3 125.6 288.6 15-29.7 57.8-109.2 75.3-142.8-13.9-28.3-58.6-133.9-72.8-160-9.7-17.8-36.1-19.4-55.8-19.7V49.8l142.5 .3v13.1c-19.4 .6-38.1 7.8-29.4 26.1 18.9 40 30.6 68.1 48.1 104.7 5.6-10.8 34.7-69.4 48.1-100.8 8.9-20.6-3.9-28.6-38.6-29.4 .3-3.6 0-10.3 .3-13.6 44.4-.3 111.1-.3 123.1-.6v13.6c-22.5 .8-45.8 12.8-58.1 31.7l-59.2 122.8c6.4 16.1 63.3 142.8 69.2 156.7L559.2 91.8c-8.6-23.1-36.4-28.1-47.2-28.3V49.6l127.8 1.1 .2 .5z"]
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));

// src/utils/format.utils.ts
function pascalCase(str) {
  return (str.match(/[a-zA-Z0-9]+/g) || []).map((w) => `${w.charAt(0).toUpperCase()}${w.slice(1)}`).join("");
}
var defineChartComponent = (chartName, chartType) => {
  const propsDefs = {
    chartData: { type: Object, required: true },
    options: { type: Object, required: false },
    chartId: { default: chartName, type: String },
    width: { default: 400, type: Number },
    height: { default: 400, type: Number },
    cssClasses: { type: String, default: "" },
    styles: { type: Object },
    plugins: { type: Array, default: () => [] },
    onLabelsUpdate: { type: Function },
    onChartUpdate: { type: Function },
    onChartDestroy: { type: Function },
    onChartRender: { type: Function }
  };
  const componentName = pascalCase(chartName);
  return vue_cjs_prod.defineComponent({
    name: componentName,
    props: propsDefs,
    emits: {
      "labels:update": () => true,
      "chart:update": (chartInstance) => true,
      "chart:destroy": () => true,
      "chart:render": (chartInstance) => true
    },
    setup(props, { emit, expose }) {
      const canvasRef = vue_cjs_prod.ref(null);
      const canvasId = `${props.chartId}`;
      let chartInstance = vue_cjs_prod.shallowRef(null);
      vue_cjs_prod.watch(() => props.chartData, watchHandler, { deep: true });
      vue_cjs_prod.watch(() => props.options, (newOptions) => {
        if (chartInstance.value && newOptions) {
          chartInstance.value.options = cloneDeep(newOptions);
          handleChartUpdate();
        }
      }, { deep: true });
      function watchHandler(newData) {
        if (chartInstance.value) {
          let chart = chartInstance.value;
          if (!isEqual(newData.labels, chartInstance.value.data.labels)) {
            chart.data.labels = newData.labels;
            handleLabelsUpdate();
          }
          if (!isEqual(newData.datasets, chartInstance.value.data.datasets)) {
            newData.datasets.forEach((dataset, index) => {
              var _a, _b;
              if (!isEmpty(dataset)) {
                const oldData = cloneDeep(chart.data);
                const oldDatasetKeys = Object.keys((_b = (_a = oldData.datasets) == null ? void 0 : _a[index]) != null ? _b : {});
                const newDatasetKeys = Object.keys(dataset);
                const deletionKeys = oldDatasetKeys.filter((key) => {
                  return key !== "_meta" && newDatasetKeys.indexOf(key) === -1;
                });
                deletionKeys.forEach((deletionKey) => {
                  if (chart.data.datasets[index]) {
                    delete chart.data.datasets[index][deletionKey];
                  }
                });
                for (const attribute in dataset) {
                  const attrValue = cloneDeep(dataset[attribute]);
                  let datasetItem = chart.data.datasets[index];
                  if (!datasetItem) {
                    chart.data.datasets[index] = {};
                  }
                  if (dataset.hasOwnProperty(attribute) && attrValue != null && chart) {
                    chart.data.datasets[index][attribute] = attrValue;
                  }
                }
              } else {
                chart.data.datasets = [];
              }
            });
          }
          handleChartUpdate();
        } else {
          if (chartInstance.value) {
            handleChartDestroy();
          }
          renderChart();
        }
      }
      function renderChart() {
        if (canvasRef.value) {
          chartInstance.value = new Chartjs.Chart(canvasRef.value, {
            data: cloneDeep(props.chartData),
            type: chartType,
            options: cloneDeep(props.options),
            plugins: props.plugins
          });
          handleChartRender();
        } else {
          console.error(`Error on component ${componentName}, canvas cannot be rendered. Check if the render appends server-side`);
        }
      }
      function handleLabelsUpdate() {
        emit("labels:update");
        props.onLabelsUpdate && props.onLabelsUpdate();
      }
      function handleChartRender() {
        if (chartInstance.value) {
          emit("chart:render", chartInstance.value);
          props.onChartRender && props.onChartRender(chartInstance.value);
        }
      }
      function handleChartUpdate() {
        if (chartInstance.value) {
          chartInstance.value.update();
          emit("chart:update", chartInstance.value);
          props.onChartUpdate && props.onChartUpdate(chartInstance.value);
        }
      }
      function handleChartDestroy() {
        chartInstance.value && chartInstance.value.destroy();
        emit("chart:destroy");
        props.onChartDestroy && props.onChartDestroy();
      }
      vue_cjs_prod.onMounted(renderChart);
      vue_cjs_prod.onBeforeUnmount(() => {
        if (chartInstance.value) {
          chartInstance.value.destroy();
        }
      });
      expose({
        canvasRef,
        renderChart,
        chartInstance,
        canvasId,
        update: handleChartUpdate
      });
      return () => vue_cjs_prod.h("div", {
        style: __spreadProps$1(__spreadValues$1({
          maxWidth: "100%"
        }, props.styles), {
          position: "relative"
        }),
        class: props.cssClasses
      }, [
        vue_cjs_prod.h("canvas", {
          style: {
            maxWidth: "100%",
            maxHeight: "100%"
          },
          id: canvasId,
          width: props.width,
          height: props.height,
          ref: canvasRef
        })
      ]);
    }
  });
};

// src/exports/component.exports.ts
defineChartComponent("bar-chart", "bar");
defineChartComponent("doughnut-chart", "doughnut");
defineChartComponent("line-chart", "line");
defineChartComponent("pie-chart", "pie");
defineChartComponent("polar-chart", "polarArea");
defineChartComponent("radar-chart", "radar");
defineChartComponent("bubble-chart", "bubble");
var ScatterChart = defineChartComponent("scatter-chart", "scatter");

const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^["{[]|^-?[0-9][0-9.]{0,14}$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor") {
    return;
  }
  return value;
}
function destr(val) {
  if (typeof val !== "string") {
    return val;
  }
  const _lval = val.toLowerCase();
  if (_lval === "true") {
    return true;
  }
  if (_lval === "false") {
    return false;
  }
  if (_lval === "null") {
    return null;
  }
  if (_lval === "nan") {
    return NaN;
  }
  if (_lval === "infinity") {
    return Infinity;
  }
  if (_lval === "undefined") {
    return void 0;
  }
  if (!JsonSigRx.test(val)) {
    return val;
  }
  try {
    if (suspectProtoRx.test(val) || suspectConstructorRx.test(val)) {
      return JSON.parse(val, jsonParseTransform);
    }
    return JSON.parse(val);
  } catch (_e) {
    return val;
  }
}
class FetchError extends Error {
  constructor() {
    super(...arguments);
    this.name = "FetchError";
  }
}
function createFetchError(request2, error, response) {
  let message = "";
  if (request2 && response) {
    message = `${response.status} ${response.statusText} (${request2.toString()})`;
  }
  if (error) {
    message = `${error.message} (${message})`;
  }
  const fetchError = new FetchError(message);
  Object.defineProperty(fetchError, "request", { get() {
    return request2;
  } });
  Object.defineProperty(fetchError, "response", { get() {
    return response;
  } });
  Object.defineProperty(fetchError, "data", { get() {
    return response && response._data;
  } });
  return fetchError;
}
const payloadMethods = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(val) {
  if (val === void 0) {
    return false;
  }
  const t = typeof val;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(val)) {
    return true;
  }
  return val.constructor && val.constructor.name === "Object" || typeof val.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*`\-.^~]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift();
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  409,
  425,
  429,
  500,
  502,
  503,
  504
]);
function createFetch(globalOptions) {
  const { fetch: fetch2, Headers: Headers2 } = globalOptions;
  function onError(ctx) {
    if (ctx.options.retry !== false) {
      const retries = typeof ctx.options.retry === "number" ? ctx.options.retry : isPayloadMethod(ctx.options.method) ? 0 : 1;
      const responseCode = ctx.response && ctx.response.status || 500;
      if (retries > 0 && retryStatusCodes.has(responseCode)) {
        return $fetchRaw(ctx.request, {
          ...ctx.options,
          retry: retries - 1
        });
      }
    }
    const err = createFetchError(ctx.request, ctx.error, ctx.response);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(err, $fetchRaw);
    }
    throw err;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _opts = {}) {
    const ctx = {
      request: _request,
      options: { ...globalOptions.defaults, ..._opts },
      response: void 0,
      error: void 0
    };
    if (ctx.options.onRequest) {
      await ctx.options.onRequest(ctx);
    }
    if (typeof ctx.request === "string") {
      if (ctx.options.baseURL) {
        ctx.request = withBase(ctx.request, ctx.options.baseURL);
      }
      if (ctx.options.params) {
        ctx.request = withQuery(ctx.request, ctx.options.params);
      }
      if (ctx.options.body && isPayloadMethod(ctx.options.method)) {
        if (isJSONSerializable(ctx.options.body)) {
          ctx.options.body = typeof ctx.options.body === "string" ? ctx.options.body : JSON.stringify(ctx.options.body);
          ctx.options.headers = new Headers2(ctx.options.headers);
          if (!ctx.options.headers.has("content-type")) {
            ctx.options.headers.set("content-type", "application/json");
          }
          if (!ctx.options.headers.has("accept")) {
            ctx.options.headers.set("accept", "application/json");
          }
        }
      }
    }
    ctx.response = await fetch2(ctx.request, ctx.options).catch(async (error) => {
      ctx.error = error;
      if (ctx.options.onRequestError) {
        await ctx.options.onRequestError(ctx);
      }
      return onError(ctx);
    });
    const responseType = (ctx.options.parseResponse ? "json" : ctx.options.responseType) || detectResponseType(ctx.response.headers.get("content-type") || "");
    if (responseType === "json") {
      const data = await ctx.response.text();
      const parseFn = ctx.options.parseResponse || destr;
      ctx.response._data = parseFn(data);
    } else {
      ctx.response._data = await ctx.response[responseType]();
    }
    if (ctx.options.onResponse) {
      await ctx.options.onResponse(ctx);
    }
    if (!ctx.response.ok) {
      if (ctx.options.onResponseError) {
        await ctx.options.onResponseError(ctx);
      }
    }
    return ctx.response.ok ? ctx.response : onError(ctx);
  };
  const $fetch2 = function $fetch22(request2, opts) {
    return $fetchRaw(request2, opts).then((r) => r._data);
  };
  $fetch2.raw = $fetchRaw;
  $fetch2.create = (defaultOptions = {}) => createFetch({
    ...globalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch2;
}
const _globalThis$2 = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}();
const fetch = _globalThis$2.fetch || (() => Promise.reject(new Error("[ohmyfetch] global.fetch is not supported!")));
const Headers = _globalThis$2.Headers;
const $fetch$1 = createFetch({ fetch, Headers });
const appConfig = useRuntimeConfig$1().app;
const baseURL = () => appConfig.baseURL;
function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
function serialCaller(hooks, args) {
  return hooks.reduce((promise, hookFn) => promise.then(() => hookFn.apply(void 0, args)), Promise.resolve(null));
}
function parallelCaller(hooks, args) {
  return Promise.all(hooks.map((hook) => hook.apply(void 0, args)));
}
class Hookable {
  constructor() {
    this._hooks = {};
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, fn) {
    if (!name || typeof fn !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let deprecatedHookObj;
    while (this._deprecatedHooks[name]) {
      const deprecatedHook = this._deprecatedHooks[name];
      if (typeof deprecatedHook === "string") {
        deprecatedHookObj = { to: deprecatedHook };
      } else {
        deprecatedHookObj = deprecatedHook;
      }
      name = deprecatedHookObj.to;
    }
    if (deprecatedHookObj) {
      if (!deprecatedHookObj.message) {
        console.warn(`${originalName} hook has been deprecated` + (deprecatedHookObj.to ? `, please use ${deprecatedHookObj.to}` : ""));
      } else {
        console.warn(deprecatedHookObj.message);
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(fn);
    return () => {
      if (fn) {
        this.removeHook(name, fn);
        fn = null;
      }
    };
  }
  hookOnce(name, fn) {
    let _unreg;
    let _fn = (...args) => {
      _unreg();
      _unreg = null;
      _fn = null;
      return fn(...args);
    };
    _unreg = this.hook(name, _fn);
    return _unreg;
  }
  removeHook(name, fn) {
    if (this._hooks[name]) {
      const idx = this._hooks[name].indexOf(fn);
      if (idx !== -1) {
        this._hooks[name].splice(idx, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = deprecated;
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map((key) => this.hook(key, hooks[key]));
    return () => {
      removeFns.splice(0, removeFns.length).forEach((unreg) => unreg());
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  callHook(name, ...args) {
    return serialCaller(this._hooks[name] || [], args);
  }
  callHookParallel(name, ...args) {
    return parallelCaller(this._hooks[name] || [], args);
  }
  callHookWith(caller, name, ...args) {
    return caller(this._hooks[name] || [], args);
  }
}
function createHooks() {
  return new Hookable();
}
function createContext$1() {
  let currentInstance = null;
  let isSingleton = false;
  const checkConflict = (instance) => {
    if (currentInstance && currentInstance !== instance) {
      throw new Error("Context conflict");
    }
  };
  return {
    use: () => currentInstance,
    set: (instance, replace) => {
      if (!replace) {
        checkConflict(instance);
      }
      currentInstance = instance;
      isSingleton = true;
    },
    unset: () => {
      currentInstance = null;
      isSingleton = false;
    },
    call: (instance, cb) => {
      checkConflict(instance);
      currentInstance = instance;
      try {
        return cb();
      } finally {
        if (!isSingleton) {
          currentInstance = null;
        }
      }
    },
    async callAsync(instance, cb) {
      currentInstance = instance;
      const onRestore = () => {
        currentInstance = instance;
      };
      const onLeave = () => currentInstance === instance ? onRestore : void 0;
      asyncHandlers.add(onLeave);
      try {
        const r = cb();
        if (!isSingleton) {
          currentInstance = null;
        }
        return await r;
      } finally {
        asyncHandlers.delete(onLeave);
      }
    }
  };
}
function createNamespace() {
  const contexts = {};
  return {
    get(key) {
      if (!contexts[key]) {
        contexts[key] = createContext$1();
      }
      contexts[key];
      return contexts[key];
    }
  };
}
const _globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
const globalKey = "__unctx__";
const defaultNamespace = _globalThis$1[globalKey] || (_globalThis$1[globalKey] = createNamespace());
const getContext = (key) => defaultNamespace.get(key);
const asyncHandlersKey = "__unctx_async_handlers__";
const asyncHandlers = _globalThis$1[asyncHandlersKey] || (_globalThis$1[asyncHandlersKey] = /* @__PURE__ */ new Set());
function createMock(name, overrides2 = {}) {
  const fn = function() {
  };
  fn.prototype.name = name;
  const props = {};
  return new Proxy(fn, {
    get(_target, prop) {
      if (prop === "caller") {
        return null;
      }
      if (prop === "__createMock__") {
        return createMock;
      }
      if (prop in overrides2) {
        return overrides2[prop];
      }
      return props[prop] = props[prop] || createMock(`${name}.${prop.toString()}`);
    },
    apply(_target, _this, _args) {
      return createMock(`${name}()`);
    },
    construct(_target, _args, _newT) {
      return createMock(`[${name}]`);
    },
    enumerate(_target) {
      return [];
    }
  });
}
const mockContext = createMock("mock");
function mock(warning) {
  console.warn(warning);
  return mockContext;
}
const unsupported = /* @__PURE__ */ new Set([
  "store",
  "spa",
  "fetchCounters"
]);
const todo = /* @__PURE__ */ new Set([
  "isHMR",
  "base",
  "payload",
  "from",
  "next",
  "error",
  "redirect",
  "redirected",
  "enablePreview",
  "$preview",
  "beforeNuxtRender",
  "beforeSerialize"
]);
const routerKeys = ["route", "params", "query"];
const staticFlags = {
  isClient: false,
  isServer: true,
  isDev: false,
  isStatic: void 0,
  target: "server",
  modern: false
};
const legacyPlugin = (nuxtApp) => {
  nuxtApp._legacyContext = new Proxy(nuxtApp, {
    get(nuxt, p) {
      if (unsupported.has(p)) {
        return mock(`Accessing ${p} is not supported in Nuxt 3.`);
      }
      if (todo.has(p)) {
        return mock(`Accessing ${p} is not yet supported in Nuxt 3.`);
      }
      if (routerKeys.includes(p)) {
        if (!("$router" in nuxtApp)) {
          return mock("vue-router is not being used in this project.");
        }
        switch (p) {
          case "route":
            return nuxt.$router.currentRoute.value;
          case "params":
          case "query":
            return nuxt.$router.currentRoute.value[p];
        }
      }
      if (p === "$config" || p === "env") {
        return useRuntimeConfig();
      }
      if (p in staticFlags) {
        return staticFlags[p];
      }
      if (p === "ssrContext") {
        return nuxt._legacyContext;
      }
      if (nuxt.ssrContext && p in nuxt.ssrContext) {
        return nuxt.ssrContext[p];
      }
      if (p === "nuxt") {
        return nuxt.payload;
      }
      if (p === "nuxtState") {
        return nuxt.payload.data;
      }
      if (p in nuxtApp.vueApp) {
        return nuxtApp.vueApp[p];
      }
      if (p in nuxtApp) {
        return nuxtApp[p];
      }
      return mock(`Accessing ${p} is not supported in Nuxt3.`);
    }
  });
};
const nuxtAppCtx = getContext("nuxt-app");
const NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(options) {
  const nuxtApp = {
    provide: void 0,
    globalName: "nuxt",
    payload: vue_cjs_prod.reactive({
      data: {},
      state: {},
      _errors: {},
      ...{ serverRendered: true }
    }),
    isHydrating: false,
    _asyncDataPromises: {},
    ...options
  };
  nuxtApp.hooks = createHooks();
  nuxtApp.hook = nuxtApp.hooks.hook;
  nuxtApp.callHook = nuxtApp.hooks.callHook;
  nuxtApp.provide = (name, value) => {
    const $name = "$" + name;
    defineGetter(nuxtApp, $name, value);
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);
  };
  defineGetter(nuxtApp.vueApp, "$nuxt", nuxtApp);
  defineGetter(nuxtApp.vueApp.config.globalProperties, "$nuxt", nuxtApp);
  if (nuxtApp.ssrContext) {
    nuxtApp.ssrContext.nuxt = nuxtApp;
  }
  {
    nuxtApp.ssrContext = nuxtApp.ssrContext || {};
    nuxtApp.ssrContext.payload = nuxtApp.payload;
  }
  {
    nuxtApp.payload.config = {
      public: options.ssrContext.runtimeConfig.public,
      app: options.ssrContext.runtimeConfig.app
    };
  }
  const runtimeConfig = options.ssrContext.runtimeConfig;
  const compatibilityConfig = new Proxy(runtimeConfig, {
    get(target, prop) {
      var _a;
      if (prop === "public") {
        return target.public;
      }
      return (_a = target[prop]) != null ? _a : target.public[prop];
    },
    set(target, prop, value) {
      {
        return false;
      }
    }
  });
  nuxtApp.provide("config", compatibilityConfig);
  return nuxtApp;
}
async function applyPlugin(nuxtApp, plugin) {
  if (typeof plugin !== "function") {
    return;
  }
  const { provide: provide2 } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};
  if (provide2 && typeof provide2 === "object") {
    for (const key in provide2) {
      nuxtApp.provide(key, provide2[key]);
    }
  }
}
async function applyPlugins(nuxtApp, plugins2) {
  for (const plugin of plugins2) {
    await applyPlugin(nuxtApp, plugin);
  }
}
function normalizePlugins(_plugins2) {
  let needsLegacyContext = false;
  const plugins2 = _plugins2.map((plugin) => {
    if (typeof plugin !== "function") {
      return () => {
      };
    }
    if (isLegacyPlugin(plugin)) {
      needsLegacyContext = true;
      return (nuxtApp) => plugin(nuxtApp._legacyContext, nuxtApp.provide);
    }
    return plugin;
  });
  if (needsLegacyContext) {
    plugins2.unshift(legacyPlugin);
  }
  return plugins2;
}
function defineNuxtPlugin(plugin) {
  plugin[NuxtPluginIndicator] = true;
  return plugin;
}
function isLegacyPlugin(plugin) {
  return !plugin[NuxtPluginIndicator];
}
function callWithNuxt(nuxt, setup, args) {
  const fn = () => args ? setup(...args) : setup();
  {
    return nuxtAppCtx.callAsync(nuxt, fn);
  }
}
function useNuxtApp() {
  const vm = vue_cjs_prod.getCurrentInstance();
  if (!vm) {
    const nuxtAppInstance = nuxtAppCtx.use();
    if (!nuxtAppInstance) {
      throw new Error("nuxt instance unavailable");
    }
    return nuxtAppInstance;
  }
  return vm.appContext.app.$nuxt;
}
function useRuntimeConfig() {
  return useNuxtApp().$config;
}
function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
const wrapInRef = (value) => vue_cjs_prod.isRef(value) ? value : vue_cjs_prod.ref(value);
const getDefault = () => null;
function useAsyncData(key, handler, options = {}) {
  var _a, _b, _c, _d, _e;
  if (typeof key !== "string") {
    throw new TypeError("asyncData key must be a string");
  }
  if (typeof handler !== "function") {
    throw new TypeError("asyncData handler must be a function");
  }
  options = { server: true, default: getDefault, ...options };
  if (options.defer) {
    console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC.");
  }
  options.lazy = (_b = (_a = options.lazy) != null ? _a : options.defer) != null ? _b : false;
  options.initialCache = (_c = options.initialCache) != null ? _c : true;
  const nuxt = useNuxtApp();
  const instance = vue_cjs_prod.getCurrentInstance();
  if (instance && !instance._nuxtOnBeforeMountCbs) {
    const cbs = instance._nuxtOnBeforeMountCbs = [];
    if (instance && false) {
      vue_cjs_prod.onBeforeMount(() => {
        cbs.forEach((cb) => {
          cb();
        });
        cbs.splice(0, cbs.length);
      });
      vue_cjs_prod.onUnmounted(() => cbs.splice(0, cbs.length));
    }
  }
  const useInitialCache = () => options.initialCache && nuxt.payload.data[key] !== void 0;
  const asyncData = {
    data: wrapInRef((_d = nuxt.payload.data[key]) != null ? _d : options.default()),
    pending: vue_cjs_prod.ref(!useInitialCache()),
    error: vue_cjs_prod.ref((_e = nuxt.payload._errors[key]) != null ? _e : null)
  };
  asyncData.refresh = (opts = {}) => {
    if (nuxt._asyncDataPromises[key]) {
      return nuxt._asyncDataPromises[key];
    }
    if (opts._initial && useInitialCache()) {
      return nuxt.payload.data[key];
    }
    asyncData.pending.value = true;
    nuxt._asyncDataPromises[key] = Promise.resolve(handler(nuxt)).then((result) => {
      if (options.transform) {
        result = options.transform(result);
      }
      if (options.pick) {
        result = pick$2(result, options.pick);
      }
      asyncData.data.value = result;
      asyncData.error.value = null;
    }).catch((error) => {
      asyncData.error.value = error;
      asyncData.data.value = vue_cjs_prod.unref(options.default());
    }).finally(() => {
      asyncData.pending.value = false;
      nuxt.payload.data[key] = asyncData.data.value;
      if (asyncData.error.value) {
        nuxt.payload._errors[key] = true;
      }
      delete nuxt._asyncDataPromises[key];
    });
    return nuxt._asyncDataPromises[key];
  };
  const initialFetch = () => asyncData.refresh({ _initial: true });
  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;
  if (fetchOnServer) {
    const promise = initialFetch();
    vue_cjs_prod.onServerPrefetch(() => promise);
  }
  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);
  Object.assign(asyncDataPromise, asyncData);
  return asyncDataPromise;
}
function pick$2(obj, keys2) {
  const newObj = {};
  for (const key of keys2) {
    newObj[key] = obj[key];
  }
  return newObj;
}
const useState = (key, init) => {
  const nuxt = useNuxtApp();
  const state2 = vue_cjs_prod.toRef(nuxt.payload.state, key);
  if (state2.value === void 0 && init) {
    const initialValue = init();
    if (vue_cjs_prod.isRef(initialValue)) {
      nuxt.payload.state[key] = initialValue;
      return initialValue;
    }
    state2.value = initialValue;
  }
  return state2;
};
const useError = () => {
  const nuxtApp = useNuxtApp();
  return useState("error", () => nuxtApp.ssrContext.error);
};
const throwError = (_err) => {
  const nuxtApp = useNuxtApp();
  useError();
  const err = typeof _err === "string" ? new Error(_err) : _err;
  nuxtApp.callHook("app:error", err);
  {
    nuxtApp.ssrContext.error = nuxtApp.ssrContext.error || err;
  }
  return err;
};
function murmurHash(key, seed = 0) {
  if (typeof key === "string") {
    key = createBuffer(key);
  }
  let i = 0;
  let h12 = seed;
  let k1;
  let h1b;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  const c1 = 3432918353;
  const c2 = 461845907;
  while (i < bytes) {
    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;
    ++i;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h12 ^= k1;
    h12 = h12 << 13 | h12 >>> 19;
    h1b = (h12 & 65535) * 5 + (((h12 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h12 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (key[i + 2] & 255) << 16;
      break;
    case 2:
      k1 ^= (key[i + 1] & 255) << 8;
      break;
    case 1:
      k1 ^= key[i] & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h12 ^= k1;
  }
  h12 ^= key.length;
  h12 ^= h12 >>> 16;
  h12 = (h12 & 65535) * 2246822507 + (((h12 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h12 ^= h12 >>> 13;
  h12 = (h12 & 65535) * 3266489909 + (((h12 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h12 ^= h12 >>> 16;
  return h12 >>> 0;
}
function createBuffer(val) {
  return new TextEncoder().encode(val);
}
const defaults$1 = {
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false
};
function objectHash(object, options = {}) {
  options = { ...defaults$1, ...options };
  const hasher = createHasher(options);
  hasher.dispatch(object);
  return hasher.toString();
}
function createHasher(options) {
  const buff = [];
  let context = [];
  const write = (str) => {
    buff.push(str);
  };
  return {
    toString() {
      return buff.join("");
    },
    getContext() {
      return context;
    },
    dispatch(value) {
      if (options.replacer) {
        value = options.replacer(value);
      }
      const type = value === null ? "null" : typeof value;
      return this["_" + type](value);
    },
    _object(object) {
      const pattern = /\[object (.*)\]/i;
      const objString = Object.prototype.toString.call(object);
      const _objType = pattern.exec(objString);
      const objType = _objType ? _objType[1].toLowerCase() : "unknown:[" + objString.toLowerCase() + "]";
      let objectNumber = null;
      if ((objectNumber = context.indexOf(object)) >= 0) {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      } else {
        context.push(object);
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write("buffer:");
        return write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this["_" + objType]) {
          this["_" + objType](object);
        } else if (options.ignoreUnknown) {
          return write("[" + objType + "]");
        } else {
          throw new Error('Unknown object type "' + objType + '"');
        }
      } else {
        let keys2 = Object.keys(object);
        if (options.unorderedObjects) {
          keys2 = keys2.sort();
        }
        if (options.respectType !== false && !isNativeFunction(object)) {
          keys2.splice(0, 0, "prototype", "__proto__", "letructor");
        }
        if (options.excludeKeys) {
          keys2 = keys2.filter(function(key) {
            return !options.excludeKeys(key);
          });
        }
        write("object:" + keys2.length + ":");
        return keys2.forEach((key) => {
          this.dispatch(key);
          write(":");
          if (!options.excludeValues) {
            this.dispatch(object[key]);
          }
          write(",");
        });
      }
    },
    _array(arr, unordered) {
      unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
      write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        return arr.forEach((entry2) => {
          return this.dispatch(entry2);
        });
      }
      const contextAdditions = [];
      const entries = arr.map((entry2) => {
        const hasher = createHasher(options);
        hasher.dispatch(entry2);
        contextAdditions.push(hasher.getContext());
        return hasher.toString();
      });
      context = context.concat(contextAdditions);
      entries.sort();
      return this._array(entries, false);
    },
    _date(date2) {
      return write("date:" + date2.toJSON());
    },
    _symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    _error(err) {
      return write("error:" + err.toString());
    },
    _boolean(bool) {
      return write("bool:" + bool.toString());
    },
    _string(string2) {
      write("string:" + string2.length + ":");
      write(string2.toString());
    },
    _function(fn) {
      write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
      if (options.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn.name));
      }
      if (options.respectFunctionProperties) {
        this._object(fn);
      }
    },
    _number(number2) {
      return write("number:" + number2.toString());
    },
    _xml(xml) {
      return write("xml:" + xml.toString());
    },
    _null() {
      return write("Null");
    },
    _undefined() {
      return write("Undefined");
    },
    _regexp(regex) {
      return write("regex:" + regex.toString());
    },
    _uint8array(arr) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint8clampedarray(arr) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int8array(arr) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint16array(arr) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int16array(arr) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint32array(arr) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int32array(arr) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float32array(arr) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float64array(arr) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _arraybuffer(arr) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    },
    _url(url2) {
      return write("url:" + url2.toString());
    },
    _map(map2) {
      write("map:");
      const arr = Array.from(map2);
      return this._array(arr, options.unorderedSets !== false);
    },
    _set(set2) {
      write("set:");
      const arr = Array.from(set2);
      return this._array(arr, options.unorderedSets !== false);
    },
    _file(file2) {
      write("file:");
      return this.dispatch([file2.name, file2.size, file2.type, file2.lastModfied]);
    },
    _blob() {
      if (options.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error('Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n');
    },
    _domwindow() {
      return write("domwindow");
    },
    _bigint(number2) {
      return write("bigint:" + number2.toString());
    },
    _process() {
      return write("process");
    },
    _timer() {
      return write("timer");
    },
    _pipe() {
      return write("pipe");
    },
    _tcp() {
      return write("tcp");
    },
    _udp() {
      return write("udp");
    },
    _tty() {
      return write("tty");
    },
    _statwatcher() {
      return write("statwatcher");
    },
    _securecontext() {
      return write("securecontext");
    },
    _connection() {
      return write("connection");
    },
    _zlib() {
      return write("zlib");
    },
    _context() {
      return write("context");
    },
    _nodescript() {
      return write("nodescript");
    },
    _httpparser() {
      return write("httpparser");
    },
    _dataview() {
      return write("dataview");
    },
    _signal() {
      return write("signal");
    },
    _fsevent() {
      return write("fsevent");
    },
    _tlswrap() {
      return write("tlswrap");
    }
  };
}
function isNativeFunction(f) {
  if (typeof f !== "function") {
    return false;
  }
  const exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
  return exp.exec(Function.prototype.toString.call(f)) != null;
}
function hash(object, options = {}) {
  const hashed = typeof object === "string" ? object : objectHash(object, options);
  return String(murmurHash(hashed));
}
function useFetch(request2, opts = {}) {
  const key = "$f_" + (opts.key || hash([request2, { ...opts, transform: null }]));
  const _request = vue_cjs_prod.computed(() => {
    let r = request2;
    if (typeof r === "function") {
      r = r();
    }
    return vue_cjs_prod.isRef(r) ? r.value : r;
  });
  const _fetchOptions = {
    ...opts,
    cache: typeof opts.cache === "boolean" ? void 0 : opts.cache
  };
  const _asyncDataOptions = {
    ...opts,
    watch: [
      _request,
      ...opts.watch || []
    ]
  };
  const asyncData = useAsyncData(key, () => {
    return $fetch(_request.value, _fetchOptions);
  }, _asyncDataOptions);
  return asyncData;
}
const MIMES = {
  html: "text/html",
  json: "application/json"
};
const defer$2 = typeof setImmediate !== "undefined" ? setImmediate : (fn) => fn();
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve2) => {
    defer$2(() => {
      event.res.end(data);
      resolve2(void 0);
    });
  });
}
function defaultContentType(event, type) {
  if (type && !event.res.getHeader("Content-Type")) {
    event.res.setHeader("Content-Type", type);
  }
}
function sendRedirect(event, location, code2 = 302) {
  event.res.statusCode = code2;
  event.res.setHeader("Location", location);
  return send(event, "Redirecting to " + location, MIMES.html);
}
class H3Error extends Error {
  constructor() {
    super(...arguments);
    this.statusCode = 500;
    this.statusMessage = "Internal Server Error";
  }
}
function createError(input) {
  var _a;
  if (typeof input === "string") {
    return new H3Error(input);
  }
  if (input instanceof H3Error) {
    return input;
  }
  const err = new H3Error((_a = input.message) != null ? _a : input.statusMessage, input.cause ? { cause: input.cause } : void 0);
  if (input.statusCode) {
    err.statusCode = input.statusCode;
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  }
  if (input.data) {
    err.data = input.data;
  }
  return err;
}
const useRouter = () => {
  var _a;
  return (_a = useNuxtApp()) == null ? void 0 : _a.$router;
};
const navigateTo = (to2, options = {}) => {
  if (!to2) {
    to2 = "/";
  }
  const router = useRouter();
  {
    const nuxtApp = useNuxtApp();
    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {
      const redirectLocation = joinURL(useRuntimeConfig().app.baseURL, router.resolve(to2).fullPath || "/");
      return nuxtApp.callHook("app:redirected").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options.redirectCode || 302));
    }
  }
  return options.replace ? router.replace(to2) : router.push(to2);
};
const firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);
const DEFAULT_EXTERNAL_REL_ATTRIBUTE = "noopener noreferrer";
function defineNuxtLink(options) {
  const componentName = options.componentName || "NuxtLink";
  const checkPropConflicts = (props, main2, sub) => {
  };
  return vue_cjs_prod.defineComponent({
    name: componentName,
    props: {
      to: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      href: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      target: {
        type: String,
        default: void 0,
        required: false
      },
      rel: {
        type: String,
        default: void 0,
        required: false
      },
      noRel: {
        type: Boolean,
        default: void 0,
        required: false
      },
      activeClass: {
        type: String,
        default: void 0,
        required: false
      },
      exactActiveClass: {
        type: String,
        default: void 0,
        required: false
      },
      replace: {
        type: Boolean,
        default: void 0,
        required: false
      },
      ariaCurrentValue: {
        type: String,
        default: void 0,
        required: false
      },
      external: {
        type: Boolean,
        default: void 0,
        required: false
      },
      custom: {
        type: Boolean,
        default: void 0,
        required: false
      }
    },
    setup(props, { slots }) {
      const router = useRouter();
      const to2 = vue_cjs_prod.computed(() => {
        checkPropConflicts();
        return props.to || props.href || "";
      });
      const isExternal = vue_cjs_prod.computed(() => {
        if (props.external) {
          return true;
        }
        if (props.target && props.target !== "_self") {
          return true;
        }
        if (typeof to2.value === "object") {
          return false;
        }
        return to2.value === "" || hasProtocol(to2.value, true);
      });
      return () => {
        var _a, _b, _c;
        if (!isExternal.value) {
          return vue_cjs_prod.h(vue_cjs_prod.resolveComponent("RouterLink"), {
            to: to2.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue
          }, slots.default);
        }
        const href = typeof to2.value === "object" ? (_b = (_a = router.resolve(to2.value)) == null ? void 0 : _a.href) != null ? _b : null : to2.value || null;
        const target = props.target || null;
        checkPropConflicts();
        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : "") || null;
        return vue_cjs_prod.h("a", { href, rel, target }, (_c = slots.default) == null ? void 0 : _c.call(slots));
      };
    }
  });
}
const __nuxt_component_1$7 = defineNuxtLink({ componentName: "NuxtLink" });
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var shared_cjs_prod = {};
Object.defineProperty(shared_cjs_prod, "__esModule", { value: true });
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list2 = str.split(",");
  for (let i = 0; i < list2.length; i++) {
    map2[list2[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source2, start = 0, end = source2.length) {
  let lines = source2.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const escapeRE = /["'&<>]/;
function escapeHtml(string2) {
  const str = "" + string2;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index2;
  let lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.slice(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escaped;
  }
  return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src2) {
  return src2.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal3 = true;
  for (let i = 0; equal3 && i < a.length; i++) {
    equal3 = looseEqual(a[i], b[i]);
  }
  return equal3;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$1(a);
  bValidType = isArray$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$3(a);
  bValidType = isObject$3(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$3(val) && !isArray$1(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$3 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction$1 = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$3(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$1 = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
shared_cjs_prod.EMPTY_ARR = EMPTY_ARR;
shared_cjs_prod.EMPTY_OBJ = EMPTY_OBJ;
shared_cjs_prod.NO = NO;
shared_cjs_prod.NOOP = NOOP;
shared_cjs_prod.PatchFlagNames = PatchFlagNames;
shared_cjs_prod.camelize = camelize;
shared_cjs_prod.capitalize = capitalize;
shared_cjs_prod.def = def;
shared_cjs_prod.escapeHtml = escapeHtml;
shared_cjs_prod.escapeHtmlComment = escapeHtmlComment;
shared_cjs_prod.extend = extend$3;
shared_cjs_prod.genPropsAccessExp = genPropsAccessExp;
shared_cjs_prod.generateCodeFrame = generateCodeFrame;
shared_cjs_prod.getGlobalThis = getGlobalThis;
shared_cjs_prod.hasChanged = hasChanged;
shared_cjs_prod.hasOwn = hasOwn;
shared_cjs_prod.hyphenate = hyphenate;
shared_cjs_prod.includeBooleanAttr = includeBooleanAttr;
shared_cjs_prod.invokeArrayFns = invokeArrayFns;
shared_cjs_prod.isArray = isArray$1;
shared_cjs_prod.isBooleanAttr = isBooleanAttr;
shared_cjs_prod.isBuiltInDirective = isBuiltInDirective;
shared_cjs_prod.isDate = isDate;
var isFunction_1 = shared_cjs_prod.isFunction = isFunction$1;
shared_cjs_prod.isGloballyWhitelisted = isGloballyWhitelisted;
shared_cjs_prod.isHTMLTag = isHTMLTag;
shared_cjs_prod.isIntegerKey = isIntegerKey;
shared_cjs_prod.isKnownHtmlAttr = isKnownHtmlAttr;
shared_cjs_prod.isKnownSvgAttr = isKnownSvgAttr;
shared_cjs_prod.isMap = isMap;
shared_cjs_prod.isModelListener = isModelListener;
shared_cjs_prod.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
shared_cjs_prod.isObject = isObject$3;
shared_cjs_prod.isOn = isOn;
shared_cjs_prod.isPlainObject = isPlainObject$1;
shared_cjs_prod.isPromise = isPromise;
shared_cjs_prod.isReservedProp = isReservedProp;
shared_cjs_prod.isSSRSafeAttrName = isSSRSafeAttrName;
shared_cjs_prod.isSVGTag = isSVGTag;
shared_cjs_prod.isSet = isSet;
shared_cjs_prod.isSpecialBooleanAttr = isSpecialBooleanAttr;
shared_cjs_prod.isString = isString;
shared_cjs_prod.isSymbol = isSymbol$1;
shared_cjs_prod.isVoidTag = isVoidTag;
shared_cjs_prod.looseEqual = looseEqual;
shared_cjs_prod.looseIndexOf = looseIndexOf;
shared_cjs_prod.makeMap = makeMap;
shared_cjs_prod.normalizeClass = normalizeClass;
shared_cjs_prod.normalizeProps = normalizeProps;
shared_cjs_prod.normalizeStyle = normalizeStyle;
shared_cjs_prod.objectToString = objectToString$1;
shared_cjs_prod.parseStringStyle = parseStringStyle;
shared_cjs_prod.propsToAttrMap = propsToAttrMap;
shared_cjs_prod.remove = remove;
shared_cjs_prod.slotFlagsText = slotFlagsText;
shared_cjs_prod.stringifyStyle = stringifyStyle;
shared_cjs_prod.toDisplayString = toDisplayString;
shared_cjs_prod.toHandlerKey = toHandlerKey;
shared_cjs_prod.toNumber = toNumber$1;
shared_cjs_prod.toRawType = toRawType;
shared_cjs_prod.toTypeString = toTypeString;
function useHead(meta2) {
  const resolvedMeta = isFunction_1(meta2) ? vue_cjs_prod.computed(meta2) : meta2;
  useNuxtApp()._useHead(resolvedMeta);
}
const preload = defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.mixin({
    beforeCreate() {
      const { _registeredComponents } = this.$nuxt.ssrContext;
      const { __moduleIdentifier } = this.$options;
      _registeredComponents.add(__moduleIdentifier);
    }
  });
});
const components$1 = {};
function _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47_46nuxt_47components_46plugin_46mjs(nuxtApp) {
  for (const name in components$1) {
    nuxtApp.vueApp.component(name, components$1[name]);
    nuxtApp.vueApp.component("Lazy" + name, components$1[name]);
  }
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var PROVIDE_KEY = `usehead`;
var HEAD_COUNT_KEY = `head:count`;
var HEAD_ATTRS_KEY = `data-head-attrs`;
var SELF_CLOSING_TAGS = ["meta", "link", "base"];
var createElement = (tag, attrs, document2) => {
  const el = document2.createElement(tag);
  for (const key of Object.keys(attrs)) {
    let value = attrs[key];
    if (key === "key" || value === false) {
      continue;
    }
    if (key === "children") {
      el.textContent = value;
    } else {
      el.setAttribute(key, value);
    }
  }
  return el;
};
var htmlEscape = (str) => str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var stringifyAttrs = (attributes) => {
  const handledAttributes = [];
  for (let [key, value] of Object.entries(attributes)) {
    if (key === "children" || key === "key") {
      continue;
    }
    if (value === false || value == null) {
      continue;
    }
    let attribute = htmlEscape(key);
    if (value !== true) {
      attribute += `="${htmlEscape(String(value))}"`;
    }
    handledAttributes.push(attribute);
  }
  return handledAttributes.length > 0 ? " " + handledAttributes.join(" ") : "";
};
function isEqualNode(oldTag, newTag) {
  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
    const nonce = newTag.getAttribute("nonce");
    if (nonce && !oldTag.getAttribute("nonce")) {
      const cloneTag = newTag.cloneNode(true);
      cloneTag.setAttribute("nonce", "");
      cloneTag.nonce = nonce;
      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
    }
  }
  return oldTag.isEqualNode(newTag);
}
var getTagKey = (props) => {
  const names2 = ["key", "id", "name", "property"];
  for (const n of names2) {
    const value = typeof props.getAttribute === "function" ? props.hasAttribute(n) ? props.getAttribute(n) : void 0 : props[n];
    if (value !== void 0) {
      return { name: n, value };
    }
  }
};
var acceptFields = [
  "title",
  "meta",
  "link",
  "base",
  "style",
  "script",
  "htmlAttrs",
  "bodyAttrs"
];
var headObjToTags = (obj) => {
  const tags = [];
  for (const key of Object.keys(obj)) {
    if (obj[key] == null)
      continue;
    if (key === "title") {
      tags.push({ tag: key, props: { children: obj[key] } });
    } else if (key === "base") {
      tags.push({ tag: key, props: __spreadValues({ key: "default" }, obj[key]) });
    } else if (acceptFields.includes(key)) {
      const value = obj[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          tags.push({ tag: key, props: item });
        });
      } else if (value) {
        tags.push({ tag: key, props: value });
      }
    }
  }
  return tags;
};
var setAttrs = (el, attrs) => {
  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);
  if (existingAttrs) {
    for (const key of existingAttrs.split(",")) {
      if (!(key in attrs)) {
        el.removeAttribute(key);
      }
    }
  }
  const keys2 = [];
  for (const key in attrs) {
    const value = attrs[key];
    if (value == null)
      continue;
    if (value === false) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
    keys2.push(key);
  }
  if (keys2.length) {
    el.setAttribute(HEAD_ATTRS_KEY, keys2.join(","));
  } else {
    el.removeAttribute(HEAD_ATTRS_KEY);
  }
};
var updateElements = (document2 = window.document, type, tags) => {
  var _a;
  const head = document2.head;
  let headCountEl = head.querySelector(`meta[name="${HEAD_COUNT_KEY}"]`);
  const headCount = headCountEl ? Number(headCountEl.getAttribute("content")) : 0;
  const oldElements = [];
  if (headCountEl) {
    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {
      if (((_a = j == null ? void 0 : j.tagName) == null ? void 0 : _a.toLowerCase()) === type) {
        oldElements.push(j);
      }
    }
  } else {
    headCountEl = document2.createElement("meta");
    headCountEl.setAttribute("name", HEAD_COUNT_KEY);
    headCountEl.setAttribute("content", "0");
    head.append(headCountEl);
  }
  let newElements = tags.map((tag) => createElement(tag.tag, tag.props, document2));
  newElements = newElements.filter((newEl) => {
    for (let i = 0; i < oldElements.length; i++) {
      const oldEl = oldElements[i];
      if (isEqualNode(oldEl, newEl)) {
        oldElements.splice(i, 1);
        return false;
      }
    }
    return true;
  });
  oldElements.forEach((t) => {
    var _a2;
    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);
  });
  newElements.forEach((t) => {
    head.insertBefore(t, headCountEl);
  });
  headCountEl.setAttribute("content", "" + (headCount - oldElements.length + newElements.length));
};
var createHead = () => {
  let allHeadObjs = [];
  let previousTags = /* @__PURE__ */ new Set();
  const head = {
    install(app) {
      app.config.globalProperties.$head = head;
      app.provide(PROVIDE_KEY, head);
    },
    get headTags() {
      const deduped = [];
      allHeadObjs.forEach((objs) => {
        const tags = headObjToTags(objs.value);
        tags.forEach((tag) => {
          if (tag.tag === "meta" || tag.tag === "base" || tag.tag === "script") {
            const key = getTagKey(tag.props);
            if (key) {
              let index2 = -1;
              for (let i = 0; i < deduped.length; i++) {
                const prev = deduped[i];
                const prevValue = prev.props[key.name];
                const nextValue = tag.props[key.name];
                if (prev.tag === tag.tag && prevValue === nextValue) {
                  index2 = i;
                  break;
                }
              }
              if (index2 !== -1) {
                deduped.splice(index2, 1);
              }
            }
          }
          deduped.push(tag);
        });
      });
      return deduped;
    },
    addHeadObjs(objs) {
      allHeadObjs.push(objs);
    },
    removeHeadObjs(objs) {
      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);
    },
    updateDOM(document2 = window.document) {
      let title;
      let htmlAttrs = {};
      let bodyAttrs = {};
      const actualTags = {};
      for (const tag of head.headTags) {
        if (tag.tag === "title") {
          title = tag.props.children;
          continue;
        }
        if (tag.tag === "htmlAttrs") {
          Object.assign(htmlAttrs, tag.props);
          continue;
        }
        if (tag.tag === "bodyAttrs") {
          Object.assign(bodyAttrs, tag.props);
          continue;
        }
        actualTags[tag.tag] = actualTags[tag.tag] || [];
        actualTags[tag.tag].push(tag);
      }
      if (title !== void 0) {
        document2.title = title;
      }
      setAttrs(document2.documentElement, htmlAttrs);
      setAttrs(document2.body, bodyAttrs);
      const tags = /* @__PURE__ */ new Set([...Object.keys(actualTags), ...previousTags]);
      for (const tag of tags) {
        updateElements(document2, tag, actualTags[tag] || []);
      }
      previousTags.clear();
      Object.keys(actualTags).forEach((i) => previousTags.add(i));
    }
  };
  return head;
};
var tagToString = (tag) => {
  let attrs = stringifyAttrs(tag.props);
  if (SELF_CLOSING_TAGS.includes(tag.tag)) {
    return `<${tag.tag}${attrs}>`;
  }
  return `<${tag.tag}${attrs}>${tag.props.children || ""}</${tag.tag}>`;
};
var renderHeadToString = (head) => {
  const tags = [];
  let titleTag = "";
  let htmlAttrs = {};
  let bodyAttrs = {};
  for (const tag of head.headTags) {
    if (tag.tag === "title") {
      titleTag = tagToString(tag);
    } else if (tag.tag === "htmlAttrs") {
      Object.assign(htmlAttrs, tag.props);
    } else if (tag.tag === "bodyAttrs") {
      Object.assign(bodyAttrs, tag.props);
    } else {
      tags.push(tagToString(tag));
    }
  }
  tags.push(`<meta name="${HEAD_COUNT_KEY}" content="${tags.length}">`);
  return {
    get headTags() {
      return titleTag + tags.join("");
    },
    get htmlAttrs() {
      return stringifyAttrs(__spreadProps(__spreadValues({}, htmlAttrs), {
        [HEAD_ATTRS_KEY]: Object.keys(htmlAttrs).join(",")
      }));
    },
    get bodyAttrs() {
      return stringifyAttrs(__spreadProps(__spreadValues({}, bodyAttrs), {
        [HEAD_ATTRS_KEY]: Object.keys(bodyAttrs).join(",")
      }));
    }
  };
};
function isObject$2(val) {
  return val !== null && typeof val === "object";
}
function _defu(baseObj, defaults2, namespace = ".", merger) {
  if (!isObject$2(defaults2)) {
    return _defu(baseObj, {}, namespace, merger);
  }
  const obj = Object.assign({}, defaults2);
  for (const key in baseObj) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const val = baseObj[key];
    if (val === null || val === void 0) {
      continue;
    }
    if (merger && merger(obj, key, val, namespace)) {
      continue;
    }
    if (Array.isArray(val) && Array.isArray(obj[key])) {
      obj[key] = val.concat(obj[key]);
    } else if (isObject$2(val) && isObject$2(obj[key])) {
      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      obj[key] = val;
    }
  }
  return obj;
}
function createDefu(merger) {
  return (...args) => args.reduce((p, c) => _defu(p, c, "", merger), {});
}
const defu = createDefu();
const _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47head_47runtime_47lib_47vueuse_45head_46plugin = defineNuxtPlugin((nuxtApp) => {
  const head = createHead();
  nuxtApp.vueApp.use(head);
  nuxtApp.hooks.hookOnce("app:mounted", () => {
    vue_cjs_prod.watchEffect(() => {
      head.updateDOM();
    });
  });
  const titleTemplate = vue_cjs_prod.ref();
  nuxtApp._useHead = (_meta) => {
    const meta2 = vue_cjs_prod.ref(_meta);
    if ("titleTemplate" in meta2.value) {
      titleTemplate.value = meta2.value.titleTemplate;
    }
    const headObj = vue_cjs_prod.computed(() => {
      const overrides2 = { meta: [] };
      if (titleTemplate.value && "title" in meta2.value) {
        overrides2.title = typeof titleTemplate.value === "function" ? titleTemplate.value(meta2.value.title) : titleTemplate.value.replace(/%s/g, meta2.value.title);
      }
      if (meta2.value.charset) {
        overrides2.meta.push({ key: "charset", charset: meta2.value.charset });
      }
      if (meta2.value.viewport) {
        overrides2.meta.push({ name: "viewport", content: meta2.value.viewport });
      }
      return defu(overrides2, meta2.value);
    });
    head.addHeadObjs(headObj);
    {
      return;
    }
  };
  {
    nuxtApp.ssrContext.renderMeta = () => renderHeadToString(head);
  }
});
const removeUndefinedProps = (props) => Object.fromEntries(Object.entries(props).filter(([, value]) => value !== void 0));
const setupForUseMeta = (metaFactory, renderChild) => (props, ctx) => {
  useHead(() => metaFactory({ ...removeUndefinedProps(props), ...ctx.attrs }, ctx));
  return () => {
    var _a, _b;
    return renderChild ? (_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a) : null;
  };
};
const globalProps = {
  accesskey: String,
  autocapitalize: String,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  class: String,
  contenteditable: {
    type: Boolean,
    default: void 0
  },
  contextmenu: String,
  dir: String,
  draggable: {
    type: Boolean,
    default: void 0
  },
  enterkeyhint: String,
  exportparts: String,
  hidden: {
    type: Boolean,
    default: void 0
  },
  id: String,
  inputmode: String,
  is: String,
  itemid: String,
  itemprop: String,
  itemref: String,
  itemscope: String,
  itemtype: String,
  lang: String,
  nonce: String,
  part: String,
  slot: String,
  spellcheck: {
    type: Boolean,
    default: void 0
  },
  style: String,
  tabindex: String,
  title: String,
  translate: String
};
const Script = vue_cjs_prod.defineComponent({
  name: "Script",
  inheritAttrs: false,
  props: {
    ...globalProps,
    async: Boolean,
    crossorigin: {
      type: [Boolean, String],
      default: void 0
    },
    defer: Boolean,
    integrity: String,
    nomodule: Boolean,
    nonce: String,
    referrerpolicy: String,
    src: String,
    type: String,
    charset: String,
    language: String
  },
  setup: setupForUseMeta((script2) => ({
    script: [script2]
  }))
});
const Link = vue_cjs_prod.defineComponent({
  name: "Link",
  inheritAttrs: false,
  props: {
    ...globalProps,
    as: String,
    crossorigin: String,
    disabled: Boolean,
    href: String,
    hreflang: String,
    imagesizes: String,
    imagesrcset: String,
    integrity: String,
    media: String,
    prefetch: {
      type: Boolean,
      default: void 0
    },
    referrerpolicy: String,
    rel: String,
    sizes: String,
    title: String,
    type: String,
    methods: String,
    target: String
  },
  setup: setupForUseMeta((link) => ({
    link: [link]
  }))
});
const Base = vue_cjs_prod.defineComponent({
  name: "Base",
  inheritAttrs: false,
  props: {
    ...globalProps,
    href: String,
    target: String
  },
  setup: setupForUseMeta((base) => ({
    base
  }))
});
const Title$1 = vue_cjs_prod.defineComponent({
  name: "Title",
  inheritAttrs: false,
  setup: setupForUseMeta((_, { slots }) => {
    var _a, _b, _c;
    const title = ((_c = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b[0]) == null ? void 0 : _c.children) || null;
    return {
      title
    };
  })
});
const Meta = vue_cjs_prod.defineComponent({
  name: "Meta",
  inheritAttrs: false,
  props: {
    ...globalProps,
    charset: String,
    content: String,
    httpEquiv: String,
    name: String
  },
  setup: setupForUseMeta((meta2) => ({
    meta: [meta2]
  }))
});
const Style = vue_cjs_prod.defineComponent({
  name: "Style",
  inheritAttrs: false,
  props: {
    ...globalProps,
    type: String,
    media: String,
    nonce: String,
    title: String,
    scoped: {
      type: Boolean,
      default: void 0
    }
  },
  setup: setupForUseMeta((props, { slots }) => {
    var _a, _b, _c;
    const style = { ...props };
    const textContent = (_c = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b[0]) == null ? void 0 : _c.children;
    if (textContent) {
      style.children = textContent;
    }
    return {
      style: [style]
    };
  })
});
const Head = vue_cjs_prod.defineComponent({
  name: "Head",
  inheritAttrs: false,
  setup: (_props, ctx) => () => {
    var _a, _b;
    return (_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a);
  }
});
const Html = vue_cjs_prod.defineComponent({
  name: "Html",
  inheritAttrs: false,
  props: {
    ...globalProps,
    manifest: String,
    version: String,
    xmlns: String
  },
  setup: setupForUseMeta((htmlAttrs) => ({ htmlAttrs }), true)
});
const Body = vue_cjs_prod.defineComponent({
  name: "Body",
  inheritAttrs: false,
  props: globalProps,
  setup: setupForUseMeta((bodyAttrs) => ({ bodyAttrs }), true)
});
const Components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Script,
  Link,
  Base,
  Title: Title$1,
  Meta,
  Style,
  Head,
  Html,
  Body
}, Symbol.toStringTag, { value: "Module" }));
const metaConfig = { "globalMeta": { "charset": "utf-8", "viewport": "width=device-width, initial-scale=1", "meta": [], "link": [], "style": [], "script": [] } };
const metaMixin = {
  created() {
    const instance = vue_cjs_prod.getCurrentInstance();
    if (!instance) {
      return;
    }
    const options = instance.type;
    if (!options || !("head" in options)) {
      return;
    }
    const nuxtApp = useNuxtApp();
    const source2 = typeof options.head === "function" ? vue_cjs_prod.computed(() => options.head(nuxtApp)) : options.head;
    useHead(source2);
  }
};
const _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47head_47runtime_47plugin = defineNuxtPlugin((nuxtApp) => {
  useHead(vue_cjs_prod.markRaw({ title: "", ...metaConfig.globalMeta }));
  nuxtApp.vueApp.mixin(metaMixin);
  for (const name in Components) {
    nuxtApp.vueApp.component(name, Components[name]);
  }
});
const interpolatePath = (route, match) => {
  return match.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, (r) => {
    var _a;
    return ((_a = route.params[r.slice(1)]) == null ? void 0 : _a.toString()) || "";
  });
};
const generateRouteKey = (override, routeProps) => {
  var _a;
  const matchedRoute = routeProps.route.matched.find((m) => m.components.default === routeProps.Component.type);
  const source2 = (_a = override != null ? override : matchedRoute == null ? void 0 : matchedRoute.meta.key) != null ? _a : interpolatePath(routeProps.route, matchedRoute);
  return typeof source2 === "function" ? source2(routeProps.route) : source2;
};
const wrapInKeepAlive = (props, children) => {
  return { default: () => children };
};
const Fragment = {
  setup(_props, { slots }) {
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots);
    };
  }
};
const _wrapIf = (component, props, slots) => {
  return { default: () => props ? vue_cjs_prod.h(component, props === true ? {} : props, slots) : vue_cjs_prod.h(Fragment, {}, slots) };
};
const isNestedKey = Symbol("isNested");
const NuxtPage = vue_cjs_prod.defineComponent({
  name: "NuxtPage",
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    route: {
      type: Object
    },
    pageKey: {
      type: [Function, String],
      default: null
    }
  },
  setup(props, { attrs }) {
    const nuxtApp = useNuxtApp();
    const isNested = vue_cjs_prod.inject(isNestedKey, false);
    vue_cjs_prod.provide(isNestedKey, true);
    return () => {
      return vue_cjs_prod.h(vueRouter_cjs.RouterView, { name: props.name, route: props.route, ...attrs }, {
        default: (routeProps) => {
          var _a;
          return routeProps.Component && _wrapIf(vue_cjs_prod.Transition, (_a = routeProps.route.meta.pageTransition) != null ? _a : defaultPageTransition, wrapInKeepAlive(routeProps.route.meta.keepalive, isNested && nuxtApp.isHydrating ? vue_cjs_prod.h(routeProps.Component, { key: generateRouteKey(props.pageKey, routeProps) }) : vue_cjs_prod.h(vue_cjs_prod.Suspense, {
            onPending: () => nuxtApp.callHook("page:start", routeProps.Component),
            onResolve: () => nuxtApp.callHook("page:finish", routeProps.Component)
          }, { default: () => vue_cjs_prod.h(routeProps.Component, { key: generateRouteKey(props.pageKey, routeProps) }) }))).default();
        }
      });
    };
  }
});
const defaultPageTransition = { name: "page", mode: "out-in" };
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$T = {
  name: "PageHeader",
  props: {
    pageTitle: String,
    pageSubtitle: String,
    pageDate: String,
    image: String,
    colour: String,
    secondaryColour: String,
    metaPageTitle: {
      type: String,
      default: null
    },
    pageLinks: {
      type: Array,
      default: () => {
        return [];
      }
    },
    backLink: {
      type: String,
      default: null
    },
    backText: {
      type: String,
      default: "Go back"
    }
  },
  computed: {
    metaTitle() {
      if (this.metaPageTitle) {
        return this.metaPageTitle;
      } else if (this.pageTitle) {
        return this.pageTitle;
      } else {
        return "";
      }
    },
    harmony: function() {
      var harmonizer = new Harmonizer();
      if (!this.colour) {
        return ["#58787f", "rgb(52, 148, 148)"];
      }
      if (this.secondaryColour) {
        return [this.colour, this.secondaryColour];
      }
      return harmonizer.harmonize(this.colour, "neutral");
    },
    gradient: function() {
      return `linear-gradient(230deg, ${this.harmony[1]} 0%, ${this.harmony[0]} 50%)`;
    }
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  }
};
function _sfc_ssrRender$J(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Title = vue_cjs_prod.resolveComponent("Title");
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_RouterLink = vue_cjs_prod.resolveComponent("RouterLink");
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-18bba453>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Title, null, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`${serverRenderer.exports.ssrInterpolate($options.metaTitle)}`);
            } else {
              return [
                vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.metaTitle), 1)
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_Title, null, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.metaTitle), 1)
            ]),
            _: 1
          })
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`<div class="container-fluid hero" style="${serverRenderer.exports.ssrRenderStyle({ backgroundImage: $options.gradient })}" data-v-18bba453><div class="container" data-v-18bba453>`);
  if (!$props.image) {
    _push(`<div data-v-18bba453><h1 class="hero" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($props.pageTitle)}</h1>`);
    if ($props.pageSubtitle) {
      _push(`<h3 class="hero" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($props.pageSubtitle)}</h3>`);
    } else {
      _push(`<!---->`);
    }
    if ($props.pageDate) {
      _push(`<h5 class="hero text-uppercase" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($options.formatDate($props.pageDate))}</h5>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div>`);
  } else {
    _push(`<div data-v-18bba453><div class="d-flex align-items-center" data-v-18bba453><div class="flex-shrink-0" data-v-18bba453><img class="me-3"${serverRenderer.exports.ssrRenderAttr("src", $props.image)}${serverRenderer.exports.ssrRenderAttr("alt", $props.pageTitle)} data-v-18bba453></div><div class="flex-grow-1 ms-3" data-v-18bba453><h1 class="hero" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($props.pageTitle)}</h1>`);
    if ($props.pageSubtitle) {
      _push(`<h3 class="hero" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($props.pageSubtitle)}</h3>`);
    } else {
      _push(`<!---->`);
    }
    if ($props.pageDate) {
      _push(`<h5 class="hero text-uppercase" data-v-18bba453>${serverRenderer.exports.ssrInterpolate($options.formatDate($props.pageDate))}</h5>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div></div></div>`);
  }
  if ($props.pageLinks.length) {
    _push(`<nav class="navbar navbar-expand-lg navbar-light sub-nav" data-v-18bba453><ul class="navbar-nav" data-v-18bba453><!--[-->`);
    serverRenderer.exports.ssrRenderList($props.pageLinks, (link, index2) => {
      _push(`<li class="nav-item" data-v-18bba453>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
        class: "nav-link",
        to: link.to,
        "active-class": "active"
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${serverRenderer.exports.ssrInterpolate(link.name)}`);
          } else {
            return [
              vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(link.name), 1)
            ];
          }
        }),
        _: 2
      }, _parent));
      _push(`</li>`);
    });
    _push(`<!--]--></ul></nav>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div></div>`);
  if ($props.backLink) {
    _push(`<div class="container-fluid" style="${serverRenderer.exports.ssrRenderStyle({ backgroundColor: $options.harmony[1] })}" data-v-18bba453><div class="container py-2" data-v-18bba453>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, { to: $props.backLink }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-left"] }, null, _parent2, _scopeId));
          _push2(` ${serverRenderer.exports.ssrInterpolate($props.backText)}`);
        } else {
          return [
            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-left"] }),
            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($props.backText), 1)
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div>`);
}
const _sfc_setup$T = _sfc_main$T.setup;
_sfc_main$T.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PageHeader.vue");
  return _sfc_setup$T ? _sfc_setup$T(props, ctx) : void 0;
};
const __nuxt_component_0$4 = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["ssrRender", _sfc_ssrRender$J], ["__scopeId", "data-v-18bba453"]]);
const _sfc_main$S = {
  name: "ColourStripe",
  props: {
    colour: String,
    secondaryColour: String
  },
  computed: {
    harmony: function() {
      var harmonizer = new Harmonizer();
      if (!this.colour) {
        return ["#58787f", "rgb(52, 148, 148)"];
      }
      if (this.secondaryColour) {
        return [this.colour, this.secondaryColour];
      }
      return harmonizer.harmonize(this.colour, "neutral");
    },
    gradient: function() {
      return `linear-gradient(230deg, ${this.harmony[1]} 0%, ${this.harmony[0]} 50%)`;
    }
  }
};
function _sfc_ssrRender$I(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    id: "stripe",
    style: { backgroundImage: $options.gradient }
  }, _attrs))} data-v-dcbfc80a></div>`);
}
const _sfc_setup$S = _sfc_main$S.setup;
_sfc_main$S.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ColourStripe.vue");
  return _sfc_setup$S ? _sfc_setup$S(props, ctx) : void 0;
};
const __nuxt_component_0$3 = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["ssrRender", _sfc_ssrRender$I], ["__scopeId", "data-v-dcbfc80a"]]);
const _sfc_main$R = {
  name: "Card",
  props: {
    missing: {
      type: Boolean,
      default: false
    },
    gradient: {
      type: Boolean,
      default: false
    },
    frosted: {
      type: Boolean,
      default: false
    },
    stripeColour: String
  }
};
function _sfc_ssrRender$H(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_ColourStripe = __nuxt_component_0$3;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    class: ["wts-card", { "wts-card-missing": $props.missing, "wts-card-gradient": $props.gradient, "wts-card-frosted": $props.frosted }]
  }, _attrs))} data-v-41c29105><div class="padding-div" data-v-41c29105>`);
  serverRenderer.exports.ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`</div>`);
  if ($props.stripeColour) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_ColourStripe, { colour: $props.stripeColour }, null, _parent));
  } else {
    _push(`<!---->`);
  }
  _push(`</div>`);
}
const _sfc_setup$R = _sfc_main$R.setup;
_sfc_main$R.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Card.vue");
  return _sfc_setup$R ? _sfc_setup$R(props, ctx) : void 0;
};
const __nuxt_component_2$4 = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["ssrRender", _sfc_ssrRender$H], ["__scopeId", "data-v-41c29105"]]);
const _sfc_main$Q = {
  name: "ExternalLinkButton",
  props: {
    link: String,
    text: {
      type: String,
      default: ""
    }
  }
};
function _sfc_ssrRender$G(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  _push(`<a${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    href: $props.link,
    target: "_blank"
  }, _attrs))} data-v-56228d50><h6 data-v-56228d50>`);
  serverRenderer.exports.ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`${serverRenderer.exports.ssrInterpolate($props.text)}`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
    class: "ms-2",
    icon: ["fas", "external-link-alt"]
  }, null, _parent));
  _push(`</h6></a>`);
}
const _sfc_setup$Q = _sfc_main$Q.setup;
_sfc_main$Q.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ExternalLinkButton.vue");
  return _sfc_setup$Q ? _sfc_setup$Q(props, ctx) : void 0;
};
const __nuxt_component_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["ssrRender", _sfc_ssrRender$G], ["__scopeId", "data-v-56228d50"]]);
const _sfc_main$P = {
  name: "ExternalLinkInline",
  props: {
    link: String,
    text: {
      type: String,
      default: ""
    }
  }
};
function _sfc_ssrRender$F(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  _push(`<a${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    href: $props.link,
    target: "_blank"
  }, _attrs))} data-v-1aabd0ee>`);
  serverRenderer.exports.ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`${serverRenderer.exports.ssrInterpolate($props.text)}`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
    class: "ms-2",
    icon: ["fas", "external-link-alt"]
  }, null, _parent));
  _push(`</a>`);
}
const _sfc_setup$P = _sfc_main$P.setup;
_sfc_main$P.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ExternalLinkInline.vue");
  return _sfc_setup$P ? _sfc_setup$P(props, ctx) : void 0;
};
const __nuxt_component_3$4 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["ssrRender", _sfc_ssrRender$F], ["__scopeId", "data-v-1aabd0ee"]]);
const meta$i = void 0;
const _sfc_main$O = {
  name: "DownloadLink",
  data() {
    return {
      apiRoot: "http://0.0.0.0:8000"
    };
  },
  props: {
    fileType: {
      type: String,
      default: "csv",
      validator(value) {
        return ["csv", "json", "xlsx"].includes(value);
      }
    },
    resourceType: {
      type: String,
      validator(value) {
        return ["vote", "bill"].includes(value);
      }
    },
    resourceId: {
      type: String
    },
    friendlyName: {
      default: null
    }
  },
  computed: {
    fasIconName() {
      if (this.fileType == "csv") {
        return "file-csv";
      } else if (this.fileType == "json") {
        return "file-code";
      } else if (this.fileType == "xlsx") {
        return "file-excel";
      }
    },
    link() {
      switch (this.fileType) {
        case "csv":
          switch (this.resourceType) {
            case "vote":
              return this.apiRoot + "/api/votes/" + this.resourceId + "?df=csv";
          }
        case "xlsx":
          switch (this.resourceType) {
            case "vote":
              return this.apiRoot + "/api/votes/" + this.resourceId + "?df=xlsx";
          }
        case "json":
          switch (this.resourceType) {
            case "vote":
              return this.apiRoot + "/api/votes/" + this.resourceId + "?format=json";
            case "bill":
              return this.apiRoot + "/api/bills/" + this.resourceId + "?format=json";
          }
      }
    },
    saveName() {
      if (!this.friendlyName) {
        return this.resourceType + "_" + this.resourceId + "." + this.fileType;
      } else {
        return this.friendlyName + "_" + this.resourceId + "." + this.fileType;
      }
    }
  }
};
function _sfc_ssrRender$E(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  _push(`<a${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    href: $options.link,
    class: "me-2",
    target: "_blank",
    download: $options.saveName
  }, _attrs))} data-v-25b6d40b>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
    class: "me-1",
    icon: ["fas", $options.fasIconName]
  }, null, _parent));
  _push(`${serverRenderer.exports.ssrInterpolate($props.fileType.toUpperCase())}</a>`);
}
const _sfc_setup$O = _sfc_main$O.setup;
_sfc_main$O.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/DownloadLink.vue");
  return _sfc_setup$O ? _sfc_setup$O(props, ctx) : void 0;
};
const __nuxt_component_4$1 = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["ssrRender", _sfc_ssrRender$E], ["__scopeId", "data-v-25b6d40b"]]);
const _sfc_main$N = {
  name: "ColourDot",
  props: ["colour"],
  computed: {
    sanitisedColour() {
      if (this.colour.startsWith("#")) {
        return this.colour;
      } else {
        return "#" + this.colour;
      }
    }
  }
};
function _sfc_ssrRender$D(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<span${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    class: "party-dot me-2",
    style: { backgroundColor: $options.sanitisedColour }
  }, _attrs))} data-v-22401f7b></span>`);
}
const _sfc_setup$N = _sfc_main$N.setup;
_sfc_main$N.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ColourDot.vue");
  return _sfc_setup$N ? _sfc_setup$N(props, ctx) : void 0;
};
const __nuxt_component_3$3 = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["ssrRender", _sfc_ssrRender$D], ["__scopeId", "data-v-22401f7b"]]);
const _sfc_main$M = {
  name: "PersonCard",
  components: {
    Card: __nuxt_component_2$4,
    ColourDot: __nuxt_component_3$3
  },
  props: {
    person: Object
  }
};
function _sfc_ssrRender$C(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_router_link = vue_cjs_prod.resolveComponent("router-link");
  const _component_Card = __nuxt_component_2$4;
  const _component_colour_dot = __nuxt_component_3$3;
  _push(serverRenderer.exports.ssrRenderComponent(_component_router_link, vue_cjs_prod.mergeProps({
    class: "router-link",
    to: "/people/" + $props.person.slug
  }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              if ($props.person.image) {
                _push3(`<div class="d-flex align-items-center" data-v-2e17528c${_scopeId2}><div class="flex-shrink-0" data-v-2e17528c${_scopeId2}>`);
                if ($props.person.image) {
                  _push3(`<img${serverRenderer.exports.ssrRenderAttr("src", $props.person.image)} class="me-3 person-image"${serverRenderer.exports.ssrRenderAttr("alt", $props.person.display_name)} data-v-2e17528c${_scopeId2}>`);
                } else {
                  _push3(`<!---->`);
                }
                _push3(`</div><div class="flex-grow-1 ms-3" data-v-2e17528c${_scopeId2}><h5 data-v-2e17528c${_scopeId2}><strong data-v-2e17528c${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.person.display_name)}</strong></h5><p class="text-muted" data-v-2e17528c${_scopeId2}>`);
                if ($props.person.colour) {
                  _push3(serverRenderer.exports.ssrRenderComponent(_component_colour_dot, {
                    colour: $props.person.colour
                  }, null, _parent3, _scopeId2));
                } else {
                  _push3(`<!---->`);
                }
                _push3(`${serverRenderer.exports.ssrInterpolate($props.person.description)}</p></div></div>`);
              } else {
                _push3(`<div data-v-2e17528c${_scopeId2}><h5 data-v-2e17528c${_scopeId2}><strong data-v-2e17528c${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.person.display_name)}</strong></h5>`);
                if ($props.person.description) {
                  _push3(`<p class="text-muted" data-v-2e17528c${_scopeId2}>`);
                  if ($props.person.colour) {
                    _push3(serverRenderer.exports.ssrRenderComponent(_component_colour_dot, {
                      colour: $props.person.colour
                    }, null, _parent3, _scopeId2));
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`${serverRenderer.exports.ssrInterpolate($props.person.description)}</p>`);
                } else {
                  _push3(`<!---->`);
                }
                _push3(`</div>`);
              }
            } else {
              return [
                $props.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                  key: 0,
                  class: "d-flex align-items-center"
                }, [
                  vue_cjs_prod.createVNode("div", { class: "flex-shrink-0" }, [
                    $props.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("img", {
                      key: 0,
                      src: $props.person.image,
                      class: "me-3 person-image",
                      alt: $props.person.display_name
                    }, null, 8, ["src", "alt"])) : vue_cjs_prod.createCommentVNode("", true)
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "flex-grow-1 ms-3" }, [
                    vue_cjs_prod.createVNode("h5", null, [
                      vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.person.display_name), 1)
                    ]),
                    vue_cjs_prod.createVNode("p", { class: "text-muted" }, [
                      $props.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                        key: 0,
                        colour: $props.person.colour
                      }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.person.description), 1)
                    ])
                  ])
                ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
                  vue_cjs_prod.createVNode("h5", null, [
                    vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.person.display_name), 1)
                  ]),
                  $props.person.description ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
                    key: 0,
                    class: "text-muted"
                  }, [
                    $props.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                      key: 0,
                      colour: $props.person.colour
                    }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.person.description), 1)
                  ])) : vue_cjs_prod.createCommentVNode("", true)
                ]))
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_Card, null, {
            default: vue_cjs_prod.withCtx(() => [
              $props.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                key: 0,
                class: "d-flex align-items-center"
              }, [
                vue_cjs_prod.createVNode("div", { class: "flex-shrink-0" }, [
                  $props.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("img", {
                    key: 0,
                    src: $props.person.image,
                    class: "me-3 person-image",
                    alt: $props.person.display_name
                  }, null, 8, ["src", "alt"])) : vue_cjs_prod.createCommentVNode("", true)
                ]),
                vue_cjs_prod.createVNode("div", { class: "flex-grow-1 ms-3" }, [
                  vue_cjs_prod.createVNode("h5", null, [
                    vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.person.display_name), 1)
                  ]),
                  vue_cjs_prod.createVNode("p", { class: "text-muted" }, [
                    $props.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                      key: 0,
                      colour: $props.person.colour
                    }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.person.description), 1)
                  ])
                ])
              ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
                vue_cjs_prod.createVNode("h5", null, [
                  vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.person.display_name), 1)
                ]),
                $props.person.description ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
                  key: 0,
                  class: "text-muted"
                }, [
                  $props.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                    key: 0,
                    colour: $props.person.colour
                  }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                  vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.person.description), 1)
                ])) : vue_cjs_prod.createCommentVNode("", true)
              ]))
            ]),
            _: 1
          })
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$M = _sfc_main$M.setup;
_sfc_main$M.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PersonCard.vue");
  return _sfc_setup$M ? _sfc_setup$M(props, ctx) : void 0;
};
const __nuxt_component_6 = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["ssrRender", _sfc_ssrRender$C], ["__scopeId", "data-v-2e17528c"]]);
const _sfc_main$L = {
  props: {
    vote: {
      type: Object
    },
    countsOnly: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  },
  computed: {
    readingOrdinal() {
      return this.vote.reading + { 1: "st reading", 2: "nd reading", 3: "rd reading" }[this.vote.reading];
    }
  }
};
function _sfc_ssrRender$B(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  if ($props.vote) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, _attrs, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          if (!$props.countsOnly) {
            _push2(`<div${_scopeId}><h6 class="text-uppercase"${_scopeId}><strong${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.readingOrdinal)}</strong></h6><h5 class="text-uppercase"${_scopeId}>`);
            if ($props.vote.motion_successful === true) {
              _push2(`<span${_scopeId}><span class="dot-yes"${_scopeId}></span> <strong${_scopeId}>Passed</strong></span>`);
            } else if ($props.vote.motion_successful === false) {
              _push2(`<span${_scopeId}><span class="dot-no"${_scopeId}></span> <strong${_scopeId}>Defeated</strong></span>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</h5><h6 class="text-muted"${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatDate($props.vote.vote_date))}</h6><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<div class="row"${_scopeId}><div class="col-3 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($props.vote.totals.ayes)}</h3><h6 class="text-muted text-uppercase"${_scopeId}><span class="dot-yes"${_scopeId}></span> Ayes</h6></div><div class="col-3 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($props.vote.totals.noes)}</h3><h6 class="text-muted text-uppercase"${_scopeId}><span class="dot-no"${_scopeId}></span> Noes</h6></div><div class="col-3 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($props.vote.totals.abstentions)}</h3><h6 class="text-muted text-uppercase"${_scopeId}><span class="dot-abstain"${_scopeId}></span> Abst.</h6></div><div class="col-3 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($props.vote.totals.absent)}</h3><h6 class="text-muted text-uppercase"${_scopeId}><span class="dot-absent"${_scopeId}></span> Abse.</h6></div></div>`);
        } else {
          return [
            !$props.countsOnly ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
              vue_cjs_prod.createVNode("h6", { class: "text-uppercase" }, [
                vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($options.readingOrdinal), 1)
              ]),
              vue_cjs_prod.createVNode("h5", { class: "text-uppercase" }, [
                $props.vote.motion_successful === true ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-yes" }),
                  vue_cjs_prod.createTextVNode(),
                  vue_cjs_prod.createVNode("strong", null, "Passed")
                ])) : $props.vote.motion_successful === false ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-no" }),
                  vue_cjs_prod.createTextVNode(),
                  vue_cjs_prod.createVNode("strong", null, "Defeated")
                ])) : vue_cjs_prod.createCommentVNode("", true)
              ]),
              vue_cjs_prod.createVNode("h6", { class: "text-muted" }, vue_cjs_prod.toDisplayString($options.formatDate($props.vote.vote_date)), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode("div", { class: "row" }, [
              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($props.vote.totals.ayes), 1),
                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-yes" }),
                  vue_cjs_prod.createTextVNode(" Ayes")
                ])
              ]),
              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($props.vote.totals.noes), 1),
                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-no" }),
                  vue_cjs_prod.createTextVNode(" Noes")
                ])
              ]),
              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($props.vote.totals.abstentions), 1),
                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-abstain" }),
                  vue_cjs_prod.createTextVNode(" Abst.")
                ])
              ]),
              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($props.vote.totals.absent), 1),
                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                  vue_cjs_prod.createVNode("span", { class: "dot-absent" }),
                  vue_cjs_prod.createTextVNode(" Abse.")
                ])
              ])
            ])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$L = _sfc_main$L.setup;
_sfc_main$L.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/VoteSummary.vue");
  return _sfc_setup$L ? _sfc_setup$L(props, ctx) : void 0;
};
const __nuxt_component_1$6 = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["ssrRender", _sfc_ssrRender$B]]);
const _sfc_main$K = {
  props: ["reading", "date", "passed"],
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  },
  computed: {
    readingOrdinal() {
      return this.reading + { 1: "st reading", 2: "nd reading", 3: "rd reading" }[this.reading];
    }
  }
};
function _sfc_ssrRender$A(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, _attrs, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h6 class="text-uppercase"${_scopeId}><strong${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.readingOrdinal)}</strong></h6><h5 class="text-uppercase"${_scopeId}>`);
        if ($props.passed === true) {
          _push2(`<span${_scopeId}><span class="dot-yes"${_scopeId}></span> <strong${_scopeId}>Passed</strong></span>`);
        } else if ($props.passed === false) {
          _push2(`<span${_scopeId}><span class="dot-no"${_scopeId}></span> <strong${_scopeId}>Defeated</strong></span>`);
        } else {
          _push2(`<!---->`);
        }
        _push2(`</h5><h6 class="text-muted"${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatDate($props.date))}</h6><hr${_scopeId}><h6 class="text-muted text-center"${_scopeId}> WhereTheyStand has no totals for this vote. It might have been a voice vote, or there might have been an import error. </h6>`);
      } else {
        return [
          vue_cjs_prod.createVNode("h6", { class: "text-uppercase" }, [
            vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($options.readingOrdinal), 1)
          ]),
          vue_cjs_prod.createVNode("h5", { class: "text-uppercase" }, [
            $props.passed === true ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, [
              vue_cjs_prod.createVNode("span", { class: "dot-yes" }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Passed")
            ])) : $props.passed === false ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, [
              vue_cjs_prod.createVNode("span", { class: "dot-no" }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Defeated")
            ])) : vue_cjs_prod.createCommentVNode("", true)
          ]),
          vue_cjs_prod.createVNode("h6", { class: "text-muted" }, vue_cjs_prod.toDisplayString($options.formatDate($props.date)), 1),
          vue_cjs_prod.createVNode("hr"),
          vue_cjs_prod.createVNode("h6", { class: "text-muted text-center" }, " WhereTheyStand has no totals for this vote. It might have been a voice vote, or there might have been an import error. ")
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$K = _sfc_main$K.setup;
_sfc_main$K.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/VoteSummaryBare.vue");
  return _sfc_setup$K ? _sfc_setup$K(props, ctx) : void 0;
};
const __nuxt_component_7$1 = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["ssrRender", _sfc_ssrRender$A]]);
const API_BASE = "https://wheretheystand.nz/api/";
const useBillsStore = defineStore("bills", {
  state() {
    return {
      items: []
    };
  },
  getters: {
    byID: (state2) => (id) => {
      return state2.items.find((bill) => bill.id == id);
    }
  },
  actions: {
    async fetch(id) {
      if (!this.byID(id)) {
        var state2 = this;
        await useFetch(API_BASE + "bills/" + id + "/", {
          onResponse({ request: request2, response, options }) {
            state2.items.push(response._data);
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$h = void 0;
const _sfc_main$J = {};
function _sfc_ssrRender$z(_ctx, _push, _parent, _attrs) {
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({
    class: "spinner-grow spinner-grow-sm text-theme2",
    role: "status"
  }, _attrs))}><span class="visually-hidden">Loading...</span></div>`);
}
const _sfc_setup$J = _sfc_main$J.setup;
_sfc_main$J.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Spinner.vue");
  return _sfc_setup$J ? _sfc_setup$J(props, ctx) : void 0;
};
const __nuxt_component_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["ssrRender", _sfc_ssrRender$z]]);
const __default__$3 = {
  name: "BillFilter",
  data() {
    return {
      page: 1,
      perPage: 10,
      hasLoadedData: false,
      next: false,
      bills: [],
      previous: false,
      count: 0,
      isLoading: false,
      showDescriptions: true,
      filterSettings: {
        titleContains: "",
        billTypes: {
          mem: true,
          gov: true,
          pri: true,
          loc: true
        },
        parliamentaryTerm: "",
        characteristics: {
          urgencyUsed: false,
          extendedSittingsUsed: false,
          submissionsOpen: false,
          votingMethod: ""
        },
        format: {
          perPage: 10,
          orderBy: "date_modified_desc"
        }
      },
      activeFilter: {
        titleContains: "",
        billTypes: {
          mem: true,
          gov: true,
          pri: true,
          loc: true
        },
        parliamentaryTerm: "",
        characteristics: {
          urgencyUsed: false,
          extendedSittingsUsed: false,
          submissionsOpen: false,
          votingMethod: ""
        },
        format: {
          perPage: 10,
          orderBy: "date_modified_desc"
        }
      }
    };
  },
  computed: {
    activeString() {
      return JSON.stringify(this.activeFilter);
    },
    userString() {
      return JSON.stringify(this.filterSettings);
    },
    displayBills() {
      if (!this.hasLoadedData) {
        return this.prefetchData.results;
      } else {
        return this.bills;
      }
    },
    displayCount() {
      if (!this.hasLoadedData) {
        return this.prefetchData.count;
      } else {
        return this.count;
      }
    },
    displayPage() {
      if (!this.hasLoadedData) {
        return this.prefetchData.page;
      } else {
        return this.page;
      }
    },
    displayNext() {
      if (!this.hasLoadedData) {
        return this.prefetchData.next;
      } else {
        return this.next;
      }
    },
    displayPrevious() {
      if (!this.hasLoadedData) {
        return this.prefetchData.previous;
      } else {
        return this.previous;
      }
    }
  },
  methods: {
    async getPage(page) {
      this.isLoading = true;
      var url2 = API_BASE + "bills/?";
      var r = await $fetch(url2 + new URLSearchParams({
        page,
        per_page: this.activeFilter.format.perPage
      }), {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          page,
          filter: this.activeFilter
        })
      });
      this.isLoading = false;
      this.hasLoadedData = true;
      this.bills = r.results;
      this.count = r.count;
      if (r.previous) {
        this.previous = true;
      } else {
        this.previous = false;
      }
      if (r.next) {
        this.next = true;
      } else {
        this.next = false;
      }
      this.page = page;
    },
    applyFilter() {
      if (this.activeString != this.userString && !this.isLoading) {
        this.activeFilter = JSON.parse(JSON.stringify(this.filterSettings));
        this.getPage(1);
      }
    },
    relativeDate(date2) {
      return formatDistanceToNow(parse$2(date2, "yyyy-MM-dd", new Date())) + " ago";
    },
    formattedDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    }
  }
};
const _sfc_main$I = /* @__PURE__ */ Object.assign(__default__$3, {
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const query = vueRouter_cjs.useRoute().query;
    var initialPage = 1;
    if (query.hasOwnProperty("page")) {
      initialPage = query.page;
    }
    const { data: prefetchData } = ([__temp, __restore] = vue_cjs_prod.withAsyncContext(() => useFetch(API_BASE + "bills/?page=" + initialPage + "&per_page=10")), __temp = await __temp, __restore(), __temp);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Head = vue_cjs_prod.resolveComponent("Head");
      const _component_Link = vue_cjs_prod.resolveComponent("Link");
      const _component_Card = __nuxt_component_2$4;
      const _component_Spinner = __nuxt_component_0$1;
      const _component_NuxtLink = __nuxt_component_1$7;
      const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-01a8be30><h4 data-v-01a8be30>Filter bills</h4>`);
      if (vue_cjs_prod.unref(prefetchData) && vue_cjs_prod.unref(prefetchData).count > 0) {
        _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page == 2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "prev",
                  href: "/bills"
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              if (vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page != 2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "prev",
                  href: "/bills?page=" + (vue_cjs_prod.unref(prefetchData).page - 1)
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              if (vue_cjs_prod.unref(prefetchData).next) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "next",
                  href: "/bills?page=" + (vue_cjs_prod.unref(prefetchData).page + 1)
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page == 2 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 0,
                  rel: "prev",
                  href: "/bills"
                })) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page != 2 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 1,
                  rel: "prev",
                  href: "/bills?page=" + (vue_cjs_prod.unref(prefetchData).page - 1)
                }, null, 8, ["href"])) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.unref(prefetchData).next ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 2,
                  rel: "next",
                  href: "/bills?page=" + (vue_cjs_prod.unref(prefetchData).page + 1)
                }, null, 8, ["href"])) : vue_cjs_prod.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<form data-v-01a8be30${_scopeId}><div class="row mb-2" data-v-01a8be30${_scopeId}><div class="col-12" data-v-01a8be30${_scopeId}><h5 data-v-01a8be30${_scopeId}>Refine by title</h5><label for="text_filter" data-v-01a8be30${_scopeId}>Title must contain the following:</label><input${serverRenderer.exports.ssrRenderAttr("value", _ctx.filterSettings.titleContains)} class="form-control" type="input" id="text_filter" data-v-01a8be30${_scopeId}><small class="text-muted" data-v-01a8be30${_scopeId}>For less strict textual search, you may wish to use the site-wide search function.</small></div></div><hr data-v-01a8be30${_scopeId}><div class="row" data-v-01a8be30${_scopeId}><div class="col-12 col-xl-3" data-v-01a8be30${_scopeId}><h5 data-v-01a8be30${_scopeId}>Bill types</h5><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.gov) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.gov, "") : _ctx.filterSettings.billTypes.gov) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_goverment" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_goverment" data-v-01a8be30${_scopeId}> Government bills </label></div><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.mem) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.mem, "") : _ctx.filterSettings.billTypes.mem) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_members" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_members" data-v-01a8be30${_scopeId}> Members&#39; bills </label></div><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.loc) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.loc, "") : _ctx.filterSettings.billTypes.loc) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_local" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_local" data-v-01a8be30${_scopeId}> Local bills </label></div><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.pri) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.pri, "") : _ctx.filterSettings.billTypes.pri) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_private" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_private" data-v-01a8be30${_scopeId}> Private bills </label></div><small data-v-01a8be30${_scopeId}><strong data-v-01a8be30${_scopeId}>OR</strong>: Bills must be any of the selected type to be shown.</small></div><div class="col-12 col-xl-3" data-v-01a8be30${_scopeId}><h5 data-v-01a8be30${_scopeId}>Temporal characteristics</h5><label for="parliament_select" data-v-01a8be30${_scopeId}>Parliamentary term of introduction</label><select class="form-select" id="parliament_select" aria-label="-" data-v-01a8be30${_scopeId}><option value="" selected data-v-01a8be30${_scopeId}>Any</option><option value="53" data-v-01a8be30${_scopeId}>53rd Parliament</option><option value="52" data-v-01a8be30${_scopeId}>52nd Parliament</option><option value="51" data-v-01a8be30${_scopeId}>51st Parliament</option><option value="50" data-v-01a8be30${_scopeId}>50th Parliament</option></select></div><div class="col-12 col-xl-3" data-v-01a8be30${_scopeId}><h5 data-v-01a8be30${_scopeId}>Procedural characteristics</h5><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.characteristics.urgencyUsed) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.characteristics.urgencyUsed, "") : _ctx.filterSettings.characteristics.urgencyUsed) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_urgency" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_urgency" data-v-01a8be30${_scopeId}> Urgency used </label></div><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.characteristics.extendedSittingsUsed) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.characteristics.extendedSittingsUsed, "") : _ctx.filterSettings.characteristics.extendedSittingsUsed) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_extended" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_extended" data-v-01a8be30${_scopeId}> Extended sittings used </label></div><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.characteristics.submissionsOpen) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.characteristics.submissionsOpen, "") : _ctx.filterSettings.characteristics.submissionsOpen) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_submissions_open" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_submissions_open" data-v-01a8be30${_scopeId}> Open for submissions </label></div><label for="voting_method_select" class="mt-2" data-v-01a8be30${_scopeId}>Voting method</label><select class="form-select" id="voting_method_select" aria-label="Voting method" data-v-01a8be30${_scopeId}><option value="" selected data-v-01a8be30${_scopeId}>Any</option><option value="per" data-v-01a8be30${_scopeId}>Personal voting used</option><option value="par" data-v-01a8be30${_scopeId}>Party voting used</option></select><small data-v-01a8be30${_scopeId}><strong data-v-01a8be30${_scopeId}>AND</strong>: Bills must meet all of these criteria to be shown.</small></div></div><hr data-v-01a8be30${_scopeId}><h5 data-v-01a8be30${_scopeId}>Display options</h5><div class="row" data-v-01a8be30${_scopeId}><div class="col-12 col-xl-3" data-v-01a8be30${_scopeId}><label for="per_page_select" data-v-01a8be30${_scopeId}>Results per page</label><select class="form-select" id="per_page_select" aria-label="Results per page" data-v-01a8be30${_scopeId}><option value="10" selected data-v-01a8be30${_scopeId}>10</option><option value="25" data-v-01a8be30${_scopeId}>25</option><option value="50" data-v-01a8be30${_scopeId}>50</option><option value="100" data-v-01a8be30${_scopeId}>100</option></select><div class="form-check" data-v-01a8be30${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.showDescriptions) ? serverRenderer.exports.ssrLooseContain(_ctx.showDescriptions, "") : _ctx.showDescriptions) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_show_descriptions" data-v-01a8be30${_scopeId}><label class="form-check-label" for="check_show_descriptions" data-v-01a8be30${_scopeId}> Show bill descriptions </label></div></div><div class="col-12 col-xl-3" data-v-01a8be30${_scopeId}><label for="order_by_select" data-v-01a8be30${_scopeId}>Order by</label><select class="form-select" id="order_by_select" aria-label="Order by" data-v-01a8be30${_scopeId}><option value="date_modified_desc" selected data-v-01a8be30${_scopeId}>Date modified (newest first)</option><option value="date_modified_asc" data-v-01a8be30${_scopeId}>Date modified (oldest first)</option><option value="introduction_date_desc" data-v-01a8be30${_scopeId}>Introduction date (newest first)</option><option value="introduction_date_asc" data-v-01a8be30${_scopeId}>Introduction date (oldest first)</option><option value="progress_desc" data-v-01a8be30${_scopeId}>Status (later stages first)</option><option value="progress_asc" data-v-01a8be30${_scopeId}>Status (early stages first)</option></select></div></div><hr data-v-01a8be30${_scopeId}><div class="row" data-v-01a8be30${_scopeId}><div class="col-12" data-v-01a8be30${_scopeId}>`);
            if (_ctx.activeString != _ctx.userString && !_ctx.isLoading) {
              _push2(`<button class="btn btn-primary" type="button" id="button-addon2" data-v-01a8be30${_scopeId}>Refine selection</button>`);
            } else {
              _push2(`<button disabled class="btn btn-primary" type="button" id="button-addon2" data-v-01a8be30${_scopeId}>Refine selection</button>`);
            }
            if (_ctx.isLoading) {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_Spinner, { class: "ms-2" }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div></div></form>`);
          } else {
            return [
              vue_cjs_prod.createVNode("form", {
                onSubmit: vue_cjs_prod.withModifiers(($event) => _ctx.applyFilter(), ["prevent"])
              }, [
                vue_cjs_prod.createVNode("div", { class: "row mb-2" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12" }, [
                    vue_cjs_prod.createVNode("h5", null, "Refine by title"),
                    vue_cjs_prod.createVNode("label", { for: "text_filter" }, "Title must contain the following:"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.titleContains = $event,
                      class: "form-control",
                      type: "input",
                      id: "text_filter"
                    }, null, 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelText, _ctx.filterSettings.titleContains]
                    ]),
                    vue_cjs_prod.createVNode("small", { class: "text-muted" }, "For less strict textual search, you may wish to use the site-wide search function.")
                  ])
                ]),
                vue_cjs_prod.createVNode("hr"),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Bill types"),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.gov = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_goverment"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.gov]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_goverment"
                      }, " Government bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.mem = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_members"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.mem]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_members"
                      }, " Members' bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.loc = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_local"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.loc]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_local"
                      }, " Local bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.pri = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_private"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.pri]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_private"
                      }, " Private bills ")
                    ]),
                    vue_cjs_prod.createVNode("small", null, [
                      vue_cjs_prod.createVNode("strong", null, "OR"),
                      vue_cjs_prod.createTextVNode(": Bills must be any of the selected type to be shown.")
                    ])
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Temporal characteristics"),
                    vue_cjs_prod.createVNode("label", { for: "parliament_select" }, "Parliamentary term of introduction"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.parliamentaryTerm = $event,
                      class: "form-select",
                      id: "parliament_select",
                      "aria-label": "-"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "",
                        selected: ""
                      }, "Any"),
                      vue_cjs_prod.createVNode("option", { value: "53" }, "53rd Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "52" }, "52nd Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "51" }, "51st Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "50" }, "50th Parliament")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.parliamentaryTerm]
                    ])
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Procedural characteristics"),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.characteristics.urgencyUsed = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_urgency"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.characteristics.urgencyUsed]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_urgency"
                      }, " Urgency used ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.characteristics.extendedSittingsUsed = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_extended"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.characteristics.extendedSittingsUsed]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_extended"
                      }, " Extended sittings used ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.characteristics.submissionsOpen = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_submissions_open"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.characteristics.submissionsOpen]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_submissions_open"
                      }, " Open for submissions ")
                    ]),
                    vue_cjs_prod.createVNode("label", {
                      for: "voting_method_select",
                      class: "mt-2"
                    }, "Voting method"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.characteristics.votingMethod = $event,
                      class: "form-select",
                      id: "voting_method_select",
                      "aria-label": "Voting method"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "",
                        selected: ""
                      }, "Any"),
                      vue_cjs_prod.createVNode("option", { value: "per" }, "Personal voting used"),
                      vue_cjs_prod.createVNode("option", { value: "par" }, "Party voting used")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.characteristics.votingMethod]
                    ]),
                    vue_cjs_prod.createVNode("small", null, [
                      vue_cjs_prod.createVNode("strong", null, "AND"),
                      vue_cjs_prod.createTextVNode(": Bills must meet all of these criteria to be shown.")
                    ])
                  ])
                ]),
                vue_cjs_prod.createVNode("hr"),
                vue_cjs_prod.createVNode("h5", null, "Display options"),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("label", { for: "per_page_select" }, "Results per page"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.format.perPage = $event,
                      class: "form-select",
                      id: "per_page_select",
                      "aria-label": "Results per page"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "10",
                        selected: ""
                      }, "10"),
                      vue_cjs_prod.createVNode("option", { value: "25" }, "25"),
                      vue_cjs_prod.createVNode("option", { value: "50" }, "50"),
                      vue_cjs_prod.createVNode("option", { value: "100" }, "100")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.format.perPage]
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => vue_cjs_prod.isRef(showDescriptions) ? showDescriptions.value = $event : null,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_show_descriptions"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.showDescriptions]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_show_descriptions"
                      }, " Show bill descriptions ")
                    ])
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("label", { for: "order_by_select" }, "Order by"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.format.orderBy = $event,
                      class: "form-select",
                      id: "order_by_select",
                      "aria-label": "Order by"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "date_modified_desc",
                        selected: ""
                      }, "Date modified (newest first)"),
                      vue_cjs_prod.createVNode("option", { value: "date_modified_asc" }, "Date modified (oldest first)"),
                      vue_cjs_prod.createVNode("option", { value: "introduction_date_desc" }, "Introduction date (newest first)"),
                      vue_cjs_prod.createVNode("option", { value: "introduction_date_asc" }, "Introduction date (oldest first)"),
                      vue_cjs_prod.createVNode("option", { value: "progress_desc" }, "Status (later stages first)"),
                      vue_cjs_prod.createVNode("option", { value: "progress_asc" }, "Status (early stages first)")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.format.orderBy]
                    ])
                  ])
                ]),
                vue_cjs_prod.createVNode("hr"),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12" }, [
                    _ctx.activeString != _ctx.userString && !_ctx.isLoading ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("button", {
                      key: 0,
                      onClick: ($event) => _ctx.applyFilter(),
                      class: "btn btn-primary",
                      type: "button",
                      id: "button-addon2"
                    }, "Refine selection", 8, ["onClick"])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("button", {
                      key: 1,
                      disabled: "",
                      class: "btn btn-primary",
                      type: "button",
                      id: "button-addon2"
                    }, "Refine selection")),
                    _ctx.isLoading ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Spinner, {
                      key: 2,
                      class: "ms-2"
                    })) : vue_cjs_prod.createCommentVNode("", true)
                  ])
                ])
              ], 40, ["onSubmit"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<span id="results-marker" data-v-01a8be30></span>`);
      if (_ctx.page) {
        _push(`<div data-v-01a8be30><h4 data-v-01a8be30>Results</h4> ${serverRenderer.exports.ssrInterpolate(_ctx.displayCount)} result`);
        if (_ctx.displayCount != 1) {
          _push(`<span data-v-01a8be30>s</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`. <!--[-->`);
        serverRenderer.exports.ssrRenderList(_ctx.displayBills, (bill) => {
          _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
            title: bill.name,
            key: bill.id,
            to: "/bills/" + bill.id,
            class: "bill-link"
          }, {
            default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`<h6 class="mb-0" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.name)}</h6><small class="me-1" data-v-01a8be30${_scopeId2}>`);
                      if (bill.progress == "inp") {
                        _push3(`<span class="badge bg-primary text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "pas") {
                        _push3(`<span class="badge bg-success text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "ena") {
                        _push3(`<span class="badge bg-success text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "dis") {
                        _push3(`<span class="badge bg-warning text-dark text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "def") {
                        _push3(`<span class="badge bg-danger text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "lap") {
                        _push3(`<span class="badge bg-danger text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "unx") {
                        _push3(`<span class="badge bg-danger text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "div") {
                        _push3(`<span class="badge bg-info text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else if (bill.progress == "wit") {
                        _push3(`<span class="badge bg-warning text-dark text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      } else {
                        _push3(`<span class="badge bg-secondary text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                      }
                      _push3(`</small><small class="text-muted text-uppercase" data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.type_desc)}</small>`);
                      if (bill.description && _ctx.showDescriptions) {
                        _push3(`<p data-v-01a8be30${_scopeId2}>${serverRenderer.exports.ssrInterpolate(bill.description)}</p>`);
                      } else if (_ctx.showDescriptions) {
                        _push3(`<p class="text-muted" data-v-01a8be30${_scopeId2}> No description. </p>`);
                      } else {
                        _push3(`<!---->`);
                      }
                      if (!_ctx.showDescriptions) {
                        _push3(`<br data-v-01a8be30${_scopeId2}>`);
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(`<small data-v-01a8be30${_scopeId2}>`);
                      if (bill.date_modified) {
                        _push3(`<span${serverRenderer.exports.ssrRenderAttr("title", _ctx.formattedDate(bill.date_modified))} class="text-muted" data-v-01a8be30${_scopeId2}>`);
                        _push3(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, { icon: ["fas", "history"] }, null, _parent3, _scopeId2));
                        _push3(` Last activity ${serverRenderer.exports.ssrInterpolate(_ctx.relativeDate(bill.date_modified))}</span>`);
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(`</small>`);
                    } else {
                      return [
                        vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(bill.name), 1),
                        vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                          bill.progress == "inp" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 0,
                            class: "badge bg-primary text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "pas" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 1,
                            class: "badge bg-success text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "ena" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 2,
                            class: "badge bg-success text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "dis" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 3,
                            class: "badge bg-warning text-dark text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "def" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 4,
                            class: "badge bg-danger text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "lap" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 5,
                            class: "badge bg-danger text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "unx" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 6,
                            class: "badge bg-danger text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "div" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 7,
                            class: "badge bg-info text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "wit" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 8,
                            class: "badge bg-warning text-dark text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 9,
                            class: "badge bg-secondary text-uppercase"
                          }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1))
                        ]),
                        vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(bill.type_desc), 1),
                        bill.description && _ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, vue_cjs_prod.toDisplayString(bill.description), 1)) : _ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
                          key: 1,
                          class: "text-muted"
                        }, " No description. ")) : vue_cjs_prod.createCommentVNode("", true),
                        !_ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("br", { key: 2 })) : vue_cjs_prod.createCommentVNode("", true),
                        vue_cjs_prod.createVNode("small", null, [
                          bill.date_modified ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                            key: 0,
                            title: _ctx.formattedDate(bill.date_modified),
                            class: "text-muted"
                          }, [
                            vue_cjs_prod.createVNode(_component_font_awesome_icon, { icon: ["fas", "history"] }),
                            vue_cjs_prod.createTextVNode(" Last activity " + vue_cjs_prod.toDisplayString(_ctx.relativeDate(bill.date_modified)), 1)
                          ], 8, ["title"])) : vue_cjs_prod.createCommentVNode("", true)
                        ])
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
              } else {
                return [
                  vue_cjs_prod.createVNode(_component_Card, null, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(bill.name), 1),
                      vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                        bill.progress == "inp" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          class: "badge bg-primary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "pas" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 1,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "ena" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 2,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "dis" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 3,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "def" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 4,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "lap" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 5,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "unx" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 6,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "div" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 7,
                          class: "badge bg-info text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "wit" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 8,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 9,
                          class: "badge bg-secondary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1))
                      ]),
                      vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(bill.type_desc), 1),
                      bill.description && _ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, vue_cjs_prod.toDisplayString(bill.description), 1)) : _ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
                        key: 1,
                        class: "text-muted"
                      }, " No description. ")) : vue_cjs_prod.createCommentVNode("", true),
                      !_ctx.showDescriptions ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("br", { key: 2 })) : vue_cjs_prod.createCommentVNode("", true),
                      vue_cjs_prod.createVNode("small", null, [
                        bill.date_modified ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          title: _ctx.formattedDate(bill.date_modified),
                          class: "text-muted"
                        }, [
                          vue_cjs_prod.createVNode(_component_font_awesome_icon, { icon: ["fas", "history"] }),
                          vue_cjs_prod.createTextVNode(" Last activity " + vue_cjs_prod.toDisplayString(_ctx.relativeDate(bill.date_modified)), 1)
                        ], 8, ["title"])) : vue_cjs_prod.createCommentVNode("", true)
                      ])
                    ]),
                    _: 2
                  }, 1024)
                ];
              }
            }),
            _: 2
          }, _parent));
        });
        _push(`<!--]-->`);
        if (!_ctx.isLoading) {
          _push(`<nav aria-label="bills_pagination" data-v-01a8be30><ul class="pagination mb-1" data-v-01a8be30><li class="${serverRenderer.exports.ssrRenderClass([{ disabled: !_ctx.displayPrevious }, "page-item"])}" data-v-01a8be30><a class="page-link" href="#results-marker" data-v-01a8be30>Previous</a></li>`);
          if (_ctx.displayPrevious) {
            _push(`<li class="page-item" data-v-01a8be30><a class="page-link" href="#results-marker" data-v-01a8be30>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage - 1)}</a></li>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<li class="page-item active" aria-current="page" data-v-01a8be30><a class="page-link" href="#results-marker" data-v-01a8be30>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage)}</a></li>`);
          if (_ctx.displayNext) {
            _push(`<li class="page-item" data-v-01a8be30><a class="page-link" href="#results-marker" data-v-01a8be30>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage + 1)}</a></li>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<li class="${serverRenderer.exports.ssrRenderClass([{ disabled: !_ctx.displayNext }, "page-item"])}" data-v-01a8be30><a class="page-link" href="#results-marker" data-v-01a8be30>Next</a></li></ul>`);
          if (_ctx.displayPage != 1) {
            _push(`<a id="back-to-start" href="#results-marker" data-v-01a8be30><small data-v-01a8be30>Back to start</small></a>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</nav>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$I = _sfc_main$I.setup;
_sfc_main$I.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/BillFilter.vue");
  return _sfc_setup$I ? _sfc_setup$I(props, ctx) : void 0;
};
const __nuxt_component_1$5 = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-01a8be30"]]);
const meta$g = void 0;
const useElectoratesStore = defineStore("electorates", {
  state() {
    return {
      items: [],
      data: {
        histories: {},
        shapes: {}
      }
    };
  },
  getters: {
    byIdentifier: (state2) => (id) => {
      if (state2.items.find((item) => item.slug === id)) {
        return state2.items.find((item) => item.slug === id);
      }
      return state2.items.find((item) => item.id === id);
    },
    historyByIdentifier: (state2) => (id) => {
      return state2.data.histories[id];
    },
    shapeByIdentifier: (state2) => (id) => {
      return state2.data.shapes[id];
    }
  },
  actions: {
    async fetch(id) {
      if (!this.byIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "electorates/" + id + "/", {
          onResponse({ request: request2, response, options }) {
            state2.items.push(response._data);
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchHistory(id) {
      if (!this.historyByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "electorates/" + id + "/history/", {
          onResponse({ request: request2, response, options }) {
            state2.data.histories[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchShape(id) {
      if (!this.shapeByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "electorates/" + id + "/shape/", {
          onResponse({ request: request2, response, options }) {
            state2.data.shapes[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$f = void 0;
const _sfc_main$H = {
  name: "ElectorateCard",
  components: {
    Card: __nuxt_component_2$4
  },
  props: {
    electorate: Object
  }
};
function _sfc_ssrRender$y(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_router_link = vue_cjs_prod.resolveComponent("router-link");
  const _component_Card = __nuxt_component_2$4;
  _push(serverRenderer.exports.ssrRenderComponent(_component_router_link, vue_cjs_prod.mergeProps({
    class: "router-link",
    to: "/electorates/" + $props.electorate.slug
  }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`<h5 data-v-df3bce42${_scopeId2}><strong data-v-df3bce42${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.electorate.name)}</strong></h5><span class="text-muted text-uppercase" data-v-df3bce42${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.electorate.type)}</span>`);
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, [
                  vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.electorate.name), 1)
                ]),
                vue_cjs_prod.createVNode("span", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString($props.electorate.type), 1)
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_Card, null, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createVNode("h5", null, [
                vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.electorate.name), 1)
              ]),
              vue_cjs_prod.createVNode("span", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString($props.electorate.type), 1)
            ]),
            _: 1
          })
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$H = _sfc_main$H.setup;
_sfc_main$H.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ElectorateCard.vue");
  return _sfc_setup$H ? _sfc_setup$H(props, ctx) : void 0;
};
const __nuxt_component_2$3 = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["ssrRender", _sfc_ssrRender$y], ["__scopeId", "data-v-df3bce42"]]);
const useGroupsStore = defineStore("groups", {
  state() {
    return {
      items: []
    };
  },
  getters: {
    byName: (state2) => (name, type) => {
      if (state2.items.find((group) => group.name === name && group.type === type)) {
        return state2.items.find((group) => group.name === name && group.type === type).items;
      }
    }
  },
  actions: {
    async fetchPeople(id) {
      if (!this.byName(id, "people")) {
        var state2 = this;
        await useFetch(API_BASE + "people/?group=" + id, {
          onResponse({ request: request2, response, options }) {
            state2.items.push({
              items: response._data,
              name: id,
              type: "people"
            });
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchElectorates(id) {
      if (!this.byName(id, "electorates")) {
        var state2 = this;
        await useFetch(API_BASE + "electorates/?group=" + id, {
          onResponse({ request: request2, response, options }) {
            state2.items.push({
              items: response._data,
              name: id,
              type: "electorates"
            });
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchParties(id) {
      if (!this.byName(id, "parties")) {
        var state2 = this;
        await useFetch(API_BASE + "parties/?group=" + id, {
          onResponse({ request: request2, response, options }) {
            state2.items.push({
              items: response._data,
              name: id,
              type: "parties"
            });
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$e = void 0;
const _sfc_main$G = {
  name: "SearchBar"
};
function _sfc_ssrRender$x(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "mb-1" }, _attrs))} data-v-3a2d4e60><form action="/search/" method="get" data-v-3a2d4e60><div class="input-group" data-v-3a2d4e60><input type="text" class="form-control" id="q" name="q" placeholder="MP, electorate or party name" data-v-3a2d4e60><button class="btn btn-primary" type="submit" id="button-addon2" data-v-3a2d4e60>Find</button></div></form><small class="text-muted" data-v-3a2d4e60>Search provided by Algolia.</small></div>`);
}
const _sfc_setup$G = _sfc_main$G.setup;
_sfc_main$G.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/SearchBar.vue");
  return _sfc_setup$G ? _sfc_setup$G(props, ctx) : void 0;
};
const __nuxt_component_1$4 = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["ssrRender", _sfc_ssrRender$x], ["__scopeId", "data-v-3a2d4e60"]]);
const _sfc_main$F = {
  name: "RandomResource",
  data() {
    return {
      loading: false
    };
  },
  methods: {
    async randomise() {
      if (this.loading) {
        return;
      }
      this.loading = true;
      var url2 = API_BASE + "client/random/";
      var to2 = await $fetch(url2);
      this.$router.push(to2.to);
      return;
    }
  }
};
function _sfc_ssrRender$w(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_Spinner = __nuxt_component_0$1;
  _push(`<a${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ href: "#" }, _attrs))} data-v-93270e28> Or, go to a random page `);
  if (!$data.loading) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent));
  } else {
    _push(`<!---->`);
  }
  if ($data.loading) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Spinner, { class: "ms-1" }, null, _parent));
  } else {
    _push(`<!---->`);
  }
  _push(`</a>`);
}
const _sfc_setup$F = _sfc_main$F.setup;
_sfc_main$F.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/RandomResource.vue");
  return _sfc_setup$F ? _sfc_setup$F(props, ctx) : void 0;
};
const __nuxt_component_2$2 = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["ssrRender", _sfc_ssrRender$w], ["__scopeId", "data-v-93270e28"]]);
const __default__$2 = {
  name: "Home",
  components: {},
  methods: {
    relativeDate(date2) {
      return formatDistanceToNow(parse$2(date2, "yyyy-MM-dd", new Date())) + " ago";
    },
    formattedDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    },
    formattedDateFull(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  }
};
const _sfc_main$E = /* @__PURE__ */ Object.assign(__default__$2, {
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const { data: homepageData } = ([__temp, __restore] = vue_cjs_prod.withAsyncContext(() => useFetch(API_BASE + "client/homepage/")), __temp = await __temp, __restore(), __temp);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Card = __nuxt_component_2$4;
      const _component_SearchBar = __nuxt_component_1$4;
      const _component_RandomResource = __nuxt_component_2$2;
      const _component_NuxtLink = __nuxt_component_1$7;
      const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
      const _component_ExternalLinkInline = __nuxt_component_3$4;
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-6091f714><div id="cover-image" class="container-fluid text-start py-5" data-v-6091f714><div class="container" data-v-6091f714><div class="row" data-v-6091f714><div class="col-12 col-xl-8 py-xl-5 py-2" data-v-6091f714><h1 class="display-4" data-v-6091f714>Wondering where they stand?</h1><hr data-v-6091f714><h3 data-v-6091f714> WhereTheyStand aggregates voting data, financial information, biographical information, and more. </h3></div><div id="onboarding" class="col-12 col-xl-4 py-xl-5 py-2" data-v-6091f714>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { frosted: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h4 class="mt-2" data-v-6091f714${_scopeId}>Find your MP, electorate or party</h4> All MPs who&#39;ve been in Parliament since 2014 have profiles. `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SearchBar, { class: "mt-2" }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_RandomResource, null, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode("h4", { class: "mt-2" }, "Find your MP, electorate or party"),
              vue_cjs_prod.createTextVNode(" All MPs who've been in Parliament since 2014 have profiles. "),
              vue_cjs_prod.createVNode(_component_SearchBar, { class: "mt-2" }),
              vue_cjs_prod.createVNode(_component_RandomResource)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></div><div class="container mt-3" data-v-6091f714><div class="row" data-v-6091f714><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Recent votes</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vue_cjs_prod.unref(homepageData)) {
              _push2(`<div data-v-6091f714${_scopeId}><ul class="homepage-resource-list" data-v-6091f714${_scopeId}><!--[-->`);
              serverRenderer.exports.ssrRenderList(vue_cjs_prod.unref(homepageData).votes, (vote, i) => {
                _push2(`<li class="mb-3 vote-list" data-v-6091f714${_scopeId}><h6 class="mb-0" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(vote.name)}</h6><small class="me-1" data-v-6091f714${_scopeId}>`);
                if (vote.type_desc) {
                  _push2(`<span class="badge bg-primary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(vote.type_desc)}</span>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</small><small class="text-muted text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(_ctx.formattedDateFull(vote.date))}</small><br data-v-6091f714${_scopeId}><div class="text-start" data-v-6091f714${_scopeId}>`);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/votes/" + vote.id,
                  class: "vote-link mt-1"
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`View vote `);
                      _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent3, _scopeId2));
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode("View vote "),
                        vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
                _push2(`</div>`);
                if (i < 4) {
                  _push2(`<hr class="mt-1" data-v-6091f714${_scopeId}>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</li>`);
              });
              _push2(`<!--]--></ul></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vue_cjs_prod.unref(homepageData) ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                vue_cjs_prod.createVNode("ul", { class: "homepage-resource-list" }, [
                  (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList(vue_cjs_prod.unref(homepageData).votes, (vote, i) => {
                    return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                      key: vote.id,
                      class: "mb-3 vote-list"
                    }, [
                      vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(vote.name), 1),
                      vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                        vote.type_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          class: "badge bg-primary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(vote.type_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                      ]),
                      vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(_ctx.formattedDateFull(vote.date)), 1),
                      vue_cjs_prod.createVNode("br"),
                      vue_cjs_prod.createVNode("div", { class: "text-start" }, [
                        vue_cjs_prod.createVNode(_component_NuxtLink, {
                          to: "/votes/" + vote.id,
                          class: "vote-link mt-1"
                        }, {
                          default: vue_cjs_prod.withCtx(() => [
                            vue_cjs_prod.createTextVNode("View vote "),
                            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                          ]),
                          _: 2
                        }, 1032, ["to"])
                      ]),
                      i < 4 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", {
                        key: 0,
                        class: "mt-1"
                      })) : vue_cjs_prod.createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Recently updated bills</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vue_cjs_prod.unref(homepageData)) {
              _push2(`<div data-v-6091f714${_scopeId}><ul class="homepage-resource-list" data-v-6091f714${_scopeId}><!--[-->`);
              serverRenderer.exports.ssrRenderList(vue_cjs_prod.unref(homepageData).bills, (bill, i) => {
                _push2(`<li class="mb-3 bill-list" data-v-6091f714${_scopeId}><h6 class="mb-0" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.name)}</h6><small class="me-1" data-v-6091f714${_scopeId}>`);
                if (bill.progress == "inp") {
                  _push2(`<span class="badge bg-primary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "pas") {
                  _push2(`<span class="badge bg-success text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "ena") {
                  _push2(`<span class="badge bg-success text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "dis") {
                  _push2(`<span class="badge bg-warning text-dark text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "def") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "lap") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "unx") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "div") {
                  _push2(`<span class="badge bg-info text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "wit") {
                  _push2(`<span class="badge bg-warning text-dark text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else {
                  _push2(`<span class="badge bg-secondary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                }
                _push2(`</small><small class="text-muted text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.type_desc)}</small><div class="text-start" data-v-6091f714${_scopeId}>`);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/bills/" + bill.id,
                  class: "bill-link mt-1"
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`View bill `);
                      _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent3, _scopeId2));
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode("View bill "),
                        vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
                _push2(`</div>`);
                if (i < 4) {
                  _push2(`<hr class="mt-1" data-v-6091f714${_scopeId}>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</li>`);
              });
              _push2(`<!--]--></ul></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vue_cjs_prod.unref(homepageData) ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                vue_cjs_prod.createVNode("ul", { class: "homepage-resource-list" }, [
                  (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList(vue_cjs_prod.unref(homepageData).bills, (bill, i) => {
                    return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                      key: bill.id,
                      class: "mb-3 bill-list"
                    }, [
                      vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(bill.name), 1),
                      vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                        bill.progress == "inp" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          class: "badge bg-primary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "pas" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 1,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "ena" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 2,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "dis" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 3,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "def" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 4,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "lap" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 5,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "unx" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 6,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "div" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 7,
                          class: "badge bg-info text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "wit" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 8,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 9,
                          class: "badge bg-secondary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1))
                      ]),
                      vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(bill.type_desc), 1),
                      vue_cjs_prod.createVNode("div", { class: "text-start" }, [
                        vue_cjs_prod.createVNode(_component_NuxtLink, {
                          to: "/bills/" + bill.id,
                          class: "bill-link mt-1"
                        }, {
                          default: vue_cjs_prod.withCtx(() => [
                            vue_cjs_prod.createTextVNode("View bill "),
                            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                          ]),
                          _: 2
                        }, 1032, ["to"])
                      ]),
                      i < 4 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", {
                        key: 0,
                        class: "mt-1"
                      })) : vue_cjs_prod.createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Elections</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="election" data-v-6091f714${_scopeId}><h5 data-v-6091f714${_scopeId}>2022 Hamilton West by-election</h5><span data-v-6091f714${_scopeId}>10 December 2022</span><br data-v-6091f714${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Interactive results`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode("Interactive results")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div><hr data-v-6091f714${_scopeId}><div class="election" data-v-6091f714${_scopeId}><h5 data-v-6091f714${_scopeId}>2022 Tauranga by-election</h5><span data-v-6091f714${_scopeId}>18 June 2022</span><br data-v-6091f714${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Interactive results `);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode("Interactive results ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div>`);
          } else {
            return [
              vue_cjs_prod.createVNode("div", { class: "election" }, [
                vue_cjs_prod.createVNode("h5", null, "2022 Hamilton West by-election"),
                vue_cjs_prod.createVNode("span", null, "10 December 2022"),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode("Interactive results")
                  ]),
                  _: 1
                })
              ]),
              vue_cjs_prod.createVNode("hr"),
              vue_cjs_prod.createVNode("div", { class: "election" }, [
                vue_cjs_prod.createVNode("h5", null, "2022 Tauranga by-election"),
                vue_cjs_prod.createVNode("span", null, "18 June 2022"),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode("Interactive results ")
                  ]),
                  _: 1
                })
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></div>`);
    };
  }
});
const _sfc_setup$E = _sfc_main$E.setup;
_sfc_main$E.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/index.vue");
  return _sfc_setup$E ? _sfc_setup$E(props, ctx) : void 0;
};
const meta$d = void 0;
const usePartiesStore = defineStore("parties", {
  state() {
    return {
      items: [],
      data: {
        members: {},
        leaders: {}
      }
    };
  },
  getters: {
    byIdentifier: (state2) => (id) => {
      if (state2.items.find((item) => item.slug === id)) {
        return state2.items.find((item) => item.slug === id);
      }
      return state2.items.find((item) => item.id === id);
    },
    membersByIdentifier: (state2) => (id) => {
      return state2.data.members[id];
    },
    leadersByIdentifier: (state2) => (id) => {
      return state2.data.leaders[id];
    }
  },
  actions: {
    async fetch(id) {
      if (!this.byIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "parties/" + id + "/", {
          onResponse({ request: request2, response, options }) {
            state2.items.push(response._data);
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchMembers(id) {
      if (!this.membersByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "parties/" + id + "/members/", {
          onResponse({ request: request2, response, options }) {
            state2.data.members[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchLeaders(id) {
      if (!this.leadersByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "parties/" + id + "/leaders/", {
          onResponse({ request: request2, response, options }) {
            state2.data.leaders[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$c = void 0;
const meta$b = void 0;
const _sfc_main$D = {
  name: "PersonList",
  props: {
    people: {
      default: [],
      type: Array
    },
    positions: {
      default: [],
      type: Array
    }
  },
  computed: {
    displayPeople() {
      if (this.people.length > 0) {
        return this.people;
      } else if (this.positions.length > 0) {
        var people = [];
        this.positions.forEach((pos) => {
          people.push(pos.person);
        });
        return people;
      } else {
        return [];
      }
    },
    showVoting() {
      if (this.people.length == 0 && this.positions.length > 0) {
        return true;
      } else {
        return false;
      }
    }
  }
};
function _sfc_ssrRender$v(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_ColourDot = __nuxt_component_3$3;
  _push(`<!--[-->`);
  serverRenderer.exports.ssrRenderList($options.displayPeople, (person, i) => {
    _push(`<div data-v-7bd41518>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
      class: "router-link",
      to: "/people/" + person.slug
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          if (person.image) {
            _push2(`<div class="d-flex align-items-center" data-v-7bd41518${_scopeId}><div class="flex-shrink-0" data-v-7bd41518${_scopeId}>`);
            if (person.image) {
              _push2(`<img${serverRenderer.exports.ssrRenderAttr("src", person.image)} class="me-3 person-image"${serverRenderer.exports.ssrRenderAttr("alt", person.display_name)} data-v-7bd41518${_scopeId}>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><div class="flex-grow-1 ms-3" data-v-7bd41518${_scopeId}><h6 data-v-7bd41518${_scopeId}><strong data-v-7bd41518${_scopeId}>${serverRenderer.exports.ssrInterpolate(person.display_name)}</strong></h6><p class="text-muted person-description" data-v-7bd41518${_scopeId}>`);
            if (person.colour) {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_ColourDot, {
                colour: person.colour
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`${serverRenderer.exports.ssrInterpolate(person.description)}</p></div></div>`);
          } else {
            _push2(`<div data-v-7bd41518${_scopeId}><h6 data-v-7bd41518${_scopeId}><strong data-v-7bd41518${_scopeId}>${serverRenderer.exports.ssrInterpolate(person.display_name)}</strong></h6>`);
            if (person.description) {
              _push2(`<p class="text-muted person-description" data-v-7bd41518${_scopeId}>`);
              if (person.colour) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_ColourDot, {
                  colour: person.colour
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(`${serverRenderer.exports.ssrInterpolate(person.description)}</p>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
          }
        } else {
          return [
            person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
              key: 0,
              class: "d-flex align-items-center"
            }, [
              vue_cjs_prod.createVNode("div", { class: "flex-shrink-0" }, [
                person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("img", {
                  key: 0,
                  src: person.image,
                  class: "me-3 person-image",
                  alt: person.display_name
                }, null, 8, ["src", "alt"])) : vue_cjs_prod.createCommentVNode("", true)
              ]),
              vue_cjs_prod.createVNode("div", { class: "flex-grow-1 ms-3" }, [
                vue_cjs_prod.createVNode("h6", null, [
                  vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(person.display_name), 1)
                ]),
                vue_cjs_prod.createVNode("p", { class: "text-muted person-description" }, [
                  person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ColourDot, {
                    key: 0,
                    colour: person.colour
                  }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                  vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(person.description), 1)
                ])
              ])
            ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
              vue_cjs_prod.createVNode("h6", null, [
                vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(person.display_name), 1)
              ]),
              person.description ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
                key: 0,
                class: "text-muted person-description"
              }, [
                person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ColourDot, {
                  key: 0,
                  colour: person.colour
                }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(person.description), 1)
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ]))
          ];
        }
      }),
      _: 2
    }, _parent));
    if (i < $options.displayPeople.length - 1) {
      _push(`<hr data-v-7bd41518>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div>`);
  });
  _push(`<!--]-->`);
}
const _sfc_setup$D = _sfc_main$D.setup;
_sfc_main$D.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PersonList.vue");
  return _sfc_setup$D ? _sfc_setup$D(props, ctx) : void 0;
};
const __nuxt_component_7 = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["ssrRender", _sfc_ssrRender$v], ["__scopeId", "data-v-7bd41518"]]);
const meta$a = void 0;
const _sfc_main$C = {
  name: "PartyCard",
  components: {
    Card: __nuxt_component_2$4
  },
  props: {
    party: Object
  }
};
function _sfc_ssrRender$u(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_router_link = vue_cjs_prod.resolveComponent("router-link");
  const _component_Card = __nuxt_component_2$4;
  _push(serverRenderer.exports.ssrRenderComponent(_component_router_link, vue_cjs_prod.mergeProps({
    class: "router-link",
    to: "/parties/" + $props.party.slug
  }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, {
          stripeColour: $props.party.colour
        }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`<h5 data-v-469832ad${_scopeId2}><strong data-v-469832ad${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.party.display_name)}</strong></h5>`);
              if ($props.party.seats) {
                _push3(`<p data-v-469832ad${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.party.seats)} seat`);
                if ($props.party.seats != 1) {
                  _push3(`<span data-v-469832ad${_scopeId2}>s</span>`);
                } else {
                  _push3(`<!---->`);
                }
                _push3(`</p>`);
              } else {
                _push3(`<!---->`);
              }
              serverRenderer.exports.ssrRenderSlot(_ctx.$slots, "default", {}, null, _push3, _parent3, _scopeId2);
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, [
                  vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.party.display_name), 1)
                ]),
                $props.party.seats ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, [
                  vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.party.seats) + " seat", 1),
                  $props.party.seats != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
                ])) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ];
            }
          }),
          _: 3
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_Card, {
            stripeColour: $props.party.colour
          }, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createVNode("h5", null, [
                vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString($props.party.display_name), 1)
              ]),
              $props.party.seats ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, [
                vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($props.party.seats) + " seat", 1),
                $props.party.seats != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
              ])) : vue_cjs_prod.createCommentVNode("", true),
              vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 3
          }, 8, ["stripeColour"])
        ];
      }
    }),
    _: 3
  }, _parent));
}
const _sfc_setup$C = _sfc_main$C.setup;
_sfc_main$C.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PartyCard.vue");
  return _sfc_setup$C ? _sfc_setup$C(props, ctx) : void 0;
};
const __nuxt_component_5$2 = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["ssrRender", _sfc_ssrRender$u], ["__scopeId", "data-v-469832ad"]]);
const meta$9 = void 0;
const useNotificationsStore$1 = defineStore("notifications", {
  state() {
    return {
      banners: [
        {
          id: 0,
          linkBehaviour: "none",
          title: "New look",
          message: "WhereTheyStand has had a facelift! The new design is still in the early stages (this is the minimum viable product), so if you run into any issues, try refreshing the page. You're always welcome to leave feedback via the link in the footer."
        }
      ],
      toasts: [],
      loaded: true,
      toastId: 0
    };
  },
  actions: {
    async fetch() {
      if (!this.loaded) {
        await useFetch(API_BASE + "notifications/banners/", {
          onResponse({ request: request2, response, options }) {
            this.banners = response._data;
          },
          onResponseError({ request: request2, response, options }) {
          },
          onRequestError({ request: request2, options, error }) {
          }
        });
      }
    },
    addToast(title, message) {
      this.toasts.push({
        id: this.toastId,
        title,
        message
      });
      this.toastId = this.toastId + 1;
    },
    closeToast(id) {
      var removeIndex = this.toasts.map((item) => item.id).indexOf(id);
      if (removeIndex >= 0) {
        this.toasts.splice(removeIndex, 1);
      }
    },
    closeBanner(id) {
      var removeIndex = this.banners.map((item) => item.id).indexOf(id);
      if (removeIndex >= 0) {
        this.banners.splice(removeIndex, 1);
      }
    },
    postResponseError(response) {
      this.addToast("Error fetching resource (response)", response.status + " " + response._data.detail);
    }
  }
});
const usePeopleStore = defineStore("people", {
  state() {
    return {
      items: [],
      data: {
        votes: {},
        bills: {},
        interests: {},
        mpExpenses: {},
        execExpenses: {},
        returns: {},
        votingSimilarity: {},
        details: {}
      }
    };
  },
  getters: {
    byIdentifier: (state2) => (id) => {
      if (state2.items.find((item) => item.slug === id)) {
        return state2.items.find((item) => item.slug === id);
      }
      return state2.items.find((item) => item.id === id);
    },
    votesByIdentifier: (state2) => (id) => {
      return state2.data.votes[id];
    },
    billsByIdentifier: (state2) => (id) => {
      return state2.data.bills[id];
    },
    interestsByIdentifier: (state2) => (id) => {
      return state2.data.interests[id];
    },
    mpExpensesByIdentifier: (state2) => (id) => {
      return state2.data.mpExpenses[id];
    },
    execExpensesByIdentifier: (state2) => (id) => {
      return state2.data.execExpenses[id];
    },
    returnsByIdentifier: (state2) => (id) => {
      return state2.data.returns[id];
    },
    votingSimilarityByIdentifier: (state2) => (id) => {
      return state2.data.votingSimilarity[id];
    },
    detailsByIdentifier: (state2) => (id) => {
      return state2.data.details[id];
    }
  },
  actions: {
    async fetch(id) {
      if (!this.byIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/", {
          onResponse({ request: request2, response, options }) {
            state2.items.push(response._data);
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchVotes(id) {
      if (!this.votesByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/votes/", {
          onResponse({ request: request2, response, options }) {
            state2.data.votes[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchBills(id) {
      if (!this.billsByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/bills/", {
          onResponse({ request: request2, response, options }) {
            state2.data.bills[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchInterests(id) {
      if (!this.interestsByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/interests/", {
          onResponse({ request: request2, response, options }) {
            state2.data.interests[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchMpExpenses(id) {
      if (!this.mpExpensesByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/mp-expenses/", {
          onResponse({ request: request2, response, options }) {
            state2.data.mpExpenses[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchExecExpenses(id) {
      if (!this.execExpensesByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/exec-expenses/", {
          onResponse({ request: request2, response, options }) {
            state2.data.execExpenses[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchReturns(id) {
      if (!this.returnsByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/returns/", {
          onResponse({ request: request2, response, options }) {
            state2.data.returns[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchVotingSimilarity(id) {
      if (!this.votingSimilarityByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/voting-similarity/", {
          onResponse({ request: request2, response, options }) {
            state2.data.votingSimilarity[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    },
    async fetchDetails(id) {
      if (!this.detailsByIdentifier(id)) {
        var state2 = this;
        await useFetch(API_BASE + "people/" + id + "/details/", {
          onResponse({ request: request2, response, options }) {
            state2.data.details[id] = response._data;
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore$1();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore$1();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$8 = void 0;
const _sfc_main$B = {
  name: "DisplayControlButton"
};
function _sfc_ssrRender$t(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<button${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-10ac7a85><h6 data-v-10ac7a85>`);
  serverRenderer.exports.ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
  _push(`</h6></button>`);
}
const _sfc_setup$B = _sfc_main$B.setup;
_sfc_main$B.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/DisplayControlButton.vue");
  return _sfc_setup$B ? _sfc_setup$B(props, ctx) : void 0;
};
const __nuxt_component_2$1 = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["ssrRender", _sfc_ssrRender$t], ["__scopeId", "data-v-10ac7a85"]]);
/*!
 * Chart.js v3.8.0
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
const requestAnimFrame = function() {
  {
    return function(callback2) {
      return callback2();
    };
  }
}();
function debounce$2(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function noop$3() {
}
const uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject$1(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys2;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject$1(loopable)) {
    keys2 = Object.keys(loopable);
    len = keys2.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys2[i]], keys2[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source2) {
  if (isArray(source2)) {
    return source2.map(clone$1);
  }
  if (isObject$1(source2)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(source2);
    const klen = keys2.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys2[k]] = clone$1(source2[keys2[k]]);
    }
    return target;
  }
  return source2;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source2, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source2[key];
  if (isObject$1(tval) && isObject$1(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source2, options) {
  const sources = isArray(source2) ? source2 : [source2];
  const ilen = sources.length;
  if (!isObject$1(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source2 = sources[i];
    if (!isObject$1(source2)) {
      continue;
    }
    const keys2 = Object.keys(source2);
    for (let k = 0, klen = keys2.length; k < klen; ++k) {
      merger(keys2[k], target, source2, options);
    }
  }
  return target;
}
function mergeIf(target, source2) {
  return merge(target, source2, { merger: _mergerIf });
}
function _mergerIf(key, target, source2) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source2[key];
  if (isObject$1(tval) && isObject$1(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
const emptyString = "";
const dot = ".";
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.slice(pos, idx)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== "undefined";
const isFunction = (value) => typeof value === "function";
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range3) {
  const roundedRange = Math.round(range3);
  range3 = almostEquals(range3, roundedRange, range3 / 1e3) ? roundedRange : range3;
  const niceRange = Math.pow(10, Math.floor(log10(range3)));
  const fraction = range3 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
function round(v2) {
  return v2 + 0.5 | 0;
}
const lim = (v2, l, h3) => Math.max(Math.min(v2, h3), l);
function p2b(v2) {
  return lim(round(v2 * 2.55), 0, 255);
}
function n2b(v2) {
  return lim(round(v2 * 255), 0, 255);
}
function b2n(v2) {
  return lim(round(v2 / 2.55) / 100, 0, 1);
}
function n2p(v2) {
  return lim(round(v2 * 100), 0, 100);
}
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = [..."0123456789ABCDEF"];
const h1 = (b) => hex[b & 15];
const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
const eq = (b) => (b & 240) >> 4 === (b & 15);
const isShort = (v2) => eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v2) {
  var f = isShort(v2) ? h1 : h2;
  return v2 ? "#" + f(v2.r) + f(v2.g) + f(v2.b) + alpha(v2.a, f) : void 0;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h3, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h3, s, v2) {
  const f = (n, k = (n + h3 / 60) % 6) => v2 - v2 * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h3, w, b) {
  const rgb = hsl2rgbn(h3, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v2) {
  const range3 = 255;
  const r = v2.r / range3;
  const g = v2.g / range3;
  const b = v2.b / range3;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h3, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h3 = hueValue(r, g, b, d, max);
    h3 = h3 * 60 + 0.5;
  }
  return [h3 | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h3, s, l) {
  return calln(hsl2rgbn, h3, s, l);
}
function hwb2rgb(h3, w, b) {
  return calln(hwb2rgbn, h3, w, b);
}
function hsv2rgb(h3, s, v2) {
  return calln(hsv2rgbn, h3, s, v2);
}
function hue(h3) {
  return (h3 % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v2;
  if (!m) {
    return;
  }
  if (m[5] !== v2) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h3 = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v2 = hwb2rgb(h3, p1, p2);
  } else if (m[1] === "hsv") {
    v2 = hsv2rgb(h3, p1, p2);
  } else {
    v2 = hsl2rgb(h3, p1, p2);
  }
  return {
    r: v2[0],
    g: v2[1],
    b: v2[2],
    a
  };
}
function rotate(v2, deg) {
  var h3 = rgb2hsl(v2);
  h3[0] = hue(h3[0] + deg);
  h3 = hsl2rgb(h3);
  v2.r = h3[0];
  v2.g = h3[1];
  v2.b = h3[2];
}
function hslString(v2) {
  if (!v2) {
    return;
  }
  const a = rgb2hsl(v2);
  const h3 = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v2.a < 255 ? `hsla(${h3}, ${s}%, ${l}%, ${b2n(v2.a)})` : `hsl(${h3}, ${s}%, ${l}%)`;
}
const map$2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys2 = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys2.length; i++) {
    ok = nk = keys2[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v2 = +m[7];
    a = m[8] ? p2b(v2) : lim(v2 * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v2) {
  return v2 && (v2.a < 255 ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})` : `rgb(${v2.r}, ${v2.g}, ${v2.b})`);
}
const to = (v2) => v2 <= 31308e-7 ? v2 * 12.92 : Math.pow(v2, 1 / 2.4) * 1.055 - 0.055;
const from = (v2) => v2 <= 0.04045 ? v2 / 12.92 : Math.pow((v2 + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v2, i, ratio) {
  if (v2) {
    let tmp = rgb2hsl(v2);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v2.r = tmp[0];
    v2.g = tmp[1];
    v2.b = tmp[2];
  }
}
function clone(v2, proto) {
  return v2 ? Object.assign(proto || {}, v2) : v2;
}
function fromObject(input) {
  var v2 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v2.a = n2b(input[3]);
      }
    }
  } else {
    v2 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v2.a = n2b(v2.a);
  }
  return v2;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v2;
    if (type === "object") {
      v2 = fromObject(input);
    } else if (type === "string") {
      v2 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v2;
    this._valid = !!v2;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v2 = clone(this._rgb);
    if (v2) {
      v2.a = b2n(v2.a);
    }
    return v2;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v2 = this._rgb;
    v2.r = 255 - v2.r;
    v2.g = 255 - v2.g;
    v2.b = 255 - v2.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
function index_esm(input) {
  return new Color(input);
}
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node2, key) {
  if (!key) {
    return node2;
  }
  const keys2 = key.split(".");
  for (let i = 0, n = keys2.length; i < n; ++i) {
    const k = keys2[i];
    node2 = node2[k] || (node2[k] = /* @__PURE__ */ Object.create(null));
  }
  return node2;
}
function set(root2, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root2, scope), values);
  }
  return merge(getScope$1(root2, ""), scope);
}
class Defaults {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject$1(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
}
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string2) {
  let textWidth = data[string2];
  if (!textWidth) {
    textWidth = data[string2] = ctx.measureText(string2).width;
    gc.push(string2);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache2) {
  cache2 = cache2 || {};
  let data = cache2.data = cache2.data || {};
  let gc = cache2.garbageCollect = cache2.garbageCollect || [];
  if (cache2.font !== font) {
    data = cache2.data = {};
    gc = cache2.garbageCollect = [];
    cache2.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      ctx.arc(x, y, radius, 0, TAU);
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        ctx.rect(x - size, y - size, 2 * size, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h: h3, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h3 - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h3);
  ctx.arc(x + w - radius.bottomRight, y + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
const numberOrZero = (v2) => +v2 || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject$1(props);
  const keys2 = objProps ? Object.keys(props) : props;
  const read = isObject$1(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys2) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
const _lookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] < value);
const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners2 = stub.listeners;
  const index2 = listeners2.indexOf(listener);
  if (index2 !== -1) {
    listeners2.splice(index2, 1);
  }
  if (listeners2.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = /* @__PURE__ */ new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache2 = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache2, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache2 = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache2, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject$1(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject$1(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject$1(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys2 = target._keys;
  if (!keys2) {
    keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys2;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta2, data, start, count) {
  const { iScale } = meta2;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
const getComputedStyle$1 = (element) => window.getComputedStyle(element, null);
const positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source2 = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source2;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source2.clientX - rect.left;
    y = source2.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  if ("native" in evt) {
    return evt;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle$1(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
(function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
})();
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}
/*!
 * Chart.js v3.8.0
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
class Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date2, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date2 - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date2 = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date2);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date2, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date2, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date2;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
    const from2 = resolve([cfg.from, currentValue, to2]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date2) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date2 - this._start;
      const remain = this._duration - elapsed;
      this._start = date2;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to2]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date2) {
    const elapsed = date2 - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
const numbers = ["x", "y", "borderWidth", "radius", "tension"];
const colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
const animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v2) => v2 | 0
      }
    }
  }
});
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject$1(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject$1(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date2 = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date2);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys2 = Object.keys(properties);
  for (let i = 0; i < keys2.length; i++) {
    const anim = animations[keys2[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject$1(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys2 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys2.push(metasets[i].index);
  }
  return keys2;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys2 = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    datasetIndex = +keys2[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys2 = Object.keys(data);
  const adata = new Array(keys2.length);
  let i, ilen, key;
  for (i = 0, ilen = keys2.length; i < ilen; ++i) {
    key = keys2[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta2) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta2.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta2) {
  return `${indexScale.id}.${valueScale.id}.${meta2.stack || meta2.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta2 of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta2.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta2.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta2 } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta2;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta2);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta2.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta2.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta2, items) {
  const datasetIndex = meta2.controller.index;
  const axis = meta2.vScale && meta2.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta2._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta2, chart) => canStack && !meta2.hidden && meta2._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta2 = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta2._stacked = isStacked(meta2.vScale, meta2);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta2.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta2.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta2.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta2.indexAxis;
    const iid = meta2.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta2.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta2.xScale = this.getScaleForId(xid);
    meta2.yScale = this.getScaleForId(yid);
    meta2.rScale = this.getScaleForId(rid);
    meta2.iScale = this.getScaleForId(iid);
    meta2.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta2 = this._cachedMeta;
    return scale === meta2.iScale ? meta2.vScale : meta2.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta2 = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta2._stacked) {
      clearStacks(meta2);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject$1(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta2 = this._cachedMeta;
        clearStacks(meta2);
        meta2._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta2 = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta2.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta2 = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta2._stacked;
    meta2._stacked = isStacked(meta2.vScale, meta2);
    if (meta2.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta2);
      meta2.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta2._stacked) {
      updateStacks(this, meta2._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta2, _data: data } = this;
    const { iScale, _stacked } = meta2;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta2._sorted;
    let prev = start > 0 && meta2._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta2._parsed = data;
      meta2._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta2, data, start, count);
      } else if (isObject$1(data[start])) {
        parsed = this.parseObjectData(meta2, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta2, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta2._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta2._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta2, data, start, count) {
    const { iScale, vScale } = meta2;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta2, data, start, count) {
    const { xScale, yScale } = meta2;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta2, data, start, count) {
    const { xScale, yScale } = meta2;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta2.index, { mode });
  }
  updateRangeFromParsed(range3, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range3.min = Math.min(range3.min, value);
    range3.max = Math.max(range3.max, value);
  }
  getMinMax(scale, canStack) {
    const meta2 = this._cachedMeta;
    const _parsed = meta2._parsed;
    const sorted = meta2._sorted && scale === meta2.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta2, this.chart);
    const range3 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range3, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range3, scale, parsed, stack);
        break;
      }
    }
    return range3;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const iScale = meta2.iScale;
    const vScale = meta2.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta2 = this._cachedMeta;
    this.update(mode || "default");
    meta2._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta2.xScale, meta2.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta2 = this._cachedMeta;
    const elements2 = meta2.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta2.dataset) {
      meta2.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache2 = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache2[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache2 = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache2[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache2[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta2 = this._cachedMeta;
    const data = meta2.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta2._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta2 = this._cachedMeta;
    if (this._parsing) {
      const removed = meta2._parsed.splice(start, count);
      if (meta2._stacked) {
        clearStacks(meta2, removed);
      }
    }
    meta2.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta2) {
  const scale = meta2.iScale;
  const values = getAllScaleValues(scale, meta2.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry2, item, vScale, i) {
  const startValue = vScale.parse(entry2[0], i);
  const endValue = vScale.parse(entry2[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry2, item, vScale, i) {
  if (isArray(entry2)) {
    parseFloatBar(entry2, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry2, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta2, data, start, count) {
  const iScale = meta2.iScale;
  const vScale = meta2.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry2;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry2 = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry2, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v2, start, end) {
  return v2 === "start" ? start : v2 === "end" ? end : v2;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta2, data, start, count) {
    return parseArrayOrPrimitive(meta2, data, start, count);
  }
  parseArrayData(meta2, data, start, count) {
    return parseArrayOrPrimitive(meta2, data, start, count);
  }
  parseObjectData(meta2, data, start, count) {
    const { iScale, vScale } = meta2;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range3, scale, parsed, stack) {
    super.updateRangeFromParsed(range3, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range3.min = Math.min(range3.min, custom.min);
      range3.max = Math.max(range3.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const { iScale, vScale } = meta2;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta2 = this._cachedMeta;
    meta2.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    this.updateElements(meta2.data, 0, meta2.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta2 = this._cachedMeta;
    const iScale = meta2.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== "undefined") {
        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta2 = this._cachedMeta;
    const iScale = meta2.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta2.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta2);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range3 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range3.start + range3.chunk * stackIndex + range3.chunk / 2;
      size = Math.min(maxBarThickness, range3.chunk * range3.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta2 = this._cachedMeta;
    const vScale = meta2.vScale;
    const rects = meta2.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta2, data, start, count) {
    const parsed = super.parsePrimitiveData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta2, data, start, count) {
    const parsed = super.parseArrayData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta2, data, start, count) {
    const parsed = super.parseObjectData(meta2, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const { xScale, yScale } = meta2;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta2.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta2 = this._cachedMeta;
    if (this._parsing === false) {
      meta2._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject$1(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta2._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta2 = this._cachedMeta;
    const arcs = meta2.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta2.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta2 = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta2._parsed[i] === null || meta2.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta2._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta2 = this._cachedMeta;
    const metaData = meta2.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta2._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta2._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta2, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta2 = chart.getDatasetMeta(i);
          arcs = meta2.data;
          controller = meta2.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta2 = chart.getDatasetMeta(0);
              const style = meta2.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta2;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta2)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta2 = this._cachedMeta;
    const dataset = meta2.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta2.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta2 = this._cachedMeta;
    meta2.dataset.updateControlPoints(this.chart.chartArea, meta2.iScale.axis);
    super.draw();
  }
}
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
function getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta2._sorted) {
    const { iScale, _parsed } = meta2;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function scaleRangesChanged(meta2) {
  const { xScale, yScale, _scaleRanges } = meta2;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta2._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta2 = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta2._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta2, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta2, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta2 = this._cachedMeta;
    const range3 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    meta2.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range3.min) {
          range3.min = parsed;
        }
        if (parsed > range3.max) {
          range3.max = parsed;
        }
      }
    });
    return range3;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta2 = this._cachedMeta;
    let count = 0;
    meta2.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
}
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta2 = chart.getDatasetMeta(0);
              const style = meta2.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
class PieController extends DoughnutController {
}
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
class RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta2, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta2, data, start, count);
  }
  update(mode) {
    const meta2 = this._cachedMeta;
    const line = meta2.dataset;
    const points = meta2.data || [];
    const labels = meta2.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
class ScatterController extends LineController {
}
ScatterController.id = "scatter";
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format2) {
    return abstract();
  }
  format(timestamp, format2) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range3 = typeof el.getRange === "function" && el.getRange(axis);
      if (range3) {
        const start = lookupMethod(data, axis, value - range3);
        const end = lookupMethod(data, axis, value + range3);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index: index2 }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta2) => {
        const index2 = items[0].index;
        const element = meta2.data[index2];
        if (element && !element.skip) {
          elements2.push({ element, datasetIndex: meta2.index, index: index2 });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v2) => v2.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject$1(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
class BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
function _detectPlatform(canvas) {
  {
    return BasicPlatform;
  }
}
class Element {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
Element.defaults = {};
Element.defaultRoutes = void 0;
const formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache2) => {
    const gc = cache2.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache2.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject$1(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject$1(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range3;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range3 = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range3.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range3.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache2, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache2 = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache2.data, cache2.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache2.data, cache2.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject$1(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject$1(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta2 = metas[i];
      if (meta2[axisID] === this.id && (!type || meta2.type === type)) {
        result.push(meta2);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes2) {
  Object.keys(routes2).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes2[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
}
var registry = new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all2) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all2 ? [] : createDescriptors(chart, plugins2, options, all2);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config) {
  const plugins2 = [];
  const keys2 = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys2.length; i++) {
    plugins2.push(registry.getPlugin(keys2[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
    }
  }
  return plugins2;
}
function getOpts(options, all2) {
  if (!all2 && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins2, options, all2) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins2.length; i++) {
    const plugin = plugins2[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all2);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys2 = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys2);
  return config.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = /* @__PURE__ */ Object.create(null);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject$1(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys2 = keyCache.get(cacheKey);
  if (!keys2) {
    keys2 = generate();
    keyCache.set(cacheKey, keys2);
    keysCached.add(keys2);
  }
  return keys2;
}
const addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[
      `plugins.${id}`,
      ...plugin.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache2 = _scopeCache.get(mainScope);
    if (!cache2 || resetCache) {
      cache2 = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache2);
    }
    return cache2;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache2 = this._cachedScopes(mainScope, resetCache);
    const cached = cache2.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys2) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys2.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys2.forEach((key) => addIfFound(scopes, options, key));
      keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys2.forEach((key) => addIfFound(scopes, defaults, key));
      keys2.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache2.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject$1(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache2 = resolverCache.get(scopes);
  if (!cache2) {
    cache2 = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache2);
  }
  const cacheKey = prefixes.join();
  let cached = cache2.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache2.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value) => isObject$1(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.8.0";
const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys2 = Object.keys(obj);
  for (const key of keys2) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
class Chart {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform())();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce$2((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta2, index2) => {
      if (datasets.filter((x) => x === meta2._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta2 = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta2.type && meta2.type !== type) {
        this._destroyDatasetMeta(i);
        meta2 = this.getDatasetMeta(i);
      }
      meta2.type = type;
      meta2.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta2.order = dataset.order || 0;
      meta2.index = i;
      meta2.label = "" + dataset.label;
      meta2.visible = this.isDatasetVisible(i);
      if (meta2.controller) {
        meta2.controller.updateIndex(i);
        meta2.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta2.controller = new ControllerClass(this, i);
        newControllers.push(meta2.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index2, mode) {
    const meta2 = this.getDatasetMeta(index2);
    const args = { meta: meta2, index: index2, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta2.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta2 = metasets[i];
      if (!filterVisible || meta2.visible) {
        result.push(meta2);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta2) {
    const ctx = this.ctx;
    const clip = meta2._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta: meta2,
      index: meta2.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta2.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta2 = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta2) {
      meta2 = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta2);
    }
    return meta2;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta2 = this.getDatasetMeta(datasetIndex);
    return typeof meta2.hidden === "boolean" ? !meta2.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta2 = this.getDatasetMeta(datasetIndex);
    meta2.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta2 = this.getDatasetMeta(datasetIndex);
    const anims = meta2.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta2.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta2, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta2 = this._metasets[datasetIndex];
    if (meta2 && meta2.controller) {
      meta2.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners2 = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners2[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners2 = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners2[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners2[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners2[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta2, item, i, ilen;
    if (mode === "dataset") {
      meta2 = this.getDatasetMeta(items[0].datasetIndex);
      meta2.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta2 = this.getDatasetMeta(datasetIndex);
      if (!meta2) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta2.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.stroke();
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
}
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path2 = line._path;
  if (!path2) {
    path2 = line._path = new Path2D();
    if (line.path(path2, start, count)) {
      path2.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path2);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject$1(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h3,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
}
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta2, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta2;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta2 = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
        return;
      }
      if (!meta2.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta2.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta2, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _resolveTarget(sources, index2, propagate) {
  const source2 = sources[index2];
  let fill2 = source2.fill;
  const visited = [index2];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject$1(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject$1(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject$1(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source2) {
  const { scale, index: index2, line } = source2;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta2 = metas[i];
    if (meta2.index === index2) {
      break;
    }
    if (!meta2.hidden) {
      below.unshift(meta2.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function _getTarget(source2) {
  const { chart, fill: fill2, line } = source2;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source2);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source2);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta2 = chart.getDatasetMeta(index2);
  const visible = meta2 && chart.isDatasetVisible(index2);
  return visible ? meta2.dataset : null;
}
function computeBoundary(source2) {
  const scale = source2.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source2);
  }
  return computeLinearBoundary(source2);
}
function computeLinearBoundary(source2) {
  const { scale = {}, fill: fill2 } = source2;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source2) {
  const { scale, fill: fill2 } = source2;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source2, area) {
  const target = _getTarget(source2);
  const { line, scale, axis } = source2;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src2, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src2;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src2);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index$m = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta2, i, line, source2;
    for (i = 0; i < count; ++i) {
      meta2 = chart.getDatasetMeta(i);
      line = meta2.dataset;
      source2 = null;
      if (line && line.options && line instanceof LineElement) {
        source2 = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta2.controller.options.indexAxis,
          scale: meta2.vScale,
          line
        };
      }
      meta2.$filler = source2;
      sources.push(source2);
    }
    for (i = 0; i < count; ++i) {
      source2 = sources[i];
      if (!source2 || source2.fill === false) {
        continue;
      }
      source2.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source2 = metasets[i].$filler;
      if (!source2) {
        continue;
      }
      source2.line.updateControlPoints(area, source2.axis);
      if (draw2) {
        _drawfill(chart.ctx, source2, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source2 = metasets[i].$filler;
      if (source2) {
        _drawfill(chart.ctx, source2, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source2 = args.meta.$filler;
    if (!source2 || source2.fill === false || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source2, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta2) => {
          const style = meta2.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta2.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta2.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta2.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta2 = this.chart.getDatasetMeta(datasetIndex);
      if (!meta2) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta2.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop$3,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop$3,
      beforeBody: noop$3,
      beforeLabel: noop$3,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta2.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta2.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop$3,
      afterBody: noop$3,
      beforeFooter: noop$3,
      footer: noop$3,
      afterFooter: noop$3
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: index$m,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({ index: index2, label: raw });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v2) => min = minDefined ? min : v2;
    const setMax = (v2) => max = maxDefined ? max : v2;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v2) => min = minDefined ? min : v2;
    const setMax = (v2) => max = maxDefined ? max : v2;
    const exp = (v2, m) => Math.pow(10, Math.floor(log10(v2)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h3, angle) {
  if (angle === 90 || angle === 270) {
    y -= h3 / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h3;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h3 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h3) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [value, index2], this);
      return label || label === 0 ? label : "";
    }).filter((v2, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
}
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
const INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
const UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map2[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index2, ticks, format2) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index2, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format2);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
const registerables = [
  controllers,
  elements,
  plugins$1,
  scales
];
Chart.register(...registerables);
const _sfc_main$A = {
  name: "TwitterUserCard",
  components: {
    Card: __nuxt_component_2$4,
    ScatterChart
  },
  props: {
    user: Object
  },
  data() {
    return {
      activeDataset: "followers",
      mode: "raw"
    };
  },
  methods: {
    formatNumber(number2) {
      return Intl.NumberFormat("en-NZ").format(number2);
    }
  },
  computed: {
    formattedDate() {
      return format(parse$2(this.bill.date_modified, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    },
    displayedDataset() {
      if (this.activeDataset === "followers") {
        return this.followersDataset;
      } else if (this.activeDataset === "following") {
        return this.followingDataset;
      } else if (this.activeDataset === "tweets") {
        return this.tweetsDataset;
      } else {
        return null;
      }
    },
    dailyNumberChange() {
      var data = this.displayedDataset.data;
      var newData = [];
      var lastTimestamp = data[0].x;
      var lastValue = data[0].y;
      data.forEach((datum) => {
        if (datum.x - 432e5 > lastTimestamp) {
          var change = datum.y - lastValue;
          var timeDelta = datum.x - lastTimestamp;
          var dailyChange = 864e5 * change / timeDelta;
          newData.push({
            x: datum.x,
            y: dailyChange
          });
          lastValue = datum.y;
          lastTimestamp = datum.x;
        }
      });
      var dataset = {
        label: this.displayedDataset.label + " - Numeric daily change",
        borderColor: "#58787f",
        fill: false,
        showLine: true,
        data: newData
      };
      return dataset;
    },
    dailyPercentChange() {
      var data = this.displayedDataset.data;
      var newData = [];
      var lastTimestamp = data[0].x;
      var lastValue = data[0].y;
      data.forEach((datum) => {
        if (datum.x - 432e5 > lastTimestamp) {
          var change = datum.y - lastValue;
          var timeDelta = datum.x - lastTimestamp;
          var dailyChange = 864e5 * change / timeDelta;
          newData.push({
            x: datum.x,
            y: dailyChange / lastValue * 100
          });
          lastValue = datum.y;
          lastTimestamp = datum.x;
        }
      });
      var dataset = {
        label: this.displayedDataset.label + " - Percentage daily change",
        borderColor: "#58787f",
        fill: false,
        showLine: true,
        data: newData
      };
      return dataset;
    },
    chartData() {
      if (this.mode === "percent_change") {
        return {
          datasets: [
            this.dailyPercentChange
          ]
        };
      } else if (this.mode === "number_change") {
        return {
          datasets: [
            this.dailyNumberChange
          ]
        };
      } else {
        return {
          datasets: [
            this.displayedDataset
          ]
        };
      }
    },
    chartOptions() {
      return {
        scales: {
          x: {
            ticks: {
              callback: function(label, index2, labels) {
                return label;
              }
            }
          }
        },
        elements: {
          point: {
            radius: 2
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                var label = ["", ""];
                if (context.parsed.y !== null) {
                  label[0] = Intl.NumberFormat("en-NZ").format(context.parsed.y);
                }
                if (context.parsed.x !== null) {
                  label[1] = context.parsed.x;
                }
                return label;
              }
            }
          },
          legend: {
            display: false
          }
        }
      };
    },
    followersDataset() {
      var data = [];
      this.user.time_series.forEach((x) => {
        data.push({
          x: Date.parse(x.timestamp),
          y: x.followers_count
        });
      });
      var dataset = {
        label: "Followers",
        borderColor: "#58787f",
        fill: false,
        showLine: true,
        data
      };
      return dataset;
    },
    followingDataset() {
      var data = [];
      this.user.time_series.forEach((x) => {
        data.push({
          x: Date.parse(x.timestamp),
          y: x.following_count
        });
      });
      var dataset = {
        label: "Following",
        borderColor: "#58787f",
        fill: false,
        showLine: true,
        data
      };
      return dataset;
    },
    tweetsDataset() {
      var data = [];
      this.user.time_series.forEach((x) => {
        data.push({
          x: Date.parse(x.timestamp),
          y: x.tweet_count
        });
      });
      var dataset = {
        label: "Tweets",
        borderColor: "#58787f",
        fill: false,
        showLine: true,
        data
      };
      return dataset;
    }
  }
};
function _sfc_ssrRender$s(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  const _component_ScatterChart = vue_cjs_prod.resolveComponent("ScatterChart");
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, _attrs, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h5${_scopeId}>Twitter account</h5><a${serverRenderer.exports.ssrRenderAttr("href", $props.user.profile_url)} target="_blank"${_scopeId}><h6${_scopeId}>`);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, { icon: ["fab", "twitter"] }, null, _parent2, _scopeId));
        _push2(` @${serverRenderer.exports.ssrInterpolate($props.user.username)}</h6></a><hr${_scopeId}><div class="row"${_scopeId}><div class="col-4 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatNumber($props.user.followers_count))}</h3><h6 class="text-muted text-uppercase"${_scopeId}>Followers</h6></div><div class="col-4 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatNumber($props.user.following_count))}</h3><h6 class="text-muted text-uppercase"${_scopeId}>Following</h6></div><div class="col-4 text-center"${_scopeId}><h3${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatNumber($props.user.tweet_count))}</h3><h6 class="text-muted text-uppercase"${_scopeId}>Tweets</h6></div></div><hr${_scopeId}><h6${_scopeId}>Chart settings</h6><div class="row"${_scopeId}><div class="col-12 col-md-6"${_scopeId}><select class="form-select col-12 mb-3" aria-label="Twitter metric type"${_scopeId}><option selected value="followers"${_scopeId}>Followers</option><option value="following"${_scopeId}>Following</option><option value="tweets"${_scopeId}>Tweets</option></select></div><div class="col-12 col-md-6 mb-3"${_scopeId}><select class="form-select col-12" aria-label="Twitter graph type"${_scopeId}><option selected value="raw"${_scopeId}>Raw counts</option><option value="percent_change"${_scopeId}>Percentage daily change</option><option value="number_change"${_scopeId}>Numeric daily change</option></select></div></div>`);
        if ($props.user.time_series.length) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_ScatterChart, {
            chartData: $options.chartData,
            options: $options.chartOptions
          }, null, _parent2, _scopeId));
        } else {
          _push2(`<!---->`);
        }
        if ($data.mode === "number_change") {
          _push2(`<p class="text-muted"${_scopeId}>Since measurements cannot be taken at exactly the same time each day, you may find that daily changes do not show as whole numbers; this is because they are calculated based on the growth over the actual interval between measurements.</p>`);
        } else {
          _push2(`<!---->`);
        }
      } else {
        return [
          vue_cjs_prod.createVNode("h5", null, "Twitter account"),
          vue_cjs_prod.createVNode("a", {
            href: $props.user.profile_url,
            target: "_blank"
          }, [
            vue_cjs_prod.createVNode("h6", null, [
              vue_cjs_prod.createVNode(_component_font_awesome_icon, { icon: ["fab", "twitter"] }),
              vue_cjs_prod.createTextVNode(" @" + vue_cjs_prod.toDisplayString($props.user.username), 1)
            ])
          ], 8, ["href"]),
          vue_cjs_prod.createVNode("hr"),
          vue_cjs_prod.createVNode("div", { class: "row" }, [
            vue_cjs_prod.createVNode("div", { class: "col-4 text-center" }, [
              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($options.formatNumber($props.user.followers_count)), 1),
              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, "Followers")
            ]),
            vue_cjs_prod.createVNode("div", { class: "col-4 text-center" }, [
              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($options.formatNumber($props.user.following_count)), 1),
              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, "Following")
            ]),
            vue_cjs_prod.createVNode("div", { class: "col-4 text-center" }, [
              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($options.formatNumber($props.user.tweet_count)), 1),
              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, "Tweets")
            ])
          ]),
          vue_cjs_prod.createVNode("hr"),
          vue_cjs_prod.createVNode("h6", null, "Chart settings"),
          vue_cjs_prod.createVNode("div", { class: "row" }, [
            vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6" }, [
              vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                class: "form-select col-12 mb-3",
                "aria-label": "Twitter metric type",
                "onUpdate:modelValue": ($event) => $data.activeDataset = $event
              }, [
                vue_cjs_prod.createVNode("option", {
                  selected: "",
                  value: "followers"
                }, "Followers"),
                vue_cjs_prod.createVNode("option", { value: "following" }, "Following"),
                vue_cjs_prod.createVNode("option", { value: "tweets" }, "Tweets")
              ], 8, ["onUpdate:modelValue"]), [
                [vue_cjs_prod.vModelSelect, $data.activeDataset]
              ])
            ]),
            vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6 mb-3" }, [
              vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                class: "form-select col-12",
                "aria-label": "Twitter graph type",
                "onUpdate:modelValue": ($event) => $data.mode = $event
              }, [
                vue_cjs_prod.createVNode("option", {
                  selected: "",
                  value: "raw"
                }, "Raw counts"),
                vue_cjs_prod.createVNode("option", { value: "percent_change" }, "Percentage daily change"),
                vue_cjs_prod.createVNode("option", { value: "number_change" }, "Numeric daily change")
              ], 8, ["onUpdate:modelValue"]), [
                [vue_cjs_prod.vModelSelect, $data.mode]
              ])
            ])
          ]),
          $props.user.time_series.length ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ScatterChart, {
            key: 0,
            chartData: $options.chartData,
            options: $options.chartOptions
          }, null, 8, ["chartData", "options"])) : vue_cjs_prod.createCommentVNode("", true),
          $data.mode === "number_change" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", {
            key: 1,
            class: "text-muted"
          }, "Since measurements cannot be taken at exactly the same time each day, you may find that daily changes do not show as whole numbers; this is because they are calculated based on the growth over the actual interval between measurements.")) : vue_cjs_prod.createCommentVNode("", true)
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$A = _sfc_main$A.setup;
_sfc_main$A.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/TwitterUserCard.vue");
  return _sfc_setup$A ? _sfc_setup$A(props, ctx) : void 0;
};
const __nuxt_component_4 = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["ssrRender", _sfc_ssrRender$s]]);
const _sfc_main$z = {
  name: "SocialMediaLink",
  components: {
    ExternalLinkButton: __nuxt_component_0$2
  },
  props: {
    username: String,
    platform: {
      validator: function(value) {
        return ["snapchat", "wikipedia", "facebook", "instagram"].indexOf(value) !== -1;
      }
    }
  },
  computed: {
    iconName() {
      switch (this.platform) {
        case "snapchat":
          return "snapchat";
        case "wikipedia":
          return "wikipedia-w";
        case "instagram":
          return "instagram";
        case "facebook":
          return "facebook";
        case "twitter":
          return "twitter";
        default:
          return "";
      }
    },
    prefix() {
      switch (this.platform) {
        case "snapchat":
          return "";
        case "wikipedia":
          return "";
        case "instagram":
          return "@";
        case "facebook":
          return "";
        case "twitter":
          return "@";
        default:
          return "";
      }
    },
    link() {
      switch (this.platform) {
        case "snapchat":
          return "https://www.snapchat.com/add/" + this.username;
        case "wikipedia":
          return "https://en.wikipedia.org/wiki/" + this.username;
        case "instagram":
          return "https://www.instagram.com/" + this.username;
        case "facebook":
          return "https://www.facebook.com/" + this.username;
        case "twitter":
          return "https://twitter.com/" + this.username;
        default:
          return "";
      }
    }
  }
};
function _sfc_ssrRender$r(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_external_link_button = __nuxt_component_0$2;
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  _push(serverRenderer.exports.ssrRenderComponent(_component_external_link_button, vue_cjs_prod.mergeProps({ link: $options.link }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
          icon: ["fab", $options.iconName]
        }, null, _parent2, _scopeId));
        _push2(` ${serverRenderer.exports.ssrInterpolate($options.prefix)}${serverRenderer.exports.ssrInterpolate($props.username)}`);
      } else {
        return [
          vue_cjs_prod.createVNode(_component_font_awesome_icon, {
            icon: ["fab", $options.iconName]
          }, null, 8, ["icon"]),
          vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.prefix) + vue_cjs_prod.toDisplayString($props.username), 1)
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$z = _sfc_main$z.setup;
_sfc_main$z.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/SocialMediaLink.vue");
  return _sfc_setup$z ? _sfc_setup$z(props, ctx) : void 0;
};
const __nuxt_component_5$1 = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["ssrRender", _sfc_ssrRender$r]]);
const meta$7 = void 0;
const _sfc_main$y = {
  name: "Grid",
  props: {
    columns: {
      type: Array
    },
    rows: {
      type: Array
    }
  }
};
function _sfc_ssrRender$q(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<table${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "table table-striped table-bordered table-responsive-sm" }, _attrs))}><thead><tr><!--[-->`);
  serverRenderer.exports.ssrRenderList($props.columns, (column, i) => {
    _push(`<th scope="col">${serverRenderer.exports.ssrInterpolate(column)}</th>`);
  });
  _push(`<!--]--></tr></thead><tbody><!--[-->`);
  serverRenderer.exports.ssrRenderList($props.rows, (row, i) => {
    _push(`<tr><!--[-->`);
    serverRenderer.exports.ssrRenderList(row, (data, j) => {
      _push(`<td>${serverRenderer.exports.ssrInterpolate(data)}</td>`);
    });
    _push(`<!--]--></tr>`);
  });
  _push(`<!--]--></tbody></table>`);
}
const _sfc_setup$y = _sfc_main$y.setup;
_sfc_main$y.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Grid.vue");
  return _sfc_setup$y ? _sfc_setup$y(props, ctx) : void 0;
};
const __nuxt_component_3$2 = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["ssrRender", _sfc_ssrRender$q]]);
const meta$6 = void 0;
const _sfc_main$x = {
  name: "PersonPersonalVote",
  components: {
    Card: __nuxt_component_2$4
  },
  props: {
    record: Object
  },
  methods: {
    dateFormat(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    },
    readingName(reading) {
      return {
        1: "1st reading",
        2: "2nd reading",
        3: "3rd reading"
      }[reading];
    }
  }
};
function _sfc_ssrRender$p(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, _attrs, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
          class: "router-link",
          to: "/bills/" + $props.record.bill.id
        }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`<h5 data-v-1611cb2e${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.record.bill.name)}</h5><div class="row" data-v-1611cb2e${_scopeId2}><!--[-->`);
              serverRenderer.exports.ssrRenderList($props.record.votes, (vote, reading) => {
                _push3(`<div class="col-4 text-center" data-v-1611cb2e${_scopeId2}>`);
                if (vote.position) {
                  _push3(`<div data-v-1611cb2e${_scopeId2}><span class="vote-info" data-v-1611cb2e${_scopeId2}>${serverRenderer.exports.ssrInterpolate($options.readingName(reading))}</span><br data-v-1611cb2e${_scopeId2}>`);
                  if (vote.position === "y") {
                    _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
                      title: "Supported",
                      class: "position-icon yes",
                      icon: ["fas", "check"]
                    }, null, _parent3, _scopeId2));
                  } else if (vote.position === "n") {
                    _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
                      title: "Opposed",
                      class: "position-icon no",
                      icon: ["fas", "times"]
                    }, null, _parent3, _scopeId2));
                  } else if (vote.position === "a") {
                    _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
                      title: "Abstained",
                      class: "position-icon abstain",
                      icon: ["fas", "map-signs"]
                    }, null, _parent3, _scopeId2));
                  } else if (vote.position === "x") {
                    _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
                      title: "Absent",
                      class: "position-icon absent",
                      icon: ["fas", "question"]
                    }, null, _parent3, _scopeId2));
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`<br data-v-1611cb2e${_scopeId2}><span class="vote-info text-muted" data-v-1611cb2e${_scopeId2}>${serverRenderer.exports.ssrInterpolate($options.dateFormat(vote.date))}</span></div>`);
                } else {
                  _push3(`<!---->`);
                }
                _push3(`</div>`);
              });
              _push3(`<!--]--></div>`);
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, vue_cjs_prod.toDisplayString($props.record.bill.name), 1),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($props.record.votes, (vote, reading) => {
                    return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                      class: "col-4 text-center",
                      key: reading
                    }, [
                      vote.position ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                        vue_cjs_prod.createVNode("span", { class: "vote-info" }, vue_cjs_prod.toDisplayString($options.readingName(reading)), 1),
                        vue_cjs_prod.createVNode("br"),
                        vote.position === "y" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                          key: 0,
                          title: "Supported",
                          class: "position-icon yes",
                          icon: ["fas", "check"]
                        })) : vote.position === "n" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                          key: 1,
                          title: "Opposed",
                          class: "position-icon no",
                          icon: ["fas", "times"]
                        })) : vote.position === "a" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                          key: 2,
                          title: "Abstained",
                          class: "position-icon abstain",
                          icon: ["fas", "map-signs"]
                        })) : vote.position === "x" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                          key: 3,
                          title: "Absent",
                          class: "position-icon absent",
                          icon: ["fas", "question"]
                        })) : vue_cjs_prod.createCommentVNode("", true),
                        vue_cjs_prod.createVNode("br"),
                        vue_cjs_prod.createVNode("span", { class: "vote-info text-muted" }, vue_cjs_prod.toDisplayString($options.dateFormat(vote.date)), 1)
                      ])) : vue_cjs_prod.createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_NuxtLink, {
            class: "router-link",
            to: "/bills/" + $props.record.bill.id
          }, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createVNode("h5", null, vue_cjs_prod.toDisplayString($props.record.bill.name), 1),
              vue_cjs_prod.createVNode("div", { class: "row" }, [
                (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($props.record.votes, (vote, reading) => {
                  return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                    class: "col-4 text-center",
                    key: reading
                  }, [
                    vote.position ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                      vue_cjs_prod.createVNode("span", { class: "vote-info" }, vue_cjs_prod.toDisplayString($options.readingName(reading)), 1),
                      vue_cjs_prod.createVNode("br"),
                      vote.position === "y" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                        key: 0,
                        title: "Supported",
                        class: "position-icon yes",
                        icon: ["fas", "check"]
                      })) : vote.position === "n" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                        key: 1,
                        title: "Opposed",
                        class: "position-icon no",
                        icon: ["fas", "times"]
                      })) : vote.position === "a" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                        key: 2,
                        title: "Abstained",
                        class: "position-icon abstain",
                        icon: ["fas", "map-signs"]
                      })) : vote.position === "x" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_FontAwesomeIcon, {
                        key: 3,
                        title: "Absent",
                        class: "position-icon absent",
                        icon: ["fas", "question"]
                      })) : vue_cjs_prod.createCommentVNode("", true),
                      vue_cjs_prod.createVNode("br"),
                      vue_cjs_prod.createVNode("span", { class: "vote-info text-muted" }, vue_cjs_prod.toDisplayString($options.dateFormat(vote.date)), 1)
                    ])) : vue_cjs_prod.createCommentVNode("", true)
                  ]);
                }), 128))
              ])
            ]),
            _: 1
          }, 8, ["to"])
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$x = _sfc_main$x.setup;
_sfc_main$x.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PersonPersonalVote.vue");
  return _sfc_setup$x ? _sfc_setup$x(props, ctx) : void 0;
};
const __nuxt_component_1$3 = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["ssrRender", _sfc_ssrRender$p], ["__scopeId", "data-v-1611cb2e"]]);
const _sfc_main$w = {
  name: "InlinePersonText",
  props: ["entity"]
};
function _sfc_ssrRender$o(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_router_link = vue_cjs_prod.resolveComponent("router-link");
  _push(serverRenderer.exports.ssrRenderComponent(_component_router_link, vue_cjs_prod.mergeProps({
    class: "link",
    to: "/people/" + $props.entity.slug
  }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<span class="inline-entity" data-v-519fa4d2${_scopeId}>`);
        if ($props.entity.colour) {
          _push2(`<span class="party-dot" style="${serverRenderer.exports.ssrRenderStyle({ backgroundColor: $props.entity.colour })}" data-v-519fa4d2${_scopeId}></span>`);
        } else {
          _push2(`<!---->`);
        }
        _push2(` ${serverRenderer.exports.ssrInterpolate($props.entity.display_name)}</span>`);
      } else {
        return [
          vue_cjs_prod.createVNode("span", { class: "inline-entity" }, [
            $props.entity.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
              key: 0,
              class: "party-dot",
              style: { backgroundColor: $props.entity.colour }
            }, null, 4)) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($props.entity.display_name), 1)
          ])
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$w = _sfc_main$w.setup;
_sfc_main$w.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/InlinePersonText.vue");
  return _sfc_setup$w ? _sfc_setup$w(props, ctx) : void 0;
};
const __nuxt_component_1$2 = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["ssrRender", _sfc_ssrRender$o], ["__scopeId", "data-v-519fa4d2"]]);
const _sfc_main$v = {
  name: "VotingSimilarityDisplay",
  components: {
    Card: __nuxt_component_2$4,
    InlinePersonText: __nuxt_component_1$2
  },
  props: {
    person: Object,
    similarityReport: Object
  }
};
function _sfc_ssrRender$n(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_inline_person_text = __nuxt_component_1$2;
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, vue_cjs_prod.mergeProps({ gradient: true }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h5${_scopeId}>${serverRenderer.exports.ssrInterpolate($props.person.display_name)} votes most similarly to:</h5><!--[-->`);
        serverRenderer.exports.ssrRenderList($props.similarityReport.people, (entity) => {
          _push2(`<span${_scopeId}>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_inline_person_text, {
            entity,
            class: "mr-2 mb-2"
          }, null, _parent2, _scopeId));
          _push2(`</span>`);
        });
        _push2(`<!--]--><p${_scopeId}>Voting similarity is based on the proportion of common voting positions in personal reading votes, with a minimum sample size of four votes.</p>`);
      } else {
        return [
          vue_cjs_prod.createVNode("h5", null, vue_cjs_prod.toDisplayString($props.person.display_name) + " votes most similarly to:", 1),
          (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($props.similarityReport.people, (entity) => {
            return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
              key: entity.slug
            }, [
              vue_cjs_prod.createVNode(_component_inline_person_text, {
                entity,
                class: "mr-2 mb-2"
              }, null, 8, ["entity"])
            ]);
          }), 128)),
          vue_cjs_prod.createVNode("p", null, "Voting similarity is based on the proportion of common voting positions in personal reading votes, with a minimum sample size of four votes.")
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$v = _sfc_main$v.setup;
_sfc_main$v.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/VotingSimilarityDisplay.vue");
  return _sfc_setup$v ? _sfc_setup$v(props, ctx) : void 0;
};
const __nuxt_component_3$1 = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["ssrRender", _sfc_ssrRender$n]]);
const _sfc_main$u = {
  name: "SmallBill",
  components: {
    Card: __nuxt_component_2$4
  },
  props: {
    bill: Object
  },
  computed: {
    relativeDate() {
      return formatDistanceToNow(parse$2(this.bill.date_modified, "yyyy-MM-dd", new Date())) + " ago";
    },
    formattedDate() {
      return format(parse$2(this.bill.date_modified, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    }
  }
};
function _sfc_ssrRender$m(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_Card = __nuxt_component_2$4;
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, vue_cjs_prod.mergeProps({
    class: "router-link",
    to: "/bills/" + $props.bill.id
  }, _attrs), {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`<h5 data-v-7916337c${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.bill.name)}</h5><p data-v-7916337c${_scopeId2}>${serverRenderer.exports.ssrInterpolate($props.bill.description)}</p>`);
              if ($props.bill.date_modified) {
                _push3(`<span${serverRenderer.exports.ssrRenderAttr("title", $options.formattedDate)} class="text-muted" data-v-7916337c${_scopeId2}>`);
                _push3(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, { icon: ["fas", "history"] }, null, _parent3, _scopeId2));
                _push3(` Last activity ${serverRenderer.exports.ssrInterpolate($options.relativeDate)}</span>`);
              } else {
                _push3(`<!---->`);
              }
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, vue_cjs_prod.toDisplayString($props.bill.name), 1),
                vue_cjs_prod.createVNode("p", null, vue_cjs_prod.toDisplayString($props.bill.description), 1),
                $props.bill.date_modified ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                  key: 0,
                  title: $options.formattedDate,
                  class: "text-muted"
                }, [
                  vue_cjs_prod.createVNode(_component_font_awesome_icon, { icon: ["fas", "history"] }),
                  vue_cjs_prod.createTextVNode(" Last activity " + vue_cjs_prod.toDisplayString($options.relativeDate), 1)
                ], 8, ["title"])) : vue_cjs_prod.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_Card, null, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createVNode("h5", null, vue_cjs_prod.toDisplayString($props.bill.name), 1),
              vue_cjs_prod.createVNode("p", null, vue_cjs_prod.toDisplayString($props.bill.description), 1),
              $props.bill.date_modified ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                key: 0,
                title: $options.formattedDate,
                class: "text-muted"
              }, [
                vue_cjs_prod.createVNode(_component_font_awesome_icon, { icon: ["fas", "history"] }),
                vue_cjs_prod.createTextVNode(" Last activity " + vue_cjs_prod.toDisplayString($options.relativeDate), 1)
              ], 8, ["title"])) : vue_cjs_prod.createCommentVNode("", true)
            ]),
            _: 1
          })
        ];
      }
    }),
    _: 1
  }, _parent));
}
const _sfc_setup$u = _sfc_main$u.setup;
_sfc_main$u.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/SmallBill.vue");
  return _sfc_setup$u ? _sfc_setup$u(props, ctx) : void 0;
};
const __nuxt_component_5 = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["ssrRender", _sfc_ssrRender$m], ["__scopeId", "data-v-7916337c"]]);
const meta$5 = void 0;
const meta$4 = void 0;
const meta$3 = void 0;
const meta$2 = void 0;
const useVotesStore = defineStore("votes", {
  state() {
    return {
      items: []
    };
  },
  getters: {
    byID: (state2) => (id) => {
      return state2.items.find((vote) => vote.id.toString() === id);
    }
  },
  actions: {
    async fetch(id) {
      if (!this.byID(id)) {
        var state2 = this;
        await useFetch(API_BASE + "votes/" + id + "/", {
          onResponse({ request: request2, response, options }) {
            state2.items.push(response._data);
          },
          onResponseError({ request: request2, response, options }) {
            const store = useNotificationsStore();
            store.postResponseError(response);
          },
          onRequestError({ request: request2, options, error }) {
            const store = useNotificationsStore();
            store.addToast("Error fetching resource (request)", error);
          }
        });
      }
    }
  }
});
const meta$1 = void 0;
const __default__$1 = {
  name: "VoteFilter",
  data() {
    return {
      votes: [],
      count: 0,
      page: 1,
      previous: false,
      next: false,
      hasLoadedData: false,
      isLoading: false,
      filterSettings: {
        titleContains: "",
        billTypes: {
          mem: true,
          gov: true,
          pri: true,
          loc: true
        },
        parliamentaryTerm: "",
        characteristics: {
          urgencyUsed: false,
          extendedSittingsUsed: false,
          submissionsOpen: false,
          votingMethod: "",
          type: ""
        },
        format: {
          perPage: 10,
          orderBy: "date_desc"
        }
      },
      activeFilter: {
        titleContains: "",
        billTypes: {
          mem: true,
          gov: true,
          pri: true,
          loc: true
        },
        parliamentaryTerm: "",
        characteristics: {
          urgencyUsed: false,
          extendedSittingsUsed: false,
          submissionsOpen: false,
          votingMethod: "",
          type: ""
        },
        format: {
          perPage: 10,
          orderBy: "date_desc"
        }
      }
    };
  },
  computed: {
    activeString() {
      return JSON.stringify(this.activeFilter);
    },
    userString() {
      return JSON.stringify(this.filterSettings);
    },
    displayVotes() {
      if (!this.hasLoadedData) {
        return this.prefetchData.results;
      } else {
        return this.votes;
      }
    },
    displayCount() {
      if (!this.hasLoadedData) {
        return this.prefetchData.count;
      } else {
        return this.count;
      }
    },
    displayPage() {
      if (!this.hasLoadedData) {
        return this.prefetchData.page;
      } else {
        return this.page;
      }
    },
    displayNext() {
      if (!this.hasLoadedData) {
        return this.prefetchData.next;
      } else {
        return this.next;
      }
    },
    displayPrevious() {
      if (!this.hasLoadedData) {
        return this.prefetchData.previous;
      } else {
        return this.previous;
      }
    }
  },
  methods: {
    async getPage(page) {
      this.isLoading = true;
      var url2 = API_BASE + "votes/?";
      var r = await $fetch(url2 + new URLSearchParams({
        page,
        per_page: this.activeFilter.format.perPage
      }), {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          page,
          filter: this.activeFilter
        })
      });
      this.isLoading = false;
      this.hasLoadedData = true;
      this.votes = r.results;
      this.count = r.count;
      if (r.previous) {
        this.previous = true;
      } else {
        this.previous = false;
      }
      if (r.next) {
        this.next = true;
      } else {
        this.next = false;
      }
      this.page = page;
    },
    applyFilter() {
      if (this.activeString != this.userString && !this.isLoading) {
        this.activeFilter = JSON.parse(JSON.stringify(this.filterSettings));
        this.getPage(1);
      }
    },
    relativeDate(date2) {
      return formatDistanceToNow(parse$2(date2, "yyyy-MM-dd", new Date())) + " ago";
    },
    formattedDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    },
    formattedDateFull(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  },
  onMounted() {
    this.getPage(1);
  }
};
const _sfc_main$t = /* @__PURE__ */ Object.assign(__default__$1, {
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const query = vueRouter_cjs.useRoute().query;
    var initialPage = 1;
    if (query.hasOwnProperty("page")) {
      initialPage = query.page;
    }
    const { data: prefetchData } = ([__temp, __restore] = vue_cjs_prod.withAsyncContext(() => useFetch(API_BASE + "votes/?page=" + initialPage + "&per_page=10")), __temp = await __temp, __restore(), __temp);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Head = vue_cjs_prod.resolveComponent("Head");
      const _component_Link = vue_cjs_prod.resolveComponent("Link");
      const _component_Card = __nuxt_component_2$4;
      const _component_Spinner = __nuxt_component_0$1;
      const _component_NuxtLink = __nuxt_component_1$7;
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-ba059728><h4 data-v-ba059728>Filter votes</h4>`);
      if (vue_cjs_prod.unref(prefetchData) && vue_cjs_prod.unref(prefetchData).count > 0) {
        _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page == 2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "prev",
                  href: "/votes"
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              if (vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page != 2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "prev",
                  href: "/votes?page=" + (vue_cjs_prod.unref(prefetchData).page - 1)
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              if (vue_cjs_prod.unref(prefetchData).next) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
                  rel: "next",
                  href: "/votes?page=" + (vue_cjs_prod.unref(prefetchData).page + 1)
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page == 2 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 0,
                  rel: "prev",
                  href: "/votes"
                })) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.unref(prefetchData).previous && vue_cjs_prod.unref(prefetchData).page != 2 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 1,
                  rel: "prev",
                  href: "/votes?page=" + (vue_cjs_prod.unref(prefetchData).page - 1)
                }, null, 8, ["href"])) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.unref(prefetchData).next ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Link, {
                  key: 2,
                  rel: "next",
                  href: "/votes?page=" + (vue_cjs_prod.unref(prefetchData).page + 1)
                }, null, 8, ["href"])) : vue_cjs_prod.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<form data-v-ba059728${_scopeId}><div class="row mb-2" data-v-ba059728${_scopeId}><div class="col-12" data-v-ba059728${_scopeId}><h5 data-v-ba059728${_scopeId}>Refine by bill title</h5><label for="text_filter" data-v-ba059728${_scopeId}>Bill title must contain the following:</label><input${serverRenderer.exports.ssrRenderAttr("value", _ctx.filterSettings.titleContains)} class="form-control" type="input" id="text_filter" data-v-ba059728${_scopeId}><small class="text-muted" data-v-ba059728${_scopeId}>For less strict textual search, you may wish to use the site-wide search function.</small></div></div><hr data-v-ba059728${_scopeId}><div class="row" data-v-ba059728${_scopeId}><div class="col-12 col-xl-3" data-v-ba059728${_scopeId}><h5 data-v-ba059728${_scopeId}>Bill types</h5><div class="form-check" data-v-ba059728${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.gov) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.gov, "") : _ctx.filterSettings.billTypes.gov) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_goverment" data-v-ba059728${_scopeId}><label class="form-check-label" for="check_goverment" data-v-ba059728${_scopeId}> Government bills </label></div><div class="form-check" data-v-ba059728${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.mem) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.mem, "") : _ctx.filterSettings.billTypes.mem) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_members" data-v-ba059728${_scopeId}><label class="form-check-label" for="check_members" data-v-ba059728${_scopeId}> Members&#39; bills </label></div><div class="form-check" data-v-ba059728${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.loc) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.loc, "") : _ctx.filterSettings.billTypes.loc) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_local" data-v-ba059728${_scopeId}><label class="form-check-label" for="check_local" data-v-ba059728${_scopeId}> Local bills </label></div><div class="form-check" data-v-ba059728${_scopeId}><input${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray(_ctx.filterSettings.billTypes.pri) ? serverRenderer.exports.ssrLooseContain(_ctx.filterSettings.billTypes.pri, "") : _ctx.filterSettings.billTypes.pri) ? " checked" : ""} class="form-check-input" type="checkbox" value="" id="check_private" data-v-ba059728${_scopeId}><label class="form-check-label" for="check_private" data-v-ba059728${_scopeId}> Private bills </label></div><small data-v-ba059728${_scopeId}><strong data-v-ba059728${_scopeId}>OR</strong>: Votes must be for a bill of one of the selected types to be shown.</small></div><div class="col-12 col-xl-3" data-v-ba059728${_scopeId}><h5 data-v-ba059728${_scopeId}>Vote options</h5><label for="parliament_select" data-v-ba059728${_scopeId}>Parliamentary term</label><select class="form-select" id="parliament_select" aria-label="-" data-v-ba059728${_scopeId}><option value="" selected data-v-ba059728${_scopeId}>Any</option><option value="53" data-v-ba059728${_scopeId}>53rd Parliament</option><option value="52" data-v-ba059728${_scopeId}>52nd Parliament</option><option value="51" data-v-ba059728${_scopeId}>51st Parliament</option><option value="50" data-v-ba059728${_scopeId}>50th Parliament</option></select><label for="vote_type_select" class="mt-2" data-v-ba059728${_scopeId}>Vote type</label><select class="form-select" id="vote_type_select" aria-label="Vote type" data-v-ba059728${_scopeId}><option value="" selected data-v-ba059728${_scopeId}>Any</option><option value="personal" data-v-ba059728${_scopeId}>Personal vote</option><option value="party" data-v-ba059728${_scopeId}>Party vote</option></select><small data-v-ba059728${_scopeId}><strong data-v-ba059728${_scopeId}>AND</strong>: Votes must meet both of these criteria to be shown.</small></div><div class="col-12 col-xl-3" data-v-ba059728${_scopeId}><h5 data-v-ba059728${_scopeId}>Display options</h5><label for="per_page_select" data-v-ba059728${_scopeId}>Results per page</label><select class="form-select" id="per_page_select" aria-label="Results per page" data-v-ba059728${_scopeId}><option value="10" selected data-v-ba059728${_scopeId}>10</option><option value="25" data-v-ba059728${_scopeId}>25</option><option value="50" data-v-ba059728${_scopeId}>50</option><option value="100" data-v-ba059728${_scopeId}>100</option></select><label for="order_by_select" class="mt-2" data-v-ba059728${_scopeId}>Order by</label><select class="form-select" id="order_by_select" aria-label="Order by" data-v-ba059728${_scopeId}><option value="date_desc" selected data-v-ba059728${_scopeId}>Date (newest first)</option><option value="date_asc" data-v-ba059728${_scopeId}>Date (oldest first)</option><option value="reading_desc" data-v-ba059728${_scopeId}>Reading (latest first)</option><option value="reading_asc" data-v-ba059728${_scopeId}>Reading (earliest first)</option></select></div></div><hr data-v-ba059728${_scopeId}><div class="row" data-v-ba059728${_scopeId}><div class="col-12" data-v-ba059728${_scopeId}>`);
            if (_ctx.activeString != _ctx.userString && !_ctx.isLoading) {
              _push2(`<button class="btn btn-primary" type="button" id="button-addon2" data-v-ba059728${_scopeId}>Refine selection</button>`);
            } else {
              _push2(`<button disabled class="btn btn-primary" type="button" id="button-addon2" data-v-ba059728${_scopeId}>Refine selection</button>`);
            }
            if (_ctx.isLoading) {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_Spinner, { class: "ms-2" }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div></div></form>`);
          } else {
            return [
              vue_cjs_prod.createVNode("form", {
                onSubmit: vue_cjs_prod.withModifiers(($event) => _ctx.applyFilter(), ["prevent"])
              }, [
                vue_cjs_prod.createVNode("div", { class: "row mb-2" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12" }, [
                    vue_cjs_prod.createVNode("h5", null, "Refine by bill title"),
                    vue_cjs_prod.createVNode("label", { for: "text_filter" }, "Bill title must contain the following:"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.titleContains = $event,
                      class: "form-control",
                      type: "input",
                      id: "text_filter"
                    }, null, 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelText, _ctx.filterSettings.titleContains]
                    ]),
                    vue_cjs_prod.createVNode("small", { class: "text-muted" }, "For less strict textual search, you may wish to use the site-wide search function.")
                  ])
                ]),
                vue_cjs_prod.createVNode("hr"),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Bill types"),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.gov = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_goverment"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.gov]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_goverment"
                      }, " Government bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.mem = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_members"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.mem]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_members"
                      }, " Members' bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.loc = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_local"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.loc]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_local"
                      }, " Local bills ")
                    ]),
                    vue_cjs_prod.createVNode("div", { class: "form-check" }, [
                      vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("input", {
                        "onUpdate:modelValue": ($event) => _ctx.filterSettings.billTypes.pri = $event,
                        class: "form-check-input",
                        type: "checkbox",
                        value: "",
                        id: "check_private"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vue_cjs_prod.vModelCheckbox, _ctx.filterSettings.billTypes.pri]
                      ]),
                      vue_cjs_prod.createVNode("label", {
                        class: "form-check-label",
                        for: "check_private"
                      }, " Private bills ")
                    ]),
                    vue_cjs_prod.createVNode("small", null, [
                      vue_cjs_prod.createVNode("strong", null, "OR"),
                      vue_cjs_prod.createTextVNode(": Votes must be for a bill of one of the selected types to be shown.")
                    ])
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Vote options"),
                    vue_cjs_prod.createVNode("label", { for: "parliament_select" }, "Parliamentary term"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.parliamentaryTerm = $event,
                      class: "form-select",
                      id: "parliament_select",
                      "aria-label": "-"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "",
                        selected: ""
                      }, "Any"),
                      vue_cjs_prod.createVNode("option", { value: "53" }, "53rd Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "52" }, "52nd Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "51" }, "51st Parliament"),
                      vue_cjs_prod.createVNode("option", { value: "50" }, "50th Parliament")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.parliamentaryTerm]
                    ]),
                    vue_cjs_prod.createVNode("label", {
                      for: "vote_type_select",
                      class: "mt-2"
                    }, "Vote type"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.characteristics.type = $event,
                      class: "form-select",
                      id: "vote_type_select",
                      "aria-label": "Vote type"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "",
                        selected: ""
                      }, "Any"),
                      vue_cjs_prod.createVNode("option", { value: "personal" }, "Personal vote"),
                      vue_cjs_prod.createVNode("option", { value: "party" }, "Party vote")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.characteristics.type]
                    ]),
                    vue_cjs_prod.createVNode("small", null, [
                      vue_cjs_prod.createVNode("strong", null, "AND"),
                      vue_cjs_prod.createTextVNode(": Votes must meet both of these criteria to be shown.")
                    ])
                  ]),
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-3" }, [
                    vue_cjs_prod.createVNode("h5", null, "Display options"),
                    vue_cjs_prod.createVNode("label", { for: "per_page_select" }, "Results per page"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.format.perPage = $event,
                      class: "form-select",
                      id: "per_page_select",
                      "aria-label": "Results per page"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "10",
                        selected: ""
                      }, "10"),
                      vue_cjs_prod.createVNode("option", { value: "25" }, "25"),
                      vue_cjs_prod.createVNode("option", { value: "50" }, "50"),
                      vue_cjs_prod.createVNode("option", { value: "100" }, "100")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.format.perPage]
                    ]),
                    vue_cjs_prod.createVNode("label", {
                      for: "order_by_select",
                      class: "mt-2"
                    }, "Order by"),
                    vue_cjs_prod.withDirectives(vue_cjs_prod.createVNode("select", {
                      "onUpdate:modelValue": ($event) => _ctx.filterSettings.format.orderBy = $event,
                      class: "form-select",
                      id: "order_by_select",
                      "aria-label": "Order by"
                    }, [
                      vue_cjs_prod.createVNode("option", {
                        value: "date_desc",
                        selected: ""
                      }, "Date (newest first)"),
                      vue_cjs_prod.createVNode("option", { value: "date_asc" }, "Date (oldest first)"),
                      vue_cjs_prod.createVNode("option", { value: "reading_desc" }, "Reading (latest first)"),
                      vue_cjs_prod.createVNode("option", { value: "reading_asc" }, "Reading (earliest first)")
                    ], 8, ["onUpdate:modelValue"]), [
                      [vue_cjs_prod.vModelSelect, _ctx.filterSettings.format.orderBy]
                    ])
                  ])
                ]),
                vue_cjs_prod.createVNode("hr"),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12" }, [
                    _ctx.activeString != _ctx.userString && !_ctx.isLoading ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("button", {
                      key: 0,
                      onClick: ($event) => _ctx.applyFilter(),
                      class: "btn btn-primary",
                      type: "button",
                      id: "button-addon2"
                    }, "Refine selection", 8, ["onClick"])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("button", {
                      key: 1,
                      disabled: "",
                      class: "btn btn-primary",
                      type: "button",
                      id: "button-addon2"
                    }, "Refine selection")),
                    _ctx.isLoading ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Spinner, {
                      key: 2,
                      class: "ms-2"
                    })) : vue_cjs_prod.createCommentVNode("", true)
                  ])
                ])
              ], 40, ["onSubmit"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<span id="results-marker" data-v-ba059728></span>`);
      if (_ctx.page) {
        _push(`<div data-v-ba059728><h4 data-v-ba059728>Results</h4> ${serverRenderer.exports.ssrInterpolate(_ctx.displayCount)} result`);
        if (_ctx.displayCount != 1) {
          _push(`<span data-v-ba059728>s</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`. <!--[-->`);
        serverRenderer.exports.ssrRenderList(_ctx.displayVotes, (vote) => {
          _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
            title: vote.name,
            key: vote.id,
            to: "/votes/" + vote.id,
            class: "vote-link"
          }, {
            default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`<div class="row" data-v-ba059728${_scopeId2}><div class="col-12 col-xl-5" data-v-ba059728${_scopeId2}><h6 class="mb-0" data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.name)}</h6><small class="me-1" data-v-ba059728${_scopeId2}>`);
                      if (vote.type_desc) {
                        _push3(`<span class="badge bg-primary text-uppercase" data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.type_desc)}</span>`);
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(`</small><small class="text-muted text-uppercase" data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(_ctx.formattedDateFull(vote.date))}</small><hr class="col-12 d-xl-none mt-2" data-v-ba059728${_scopeId2}></div><div class="col-12 col-xl-7" data-v-ba059728${_scopeId2}><div class="row" data-v-ba059728${_scopeId2}><div class="col-3 text-center" data-v-ba059728${_scopeId2}><h3 data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.ayes)}</h3><h6 class="text-muted text-uppercase" data-v-ba059728${_scopeId2}><span class="dot-yes" data-v-ba059728${_scopeId2}></span> Ayes</h6></div><div class="col-3 text-center" data-v-ba059728${_scopeId2}><h3 data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.noes)}</h3><h6 class="text-muted text-uppercase" data-v-ba059728${_scopeId2}><span class="dot-no" data-v-ba059728${_scopeId2}></span> Noes</h6></div><div class="col-3 text-center" data-v-ba059728${_scopeId2}><h3 data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.abstentions)}</h3><h6 class="text-muted text-uppercase" data-v-ba059728${_scopeId2}><span class="dot-abstain" data-v-ba059728${_scopeId2}></span> Abstentions</h6></div><div class="col-3 text-center" data-v-ba059728${_scopeId2}><h3 data-v-ba059728${_scopeId2}>${serverRenderer.exports.ssrInterpolate(vote.absent)}</h3><h6 class="text-muted text-uppercase" data-v-ba059728${_scopeId2}><span class="dot-absent" data-v-ba059728${_scopeId2}></span> Absent</h6></div></div></div></div>`);
                    } else {
                      return [
                        vue_cjs_prod.createVNode("div", { class: "row" }, [
                          vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-5" }, [
                            vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(vote.name), 1),
                            vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                              vote.type_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                                key: 0,
                                class: "badge bg-primary text-uppercase"
                              }, vue_cjs_prod.toDisplayString(vote.type_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                            ]),
                            vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(_ctx.formattedDateFull(vote.date)), 1),
                            vue_cjs_prod.createVNode("hr", { class: "col-12 d-xl-none mt-2" })
                          ]),
                          vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-7" }, [
                            vue_cjs_prod.createVNode("div", { class: "row" }, [
                              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.ayes), 1),
                                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                  vue_cjs_prod.createVNode("span", { class: "dot-yes" }),
                                  vue_cjs_prod.createTextVNode(" Ayes")
                                ])
                              ]),
                              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.noes), 1),
                                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                  vue_cjs_prod.createVNode("span", { class: "dot-no" }),
                                  vue_cjs_prod.createTextVNode(" Noes")
                                ])
                              ]),
                              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.abstentions), 1),
                                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                  vue_cjs_prod.createVNode("span", { class: "dot-abstain" }),
                                  vue_cjs_prod.createTextVNode(" Abstentions")
                                ])
                              ]),
                              vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                                vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.absent), 1),
                                vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                  vue_cjs_prod.createVNode("span", { class: "dot-absent" }),
                                  vue_cjs_prod.createTextVNode(" Absent")
                                ])
                              ])
                            ])
                          ])
                        ])
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
              } else {
                return [
                  vue_cjs_prod.createVNode(_component_Card, null, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createVNode("div", { class: "row" }, [
                        vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-5" }, [
                          vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(vote.name), 1),
                          vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                            vote.type_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                              key: 0,
                              class: "badge bg-primary text-uppercase"
                            }, vue_cjs_prod.toDisplayString(vote.type_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                          ]),
                          vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(_ctx.formattedDateFull(vote.date)), 1),
                          vue_cjs_prod.createVNode("hr", { class: "col-12 d-xl-none mt-2" })
                        ]),
                        vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-7" }, [
                          vue_cjs_prod.createVNode("div", { class: "row" }, [
                            vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.ayes), 1),
                              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                vue_cjs_prod.createVNode("span", { class: "dot-yes" }),
                                vue_cjs_prod.createTextVNode(" Ayes")
                              ])
                            ]),
                            vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.noes), 1),
                              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                vue_cjs_prod.createVNode("span", { class: "dot-no" }),
                                vue_cjs_prod.createTextVNode(" Noes")
                              ])
                            ]),
                            vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.abstentions), 1),
                              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                vue_cjs_prod.createVNode("span", { class: "dot-abstain" }),
                                vue_cjs_prod.createTextVNode(" Abstentions")
                              ])
                            ]),
                            vue_cjs_prod.createVNode("div", { class: "col-3 text-center" }, [
                              vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString(vote.absent), 1),
                              vue_cjs_prod.createVNode("h6", { class: "text-muted text-uppercase" }, [
                                vue_cjs_prod.createVNode("span", { class: "dot-absent" }),
                                vue_cjs_prod.createTextVNode(" Absent")
                              ])
                            ])
                          ])
                        ])
                      ])
                    ]),
                    _: 2
                  }, 1024)
                ];
              }
            }),
            _: 2
          }, _parent));
        });
        _push(`<!--]-->`);
        if (!_ctx.isLoading) {
          _push(`<nav aria-label="votes_pagination" data-v-ba059728><ul class="pagination mb-1" data-v-ba059728><li class="${serverRenderer.exports.ssrRenderClass([{ disabled: !_ctx.displayPrevious }, "page-item"])}" data-v-ba059728><a class="page-link" href="#results-marker" data-v-ba059728>Previous</a></li>`);
          if (_ctx.displayPrevious) {
            _push(`<li class="page-item" data-v-ba059728><a class="page-link" href="#results-marker" data-v-ba059728>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage - 1)}</a></li>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<li class="page-item active" aria-current="page" data-v-ba059728><a class="page-link" href="#results-marker" data-v-ba059728>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage)}</a></li>`);
          if (_ctx.displayNext) {
            _push(`<li class="page-item" data-v-ba059728><a class="page-link" href="#results-marker" data-v-ba059728>${serverRenderer.exports.ssrInterpolate(_ctx.displayPage + 1)}</a></li>`);
          } else {
            _push(`<!---->`);
          }
          _push(`<li class="${serverRenderer.exports.ssrRenderClass([{ disabled: !_ctx.displayNext }, "page-item"])}" data-v-ba059728><a class="page-link" href="#results-marker" data-v-ba059728>Next</a></li></ul>`);
          if (_ctx.displayPage != 1) {
            _push(`<a id="back-to-start" href="#results-marker" data-v-ba059728><small data-v-ba059728>Back to start</small></a>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</nav>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$t = _sfc_main$t.setup;
_sfc_main$t.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/VoteFilter.vue");
  return _sfc_setup$t ? _sfc_setup$t(props, ctx) : void 0;
};
const __nuxt_component_1$1 = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-ba059728"]]);
const meta = void 0;
const routes = [
  {
    name: "about",
    path: "/about",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/about.vue",
    children: [],
    meta: meta$i,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return about$1;
    })
  },
  {
    name: "bills-id",
    path: "/bills/:id",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/bills/[id]/index.vue",
    children: [],
    meta: meta$h,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$l;
    })
  },
  {
    name: "bills",
    path: "/bills",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/bills/index.vue",
    children: [],
    meta: meta$g,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$j;
    })
  },
  {
    name: "electorates-id",
    path: "/electorates/:id",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/electorates/[id]/index.vue",
    children: [],
    meta: meta$f,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$h;
    })
  },
  {
    name: "electorates",
    path: "/electorates",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/electorates/index.vue",
    children: [],
    meta: meta$e,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$f;
    })
  },
  {
    name: "index",
    path: "/",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/index.vue",
    children: [],
    meta: meta$d,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$d;
    })
  },
  {
    path: "/parties/:id",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/parties/[id].vue",
    children: [
      {
        name: "parties-id-documents",
        path: "documents",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/parties/[id]/documents.vue",
        children: [],
        meta: meta$b,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return documents$1;
        })
      },
      {
        name: "parties-id",
        path: "",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/parties/[id]/index.vue",
        children: [],
        meta: meta$a,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return index$b;
        })
      }
    ],
    meta: meta$c,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return _id_$3;
    })
  },
  {
    name: "parties",
    path: "/parties",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/parties/index.vue",
    children: [],
    meta: meta$9,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$9;
    })
  },
  {
    path: "/people/:id",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/[id].vue",
    children: [
      {
        name: "people-id-details",
        path: "details",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/[id]/details.vue",
        children: [],
        meta: meta$7,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return details$1;
        })
      },
      {
        name: "people-id-expenses",
        path: "expenses",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/[id]/expenses.vue",
        children: [],
        meta: meta$6,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return expenses$1;
        })
      },
      {
        name: "people-id",
        path: "",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/[id]/index.vue",
        children: [],
        meta: meta$5,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return index$7;
        })
      },
      {
        name: "people-id-interests",
        path: "interests",
        file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/[id]/interests.vue",
        children: [],
        meta: meta$4,
        alias: [],
        component: () => Promise.resolve().then(function() {
          return interests$1;
        })
      }
    ],
    meta: meta$8,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return _id_$1;
    })
  },
  {
    name: "people",
    path: "/people",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/people/index.vue",
    children: [],
    meta: meta$3,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$5;
    })
  },
  {
    name: "terms",
    path: "/terms",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/terms.vue",
    children: [],
    meta: meta$2,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return terms$1;
    })
  },
  {
    name: "votes-id",
    path: "/votes/:id",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/votes/[id]/index.vue",
    children: [],
    meta: meta$1,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$3;
    })
  },
  {
    name: "votes",
    path: "/votes",
    file: "/Users/jcm/Local Documents/GitHub/wheretheystand-client/wts-client/pages/votes/index.vue",
    children: [],
    meta,
    alias: [],
    component: () => Promise.resolve().then(function() {
      return index$1;
    })
  }
];
const configRouterOptions = {};
const routerOptions = {
  ...configRouterOptions
};
const globalMiddleware = [];
const namedMiddleware = {};
const _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47pages_47runtime_47router = defineNuxtPlugin(async (nuxtApp) => {
  nuxtApp.vueApp.component("NuxtPage", NuxtPage);
  nuxtApp.vueApp.component("NuxtNestedPage", NuxtPage);
  nuxtApp.vueApp.component("NuxtChild", NuxtPage);
  const baseURL2 = useRuntimeConfig().app.baseURL;
  const routerHistory = vueRouter_cjs.createMemoryHistory(baseURL2);
  const initialURL = nuxtApp.ssrContext.url;
  const router = vueRouter_cjs.createRouter({
    ...routerOptions,
    history: routerHistory,
    routes
  });
  nuxtApp.vueApp.use(router);
  const previousRoute = vue_cjs_prod.shallowRef(router.currentRoute.value);
  router.afterEach((_to, from2) => {
    previousRoute.value = from2;
  });
  Object.defineProperty(nuxtApp.vueApp.config.globalProperties, "previousRoute", {
    get: () => previousRoute.value
  });
  const route = {};
  for (const key in router.currentRoute.value) {
    route[key] = vue_cjs_prod.computed(() => router.currentRoute.value[key]);
  }
  const _activeRoute = vue_cjs_prod.shallowRef(router.resolve(initialURL));
  const syncCurrentRoute = () => {
    _activeRoute.value = router.currentRoute.value;
  };
  nuxtApp.hook("page:finish", syncCurrentRoute);
  router.afterEach((to2, from2) => {
    var _a, _b, _c, _d;
    if (((_b = (_a = to2.matched[0]) == null ? void 0 : _a.components) == null ? void 0 : _b.default) === ((_d = (_c = from2.matched[0]) == null ? void 0 : _c.components) == null ? void 0 : _d.default)) {
      syncCurrentRoute();
    }
  });
  const activeRoute = {};
  for (const key in _activeRoute.value) {
    activeRoute[key] = vue_cjs_prod.computed(() => _activeRoute.value[key]);
  }
  nuxtApp._route = vue_cjs_prod.reactive(route);
  nuxtApp._activeRoute = vue_cjs_prod.reactive(activeRoute);
  nuxtApp._middleware = nuxtApp._middleware || {
    global: [],
    named: {}
  };
  useError();
  try {
    if (true) {
      await router.push(initialURL);
    }
    await router.isReady();
  } catch (error2) {
    callWithNuxt(nuxtApp, throwError, [error2]);
  }
  router.beforeEach(async (to2, from2) => {
    var _a;
    to2.meta = vue_cjs_prod.reactive(to2.meta);
    nuxtApp._processingMiddleware = true;
    const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);
    for (const component of to2.matched) {
      const componentMiddleware = component.meta.middleware;
      if (!componentMiddleware) {
        continue;
      }
      if (Array.isArray(componentMiddleware)) {
        for (const entry2 of componentMiddleware) {
          middlewareEntries.add(entry2);
        }
      } else {
        middlewareEntries.add(componentMiddleware);
      }
    }
    for (const entry2 of middlewareEntries) {
      const middleware = typeof entry2 === "string" ? nuxtApp._middleware.named[entry2] || await ((_a = namedMiddleware[entry2]) == null ? void 0 : _a.call(namedMiddleware).then((r) => r.default || r)) : entry2;
      if (!middleware) {
        throw new Error(`Unknown route middleware: '${entry2}'.`);
      }
      const result = await callWithNuxt(nuxtApp, middleware, [to2, from2]);
      {
        if (result === false || result instanceof Error) {
          const error2 = result || createError({
            statusMessage: `Route navigation aborted: ${initialURL}`
          });
          return callWithNuxt(nuxtApp, throwError, [error2]);
        }
      }
      if (result || result === false) {
        return result;
      }
    }
  });
  router.afterEach(async (to2) => {
    delete nuxtApp._processingMiddleware;
    if (to2.matched.length === 0) {
      callWithNuxt(nuxtApp, throwError, [createError({
        statusCode: 404,
        statusMessage: `Page not found: ${to2.fullPath}`
      })]);
    } else if (to2.matched[0].name === "404" && nuxtApp.ssrContext) {
      nuxtApp.ssrContext.res.statusCode = 404;
    } else {
      const currentURL = to2.fullPath || "/";
      if (!isEqual$1(currentURL, initialURL)) {
        await callWithNuxt(nuxtApp, navigateTo, [currentURL]);
      }
    }
  });
  nuxtApp.hooks.hookOnce("app:created", async () => {
    try {
      await router.replace({
        ...router.resolve(initialURL),
        name: void 0,
        force: true
      });
    } catch (error2) {
      callWithNuxt(nuxtApp, throwError, [error2]);
    }
  });
  return { provide: { router } };
});
const PiniaNuxtPlugin = (context, inject2) => {
  const pinia = createPinia();
  {
    context.vueApp.use(pinia);
  }
  inject2("pinia", pinia);
  context.pinia = pinia;
  setActivePinia(pinia);
  pinia._p.push(({ store }) => {
    Object.defineProperty(store, "$nuxt", { value: context });
  });
  {
    {
      context.nuxtState.pinia = pinia.state.value;
    }
  }
};
library$1.add(faHistory, faTimes, faCheck, faMapSigns, faQuestion, faChevronUp, faChevronDown, faExternalLinkAlt, faTwitter, faFacebook, faInstagram, faSnapchat, faWikipediaW, faInfoCircle, faArrowRight, faPeopleGroup, faPerson, faArrowLeft, faFileCsv, faFileCode, faFileExcel, faBook, faFileLines, faForwardFast, faCalendar, faPenNib, faMicrophoneLines);
const _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47fontawesome_46js = defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.component("FontAwesomeIcon", FontAwesomeIcon);
});
var src$4 = {};
var Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: true });
class Deferred {
  constructor(defaultVal = null) {
    this.state = "pending";
    this.fate = "unresolved";
    this._val = defaultVal || null;
    this.promise = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
    this.promise.then((val) => {
      this.state = "fulfilled";
      this._val = val;
    }, () => {
      this.state = "rejected";
      this._val = null;
    });
  }
  resolve(value) {
    if (this.fate === "resolved") {
      throw "Deferred cannot be resolved twice";
    }
    this.fate = "resolved";
    this._resolve(value);
  }
  reject(reason) {
    if (this.fate === "resolved") {
      throw "Deferred cannot be resolved twice";
    }
    this.fate = "resolved";
    this._reject(reason);
  }
  isResolved() {
    return this.fate === "resolved";
  }
  isPending() {
    return this.state === "pending";
  }
  isFulfilled() {
    return this.state === "fulfilled";
  }
  isRejected() {
    return this.state === "rejected";
  }
  get val() {
    return this._val;
  }
}
Deferred$1.default = Deferred;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(src$4, "__esModule", { value: true });
const Deferred_1 = __importDefault$1(Deferred$1);
var _default$1 = src$4.default = Deferred_1.default;
var mapboxGl$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define(_, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
      }
    }
    define(["exports"], function(t) {
      var e = typeof self != "undefined" ? self : {}, r = "2.13.0";
      let n;
      const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (n == null) {
          const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            n = process.env.API_URL_REGEX != null ? new RegExp(process.env.API_URL_REGEX) : t2;
          } catch (e2) {
            n = t2;
          }
        }
        return n;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, s = { supported: false, testSupport: function(t2) {
        !l && o && (u ? c(t2) : a = t2);
      } };
      let a, o, l = false, u = false;
      function c(t2) {
        const e2 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e2);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, o), t2.isContextLost())
            return;
          s.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e2), l = true;
      }
      e.document && (o = e.document.createElement("img"), o.onload = function() {
        a && c(a), a = null, u = true;
      }, o.onerror = function() {
        l = true, a = null;
      }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const h3 = "01";
      var p = f;
      function f(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
      }
      f.prototype = { sampleCurveX: function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, sampleCurveY: function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, sampleCurveDerivativeX: function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, solveCurveX: function(t2, e2) {
        if (e2 === void 0 && (e2 = 1e-6), t2 < 0)
          return 0;
        if (t2 > 1)
          return 1;
        for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
          var i2 = this.sampleCurveX(r2) - t2;
          if (Math.abs(i2) < e2)
            return r2;
          var s2 = this.sampleCurveDerivativeX(r2);
          if (Math.abs(s2) < 1e-6)
            break;
          r2 -= i2 / s2;
        }
        var a2 = 0, o2 = 1;
        for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
          t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
        return r2;
      }, solve: function(t2, e2) {
        return this.sampleCurveY(this.solveCurveX(t2, e2));
      } };
      var d = y;
      function y(t2, e2) {
        this.x = t2, this.y = e2;
      }
      y.prototype = { clone: function() {
        return new y(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e2) {
        return this.clone()._rotateAround(t2, e2);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e2 = t2.x - this.x, r2 = t2.y - this.y;
        return e2 * e2 + r2 * r2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e2) {
        return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
      }, _matMult: function(t2) {
        var e2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
      }, _rotateAround: function(t2, e2) {
        var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
        return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, y.convert = function(t2) {
        return t2 instanceof y ? t2 : Array.isArray(t2) ? new y(t2[0], t2[1]) : t2;
      };
      const m = Math.PI / 180, g = 180 / Math.PI;
      function x(t2) {
        return t2 * m;
      }
      function v2(t2) {
        return t2 * g;
      }
      const b = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function w(t2) {
        if (t2 <= 0)
          return 0;
        if (t2 >= 1)
          return 1;
        const e2 = t2 * t2, r2 = e2 * t2;
        return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
      }
      function _(t2, e2, r2, n2) {
        const i2 = new p(t2, e2, r2, n2);
        return function(t3) {
          return i2.solve(t3);
        };
      }
      const A = _(0.25, 0.1, 0.25, 1);
      function S(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function k(t2, e2, r2) {
        return (r2 = S((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
      }
      function I(t2, e2, r2) {
        const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function M(t2, e2, r2) {
        if (!t2.length)
          return r2(null, []);
        let n2 = t2.length;
        const i2 = new Array(t2.length);
        let s2 = null;
        t2.forEach((t3, a2) => {
          e2(t3, (t4, e3) => {
            t4 && (s2 = t4), i2[a2] = e3, --n2 == 0 && r2(s2, i2);
          });
        });
      }
      function T(t2) {
        const e2 = [];
        for (const r2 in t2)
          e2.push(t2[r2]);
        return e2;
      }
      function z(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let B = 1;
      function E() {
        return B++;
      }
      function C() {
        return function t2(e2) {
          return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
        }();
      }
      function P(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }
      function D(t2) {
        return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
      }
      function V(t2, e2) {
        t2.forEach((t3) => {
          e2[t3] && (e2[t3] = e2[t3].bind(e2));
        });
      }
      function L(t2, e2) {
        return t2.indexOf(e2, t2.length - e2.length) !== -1;
      }
      function F(t2, e2, r2) {
        const n2 = {};
        for (const i2 in t2)
          n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
        return n2;
      }
      function R2(t2, e2, r2) {
        const n2 = {};
        for (const i2 in t2)
          e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
        return n2;
      }
      function j(t2) {
        return Array.isArray(t2) ? t2.map(j) : typeof t2 == "object" && t2 ? F(t2, j) : t2;
      }
      const U = {};
      function $(t2) {
        U[t2] || (typeof console != "undefined" && console.warn(t2), U[t2] = true);
      }
      function O(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function q(t2) {
        let e2 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
        return e2;
      }
      function N() {
        return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope;
      }
      function G(t2) {
        const e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e2[r2] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t3 = parseInt(e2["max-age"], 10);
          isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
        }
        return e2;
      }
      let X = null;
      function Z(t2) {
        if (X == null) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          X = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return X;
      }
      function K(t2) {
        try {
          const r2 = e[t2];
          return r2.setItem("_mapbox_test_", 1), r2.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }
      function Y(t2, e2) {
        return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
      }
      const H = "mapbox-tiles";
      let W, J, Q = 500, tt = 50;
      function et() {
        try {
          return e.caches;
        } catch (t2) {
        }
      }
      function rt() {
        et() && !W && (W = e.caches.open(H));
      }
      function nt(t2) {
        const e2 = t2.indexOf("?");
        if (e2 < 0)
          return t2;
        const r2 = function(t3) {
          const e3 = t3.indexOf("?");
          return e3 > 0 ? t3.slice(e3 + 1).split("&") : [];
        }(t2), n2 = r2.filter((t3) => {
          const e3 = t3.split("=");
          return e3[0] === "language" || e3[0] === "worldview";
        });
        return n2.length ? `${t2.slice(0, e2)}?${n2.join("&")}` : t2.slice(0, e2);
      }
      let it = 1 / 0;
      const st = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      typeof Object.freeze == "function" && Object.freeze(st);
      class at extends Error {
        constructor(t2, e2, r2) {
          e2 === 401 && gt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const ot = N() ? () => self.worker && self.worker.referrer : () => (e.location.protocol === "blob:" ? e.parent : e).location.href;
      const lt = function(t2, r2) {
        if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ot()) && !/^\w+:/.test(n2))) {
          if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
            return function(t3, r3) {
              const n3 = new e.AbortController(), i2 = new e.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ot(), signal: n3.signal });
              let s2 = false, a2 = false;
              const o2 = (l2 = i2.url).indexOf("sku=") > 0 && gt(l2);
              var l2;
              t3.type === "json" && i2.headers.set("Accept", "application/json");
              const u2 = (n4, s3, l3) => {
                if (a2)
                  return;
                if (n4 && n4.message !== "SecurityError" && $(n4), s3 && l3)
                  return c2(s3);
                const u3 = Date.now();
                e.fetch(i2).then((e2) => {
                  if (e2.ok) {
                    const t4 = o2 ? e2.clone() : null;
                    return c2(e2, t4, u3);
                  }
                  return r3(new at(e2.statusText, e2.status, t3.url));
                }).catch((e2) => {
                  e2.name !== "AbortError" && r3(new Error(`${e2.message} ${t3.url}`));
                });
              }, c2 = (n4, o3, l3) => {
                (t3.type === "arrayBuffer" ? n4.arrayBuffer() : t3.type === "json" ? n4.json() : n4.text()).then((t4) => {
                  a2 || (o3 && l3 && function(t5, r4, n5) {
                    if (rt(), !W)
                      return;
                    const i3 = { status: r4.status, statusText: r4.statusText, headers: new e.Headers() };
                    r4.headers.forEach((t6, e2) => i3.headers.set(e2, t6));
                    const s3 = G(r4.headers.get("Cache-Control") || "");
                    if (s3["no-store"])
                      return;
                    s3["max-age"] && i3.headers.set("Expires", new Date(n5 + 1e3 * s3["max-age"]).toUTCString());
                    const a3 = i3.headers.get("Expires");
                    a3 && (new Date(a3).getTime() - n5 < 42e4 || function(t6, e2) {
                      if (J === void 0)
                        try {
                          new Response(new ReadableStream()), J = true;
                        } catch (t7) {
                          J = false;
                        }
                      J ? e2(t6.body) : t6.blob().then(e2);
                    }(r4, (r5) => {
                      const n6 = new e.Response(r5, i3);
                      rt(), W && W.then((e2) => e2.put(nt(t5.url), n6)).catch((t6) => $(t6.message));
                    }));
                  }(i2, o3, l3), s2 = true, r3(null, t4, n4.headers.get("Cache-Control"), n4.headers.get("Expires")));
                }).catch((t4) => {
                  a2 || r3(new Error(t4.message));
                });
              };
              return o2 ? function(t4, e2) {
                if (rt(), !W)
                  return e2(null);
                const r4 = nt(t4.url);
                W.then((t5) => {
                  t5.match(r4).then((n4) => {
                    const i3 = function(t6) {
                      if (!t6)
                        return false;
                      const e3 = new Date(t6.headers.get("Expires") || 0), r5 = G(t6.headers.get("Cache-Control") || "");
                      return e3 > Date.now() && !r5["no-cache"];
                    }(n4);
                    t5.delete(r4), i3 && t5.put(r4, n4.clone()), e2(null, n4, i3);
                  }).catch(e2);
                }).catch(e2);
              }(i2, u2) : u2(null, null), { cancel: () => {
                a2 = true, s2 || n3.abort();
              } };
            }(t2, r2);
          if (N() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t2, r2, void 0, true);
        }
        var n2;
        return function(t3, r3) {
          const n3 = new e.XMLHttpRequest();
          n3.open(t3.method || "GET", t3.url, true), t3.type === "arrayBuffer" && (n3.responseType = "arraybuffer");
          for (const e2 in t3.headers)
            n3.setRequestHeader(e2, t3.headers[e2]);
          return t3.type === "json" && (n3.responseType = "text", n3.setRequestHeader("Accept", "application/json")), n3.withCredentials = t3.credentials === "include", n3.onerror = () => {
            r3(new Error(n3.statusText));
          }, n3.onload = () => {
            if ((n3.status >= 200 && n3.status < 300 || n3.status === 0) && n3.response !== null) {
              let e2 = n3.response;
              if (t3.type === "json")
                try {
                  e2 = JSON.parse(n3.response);
                } catch (t4) {
                  return r3(t4);
                }
              r3(null, e2, n3.getResponseHeader("Cache-Control"), n3.getResponseHeader("Expires"));
            } else
              r3(new at(n3.statusText, n3.status, t3.url));
          }, n3.send(t3.body), { cancel: () => n3.abort() };
        }(t2, r2);
      }, ut = function(t2, e2) {
        return lt(z(t2, { type: "arrayBuffer" }), e2);
      };
      function ct(t2) {
        const r2 = e.document.createElement("a");
        return r2.href = t2, r2.protocol === e.document.location.protocol && r2.host === e.document.location.host;
      }
      const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let pt, ft;
      pt = [], ft = 0;
      const dt = function(t2, r2) {
        if (s.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
          const e2 = { requestParameters: t2, callback: r2, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return pt.push(e2), e2;
        }
        ft++;
        let n2 = false;
        const a2 = () => {
          if (!n2)
            for (n2 = true, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = pt.shift(), { requestParameters: e2, callback: r3, cancelled: n3 } = t3;
              n3 || (t3.cancel = dt(e2, r3).cancel);
            }
        }, o2 = ut(t2, (t3, n3, i2, s2) => {
          a2(), t3 ? r2(t3) : n3 && (e.createImageBitmap ? function(t4, r3) {
            const n4 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
            e.createImageBitmap(n4).then((t5) => {
              r3(null, t5);
            }).catch((t5) => {
              r3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(n3, (t4, e2) => r2(t4, e2, i2, s2)) : function(t4, r3) {
            const n4 = new e.Image(), i3 = e.URL;
            n4.onload = () => {
              r3(null, n4), i3.revokeObjectURL(n4.src), n4.onload = null, e.requestAnimationFrame(() => {
                n4.src = ht;
              });
            }, n4.onerror = () => r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const s3 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
            n4.src = t4.byteLength ? i3.createObjectURL(s3) : ht;
          }(n3, (t4, e2) => r2(t4, e2, i2, s2)));
        });
        return { cancel: () => {
          o2.cancel(), a2();
        } };
      }, yt = "NO_ACCESS_TOKEN";
      function mt(t2) {
        return t2.indexOf("mapbox:") === 0;
      }
      function gt(t2) {
        return i.API_URL_REGEX.test(t2);
      }
      function xt(t2) {
        return i.API_CDN_URL_REGEX.test(t2);
      }
      function vt(t2) {
        return i.API_STYLE_REGEX.test(t2) && !bt(t2);
      }
      function bt(t2) {
        return i.API_SPRITE_REGEX.test(t2);
      }
      const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function _t(t2) {
        const e2 = t2.match(wt);
        if (!e2)
          throw new Error("Unable to parse URL object");
        return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
      }
      function At(t2) {
        const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
        return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
      }
      function St(t2) {
        if (!t2)
          return null;
        const r2 = t2.split(".");
        if (!r2 || r2.length !== 3)
          return null;
        try {
          return JSON.parse(decodeURIComponent(e.atob(r2[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (t3) {
          return null;
        }
      }
      class kt {
        constructor(t2) {
          this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t2) {
          const r2 = St(i.ACCESS_TOKEN);
          let n2 = "";
          return n2 = r2 && r2.u ? e.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2)))) : i.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${n2}` : `mapbox.eventData:${n2}`;
        }
        fetchEventData() {
          const t2 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
          if (t2)
            try {
              const t3 = e.localStorage.getItem(r2);
              t3 && (this.eventData = JSON.parse(t3));
              const i2 = e.localStorage.getItem(n2);
              i2 && (this.anonId = i2);
            } catch (t3) {
              $("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t2 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
          if (t2)
            try {
              e.localStorage.setItem(n2, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r2, JSON.stringify(this.eventData));
            } catch (t3) {
              $("Unable to write to LocalStorage");
            }
        }
        processRequests(t2) {
        }
        postEvent(t2, e2, r2, n2) {
          if (!i.EVENTS_URL)
            return;
          const s2 = _t(i.EVENTS_URL);
          s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
          const a2 = { event: this.type, created: new Date(t2).toISOString() }, o2 = e2 ? z(a2, e2) : a2, l2 = { url: At(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
          this.pendingRequest = function(t3, e3) {
            return lt(z(t3, { method: "POST" }), e3);
          }(l2, (t3) => {
            this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n2);
          });
        }
        queueRequest(t2, e2) {
          this.queue.push(t2), this.processRequests(e2);
        }
      }
      const It = new class extends kt {
        constructor(t2) {
          super("appUserTurnstile"), this._customAccessToken = t2;
        }
        postTurnstileEvent(t2, e2) {
          i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => mt(t3) || gt(t3)) && this.queueRequest(Date.now(), e2);
        }
        processRequests(t2) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const e2 = St(i.ACCESS_TOKEN), n2 = e2 ? e2.u : i.ACCESS_TOKEN;
          let s2 = n2 !== this.eventData.tokenU;
          D(this.anonId) || (this.anonId = C(), s2 = true);
          const a2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(a2), r2 = (a2 - this.eventData.lastSuccess) / 864e5;
            s2 = s2 || r2 >= 1 || r2 < -1 || t3.getDate() !== e3.getDate();
          } else
            s2 = true;
          s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h3, "enabled.telemetry": false, userId: this.anonId }, (t3) => {
            t3 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = n2);
          }, t2) : this.processRequests();
        }
      }(), Mt = It.postTurnstileEvent.bind(It), Tt = new class extends kt {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t2, e2, r2, n2) {
          this.skuToken = e2, this.errorCb = n2, i.EVENTS_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(yt)));
        }
        processRequests(t2) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: e2, timestamp: n2 } = this.queue.shift();
          e2 && this.success[e2] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h3, skuToken: this.skuToken, userId: this.anonId }, (t3) => {
            t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
          }, t2));
        }
      }(), zt = Tt.postMapLoadEvent.bind(Tt), Bt = new class extends kt {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t2, e2) {
          i.EVENTS_URL && (t2 || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e2 }, t2);
        }
        processRequests(t2) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { timestamp: n2, performanceData: i2 } = this.queue.shift(), s2 = function(t3) {
            const n3 = e.performance.getEntriesByType("resource"), i3 = e.performance.getEntriesByType("mark"), s3 = function(t4) {
              const e2 = {};
              if (t4) {
                for (const r2 in t4)
                  if (r2 !== "other")
                    for (const n4 of t4[r2]) {
                      const t5 = `${r2}ResolveRangeMin`, i4 = `${r2}ResolveRangeMax`, s4 = `${r2}RequestCount`, a3 = `${r2}RequestCachedCount`;
                      e2[t5] = Math.min(e2[t5] || 1 / 0, n4.startTime), e2[i4] = Math.max(e2[i4] || -1 / 0, n4.responseEnd);
                      const o3 = (t6) => {
                        e2[t6] === void 0 && (e2[t6] = 0), ++e2[t6];
                      };
                      n4.transferSize !== void 0 && n4.transferSize === 0 && o3(a3), o3(s4);
                    }
              }
              return e2;
            }(function(t4, e2) {
              const r2 = {};
              if (t4)
                for (const n4 of t4) {
                  const t5 = e2(n4);
                  r2[t5] === void 0 && (r2[t5] = []), r2[t5].push(n4);
                }
              return r2;
            }(n3, Ft)), a2 = e.devicePixelRatio, o2 = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection, l2 = { counters: [], metadata: [], attributes: [] }, u2 = (t4, e2, r2) => {
              r2 != null && t4.push({ name: e2, value: r2.toString() });
            };
            for (const t4 in s3)
              u2(l2.counters, t4, s3[t4]);
            if (t3.interactionRange[0] !== 1 / 0 && t3.interactionRange[1] !== -1 / 0 && (u2(l2.counters, "interactionRangeMin", t3.interactionRange[0]), u2(l2.counters, "interactionRangeMax", t3.interactionRange[1])), i3)
              for (const t4 of Object.keys(Vt)) {
                const e2 = Vt[t4], r2 = i3.find((t5) => t5.name === e2);
                r2 && u2(l2.counters, e2, r2.startTime);
              }
            return u2(l2.counters, "visibilityHidden", t3.visibilityHidden), u2(l2.attributes, "style", function(t4) {
              if (t4)
                for (const e2 of t4) {
                  const t5 = e2.name.split("?")[0];
                  if (vt(t5)) {
                    const e3 = t5.split("/").slice(-2);
                    if (e3.length === 2)
                      return `mapbox://styles/${e3[0]}/${e3[1]}`;
                  }
                }
            }(n3)), u2(l2.attributes, "terrainEnabled", t3.terrainEnabled ? "true" : "false"), u2(l2.attributes, "fogEnabled", t3.fogEnabled ? "true" : "false"), u2(l2.attributes, "projection", t3.projection), u2(l2.attributes, "zoom", t3.zoom), u2(l2.metadata, "devicePixelRatio", a2), u2(l2.metadata, "connectionEffectiveType", o2 ? o2.effectiveType : void 0), u2(l2.metadata, "navigatorUserAgent", e.navigator.userAgent), u2(l2.metadata, "screenWidth", e.screen.width), u2(l2.metadata, "screenHeight", e.screen.height), u2(l2.metadata, "windowWidth", e.innerWidth), u2(l2.metadata, "windowHeight", e.innerHeight), u2(l2.metadata, "mapWidth", t3.width / a2), u2(l2.metadata, "mapHeight", t3.height / a2), u2(l2.metadata, "webglRenderer", t3.renderer), u2(l2.metadata, "webglVendor", t3.vendor), u2(l2.metadata, "sdkVersion", r), u2(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
          }(i2);
          for (const t3 of s2.metadata)
            ;
          for (const t3 of s2.counters)
            ;
          for (const t3 of s2.attributes)
            ;
          this.postEvent(n2, s2, () => {
          }, t2);
        }
      }(), Et = Bt.postPerformanceEvent.bind(Bt), Ct = new class extends kt {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t2, e2, r2, n2) {
          if (!i.API_URL || !i.SESSION_PATH)
            return;
          const s2 = _t(i.API_URL + i.SESSION_PATH);
          s2.params.push(`sku=${e2 || ""}`), s2.params.push(`access_token=${n2 || i.ACCESS_TOKEN || ""}`);
          const a2 = { url: At(s2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = function(t3, e3) {
            return lt(z(t3, { method: "GET" }), e3);
          }(a2, (t3) => {
            this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n2);
          });
        }
        getSessionAPI(t2, e2, r2, n2) {
          this.skuToken = e2, this.errorCb = n2, i.SESSION_PATH && i.API_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(yt)));
        }
        processRequests(t2) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: e2, timestamp: r2 } = this.queue.shift();
          e2 && this.success[e2] || this.getSession(r2, this.skuToken, (t3) => {
            t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
          }, t2);
        }
      }(), Pt = Ct.getSessionAPI.bind(Ct), Dt = /* @__PURE__ */ new Set(), Vt = { create: "create", load: "load", fullLoad: "fullLoad" }, Lt = { mark(t2) {
        e.performance.mark(t2);
      }, measure(t2, r2, n2) {
        e.performance.measure(t2, r2, n2);
      } };
      function Ft(t2) {
        const e2 = t2.name.split("?")[0];
        return xt(e2) && e2.includes("mapbox-gl.js") ? "javascript" : xt(e2) && e2.includes("mapbox-gl.css") ? "css" : function(t3) {
          return i.API_FONTS_REGEX.test(t3);
        }(e2) ? "fontRange" : bt(e2) ? "sprite" : vt(e2) ? "style" : function(t3) {
          return i.API_TILEJSON_REGEX.test(t3);
        }(e2) ? "tilejson" : "other";
      }
      const Rt = e.performance;
      function jt(t2) {
        const e2 = t2 ? t2.url.toString() : void 0;
        return Rt.getEntriesByName(e2);
      }
      let Ut, $t, Ot, qt;
      const Nt = { now: () => Ot !== void 0 ? Ot : e.performance.now(), setNow(t2) {
        Ot = t2;
      }, restoreNow() {
        Ot = void 0;
      }, frame(t2) {
        const r2 = e.requestAnimationFrame(t2);
        return { cancel: () => e.cancelAnimationFrame(r2) };
      }, getImageData(t2, r2 = 0) {
        const { width: n2, height: i2 } = t2;
        qt || (qt = e.document.createElement("canvas"));
        const s2 = qt.getContext("2d", { willReadFrequently: true });
        if (!s2)
          throw new Error("failed to create canvas 2d context");
        return (n2 > qt.width || i2 > qt.height) && (qt.width = n2, qt.height = i2), s2.clearRect(-r2, -r2, n2 + 2 * r2, i2 + 2 * r2), s2.drawImage(t2, 0, 0, n2, i2), s2.getImageData(-r2, -r2, n2 + 2 * r2, i2 + 2 * r2);
      }, resolveURL: (t2) => (Ut || (Ut = e.document.createElement("a")), Ut.href = t2, Ut.href), get devicePixelRatio() {
        return e.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!e.matchMedia && ($t == null && ($t = e.matchMedia("(prefers-reduced-motion: reduce)")), $t.matches);
      } };
      function Gt(t2, e2, r2) {
        r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function Xt(t2, e2, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e2);
          n2 !== -1 && r2[t2].splice(n2, 1);
        }
      }
      class Zt {
        constructor(t2, e2 = {}) {
          z(this, e2), this.type = t2;
        }
      }
      class Kt extends Zt {
        constructor(t2, e2 = {}) {
          super("error", z({ error: t2 }, e2));
        }
      }
      class Yt {
        on(t2, e2) {
          return this._listeners = this._listeners || {}, Gt(t2, e2, this._listeners), this;
        }
        off(t2, e2) {
          return Xt(t2, e2, this._listeners), Xt(t2, e2, this._oneTimeListeners), this;
        }
        once(t2, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e2) {
          typeof t2 == "string" && (t2 = new Zt(t2, e2 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              Xt(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (z(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof Kt && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
        }
        setEventedParent(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        }
      }
      var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function Wt(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      function Jt(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function Qt(t2) {
        if (Array.isArray(t2))
          return t2.map(Qt);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e2 = {};
          for (const r2 in t2)
            e2[r2] = Qt(t2[r2]);
          return e2;
        }
        return Jt(t2);
      }
      class te extends Error {
        constructor(t2, e2) {
          super(e2), this.message = e2, this.key = t2;
        }
      }
      var ee = te;
      class re {
        constructor(t2, e2 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e2)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new re(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      var ne = re;
      const ie = { kind: "null" }, se = { kind: "number" }, ae = { kind: "string" }, oe = { kind: "boolean" }, le = { kind: "color" }, ue = { kind: "object" }, ce = { kind: "value" }, he = { kind: "collator" }, pe = { kind: "formatted" }, fe = { kind: "resolvedImage" };
      function de(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function ye(t2) {
        if (t2.kind === "array") {
          const e2 = ye(t2.itemType);
          return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
        }
        return t2.kind;
      }
      const me = [ie, se, ae, oe, le, pe, ue, de(ce), fe];
      function ge(t2, e2) {
        if (e2.kind === "error")
          return null;
        if (t2.kind === "array") {
          if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !ge(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if (t2.kind === "value") {
            for (const t3 of me)
              if (!ge(t3, e2))
                return null;
          }
        }
        return `Expected ${ye(t2)} but found ${ye(e2)} instead.`;
      }
      function xe(t2, e2) {
        return e2.some((e3) => e3.kind === t2.kind);
      }
      function ve(t2, e2) {
        return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
      }
      var be, we = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function _e(t2) {
        return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
      }
      function Ae(t2) {
        return _e(t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 * 255 : parseInt(t2));
      }
      function Se(t2) {
        return (e2 = t2[t2.length - 1] === "%" ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
        var e2;
      }
      function ke(t2, e2, r2) {
        return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e2 - t2) * r2 * 6 : 2 * r2 < 1 ? e2 : 3 * r2 < 2 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
      }
      try {
        be = {}.parseCSSColor = function(t2) {
          var e2, r2 = t2.replace(/ /g, "").toLowerCase();
          if (r2 in we)
            return we[r2].slice();
          if (r2[0] === "#")
            return r2.length === 4 ? (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : r2.length === 7 && (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
          var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
          if (n2 !== -1 && i2 + 1 === r2.length) {
            var s2 = r2.substr(0, n2), a2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
            switch (s2) {
              case "rgba":
                if (a2.length !== 4)
                  return null;
                o2 = Se(a2.pop());
              case "rgb":
                return a2.length !== 3 ? null : [Ae(a2[0]), Ae(a2[1]), Ae(a2[2]), o2];
              case "hsla":
                if (a2.length !== 4)
                  return null;
                o2 = Se(a2.pop());
              case "hsl":
                if (a2.length !== 3)
                  return null;
                var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Se(a2[1]), c2 = Se(a2[2]), h4 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h4;
                return [_e(255 * ke(p2, h4, l2 + 1 / 3)), _e(255 * ke(p2, h4, l2)), _e(255 * ke(p2, h4, l2 - 1 / 3)), o2];
              default:
                return null;
            }
          }
          return null;
        };
      } catch (t2) {
      }
      class Ie {
        constructor(t2, e2, r2, n2 = 1) {
          this.r = t2, this.g = e2, this.b = r2, this.a = n2;
        }
        static parse(t2) {
          if (!t2)
            return;
          if (t2 instanceof Ie)
            return t2;
          if (typeof t2 != "string")
            return;
          const e2 = be(t2);
          return e2 ? new Ie(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
        }
        toString() {
          const [t2, e2, r2, n2] = this.toArray();
          return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
        }
        toArray() {
          const { r: t2, g: e2, b: r2, a: n2 } = this;
          return n2 === 0 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
        }
        toArray01() {
          const { r: t2, g: e2, b: r2, a: n2 } = this;
          return n2 === 0 ? [0, 0, 0, 0] : [t2 / n2, e2 / n2, r2 / n2, n2];
        }
        toArray01PremultipliedAlpha() {
          const { r: t2, g: e2, b: r2, a: n2 } = this;
          return [t2, e2, r2, n2];
        }
      }
      Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
      var Me = Ie;
      class Te {
        constructor(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t2, e2) {
          return this.collator.compare(t2, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class ze {
        constructor(t2, e2, r2, n2, i2) {
          this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }
      }
      class Be {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new Be([new ze(t2, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
        }
        static factory(t2) {
          return t2 instanceof Be ? t2 : Be.fromString(t2);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
        }
        serialize() {
          const t2 = ["format"];
          for (const e2 of this.sections) {
            if (e2.image) {
              t2.push(["image", e2.image.name]);
              continue;
            }
            t2.push(e2.text);
            const r2 = {};
            e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r2);
          }
          return t2;
        }
      }
      class Ee {
        constructor(t2) {
          this.name = t2.name, this.available = t2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t2) {
          return t2 ? new Ee({ name: t2, available: false }) : null;
        }
        serialize() {
          return ["image", this.name];
        }
      }
      function Ce(t2, e2, r2, n2) {
        return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === void 0 || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Pe(t2) {
        if (t2 === null)
          return true;
        if (typeof t2 == "string")
          return true;
        if (typeof t2 == "boolean")
          return true;
        if (typeof t2 == "number")
          return true;
        if (t2 instanceof Me)
          return true;
        if (t2 instanceof Te)
          return true;
        if (t2 instanceof Be)
          return true;
        if (t2 instanceof Ee)
          return true;
        if (Array.isArray(t2)) {
          for (const e2 of t2)
            if (!Pe(e2))
              return false;
          return true;
        }
        if (typeof t2 == "object") {
          for (const e2 in t2)
            if (!Pe(t2[e2]))
              return false;
          return true;
        }
        return false;
      }
      function De(t2) {
        if (t2 === null)
          return ie;
        if (typeof t2 == "string")
          return ae;
        if (typeof t2 == "boolean")
          return oe;
        if (typeof t2 == "number")
          return se;
        if (t2 instanceof Me)
          return le;
        if (t2 instanceof Te)
          return he;
        if (t2 instanceof Be)
          return pe;
        if (t2 instanceof Ee)
          return fe;
        if (Array.isArray(t2)) {
          const e2 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = De(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = ce;
              break;
            }
            r2 = t3;
          }
          return de(r2 || ce, e2);
        }
        return ue;
      }
      function Ve(t2) {
        const e2 = typeof t2;
        return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof Me || t2 instanceof Be || t2 instanceof Ee ? t2.toString() : JSON.stringify(t2);
      }
      class Le {
        constructor(t2, e2) {
          this.type = t2, this.value = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!Pe(t2[1]))
            return e2.error("invalid value");
          const r2 = t2[1];
          let n2 = De(r2);
          const i2 = e2.expectedType;
          return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new Le(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
        }
      }
      var Fe = Le, Re = class {
        constructor(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        }
        toJSON() {
          return this.message;
        }
      };
      const je = { string: ae, number: se, boolean: oe, object: ue };
      class Ue {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if (i2 === "array") {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if (typeof r3 != "string" || !(r3 in je) || r3 === "object")
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = je[r3], n2++;
            } else
              i3 = ce;
            if (t2.length > 3) {
              if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = de(i3, s3);
          } else
            r2 = je[i2];
          const s2 = [];
          for (; n2 < t2.length; n2++) {
            const r3 = e2.parse(t2[n2], n2, ce);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new Ue(r2, s2);
        }
        evaluate(t2) {
          for (let e2 = 0; e2 < this.args.length; e2++) {
            const r2 = this.args[e2].evaluate(t2);
            if (!ge(this.type, De(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r2))} instead.`);
          }
          return null;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = this.type, e2 = [t2.kind];
          if (t2.kind === "array") {
            const r2 = t2.itemType;
            if (r2.kind === "string" || r2.kind === "number" || r2.kind === "boolean") {
              e2.push(r2.kind);
              const n2 = t2.N;
              (typeof n2 == "number" || this.args.length > 1) && e2.push(n2);
            }
          }
          return e2.concat(this.args.map((t3) => t3.serialize()));
        }
      }
      var $e = Ue;
      class Oe {
        constructor(t2) {
          this.type = pe, this.sections = t2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && typeof r2 == "object")
            return e2.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, se), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, de(ae)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, le), !a2))
                return null;
              const o2 = n2[n2.length - 1];
              o2.scale = t3, o2.font = r4, o2.textColor = a2;
            } else {
              const s3 = e2.parse(t2[r3], 1, ce);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new Oe(n2);
        }
        evaluate(t2) {
          return new Be(this.sections.map((e2) => {
            const r2 = e2.content.evaluate(t2);
            return De(r2) === fe ? new ze("", r2, null, null, null) : new ze(Ve(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e2 of this.sections)
            t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["format"];
          for (const e2 of this.sections) {
            t2.push(e2.content.serialize());
            const r2 = {};
            e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
          }
          return t2;
        }
      }
      class qe {
        constructor(t2) {
          this.type = fe, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, ae);
          return r2 ? new qe(r2) : e2.error("No image name provided.");
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = Ee.fromString(e2);
          return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["image", this.input.serialize()];
        }
      }
      const Ne = { "to-boolean": oe, "to-color": le, "to-number": se, "to-string": ae };
      class Ge {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[0];
          if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
            return e2.error("Expected one argument.");
          const n2 = Ne[r2], i2 = [];
          for (let r3 = 1; r3 < t2.length; r3++) {
            const n3 = e2.parse(t2[r3], r3, ce);
            if (!n3)
              return null;
            i2.push(n3);
          }
          return new Ge(n2, i2);
        }
        evaluate(t2) {
          if (this.type.kind === "boolean")
            return Boolean(this.args[0].evaluate(t2));
          if (this.type.kind === "color") {
            let e2, r2;
            for (const n2 of this.args) {
              if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Me)
                return e2;
              if (typeof e2 == "string") {
                const r3 = t2.parseColor(e2);
                if (r3)
                  return r3;
              } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ce(e2[0], e2[1], e2[2], e2[3]), !r2))
                return new Me(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
            }
            throw new Re(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : String(JSON.stringify(e2))}'`);
          }
          if (this.type.kind === "number") {
            let e2 = null;
            for (const r2 of this.args) {
              if (e2 = r2.evaluate(t2), e2 === null)
                return 0;
              const n2 = Number(e2);
              if (!isNaN(n2))
                return n2;
            }
            throw new Re(`Could not convert ${JSON.stringify(e2)} to number.`);
          }
          return this.type.kind === "formatted" ? Be.fromString(Ve(this.args[0].evaluate(t2))) : this.type.kind === "resolvedImage" ? Ee.fromString(Ve(this.args[0].evaluate(t2))) : Ve(this.args[0].evaluate(t2));
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          if (this.type.kind === "formatted")
            return new Oe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage")
            return new qe(this.args[0]).serialize();
          const t2 = [`to-${this.type.kind}`];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      var Xe = Ge;
      const Ze = ["Unknown", "Point", "LineString", "Polygon"];
      var Ke = class {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Ze[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
          }
          return 0;
        }
        parseColor(t2) {
          let e2 = this._parseColorCache[t2];
          return e2 || (e2 = this._parseColorCache[t2] = Me.parse(t2)), e2;
        }
      };
      class Ye {
        constructor(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        }
        evaluate(t2) {
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t2) => t2.serialize()));
        }
        static parse(t2, e2) {
          const r2 = t2[0], n2 = Ye.definitions[r2];
          if (!n2)
            return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
          let o2 = null;
          for (const [n3, s3] of a2) {
            o2 = new _r(e2.registry, e2.path, null, e2.scope);
            const a3 = [];
            let l2 = false;
            for (let e3 = 1; e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
              if (!s4) {
                l2 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l2)
              if (Array.isArray(n3) && n3.length !== a3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0; t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (o2.errors.length === 0)
                  return new Ye(r2, i2, s3, a3);
              }
          }
          if (a2.length === 1)
            e2.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2).map(([t3]) => {
              return e3 = t3, Array.isArray(e3) ? `(${e3.map(ye).join(", ")})` : `(${ye(e3.type)}...)`;
              var e3;
            }).join(" | "), n3 = [];
            for (let r4 = 1; r4 < t2.length; r4++) {
              const i3 = e2.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(ye(i3.type));
            }
            e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e2) {
          Ye.definitions = e2;
          for (const r2 in e2)
            t2[r2] = Ye;
        }
      }
      var He = Ye;
      class We {
        constructor(t2, e2, r2) {
          this.type = he, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected one argument.");
          const r2 = t2[1];
          if (typeof r2 != "object" || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          const n2 = e2.parse(r2["case-sensitive"] !== void 0 && r2["case-sensitive"], 1, oe);
          if (!n2)
            return null;
          const i2 = e2.parse(r2["diacritic-sensitive"] !== void 0 && r2["diacritic-sensitive"], 1, oe);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e2.parse(r2.locale, 1, ae), !s2) ? null : new We(n2, i2, s2);
        }
        evaluate(t2) {
          return new Te(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
        }
      }
      const Je = 8192;
      function Qe(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function tr(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function er(t2, e2) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * Je), Math.round(n2 * i2 * Je)];
      }
      function rr(t2, e2, r2) {
        const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function nr(t2, e2) {
        let r2 = false;
        for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
          const o3 = e2[a2];
          for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
            if (rr(t2, o3[e3], o3[e3 + 1]))
              return false;
            (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
          }
        }
        var n2, i2, s2;
        return r2;
      }
      function ir(t2, e2) {
        for (let r2 = 0; r2 < e2.length; r2++)
          if (nr(t2, e2[r2]))
            return true;
        return false;
      }
      function sr(t2, e2, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function ar(t2, e2, r2) {
        for (const u2 of r2)
          for (let r3 = 0; r3 < u2.length - 1; ++r3)
            if ((o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] != 0 && sr(n2, i2, s2, a2) && sr(s2, a2, n2, i2))
              return true;
        var n2, i2, s2, a2, o2, l2;
        return false;
      }
      function or(t2, e2) {
        for (let r2 = 0; r2 < t2.length; ++r2)
          if (!nr(t2[r2], e2))
            return false;
        for (let r2 = 0; r2 < t2.length - 1; ++r2)
          if (ar(t2[r2], t2[r2 + 1], e2))
            return false;
        return true;
      }
      function lr(t2, e2) {
        for (let r2 = 0; r2 < e2.length; r2++)
          if (or(t2, e2[r2]))
            return true;
        return false;
      }
      function ur(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0; n3 < t2[i2].length; n3++) {
            const a2 = er(t2[i2][n3], r2);
            Qe(e2, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function cr(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = ur(t2[i2], e2, r2);
          n2.push(s2);
        }
        return n2;
      }
      function hr(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        Qe(e2, t2);
      }
      function pr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
        if (!t2)
          return a2;
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            hr(n4, e2, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function fr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Je, s2 = [n2.x * Je, n2.y * Je], a2 = [];
        if (!t2)
          return a2;
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Qe(e2, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              hr(n3, e2, r2, i2);
        }
        var o2;
        return a2;
      }
      class dr {
        constructor(t2, e2) {
          this.type = oe, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (Pe(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection")
              for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r2 = e3.features[t3].geometry.type;
                if (r2 === "Polygon" || r2 === "MultiPolygon")
                  return new dr(e3, e3.features[t3].geometry);
              }
            else if (e3.type === "Feature") {
              const t3 = e3.geometry.type;
              if (t3 === "Polygon" || t3 === "MultiPolygon")
                return new dr(e3, e3.geometry);
            } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
              return new dr(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if (e2.type === "Polygon") {
                  const s2 = ur(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r2, n2, i2);
                  if (!tr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!nr(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = cr(e2.coordinates, n2, i2), a2 = pr(t3.geometry(), r2, n2, i2);
                  if (!tr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!ir(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if (e2.type === "Polygon") {
                  const s2 = ur(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r2, n2, i2);
                  if (!tr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!or(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = cr(e2.coordinates, n2, i2), a2 = fr(t3.geometry(), r2, n2, i2);
                  if (!tr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!lr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var yr = dr;
      function mr(t2) {
        if (t2 instanceof He) {
          if (t2.name === "get" && t2.args.length === 1)
            return false;
          if (t2.name === "feature-state")
            return false;
          if (t2.name === "has" && t2.args.length === 1)
            return false;
          if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof yr)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !mr(t3) && (e2 = false);
        }), e2;
      }
      function gr(t2) {
        if (t2 instanceof He && t2.name === "feature-state")
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !gr(t3) && (e2 = false);
        }), e2;
      }
      function xr(t2, e2) {
        if (t2 instanceof He && e2.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !xr(t3, e2) && (r2 = false);
        }), r2;
      }
      class vr {
        constructor(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2 || typeof t2[1] != "string")
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e2.scope.has(r2) ? new vr(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var br = vr;
      class wr {
        constructor(t2, e2 = [], r2, n2 = new ne(), i2 = []) {
          this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
        }
        parse(t2, e2, r2, n2, i2 = {}) {
          return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e2) {
          function r2(t3, e3, r3) {
            return r3 === "assert" ? new $e(e3, [t3]) : r3 === "coerce" ? new Xe(e3, [t3]) : t3;
          }
          if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (t2.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = t2[0];
            if (typeof n2 != "string")
              return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n2];
            if (i2) {
              let n3 = i2.parse(t2, this);
              if (!n3)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, i3 = n3.type;
                if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                  if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string") {
                    if (this.checkSubtype(t3, i3))
                      return null;
                  } else
                    n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                else
                  n3 = r2(n3, t3, e2.typeAnnotation || "assert");
              }
              if (!(n3 instanceof Fe) && n3.type.kind !== "resolvedImage" && Ar(n3)) {
                const t3 = new Ke();
                try {
                  n3 = new Fe(n3.type, n3.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return n3;
            }
            return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t2 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e2, r2) {
          const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new wr(this.registry, n2, e2 || null, i2, this.errors);
        }
        error(t2, ...e2) {
          const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new ee(r2, t2));
        }
        checkSubtype(t2, e2) {
          const r2 = ge(t2, e2);
          return r2 && this.error(r2), r2;
        }
      }
      var _r = wr;
      function Ar(t2) {
        if (t2 instanceof br)
          return Ar(t2.boundExpression);
        if (t2 instanceof He && t2.name === "error")
          return false;
        if (t2 instanceof We)
          return false;
        if (t2 instanceof yr)
          return false;
        const e2 = t2 instanceof Xe || t2 instanceof $e;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e2 ? r2 && Ar(t3) : r2 && t3 instanceof Fe;
        }), !!r2 && mr(t2) && xr(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
      }
      function Sr(t2, e2) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (; s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2))
              throw new Re("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      class kr {
        constructor(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r2 = e2.parse(t2[1], 1, se);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
          for (let r3 = 1; r3 < t2.length; r3 += 2) {
            const s2 = r3 === 1 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
            if (typeof s2 != "number")
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u2 = e2.parse(a2, l2, i2);
            if (!u2)
              return null;
            i2 = i2 || u2.type, n2.push([s2, u2]);
          }
          return new kr(i2, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Sr(e2, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["step", this.input.serialize()];
          for (let e2 = 0; e2 < this.labels.length; e2++)
            e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
          return t2;
        }
      }
      var Ir = kr;
      function Mr(t2, e2, r2) {
        return t2 * (1 - r2) + e2 * r2;
      }
      var Tr = Object.freeze({ __proto__: null, number: Mr, color: function(t2, e2, r2) {
        return new Me(Mr(t2.r, e2.r, r2), Mr(t2.g, e2.g, r2), Mr(t2.b, e2.b, r2), Mr(t2.a, e2.a, r2));
      }, array: function(t2, e2, r2) {
        return t2.map((t3, n2) => Mr(t3, e2[n2], r2));
      } });
      const zr = 0.95047, Br = 1.08883, Er = 4 / 29, Cr = 6 / 29, Pr = 3 * Cr * Cr, Dr = Math.PI / 180, Vr = 180 / Math.PI;
      function Lr(t2) {
        return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pr + Er;
      }
      function Fr(t2) {
        return t2 > Cr ? t2 * t2 * t2 : Pr * (t2 - Er);
      }
      function Rr(t2) {
        return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
      }
      function jr(t2) {
        return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function Ur(t2) {
        const e2 = jr(t2.r), r2 = jr(t2.g), n2 = jr(t2.b), i2 = Lr((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / zr), s2 = Lr((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Lr((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / Br)), alpha: t2.a };
      }
      function $r(t2) {
        let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
        return e2 = 1 * Fr(e2), r2 = zr * Fr(r2), n2 = Br * Fr(n2), new Me(Rr(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Rr(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Rr(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
      }
      function Or(t2, e2, r2) {
        const n2 = e2 - t2;
        return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
      }
      const qr = { forward: Ur, reverse: $r, interpolate: function(t2, e2, r2) {
        return { l: Mr(t2.l, e2.l, r2), a: Mr(t2.a, e2.a, r2), b: Mr(t2.b, e2.b, r2), alpha: Mr(t2.alpha, e2.alpha, r2) };
      } }, Nr = { forward: function(t2) {
        const { l: e2, a: r2, b: n2 } = Ur(t2), i2 = Math.atan2(n2, r2) * Vr;
        return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
      }, reverse: function(t2) {
        const e2 = t2.h * Dr, r2 = t2.c;
        return $r({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
      }, interpolate: function(t2, e2, r2) {
        return { h: Or(t2.h, e2.h, r2), c: Mr(t2.c, e2.c, r2), l: Mr(t2.l, e2.l, r2), alpha: Mr(t2.alpha, e2.alpha, r2) };
      } };
      var Gr = Object.freeze({ __proto__: null, lab: qr, hcl: Nr });
      class Xr {
        constructor(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e2, r2, n2) {
          let i2 = 0;
          if (t2.name === "exponential")
            i2 = Zr(e2, t2.base, r2, n2);
          else if (t2.name === "linear")
            i2 = Zr(e2, 1, r2, n2);
          else if (t2.name === "cubic-bezier") {
            const s2 = t2.controlPoints;
            i2 = new p(s2[0], s2[1], s2[2], s2[3]).solve(Zr(e2, 1, r2, n2));
          }
          return i2;
        }
        static parse(t2, e2) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || n2.length === 0)
            return e2.error("Expected an interpolation type expression.", 1);
          if (n2[0] === "linear")
            n2 = { name: "linear" };
          else if (n2[0] === "exponential") {
            const t3 = n2[1];
            if (typeof t3 != "number")
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if (n2[0] !== "cubic-bezier")
              return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, se), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          r2 === "interpolate-hcl" || r2 === "interpolate-lab" ? o2 = le : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
            if (typeof r3 != "number")
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u2 = e2.parse(n3, l2, o2);
            if (!u2)
              return null;
            o2 = o2 || u2.type, a2.push([r3, u2]);
          }
          return o2.kind === "number" || o2.kind === "color" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new Xr(o2, r2, n2, i2, a2) : e2.error(`Type ${ye(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = Sr(e2, n2), a2 = Xr.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
          return this.operator === "interpolate" ? Tr[this.type.kind.toLowerCase()](o2, l2, a2) : this.operator === "interpolate-hcl" ? Nr.reverse(Nr.interpolate(Nr.forward(o2), Nr.forward(l2), a2)) : qr.reverse(qr.interpolate(qr.forward(o2), qr.forward(l2), a2));
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          let t2;
          t2 = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const e2 = [this.operator, t2, this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++)
            e2.push(this.labels[t3], this.outputs[t3].serialize());
          return e2;
        }
      }
      function Zr(t2, e2, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }
      var Kr = Xr;
      class Yr {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expectected at least one argument.");
          let r2 = null;
          const n2 = e2.expectedType;
          n2 && n2.kind !== "value" && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          const s2 = n2 && i2.some((t3) => ge(n2, t3.type));
          return new Yr(s2 ? ce : r2, i2);
        }
        evaluate(t2) {
          let e2, r2 = null, n2 = 0;
          for (const i2 of this.args) {
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Ee && !r2.available && (e2 || (e2 = r2), r2 = null, n2 === this.args.length))
              return e2;
            if (r2 !== null)
              break;
          }
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["coalesce"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      var Hr = Yr;
      class Wr {
        constructor(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e2 of this.bindings)
            t2(e2[1]);
          t2(this.result);
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if (typeof i2 != "string")
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e2.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return n2 ? new Wr(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t2 = ["let"];
          for (const [e2, r2] of this.bindings)
            t2.push(e2, r2.serialize());
          return t2.push(this.result.serialize()), t2;
        }
      }
      var Jr = Wr;
      class Qr {
        constructor(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, se), n2 = e2.parse(t2[2], 2, de(e2.expectedType || ce));
          return r2 && n2 ? new Qr(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new Re(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r2.length)
            throw new Re(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new Re(`Array index must be an integer, but found ${e2} instead.`);
          return r2[e2];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var tn = Qr;
      class en {
        constructor(t2, e2) {
          this.type = oe, this.needle = t2, this.haystack = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
          return r2 && n2 ? xe(r2.type, [oe, ae, se, ie, ce]) ? new en(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (r2 == null)
            return false;
          if (!ve(e2, ["boolean", "string", "number", "null"]))
            throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
          if (!ve(r2, ["string", "array"]))
            throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r2))} instead.`);
          return r2.indexOf(e2) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var rn = en;
      class nn {
        constructor(t2, e2, r2) {
          this.type = se, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, ce);
          if (!r2 || !n2)
            return null;
          if (!xe(r2.type, [oe, ae, se, ie, ce]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, se);
            return i2 ? new nn(r2, n2, i2) : null;
          }
          return new nn(r2, n2);
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!ve(e2, ["boolean", "string", "number", "null"]))
            throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e2))} instead.`);
          if (!ve(r2, ["string", "array"]))
            throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r2))} instead.`);
          if (this.fromIndex) {
            const n2 = this.fromIndex.evaluate(t2);
            return r2.indexOf(e2, n2);
          }
          return r2.indexOf(e2);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const t2 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var sn = nn;
      class an {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e2) {
          if (t2.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r2, n2;
          e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l2 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u2 = e2.concat(a3);
            if (o3.length === 0)
              return u2.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if (typeof t3 != "number" && typeof t3 != "string")
                return u2.error("Branch labels must be numbers or strings.");
              if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof t3 == "number" && Math.floor(t3) !== t3)
                return u2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u2.checkSubtype(r2, De(t3)))
                  return null;
              } else
                r2 = De(t3);
              if (i2[String(t3)] !== void 0)
                return u2.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e2.parse(l2, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t2[1], 1, ce);
          if (!a2)
            return null;
          const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, a2.type) ? null : new an(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          return (De(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
          for (const t3 of e2) {
            const e3 = n2[this.cases[t3]];
            e3 === void 0 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
          }
          const i2 = (t3) => this.inputType.kind === "number" ? Number(t3) : t3;
          for (const [e3, n3] of r2)
            t2.push(n3.length === 1 ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
          return t2.push(this.otherwise.serialize()), t2;
        }
      }
      var on = an;
      class ln {
        constructor(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r2;
          e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
          const n2 = [];
          for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
            const s2 = e2.parse(t2[i3], i3, oe);
            if (!s2)
              return null;
            const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          return i2 ? new ln(r2, n2, i2) : null;
        }
        evaluate(t2) {
          for (const [e2, r2] of this.branches)
            if (e2.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e2, r2] of this.branches)
            t2(e2), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["case"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      var un = ln;
      class cn {
        constructor(t2, e2, r2, n2) {
          this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, ce), n2 = e2.parse(t2[2], 2, se);
          if (!r2 || !n2)
            return null;
          if (!xe(r2.type, [de(ce), ae, ce]))
            return e2.error(`Expected first argument to be of type array or string, but found ${ye(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, se);
            return i2 ? new cn(r2.type, r2, n2, i2) : null;
          }
          return new cn(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          if (!ve(e2, ["string", "array"]))
            throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e2))} instead.`);
          if (this.endIndex) {
            const n2 = this.endIndex.evaluate(t2);
            return e2.slice(r2, n2);
          }
          return e2.slice(r2);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const t2 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var hn = cn;
      function pn(t2, e2) {
        return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
      }
      function fn(t2, e2, r2, n2) {
        return n2.compare(e2, r2) === 0;
      }
      function dn(t2, e2, r2) {
        const n2 = t2 !== "==" && t2 !== "!=";
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = oe, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
          }
          static parse(t3, e3) {
            if (t3.length !== 3 && t3.length !== 4)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, ce);
            if (!s2)
              return null;
            if (!pn(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${ye(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, ce);
            if (!a2)
              return null;
            if (!pn(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${ye(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
              return e3.error(`Cannot compare types '${ye(s2.type)}' and '${ye(a2.type)}'.`);
            n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new $e(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new $e(s2.type, [a2])));
            let o2 = null;
            if (t3.length === 4) {
              if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, he), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = De(s2), r3 = De(a2);
              if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                throw new Re(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = De(s2), r3 = De(a2);
              if (t3.kind !== "string" || r3.kind !== "string")
                return e2(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t2];
            return this.eachChild((t3) => {
              e3.push(t3.serialize());
            }), e3;
          }
        };
      }
      const yn = dn("==", function(t2, e2, r2) {
        return e2 === r2;
      }, fn), mn = dn("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !fn(0, e2, r2, n2);
      }), gn = dn("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), xn = dn(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), vn = dn("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), bn = dn(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      });
      class wn {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.type = ae, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, se);
          if (!r2)
            return null;
          const n2 = t2[2];
          if (typeof n2 != "object" || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e2.parse(n2.locale, 1, ae), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e2.parse(n2.currency, 1, ae), !s2))
            return null;
          let a2 = null;
          if (n2.unit && (a2 = e2.parse(n2.unit, 1, ae), !a2))
            return null;
          let o2 = null;
          if (n2["min-fraction-digits"] && (o2 = e2.parse(n2["min-fraction-digits"], 1, se), !o2))
            return null;
          let l2 = null;
          return n2["max-fraction-digits"] && (l2 = e2.parse(n2["max-fraction-digits"], 1, se), !l2) ? null : new wn(r2, i2, s2, a2, o2, l2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
        }
      }
      class _n {
        constructor(t2) {
          this.type = se, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1);
          return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${ye(r2.type)} instead.`) : new _n(r2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          if (typeof e2 == "string")
            return e2.length;
          if (Array.isArray(e2))
            return e2.length;
          throw new Re(`Expected value to be of type string or array, but found ${ye(De(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["length"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      const An = { "==": yn, "!=": mn, ">": xn, "<": gn, ">=": bn, "<=": vn, array: $e, at: tn, boolean: $e, case: un, coalesce: Hr, collator: We, format: Oe, image: qe, in: rn, "index-of": sn, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: _n, let: Jr, literal: Fe, match: on, number: $e, "number-format": wn, object: $e, slice: hn, step: Ir, string: $e, "to-boolean": Xe, "to-color": Xe, "to-number": Xe, "to-string": Xe, var: br, within: yr };
      function Sn(t2, [e2, r2, n2, i2]) {
        e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Ce(e2, r2, n2, s2);
        if (a2)
          throw new Re(a2);
        return new Me(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
      }
      function kn(t2, e2) {
        return t2 in e2;
      }
      function In(t2, e2) {
        const r2 = e2[t2];
        return r2 === void 0 ? null : r2;
      }
      function Mn(t2) {
        return { type: t2 };
      }
      He.register(An, { error: [{ kind: "error" }, [ae], (t2, [e2]) => {
        throw new Re(e2.evaluate(t2));
      }], typeof: [ae, [ce], (t2, [e2]) => ye(De(e2.evaluate(t2)))], "to-rgba": [de(se, 4), [le], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [le, [se, se, se], Sn], rgba: [le, [se, se, se, se], Sn], has: { type: oe, overloads: [[[ae], (t2, [e2]) => kn(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r2]) => kn(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: ce, overloads: [[[ae], (t2, [e2]) => In(e2.evaluate(t2), t2.properties())], [[ae, ue], (t2, [e2, r2]) => In(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [ce, [ae], (t2, [e2]) => In(e2.evaluate(t2), t2.featureState || {})], properties: [ue, [], (t2) => t2.properties()], "geometry-type": [ae, [], (t2) => t2.geometryType()], id: [ce, [], (t2) => t2.id()], zoom: [se, [], (t2) => t2.globals.zoom], pitch: [se, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [se, [], (t2) => t2.distanceFromCenter()], "heatmap-density": [se, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [se, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [se, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [ce, [], (t2) => t2.globals.accumulated === void 0 ? null : t2.globals.accumulated], "+": [se, Mn(se), (t2, e2) => {
        let r2 = 0;
        for (const n2 of e2)
          r2 += n2.evaluate(t2);
        return r2;
      }], "*": [se, Mn(se), (t2, e2) => {
        let r2 = 1;
        for (const n2 of e2)
          r2 *= n2.evaluate(t2);
        return r2;
      }], "-": { type: se, overloads: [[[se, se], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[se], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [se, [se, se], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [se, [se, se], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [se, [], () => Math.LN2], pi: [se, [], () => Math.PI], e: [se, [], () => Math.E], "^": [se, [se, se], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [se, [se], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [se, [se], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [se, [se], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [se, [se], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [se, [se], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [se, [se], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [se, [se], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [se, [se], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [se, Mn(se), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [se, Mn(se), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [se, [se], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [se, [se], (t2, [e2]) => {
        const r2 = e2.evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [se, [se], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [se, [se], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [oe, [ae, ce], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [oe, [ce], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [oe, [ae], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [oe, [ae, ce], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter-id-<": [oe, [ce], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter->": [oe, [ae, ce], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-id->": [oe, [ce], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-<=": [oe, [ae, ce], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter-id-<=": [oe, [ce], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter->=": [oe, [ae, ce], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-id->=": [oe, [ce], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-has": [oe, [ce], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [oe, [], (t2) => t2.id() !== null && t2.id() !== void 0], "filter-type-in": [oe, [de(ae)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [oe, [de(ce)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [oe, [ae, de(ce)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [oe, [ae, de(ce)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
        for (; r3 <= n2; ) {
          const i2 = r3 + n2 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: oe, overloads: [[[oe, oe], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Mn(oe), (t2, e2) => {
        for (const r2 of e2)
          if (!r2.evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: oe, overloads: [[[oe, oe], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Mn(oe), (t2, e2) => {
        for (const r2 of e2)
          if (r2.evaluate(t2))
            return true;
        return false;
      }]] }, "!": [oe, [oe], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [oe, [ae], (t2, [e2]) => {
        const r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e2.evaluate(t2));
      }], upcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ae, [ae], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ae, Mn(ce), (t2, e2) => e2.map((e3) => Ve(e3.evaluate(t2))).join("")], "resolved-locale": [ae, [he], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
      var Tn = An;
      function zn(t2) {
        return { result: "success", value: t2 };
      }
      function Bn(t2) {
        return { result: "error", value: t2 };
      }
      function En(t2) {
        return t2["property-type"] === "data-driven";
      }
      function Cn(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function Pn(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function Dn(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
      }
      function Vn(t2) {
        return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
      }
      function Ln(t2) {
        return t2;
      }
      function Fn(t2, e2) {
        const r2 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== void 0), s2 = t2.type || (Pn(e2) ? "exponential" : "interval");
        if (r2 && ((t2 = Wt({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Me.parse(t3[1])])), t2.default = Me.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && t2.colorSpace !== "rgb" && !Gr[t2.colorSpace])
          throw new Error(`Unknown color space: ${t2.colorSpace}`);
        let a2, o2, l2;
        if (s2 === "exponential")
          a2 = $n;
        else if (s2 === "interval")
          a2 = Un;
        else if (s2 === "categorical") {
          a2 = jn, o2 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t2.stops)
            o2[e3[0]] = e3[1];
          l2 = typeof t2.stops[0][0];
        } else {
          if (s2 !== "identity")
            throw new Error(`Unknown function type "${s2}"`);
          a2 = On;
        }
        if (n2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0; e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            r3[s4] === void 0 && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, Fn(r3[t3], e2)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: Kr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => $n({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
        }
        if (i2) {
          const r3 = s2 === "exponential" ? { name: "exponential", base: t2.base !== void 0 ? t2.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: Kr.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
          return i3 === void 0 ? Rn(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
        } };
      }
      function Rn(t2, e2, r2) {
        return t2 !== void 0 ? t2 : e2 !== void 0 ? e2 : r2 !== void 0 ? r2 : void 0;
      }
      function jn(t2, e2, r2, n2, i2) {
        return Rn(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
      }
      function Un(t2, e2, r2) {
        if (Dn(r2) !== "number")
          return Rn(t2.default, e2.default);
        const n2 = t2.stops.length;
        if (n2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = Sr(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function $n(t2, e2, r2) {
        const n2 = t2.base !== void 0 ? t2.base : 1;
        if (Dn(r2) !== "number")
          return Rn(t2.default, e2.default);
        const i2 = t2.stops.length;
        if (i2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = Sr(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
        let u2 = Tr[e2.type] || Ln;
        if (t2.colorSpace && t2.colorSpace !== "rgb") {
          const e3 = Gr[t2.colorSpace];
          u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
        }
        return typeof o2.evaluate == "function" ? { evaluate(...t3) {
          const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
          if (e3 !== void 0 && r3 !== void 0)
            return u2(e3, r3, a2);
        } } : u2(o2, l2, a2);
      }
      function On(t2, e2, r2) {
        return e2.type === "color" ? r2 = Me.parse(r2) : e2.type === "formatted" ? r2 = Be.fromString(r2.toString()) : e2.type === "resolvedImage" ? r2 = Ee.fromString(r2.toString()) : Dn(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = void 0), Rn(r2, t2.default, e2.default);
      }
      class qn {
        constructor(t2, e2) {
          this.expression = t2, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e2 ? function(t3) {
            return t3.type === "color" && (Vn(t3.default) || Array.isArray(t3.default)) ? new Me(0, 0, 0, 0) : t3.type === "color" ? Me.parse(t3.default) || null : t3.default === void 0 ? null : t3.default;
          }(e2) : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2, a2, o2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e2, r2, n2, i2, s2, a2, o2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (t3 == null || typeof t3 == "number" && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function Nn(t2) {
        return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in Tn;
      }
      function Gn(t2, e2) {
        const r2 = new _r(Tn, [], e2 ? function(t3) {
          const e3 = { color: le, string: ae, number: se, enum: ae, boolean: oe, formatted: pe, resolvedImage: fe };
          return t3.type === "array" ? de(e3[t3.value] || ce, t3.length) : e3[t3.type];
        }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return n2 ? zn(new qn(n2, e2)) : Bn(r2.errors);
      }
      class Xn {
        constructor(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !gr(e2.expression);
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
      }
      class Zn {
        constructor(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !gr(e2.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e2, r2) {
          return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        }
      }
      function Kn(t2, e2) {
        if ((t2 = Gn(t2, e2)).result === "error")
          return t2;
        const r2 = t2.value.expression, n2 = mr(r2);
        if (!n2 && !En(e2))
          return Bn([new ee("", "data expressions not supported")]);
        const i2 = xr(r2, ["zoom", "pitch", "distance-from-center"]);
        if (!i2 && !Cn(e2))
          return Bn([new ee("", "zoom expressions not supported")]);
        const s2 = Hn(r2);
        return s2 || i2 ? s2 instanceof ee ? Bn([s2]) : s2 instanceof Kr && !Pn(e2) ? Bn([new ee("", '"interpolate" expressions cannot be used with this property')]) : zn(s2 ? new Zn(n2 ? "camera" : "composite", t2.value, s2.labels, s2 instanceof Kr ? s2.interpolation : void 0) : new Xn(n2 ? "constant" : "source", t2.value)) : Bn([new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Yn {
        constructor(t2, e2) {
          this._parameters = t2, this._specification = e2, Wt(this, Fn(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new Yn(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function Hn(t2) {
        let e2 = null;
        if (t2 instanceof Jr)
          e2 = Hn(t2.result);
        else if (t2 instanceof Hr) {
          for (const r2 of t2.args)
            if (e2 = Hn(r2), e2)
              break;
        } else
          (t2 instanceof Ir || t2 instanceof Kr) && t2.input instanceof He && t2.input.name === "zoom" && (e2 = t2);
        return e2 instanceof ee || t2.eachChild((t3) => {
          const r2 = Hn(t3);
          r2 instanceof ee ? e2 = r2 : !e2 && r2 ? e2 = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      class Wn {
        constructor(t2, e2, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function Jn(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
        let o2 = [];
        const l2 = Dn(r2);
        if (l2 !== "object")
          return [new Wn(e2, r2, `object expected, ${l2} found`)];
        for (const t3 in r2) {
          const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
          let c2;
          i2[l3] ? c2 = i2[l3] : n2[l3] ? c2 = Ci : i2["*"] ? c2 = i2["*"] : n2["*"] && (c2 = Ci), c2 ? o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2)) : o2.push(new Wn(e2, r2[t3], `unknown property "${t3}"`));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && n2[t3].default === void 0 && r2[t3] === void 0 && o2.push(new Wn(e2, r2, `missing required property "${t3}"`));
        return o2;
      }
      function Qn(t2) {
        const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Ci;
        if (Dn(e2) !== "array")
          return [new Wn(s2, e2, `array expected, ${Dn(e2)} found`)];
        if (r2.length && e2.length !== r2.length)
          return [new Wn(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [new Wn(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
        let o2 = { type: r2.value, values: r2.values, minimum: r2.minimum, maximum: r2.maximum, function: void 0 };
        i2.$version < 7 && (o2.function = r2.function), Dn(r2.value) === "object" && (o2 = r2.value);
        let l2 = [];
        for (let t3 = 0; t3 < e2.length; t3++)
          l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
        return l2;
      }
      function ti(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
        let i2 = Dn(r2);
        if (i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number")
          return [new Wn(e2, r2, `number expected, ${i2} found`)];
        if ("minimum" in n2) {
          let i3 = n2.minimum;
          if (Dn(n2.minimum) === "array" && (i3 = n2.minimum[t2.arrayIndex]), r2 < i3)
            return [new Wn(e2, r2, `${r2} is less than the minimum value ${i3}`)];
        }
        if ("maximum" in n2) {
          let i3 = n2.maximum;
          if (Dn(n2.maximum) === "array" && (i3 = n2.maximum[t2.arrayIndex]), r2 > i3)
            return [new Wn(e2, r2, `${r2} is greater than the maximum value ${i3}`)];
        }
        return [];
      }
      function ei(t2) {
        const e2 = t2.valueSpec, r2 = Jt(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = r2 !== "categorical" && t2.value.property === void 0, l2 = !o2, u2 = Dn(t2.value.stops) === "array" && Dn(t2.value.stops[0]) === "array" && Dn(t2.value.stops[0][0]) === "object", c2 = Jn({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if (r2 === "identity")
            return [new Wn(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n3 = t3.value;
          return e3 = e3.concat(Qn({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h4 })), Dn(n3) === "array" && n3.length === 0 && e3.push(new Wn(t3.key, n3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return Ci({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return r2 === "identity" && o2 && c2.push(new Wn(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new Wn(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !Pn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !En(t2.valueSpec) ? c2.push(new Wn(t2.key, t2.value, "property functions not supported")) : o2 && !Cn(t2.valueSpec) && c2.push(new Wn(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u2 || t2.value.property !== void 0 || c2.push(new Wn(t2.key, t2.value, '"property" property is required')), c2;
        function h4(t3) {
          let r3 = [];
          const n3 = t3.value, o3 = t3.key;
          if (Dn(n3) !== "array")
            return [new Wn(o3, n3, `array expected, ${Dn(n3)} found`)];
          if (n3.length !== 2)
            return [new Wn(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u2) {
            if (Dn(n3[0]) !== "object")
              return [new Wn(o3, n3, `object expected, ${Dn(n3[0])} found`)];
            if (n3[0].zoom === void 0)
              return [new Wn(o3, n3, "object stop key must have zoom")];
            if (n3[0].value === void 0)
              return [new Wn(o3, n3, "object stop key must have value")];
            const e3 = Jt(n3[0].zoom);
            if (typeof e3 != "number")
              return [new Wn(o3, n3[0].zoom, "stop zoom values must be numbers")];
            if (s2 && s2 > e3)
              return [new Wn(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
            e3 !== s2 && (s2 = e3, i2 = void 0, a2 = {}), r3 = r3.concat(Jn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: ti, value: p2 } }));
          } else
            r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
          return Nn(Qt(n3[1])) ? r3.concat([new Wn(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(Ci({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function p2(t3, s3) {
          const o3 = Dn(t3.value), l3 = Jt(t3.value), u3 = t3.value !== null ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [new Wn(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
          } else
            n2 = o3;
          if (o3 !== "number" && o3 !== "string" && o3 !== "boolean" && typeof l3 != "number" && typeof l3 != "string" && typeof l3 != "boolean")
            return [new Wn(t3.key, u3, "stop domain value must be a number, string, or boolean")];
          if (o3 !== "number" && r2 !== "categorical") {
            let n3 = `number expected, ${o3} found`;
            return En(e2) && r2 === void 0 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Wn(t3.key, u3, n3)];
          }
          return r2 !== "categorical" || o3 !== "number" || typeof l3 == "number" && isFinite(l3) && Math.floor(l3) === l3 ? r2 !== "categorical" && o3 === "number" && typeof l3 == "number" && typeof i2 == "number" && i2 !== void 0 && l3 < i2 ? [new Wn(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, r2 === "categorical" && l3 in a2 ? [new Wn(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Wn(t3.key, u3, `integer expected, found ${String(l3)}`)];
        }
      }
      function ri(t2) {
        const e2 = (t2.expressionContext === "property" ? Kn : Gn)(Qt(t2.value), t2.valueSpec);
        if (e2.result === "error")
          return e2.value.map((e3) => new Wn(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e2.value.expression || e2.value._styleExpression.expression;
        if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
          return [new Wn(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (t2.expressionContext === "property" && t2.propertyType === "layout" && !gr(r2))
          return [new Wn(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (t2.expressionContext === "filter")
          return ni(r2, t2);
        if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
          if (!xr(r2, ["zoom", "feature-state"]))
            return [new Wn(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (t2.expressionContext === "cluster-initial" && !mr(r2))
            return [new Wn(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function ni(t2, e2) {
        const r2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (e2.valueSpec && e2.valueSpec.expression)
          for (const t3 of e2.valueSpec.expression.parameters)
            r2.delete(t3);
        if (r2.size === 0)
          return [];
        const n2 = [];
        return t2 instanceof He && r2.has(t2.name) ? [new Wn(e2.key, e2.value, `["${t2.name}"] expression is not supported in a filter for a ${e2.object.type} layer with id: ${e2.object.id}`)] : (t2.eachChild((t3) => {
          n2.push(...ni(t3, e2));
        }), n2);
      }
      function ii(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
        return Array.isArray(n2.values) ? n2.values.indexOf(Jt(r2)) === -1 && i2.push(new Wn(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(Jt(r2)) === -1 && i2.push(new Wn(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function si(t2) {
        if (t2 === true || t2 === false)
          return true;
        if (!Array.isArray(t2) || t2.length === 0)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
          case "in":
            return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e2 of t2.slice(1))
              if (!si(e2) && typeof e2 != "boolean")
                return false;
            return true;
          default:
            return true;
        }
      }
      function ai(t2, e2 = "fill") {
        if (t2 == null)
          return { filter: () => true, needGeometry: false, needFeature: false };
        si(t2) || (t2 = fi(t2));
        const r2 = t2;
        let n2 = true;
        try {
          n2 = function(t3) {
            if (!ui(t3))
              return t3;
            let e3 = Qt(t3);
            return li(e3), e3 = oi(e3), e3;
          }(r2);
        } catch (t3) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r2, null, 2)}
        `);
        }
        const i2 = Ht[`filter_${e2}`], s2 = Gn(n2, i2);
        let a2 = null;
        if (s2.result === "error")
          throw new Error(s2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        a2 = (t3, e3, r3) => s2.value.evaluate(t3, e3, {}, r3);
        let o2 = null, l2 = null;
        if (n2 !== r2) {
          const t3 = Gn(r2, i2);
          if (t3.result === "error")
            throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          o2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), l2 = !mr(t3.value.expression);
        }
        return { filter: a2, dynamicFilter: o2 || void 0, needGeometry: pi(n2), needFeature: !!l2 };
      }
      function oi(t2) {
        if (!Array.isArray(t2))
          return t2;
        const e2 = function(t3) {
          if (ci.has(t3[0])) {
            for (let e3 = 1; e3 < t3.length; e3++)
              if (ui(t3[e3]))
                return true;
          }
          return t3;
        }(t2);
        return e2 === true ? e2 : e2.map((t3) => oi(t3));
      }
      function li(t2) {
        let e2 = false;
        const r2 = [];
        if (t2[0] === "case") {
          for (let n2 = 1; n2 < t2.length - 1; n2 += 2)
            e2 = e2 || ui(t2[n2]), r2.push(t2[n2 + 1]);
          r2.push(t2[t2.length - 1]);
        } else if (t2[0] === "match") {
          e2 = e2 || ui(t2[1]);
          for (let e3 = 2; e3 < t2.length - 1; e3 += 2)
            r2.push(t2[e3 + 1]);
          r2.push(t2[t2.length - 1]);
        } else if (t2[0] === "step") {
          e2 = e2 || ui(t2[1]);
          for (let e3 = 1; e3 < t2.length - 1; e3 += 2)
            r2.push(t2[e3 + 1]);
        }
        e2 && (t2.length = 0, t2.push("any", ...r2));
        for (let e3 = 1; e3 < t2.length; e3++)
          li(t2[e3]);
      }
      function ui(t2) {
        if (!Array.isArray(t2))
          return false;
        if ((e2 = t2[0]) === "pitch" || e2 === "distance-from-center")
          return true;
        var e2;
        for (let e3 = 1; e3 < t2.length; e3++)
          if (ui(t2[e3]))
            return true;
        return false;
      }
      const ci = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function hi(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function pi(t2) {
        if (!Array.isArray(t2))
          return false;
        if (t2[0] === "within")
          return true;
        for (let e2 = 1; e2 < t2.length; e2++)
          if (pi(t2[e2]))
            return true;
        return false;
      }
      function fi(t2) {
        if (!t2)
          return true;
        const e2 = t2[0];
        return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? di(t2[1], t2[2], "==") : e2 === "!=" ? gi(di(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? di(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(fi))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(fi)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(fi).map(gi)) : e2 === "in" ? yi(t2[1], t2.slice(2)) : e2 === "!in" ? gi(yi(t2[1], t2.slice(2))) : e2 === "has" ? mi(t2[1]) : e2 === "!has" ? gi(mi(t2[1])) : e2 !== "within" || t2;
        var r2;
      }
      function di(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e2];
          case "$id":
            return [`filter-id-${r2}`, e2];
          default:
            return [`filter-${r2}`, t2, e2];
        }
      }
      function yi(t2, e2) {
        if (e2.length === 0)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(hi)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function mi(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function gi(t2) {
        return ["!", t2];
      }
      function xi(t2) {
        return si(Qt(t2.value)) ? ri(Wt({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : vi(t2);
      }
      function vi(t2) {
        const e2 = t2.value, r2 = t2.key;
        if (Dn(e2) !== "array")
          return [new Wn(r2, e2, `array expected, ${Dn(e2)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new Wn(r2, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(ii({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), Jt(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && Jt(e2[1]) === "$type" && s2.push(new Wn(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            e2.length !== 3 && s2.push(new Wn(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = Dn(e2[1]), i2 !== "string" && s2.push(new Wn(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2; a2 < e2.length; a2++)
              i2 = Dn(e2[a2]), Jt(e2[1]) === "$type" ? s2 = s2.concat(ii({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new Wn(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1; n3 < e2.length; n3++)
              s2 = s2.concat(vi({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = Dn(e2[1]), e2.length !== 2 ? s2.push(new Wn(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new Wn(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
            break;
          case "within":
            i2 = Dn(e2[1]), e2.length !== 2 ? s2.push(new Wn(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "object" && s2.push(new Wn(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
        }
        return s2;
      }
      function bi(t2, e2) {
        const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
        if (!o2)
          return [];
        const l2 = a2.match(/^(.*)-transition$/);
        if (e2 === "paint" && l2 && o2[l2[1]] && o2[l2[1]].transition)
          return Ci({ key: r2, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
        const u2 = t2.valueSpec || o2[a2];
        if (!u2)
          return [new Wn(r2, s2, `unknown property "${a2}"`)];
        let c2;
        if (Dn(s2) === "string" && En(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
          return [new Wn(r2, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
        const h4 = [];
        return t2.layerType === "symbol" && (a2 === "text-field" && n2 && !n2.glyphs && h4.push(new Wn(r2, s2, 'use of "text-field" requires a style "glyphs" property')), a2 === "text-font" && Vn(Qt(s2)) && Jt(s2.type) === "identity" && h4.push(new Wn(r2, s2, '"text-font" does not support identity functions'))), h4.concat(Ci({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
      }
      function wi(t2) {
        return bi(t2, "paint");
      }
      function _i(t2) {
        return bi(t2, "layout");
      }
      function Ai(t2) {
        let e2 = [];
        const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
        r2.type || r2.ref || e2.push(new Wn(n2, r2, 'either "type" or "ref" is required'));
        let a2 = Jt(r2.type);
        const o2 = Jt(r2.ref);
        if (r2.id) {
          const s3 = Jt(r2.id);
          for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            Jt(t3.id) === s3 && e2.push(new Wn(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e2.push(new Wn(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            Jt(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e2.push(new Wn(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = Jt(t3.type) : typeof o2 == "string" && e2.push(new Wn(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if (a2 !== "background" && a2 !== "sky")
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && Jt(t3.type);
            t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new Wn(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new Wn(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : s3 !== "vector" || r2["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new Wn(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r2.paint || !r2.paint["line-gradient"] && !r2.paint["line-trim-offset"] || s3 === "geojson" && t3.lineMetrics || e2.push(new Wn(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Wn(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new Wn(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e2.push(new Wn(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat(Jn({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Ci({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: (t3) => xi(Wt({ layerType: a2 }, t3)), layout: (t3) => Jn({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => _i(Wt({ layerType: a2 }, t4)) } }), paint: (t3) => Jn({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => wi(Wt({ layerType: a2 }, t4)) } }) } })), e2;
      }
      function Si(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Dn(e2);
        return n2 !== "string" ? [new Wn(r2, e2, `string expected, ${n2} found`)] : [];
      }
      const ki = { promoteId: function({ key: t2, value: e2 }) {
        if (Dn(e2) === "string")
          return Si({ key: t2, value: e2 });
        {
          const r2 = [];
          for (const n2 in e2)
            r2.push(...Si({ key: `${t2}.${n2}`, value: e2[n2] }));
          return r2;
        }
      } };
      function Ii(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
        if (!e2.type)
          return [new Wn(r2, e2, '"type" is required')];
        const s2 = Jt(e2.type);
        let a2;
        switch (s2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return a2 = Jn({ key: r2, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ki }), a2;
          case "geojson":
            if (a2 = Jn({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ki }), e2.cluster)
              for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], s3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                a2.push(...ri({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...ri({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
            return a2;
          case "video":
            return Jn({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
          case "image":
            return Jn({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
          case "canvas":
            return [new Wn(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return ii({ key: `${r2}.type`, value: e2.type, valueSpec: { values: Mi(n2) }, style: i2, styleSpec: n2 });
        }
      }
      function Mi(t2) {
        return t2.source.reduce((e2, r2) => {
          const n2 = t2[r2];
          return n2.type.type === "enum" && (e2 = e2.concat(Object.keys(n2.type.values))), e2;
        }, []);
      }
      function Ti(t2) {
        const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = Dn(e2);
        if (e2 === void 0)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new Wn("light", e2, `object expected, ${a2} found`)]), s2;
        for (const t3 in e2) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      function zi(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
        let a2 = [];
        const o2 = Dn(e2);
        if (e2 === void 0)
          return a2;
        if (o2 !== "object")
          return a2 = a2.concat([new Wn("terrain", e2, `object expected, ${o2} found`)]), a2;
        for (const t3 in e2) {
          const r3 = t3.match(/^(.*)-transition$/);
          a2 = a2.concat(r3 && s2[r3[1]] && s2[r3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        if (e2.source) {
          const t3 = n2.sources && n2.sources[e2.source], i3 = t3 && Jt(t3.type);
          t3 ? i3 !== "raster-dem" && a2.push(new Wn(r2, e2.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new Wn(r2, e2.source, `source "${e2.source}" not found`));
        } else
          a2.push(new Wn(r2, e2, 'terrain is missing required property "source"'));
        return a2;
      }
      function Bi(t2) {
        const e2 = t2.value, r2 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
        let s2 = [];
        const a2 = Dn(e2);
        if (e2 === void 0)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new Wn("fog", e2, `object expected, ${a2} found`)]), s2;
        for (const t3 in e2) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Ci({ key: t3, value: e2[t3], valueSpec: n2.transition, style: r2, styleSpec: n2 }) : i2[t3] ? Ci({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r2, styleSpec: n2 }) : [new Wn(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      const Ei = { "*": () => [], array: Qn, boolean: function(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Dn(e2);
        return n2 !== "boolean" ? [new Wn(r2, e2, `boolean expected, ${n2} found`)] : [];
      }, number: ti, color: function(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = Dn(r2);
        return n2 !== "string" ? [new Wn(e2, r2, `color expected, ${n2} found`)] : be(r2) === null ? [new Wn(e2, r2, `color expected, "${r2}" found`)] : [];
      }, enum: ii, filter: xi, function: ei, layer: Ai, object: Jn, source: Ii, light: Ti, terrain: zi, fog: Bi, string: Si, formatted: function(t2) {
        return Si(t2).length === 0 ? [] : ri(t2);
      }, resolvedImage: function(t2) {
        return Si(t2).length === 0 ? [] : ri(t2);
      }, projection: function(t2) {
        const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style;
        let s2 = [];
        const a2 = Dn(e2);
        if (a2 === "object")
          for (const t3 in e2)
            s2 = s2.concat(Ci({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }));
        else
          a2 !== "string" && (s2 = s2.concat([new Wn("projection", e2, `object or string expected, ${a2} found`)]));
        return s2;
      } };
      function Ci(t2) {
        const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
        return r2.expression && Vn(Jt(e2)) ? ei(t2) : r2.expression && Nn(Qt(e2)) ? ri(t2) : r2.type && Ei[r2.type] ? Ei[r2.type](t2) : Jn(Wt({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function Pi(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Si(t2);
        return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new Wn(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new Wn(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function Di(t2, e2 = Ht) {
        return Fi(Ci({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Pi, "*": () => [] } }));
      }
      const Vi = (t2) => Fi(wi(t2)), Li = (t2) => Fi(_i(t2));
      function Fi(t2) {
        return t2.slice().sort((t3, e2) => t3.line && e2.line ? t3.line - e2.line : 0);
      }
      function Ri(t2, e2) {
        let r2 = false;
        if (e2 && e2.length)
          for (const n2 of e2)
            t2.fire(new Kt(new Error(n2.message))), r2 = true;
        return r2;
      }
      var ji = Ui;
      function Ui(t2, e2, r2) {
        var n2 = this.cells = [];
        if (t2 instanceof ArrayBuffer) {
          this.arrayBuffer = t2;
          var i2 = new Int32Array(this.arrayBuffer);
          t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
          for (var s2 = 0; s2 < this.d * this.d; s2++) {
            var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
            n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
          }
          var l2 = i2[3 + n2.length + 1];
          this.keys = i2.subarray(i2[3 + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
        } else {
          this.d = e2 + 2 * r2;
          for (var u2 = 0; u2 < this.d * this.d; u2++)
            n2.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
        var c2 = r2 / e2 * t2;
        this.min = -c2, this.max = t2 + c2;
      }
      Ui.prototype.insert = function(t2, e2, r2, n2, i2) {
        this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
      }, Ui.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Ui.prototype._insertCell = function(t2, e2, r2, n2, i2, s2) {
        this.cells[i2].push(s2);
      }, Ui.prototype.query = function(t2, e2, r2, n2, i2) {
        var s2 = this.min, a2 = this.max;
        if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
          return Array.prototype.slice.call(this.keys);
        var o2 = [];
        return this._forEachCell(t2, e2, r2, n2, this._queryCell, o2, {}, i2), o2;
      }, Ui.prototype._queryCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
        var l2 = this.cells[i2];
        if (l2 !== null)
          for (var u2 = this.keys, c2 = this.bboxes, h4 = 0; h4 < l2.length; h4++) {
            var p2 = l2[h4];
            if (a2[p2] === void 0) {
              var f2 = 4 * p2;
              (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t2 <= c2[f2 + 2] && e2 <= c2[f2 + 3] && r2 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
            }
          }
      }, Ui.prototype._forEachCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
        for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h4 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
          for (var f2 = u2; f2 <= h4; f2++) {
            var d2 = this.d * f2 + p2;
            if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r2, n2, d2, s2, a2, o2))
              return;
          }
      }, Ui.prototype._convertFromCellCoord = function(t2) {
        return (t2 - this.padding) / this.scale;
      }, Ui.prototype._convertToCellCoord = function(t2) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
      }, Ui.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
          r2 += this.cells[n2].length;
        var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
        i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
        for (var s2 = e2, a2 = 0; a2 < t2.length; a2++) {
          var o2 = t2[a2];
          i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
        }
        return i2[3 + t2.length] = s2, i2.set(this.keys, s2), i2[3 + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
      };
      const $i = {};
      function Oi(t2, e2, r2 = {}) {
        Object.defineProperty(t2, "_classRegistryKey", { value: e2, writeable: false }), $i[e2] = { klass: t2, omit: r2.omit || [] };
      }
      Oi(Object, "Object"), ji.serialize = function(t2, e2) {
        const r2 = t2.toArrayBuffer();
        return e2 && e2.push(r2), { buffer: r2 };
      }, ji.deserialize = function(t2) {
        return new ji(t2.buffer);
      }, Object.defineProperty(ji, "name", { value: "Grid" }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", { omit: ["_evaluator"] }), Oi(Zn, "ZoomDependentExpression"), Oi(Xn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t2 in Tn)
        $i[Tn[t2]._classRegistryKey] || Oi(Tn[t2], `Expression${t2}`);
      function qi(t2) {
        return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
      }
      function Ni(t2) {
        return e.ImageBitmap && t2 instanceof e.ImageBitmap;
      }
      function Gi(t2, r2) {
        if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
          return t2;
        if (qi(t2) || Ni(t2))
          return r2 && r2.push(t2), t2;
        if (ArrayBuffer.isView(t2)) {
          const e2 = t2;
          return r2 && r2.push(e2.buffer), e2;
        }
        if (t2 instanceof e.ImageData)
          return r2 && r2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const e2 = [];
          for (const n2 of t2)
            e2.push(Gi(n2, r2));
          return e2;
        }
        if (typeof t2 == "object") {
          const e2 = t2.constructor, n2 = e2._classRegistryKey;
          if (!n2)
            throw new Error(`can't serialize object of unregistered class ${n2}`);
          const i2 = e2.serialize ? e2.serialize(t2, r2) : {};
          if (!e2.serialize) {
            for (const e3 in t2)
              t2.hasOwnProperty(e3) && ($i[n2].omit.indexOf(e3) >= 0 || (i2[e3] = Gi(t2[e3], r2)));
            t2 instanceof Error && (i2.message = t2.message);
          }
          if (i2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return n2 !== "Object" && (i2.$name = n2), i2;
        }
        throw new Error("can't serialize object of type " + typeof t2);
      }
      function Xi(t2) {
        if (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || qi(t2) || Ni(t2) || ArrayBuffer.isView(t2) || t2 instanceof e.ImageData)
          return t2;
        if (Array.isArray(t2))
          return t2.map(Xi);
        if (typeof t2 == "object") {
          const e2 = t2.$name || "Object", { klass: r2 } = $i[e2];
          if (!r2)
            throw new Error(`can't deserialize unregistered class ${e2}`);
          if (r2.deserialize)
            return r2.deserialize(t2);
          const n2 = Object.create(r2.prototype);
          for (const e3 of Object.keys(t2))
            e3 !== "$name" && (n2[e3] = Xi(t2[e3]));
          return n2;
        }
        throw new Error("can't deserialize object of type " + typeof t2);
      }
      const Zi = (t2) => t2 >= 1536 && t2 <= 1791, Ki = (t2) => t2 >= 1872 && t2 <= 1919, Yi = (t2) => t2 >= 2208 && t2 <= 2303, Hi = (t2) => t2 >= 11904 && t2 <= 12031, Wi = (t2) => t2 >= 12032 && t2 <= 12255, Ji = (t2) => t2 >= 12272 && t2 <= 12287, Qi = (t2) => t2 >= 12288 && t2 <= 12351, ts = (t2) => t2 >= 12352 && t2 <= 12447, es = (t2) => t2 >= 12448 && t2 <= 12543, rs = (t2) => t2 >= 12544 && t2 <= 12591, ns = (t2) => t2 >= 12704 && t2 <= 12735, is = (t2) => t2 >= 12736 && t2 <= 12783, ss = (t2) => t2 >= 12784 && t2 <= 12799, as = (t2) => t2 >= 12800 && t2 <= 13055, os2 = (t2) => t2 >= 13056 && t2 <= 13311, ls = (t2) => t2 >= 13312 && t2 <= 19903, us = (t2) => t2 >= 19968 && t2 <= 40959, cs = (t2) => t2 >= 40960 && t2 <= 42127, hs = (t2) => t2 >= 42128 && t2 <= 42191, ps = (t2) => t2 >= 44032 && t2 <= 55215, fs2 = (t2) => t2 >= 63744 && t2 <= 64255, ds = (t2) => t2 >= 64336 && t2 <= 65023, ys = (t2) => t2 >= 65040 && t2 <= 65055, ms = (t2) => t2 >= 65072 && t2 <= 65103, gs = (t2) => t2 >= 65104 && t2 <= 65135, xs = (t2) => t2 >= 65136 && t2 <= 65279, vs = (t2) => t2 >= 65280 && t2 <= 65519;
      function bs(t2) {
        for (const e2 of t2)
          if (As(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function ws(t2) {
        for (const e2 of t2)
          if (!_s(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function _s(t2) {
        return !(Zi(t2) || Ki(t2) || Yi(t2) || ds(t2) || xs(t2));
      }
      function As(t2) {
        return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(ns(t2) || rs(t2) || ms(t2) && !(t2 >= 65097 && t2 <= 65103) || fs2(t2) || os2(t2) || Hi(t2) || is(t2) || !(!Qi(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || ls(t2) || us(t2) || as(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || ps(t2) || ts(t2) || Ji(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || Wi(t2) || ss(t2) || es(t2) && t2 !== 12540 || !(!vs(t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!gs(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || ys(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || cs(t2) || hs(t2))));
      }
      function Ss(t2) {
        return !(As(t2) || function(t3) {
          return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && t3 !== 9251 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Qi(t3) || es(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || ms(t3) || gs(t3) || vs(t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
        }(t2));
      }
      function ks(t2) {
        return t2 >= 1424 && t2 <= 2303 || ds(t2) || xs(t2);
      }
      function Is(t2, e2) {
        return !(!e2 && ks(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
      }
      function Ms(t2) {
        for (const e2 of t2)
          if (ks(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const Ts = "deferred", zs = "loading", Bs = "loaded";
      let Es = null, Cs = "unavailable", Ps = null;
      const Ds = function(t2) {
        t2 && typeof t2 == "string" && t2.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t2);
      };
      function Vs() {
        Ls.fire(new Zt("pluginStateChange", { pluginStatus: Cs, pluginURL: Ps }));
      }
      const Ls = new Yt(), Fs = function() {
        return Cs;
      }, Rs = function() {
        if (Cs !== Ts || !Ps)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Cs = zs, Vs(), Ps && ut({ url: Ps }, (t2) => {
          t2 ? Ds(t2) : (Cs = Bs, Vs());
        });
      }, js = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Cs === Bs || js.applyArabicShaping != null, isLoading: () => Cs === zs, setState(t2) {
        Cs = t2.pluginStatus, Ps = t2.pluginURL;
      }, isParsed: () => js.applyArabicShaping != null && js.processBidirectionalText != null && js.processStyledBidirectionalText != null, getPluginURL: () => Ps };
      class Us {
        constructor(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
        }
        isSupportedScript(t2) {
          return function(t3, e2) {
            for (const r2 of t3)
              if (!Is(r2.charCodeAt(0), e2))
                return false;
            return true;
          }(t2, js.isLoaded());
        }
      }
      class $s {
        constructor(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (Vn(t3))
              return new Yn(t3, e3);
            if (Nn(t3)) {
              const r2 = Kn(t3, e3);
              if (r2.result === "error")
                throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return r2.value;
            }
            {
              let r2 = t3;
              return typeof t3 == "string" && e3.type === "color" && (r2 = Me.parse(t3)), { kind: "constant", evaluate: () => r2 };
            }
          }(e2 === void 0 ? t2.specification.default : e2, t2.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t2, e2, r2) {
          return this.property.possiblyEvaluate(this, t2, e2, r2);
        }
      }
      class Os {
        constructor(t2) {
          this.property = t2, this.value = new $s(t2, void 0);
        }
        transitioned(t2, e2) {
          return new Ns(this.property, this.value, e2, z({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new Ns(this.property, this.value, null, {}, 0);
        }
      }
      class qs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        }
        getValue(t2) {
          return j(this._values[t2].value.value);
        }
        setValue(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].value = new $s(this._values[t2].property, e2 === null ? void 0 : j(e2));
        }
        getTransition(t2) {
          return j(this._values[t2].transition);
        }
        setTransition(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Os(this._values[t2].property)), this._values[t2].transition = j(e2) || void 0;
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== void 0 && (t2[e2] = r2);
            const n2 = this.getTransition(e2);
            n2 !== void 0 && (t2[`${e2}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e2) {
          const r2 = new Gs(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new Gs(this._properties);
          for (const e2 of Object.keys(this._values))
            t2._values[e2] = this._values[e2].untransitioned();
          return t2;
        }
      }
      class Ns {
        constructor(t2, e2, r2, n2, i2) {
          const s2 = n2.delay || 0, a2 = n2.duration || 0;
          i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e2, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, w(a2));
            }
          }
          return i2;
        }
      }
      class Gs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Ks(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }
      class Xs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        }
        getValue(t2) {
          return j(this._values[t2].value);
        }
        setValue(t2, e2) {
          this._values[t2] = new $s(this._values[t2].property, e2 === null ? void 0 : j(e2));
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== void 0 && (t2[e2] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Ks(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
      }
      class Zs {
        constructor(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t2) {
          return this.value.kind === "constant" ? this.value.value : t2;
        }
        evaluate(t2, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
        }
      }
      class Ks {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }
      class Ys {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2) {
          return t2.expression.evaluate(e2);
        }
        interpolate(t2, e2, r2) {
          const n2 = Tr[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        }
      }
      class Hs {
        constructor(t2, e2) {
          this.specification = t2, this.overrides = e2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return new Zs(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
        }
        interpolate(t2, e2, r2) {
          if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
            return t2;
          if (t2.value.value === void 0 || e2.value.value === void 0)
            return new Zs(this, { kind: "constant", value: void 0 }, t2.parameters);
          const n2 = Tr[this.specification.type];
          return n2 ? new Zs(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
        }
      }
      class Ws {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return !!t2.expression.evaluate(e2, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }
      class Js {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const e2 = new Us(0, {});
          for (const r2 in t2) {
            const n2 = t2[r2];
            n2.specification.overridable && this.overridableProperties.push(r2);
            const i2 = this.defaultPropertyValues[r2] = new $s(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new Os(n2);
            this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
          }
        }
      }
      function Qs(t2, e2) {
        return 256 * (t2 = S(Math.floor(t2), 0, 255)) + S(Math.floor(e2), 0, 255);
      }
      Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
      const ta = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class ea {
        constructor(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class ra {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function na(t2, e2 = 1) {
        let r2 = 0, n2 = 0;
        return { members: t2.map((t3) => {
          const i2 = ta[t3.type].BYTES_PER_ELEMENT, s2 = r2 = ia(r2, Math.max(e2, i2)), a2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: ia(r2, Math.max(n2, e2)), alignment: e2 };
      }
      function ia(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }
      class sa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
        }
      }
      sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
      class aa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
      class oa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
      class la extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
          return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
        }
      }
      la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
      class ua extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
      class ca extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 6 * t2, o2 = 3 * t2;
          return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
        }
      }
      ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
      class ha extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
        }
      }
      ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
      class pa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
      class fa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2) {
          const f2 = 12 * t2;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h4, this.int16[f2 + 11] = p2, t2;
        }
      }
      fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
      class da extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 10 * t2, l2 = 5 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
        }
      }
      da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
      class ya extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint32[1 * t2 + 0] = e2, t2;
        }
      }
      ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
      class ma extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2) {
          const f2 = this.length;
          return this.resize(f2 + 1), this.emplace(f2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2) {
          const d2 = 20 * t2, y2 = 10 * t2;
          return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l2, this.float32[y2 + 6] = u2, this.int16[d2 + 14] = c2, this.uint32[y2 + 8] = h4, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
        }
      }
      ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
      class ga extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = 8 * t2;
          return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
        }
      }
      ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
      class xa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
      class va extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 12 * t2, a2 = 3 * t2;
          return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
        }
      }
      va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
      class ba extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
      class wa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
      class _a extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2) {
          const w2 = this.length;
          return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2) {
          const _2 = 30 * t2, A2 = 15 * t2, S2 = 60 * t2;
          return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u2, this.uint32[A2 + 7] = c2, this.uint16[_2 + 16] = h4, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = f2, this.float32[A2 + 10] = d2, this.float32[A2 + 11] = y2, this.uint8[S2 + 48] = m2, this.uint8[S2 + 49] = g2, this.uint8[S2 + 50] = x2, this.uint32[A2 + 13] = v3, this.int16[_2 + 28] = b2, this.uint8[S2 + 58] = w2, t2;
        }
      }
      _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class Aa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2) {
          const B2 = this.length;
          return this.resize(B2 + 1), this.emplace(B2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2, B2) {
          const E2 = 38 * t2, C2 = 19 * t2;
          return this.int16[E2 + 0] = e2, this.int16[E2 + 1] = r2, this.int16[E2 + 2] = n2, this.float32[C2 + 2] = i2, this.float32[C2 + 3] = s2, this.int16[E2 + 8] = a2, this.int16[E2 + 9] = o2, this.int16[E2 + 10] = l2, this.int16[E2 + 11] = u2, this.int16[E2 + 12] = c2, this.int16[E2 + 13] = h4, this.uint16[E2 + 14] = p2, this.uint16[E2 + 15] = f2, this.uint16[E2 + 16] = d2, this.uint16[E2 + 17] = y2, this.uint16[E2 + 18] = m2, this.uint16[E2 + 19] = g2, this.uint16[E2 + 20] = x2, this.uint16[E2 + 21] = v3, this.uint16[E2 + 22] = b2, this.uint16[E2 + 23] = w2, this.uint16[E2 + 24] = _2, this.uint16[E2 + 25] = A2, this.uint16[E2 + 26] = S2, this.uint16[E2 + 27] = k2, this.uint16[E2 + 28] = I2, this.uint32[C2 + 15] = M2, this.float32[C2 + 16] = T2, this.float32[C2 + 17] = z2, this.float32[C2 + 18] = B2, t2;
        }
      }
      Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
      class Sa extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.float32[1 * t2 + 0] = e2, t2;
        }
      }
      Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
      class ka extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 5 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
        }
      }
      ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
      class Ia extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 6 * t2;
          return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
        }
      }
      Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
      class Ma extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
        }
      }
      Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
      class Ta extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint16[1 * t2 + 0] = e2, t2;
        }
      }
      Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
      class za extends ra {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
        }
      }
      za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
      class Ba extends ea {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Ba.prototype.size = 40;
      class Ea extends ma {
        get(t2) {
          return new Ba(this, t2);
        }
      }
      Oi(Ea, "CollisionBoxArray");
      class Ca extends ea {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 49] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 50] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 13] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t2) {
          this._structArray.uint8[this._pos1 + 58] = t2;
        }
      }
      Ca.prototype.size = 60;
      class Pa extends _a {
        get(t2) {
          return new Ca(this, t2);
        }
      }
      Oi(Pa, "PlacedSymbolArray");
      class Da extends ea {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 13];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 28];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 15];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 15] = t2;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 18];
        }
      }
      Da.prototype.size = 76;
      class Va extends Aa {
        get(t2) {
          return new Da(this, t2);
        }
      }
      Oi(Va, "SymbolInstanceArray");
      class La extends Sa {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      Oi(La, "GlyphOffsetArray");
      class Fa extends sa {
        getx(t2) {
          return this.int16[2 * t2 + 0];
        }
        gety(t2) {
          return this.int16[2 * t2 + 1];
        }
      }
      Oi(Fa, "SymbolLineVertexArray");
      class Ra extends ea {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Ra.prototype.size = 12;
      class ja extends Ia {
        get(t2) {
          return new Ra(this, t2);
        }
      }
      Oi(ja, "FeatureIndexArray");
      class Ua extends Ma {
        geta_centroid_pos0(t2) {
          return this.uint16[2 * t2 + 0];
        }
        geta_centroid_pos1(t2) {
          return this.uint16[2 * t2 + 1];
        }
      }
      Oi(Ua, "FillExtrusionCentroidArray");
      const $a = na([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Oa = na([{ name: "a_dash", components: 4, type: "Uint16" }]);
      var qa = {}, Na = { get exports() {
        return qa;
      }, set exports(t2) {
        qa = t2;
      } }, Ga = {};
      ({ get exports() {
        return Ga;
      }, set exports(t2) {
        Ga = t2;
      } }).exports = function(t2, e2) {
        var r2, n2, i2, s2, a2, o2, l2, u2;
        for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
          l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
        switch (l2 = 0, r2) {
          case 3:
            l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
          case 2:
            l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
          case 1:
            i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
        }
        return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
      };
      var Xa = {};
      ({ get exports() {
        return Xa;
      }, set exports(t2) {
        Xa = t2;
      } }).exports = function(t2, e2) {
        for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
          r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
        switch (n2) {
          case 3:
            i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
          case 2:
            i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
          case 1:
            i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
        }
        return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
      };
      var Za = Ga, Ka = Xa;
      Na.exports = Za, qa.murmur3 = Za, qa.murmur2 = Ka;
      class Ya {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t2, e2, r2, n2) {
          this.ids.push(Ha(t2)), this.positions.push(e2, r2, n2);
        }
        getPositions(t2) {
          const e2 = Ha(t2);
          let r2 = 0, n2 = this.ids.length - 1;
          for (; r2 < n2; ) {
            const t3 = r2 + n2 >> 1;
            this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
          }
          const i2 = [];
          for (; this.ids[r2] === e2; )
            i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
          return i2;
        }
        static serialize(t2, e2) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return Wa(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e2 = new Ya();
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        }
      }
      function Ha(t2) {
        const e2 = +t2;
        return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : qa(String(t2));
      }
      function Wa(t2, e2, r2, n2) {
        for (; r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            Ja(t2, s2, a2), Ja(e2, 3 * s2, 3 * a2), Ja(e2, 3 * s2 + 1, 3 * a2 + 1), Ja(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (Wa(t2, e2, r2, a2), r2 = a2 + 1) : (Wa(t2, e2, a2 + 1, n2), n2 = a2);
        }
      }
      function Ja(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      Oi(Ya, "FeaturePositionMap");
      class Qa {
        constructor(t2) {
          this.gl = t2.gl, this.initialized = false;
        }
        fetchUniformLocation(t2, e2) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
        }
      }
      class to2 extends Qa {
        constructor(t2) {
          super(t2), this.current = 0;
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
        }
      }
      class eo extends Qa {
        constructor(t2) {
          super(t2), this.current = [0, 0, 0, 0];
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
        }
      }
      class ro extends Qa {
        constructor(t2) {
          super(t2), this.current = Me.transparent;
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
        }
      }
      const no = new Float32Array(16), io = new Float32Array(9), so = new Float32Array(4);
      function ao(t2) {
        return [Qs(255 * t2.r, 255 * t2.g), Qs(255 * t2.b, 255 * t2.a)];
      }
      class oo {
        constructor(t2, e2, r2) {
          this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e2, r2, n2, i2) {
          e2.set(t2, i2, n2.constantOr(this.value));
        }
        getBinding(t2, e2) {
          return this.type === "color" ? new ro(t2) : new to2(t2);
        }
      }
      class lo {
        constructor(t2, e2) {
          this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(t2) {
          this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
        }
        setUniform(t2, e2, r2, n2, i2) {
          const s2 = i2 === "u_pattern" || i2 === "u_dash" ? this.pattern : i2 === "u_pixel_ratio" ? this.pixelRatio : null;
          s2 && e2.set(t2, i2, s2);
        }
        getBinding(t2, e2) {
          return e2 === "u_pattern" || e2 === "u_dash" ? new eo(t2) : new to2(t2);
        }
      }
      class uo {
        constructor(t2, e2, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
        }
        populatePaintArray(t2, e2, r2, n2, i2, s2) {
          const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new Us(0), e2, {}, i2, n2, s2);
          this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate({ zoom: 0 }, r2, n2, void 0, i2);
          this._setPaintValue(t2, e2, s2);
        }
        _setPaintValue(t2, e2, r2) {
          if (this.type === "color") {
            const n2 = ao(r2);
            for (let r3 = t2; r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2; n2 < e2; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class co {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t2, e2, r2, n2, i2, s2) {
          const a2 = this.expression.evaluate(new Us(this.zoom), e2, {}, i2, n2, s2), o2 = this.expression.evaluate(new Us(this.zoom + 1), e2, {}, i2, n2, s2), l2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(l2, t2, a2, o2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2, void 0, i2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2, void 0, i2);
          this._setPaintValue(t2, e2, s2, a2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          if (this.type === "color") {
            const i2 = ao(r2), s2 = ao(n2);
            for (let r3 = t2; r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2; i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e2, r2, n2, i2) {
          const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = S(this.expression.interpolationFactor(s2, this.zoom, this.zoom + 1), 0, 1);
          e2.set(t2, i2, a2);
        }
        getBinding(t2, e2) {
          return new to2(t2);
        }
      }
      class ho {
        constructor(t2, e2, r2, n2, i2) {
          this.expression = t2, this.layerId = i2, this.paintVertexAttributes = (r2 === "array" ? Oa : $a).members;
          for (let t3 = 0; t3 < e2.length; ++t3)
            ;
          this.paintVertexArray = new n2();
        }
        populatePaintArray(t2, e2, r2) {
          const n2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e2, r2, n2, i2, s2) {
          this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s2);
        }
        _setPaintValues(t2, e2, r2, n2) {
          if (!n2 || !r2)
            return;
          const i2 = n2[r2];
          if (!i2)
            return;
          const { tl: s2, br: a2, pixelRatio: o2 } = i2;
          for (let r3 = t2; r3 < e2; r3++)
            this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1], o2);
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class po {
        constructor(t2, e2, r2 = () => true) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            if (!r2(i2))
              continue;
            const s2 = t2.paint.get(i2);
            if (!(s2 instanceof Zs && En(s2.property.specification)))
              continue;
            const a2 = mo(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = i2 === "line-dasharray" || i2.endsWith("pattern"), h4 = i2 === "line-dasharray" && t2.layout.get("line-cap").value.kind !== "constant";
            if (o2.kind !== "constant" || h4)
              if (o2.kind === "source" || h4 || c2) {
                const e3 = vo(i2, l2, "source");
                this.binders[i2] = c2 ? new ho(o2, a2, l2, e3, t2.id) : new uo(o2, a2, l2, e3), n2.push(`/a_${i2}`);
              } else {
                const t3 = vo(i2, l2, "composite");
                this.binders[i2] = new co(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
            else
              this.binders[i2] = c2 ? new lo(o2.value, a2) : new oo(o2.value, a2, l2), n2.push(`/u_${i2}`);
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e2 = this.binders[t2];
          return e2 instanceof uo || e2 instanceof co ? e2.maxValue : 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2) {
          for (const a2 in this.binders) {
            const o2 = this.binders[a2];
            (o2 instanceof uo || o2 instanceof co || o2 instanceof ho) && o2.populatePaintArray(t2, e2, r2, n2, i2, s2);
          }
        }
        setConstantPatternPositions(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            r2 instanceof lo && r2.setConstantPatternPositions(t2);
          }
        }
        updatePaintArrays(t2, e2, r2, n2, i2, s2) {
          let a2 = false;
          for (const o2 in t2) {
            const l2 = e2.getPositions(o2);
            for (const e3 of l2) {
              const l3 = r2.feature(e3.index);
              for (const r3 in this.binders) {
                const u2 = this.binders[r3];
                if ((u2 instanceof uo || u2 instanceof co || u2 instanceof ho) && u2.expression.isStateDependent === true) {
                  const c2 = n2.paint.get(r3);
                  u2.expression = c2.value, u2.updatePaintArray(e3.start, e3.end, l3, t2[o2], i2, s2), a2 = true;
                }
              }
            }
          }
          return a2;
        }
        defines() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof oo || r2 instanceof lo) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof uo || r2 instanceof co || r2 instanceof ho)
              for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof oo || r2 instanceof lo || r2 instanceof co)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2) {
          const e2 = [];
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            if (n2 instanceof oo || n2 instanceof lo || n2 instanceof co)
              for (const i2 of n2.uniformNames)
                e2.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
          }
          return e2;
        }
        setUniforms(t2, e2, r2, n2, i2) {
          for (const { name: e3, property: s2, binding: a2 } of r2)
            this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof uo || r2 instanceof co || r2 instanceof ho) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof uo || e2 instanceof co || e2 instanceof ho) && e2.destroy();
          }
        }
      }
      class fo {
        constructor(t2, e2, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new po(n2, e2, r2);
          this.needsUpload = false, this._featureMap = new Ya(), this._bufferOffset = 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2, a2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2, a2);
          e2.id !== void 0 && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e2, r2, n2, i2) {
          for (const s2 of r2)
            this.needsUpload = this.programConfigurations[s2.id].updatePaintArrays(t2, this._featureMap, e2, s2, n2, i2) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      const yo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function mo(t2, e2) {
        return yo[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      const go = { "line-pattern": { source: ca, composite: ca }, "fill-pattern": { source: ca, composite: ca }, "fill-extrusion-pattern": { source: ca, composite: ca }, "line-dasharray": { source: ha, composite: ha } }, xo = { color: { source: za, composite: ua }, number: { source: Sa, composite: za } };
      function vo(t2, e2, r2) {
        const n2 = go[t2];
        return n2 && n2[r2] || xo[e2][r2];
      }
      Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", { omit: ["_buffers"] }), Oi(fo, "ProgramConfigurationSet");
      const bo = "-transition";
      class wo extends Yt {
        constructor(t2, e2) {
          if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, t2.type !== "custom" && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && t2.type !== "sky" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Xs(e2.layout)), e2.paint)) {
            this._transitionablePaint = new qs(e2.paint);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e2.paint);
          }
        }
        getLayoutProperty(t2) {
          return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e2, r2 = {}) {
          e2 != null && this._validate(Li, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
        }
        getPaintProperty(t2) {
          return L(t2, bo) ? this._transitionablePaint.getTransition(t2.slice(0, -bo.length)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e2, r2 = {}) {
          if (e2 != null && this._validate(Vi, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
            return false;
          if (L(t2, bo))
            return this._transitionablePaint.setTransition(t2.slice(0, -bo.length), e2 || void 0), false;
          {
            const r3 = this._transitionablePaint._values[t2], n2 = r3.value.isDataDriven(), i2 = r3.value;
            this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
            const s2 = this._transitionablePaint._values[t2].value, a2 = s2.isDataDriven(), o2 = L(t2, "pattern") || t2 === "line-dasharray";
            return a2 || n2 || o2 || this._handleOverridablePaintPropertyUpdate(t2, i2, s2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        getProgramIds() {
          return null;
        }
        getProgramConfiguration(t2) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e2) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
        }
        serialize() {
          const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), R2(t2, (t3, e2) => !(t3 === void 0 || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
        }
        _validate(t2, e2, r2, n2, i2 = {}) {
          return (!i2 || i2.validate !== false) && Ri(this, t2.call(Di, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: Ht, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e2 = this.paint.get(t2);
            if (e2 instanceof Zs && En(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
      }
      const _o = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), Ao = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class So {
        constructor(t2 = []) {
          this.segments = t2;
        }
        prepareSegment(t2, e2, r2, n2) {
          let i2 = this.segments[this.segments.length - 1];
          return t2 > So.MAX_VERTEX_ARRAY_LENGTH && $(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > So.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, n2 !== void 0 && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e2 in t2.vaos)
              t2.vaos[e2].destroy();
        }
        static simpleSegment(t2, e2, r2, n2) {
          return new So([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }
      }
      So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");
      var ko = 8192;
      class Io {
        constructor(t2, e2) {
          t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
        }
        setNorthEast(t2) {
          return this._ne = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
        }
        setSouthWest(t2) {
          return this._sw = t2 instanceof ru ? new ru(t2.lng, t2.lat) : ru.convert(t2), this;
        }
        extend(t2) {
          const e2 = this._sw, r2 = this._ne;
          let n2, i2;
          if (t2 instanceof ru)
            n2 = t2, i2 = t2;
          else {
            if (!(t2 instanceof Io))
              return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(Io.convert(t2)) : this.extend(ru.convert(t2)) : typeof t2 == "object" && t2 !== null && t2.hasOwnProperty("lat") && t2.hasOwnProperty("lon") ? this.extend(ru.convert(t2)) : this;
            if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
              return this;
          }
          return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new ru(n2.lng, n2.lat), this._ne = new ru(i2.lng, i2.lat)), this;
        }
        getCenter() {
          return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new ru(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new ru(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t2) {
          const { lng: e2, lat: r2 } = ru.convert(t2);
          let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
        }
        static convert(t2) {
          return !t2 || t2 instanceof Io ? t2 : new Io(t2);
        }
      }
      var Mo = 1e-6, To = typeof Float32Array != "undefined" ? Float32Array : Array;
      function zo() {
        var t2 = new To(9);
        return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
      }
      function Bo(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h4 = e2[8], p2 = r2[0], f2 = r2[1], d2 = r2[2], y2 = r2[3], m2 = r2[4], g2 = r2[5], x2 = r2[6], v3 = r2[7], b2 = r2[8];
        return t2[0] = p2 * n2 + f2 * a2 + d2 * u2, t2[1] = p2 * i2 + f2 * o2 + d2 * c2, t2[2] = p2 * s2 + f2 * l2 + d2 * h4, t2[3] = y2 * n2 + m2 * a2 + g2 * u2, t2[4] = y2 * i2 + m2 * o2 + g2 * c2, t2[5] = y2 * s2 + m2 * l2 + g2 * h4, t2[6] = x2 * n2 + v3 * a2 + b2 * u2, t2[7] = x2 * i2 + v3 * o2 + b2 * c2, t2[8] = x2 * s2 + v3 * l2 + b2 * h4, t2;
      }
      function Eo(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function Co(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h4 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v3 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, S2 = c2 * y2 - h4 * d2, k2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, M2 = h4 * m2 - p2 * y2, T2 = h4 * g2 - f2 * y2, z2 = p2 * g2 - f2 * m2, B2 = x2 * z2 - v3 * T2 + b2 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
        return B2 ? (t2[0] = (o2 * z2 - l2 * T2 + u2 * M2) * (B2 = 1 / B2), t2[1] = (i2 * T2 - n2 * z2 - s2 * M2) * B2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * B2, t2[3] = (p2 * _2 - h4 * A2 - f2 * w2) * B2, t2[4] = (l2 * I2 - a2 * z2 - u2 * k2) * B2, t2[5] = (r2 * z2 - i2 * I2 + s2 * k2) * B2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v3) * B2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v3) * B2, t2[8] = (a2 * T2 - o2 * I2 + u2 * S2) * B2, t2[9] = (n2 * I2 - r2 * T2 - s2 * S2) * B2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * B2, t2[11] = (h4 * b2 - c2 * _2 - f2 * x2) * B2, t2[12] = (o2 * k2 - a2 * M2 - l2 * S2) * B2, t2[13] = (r2 * M2 - n2 * k2 + i2 * S2) * B2, t2[14] = (y2 * v3 - d2 * w2 - m2 * x2) * B2, t2[15] = (c2 * w2 - h4 * v3 + p2 * x2) * B2, t2) : null;
      }
      function Po(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h4 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v3 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
        return t2[0] = v3 * n2 + b2 * o2 + w2 * h4 + _2 * y2, t2[1] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v3 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v3 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h4 + (_2 = r2[7]) * y2, t2[5] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v3 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v3 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h4 + (_2 = r2[11]) * y2, t2[9] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v3 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v3 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h4 + (_2 = r2[15]) * y2, t2[13] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v3 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
      }
      function Do(t2, e2, r2) {
        var n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h4 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h4, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h4 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
      }
      function Vo(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }
      function Lo(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h4 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h4 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h4 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
      }
      function Fo(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h4 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h4 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h4 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
      }
      function Ro(t2, e2) {
        return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function jo(t2, e2, r2) {
        var n2, i2, s2, a2 = r2[0], o2 = r2[1], l2 = r2[2], u2 = Math.hypot(a2, o2, l2);
        return u2 < Mo ? null : (a2 *= u2 = 1 / u2, o2 *= u2, l2 *= u2, n2 = Math.sin(e2), i2 = Math.cos(e2), t2[0] = a2 * a2 * (s2 = 1 - i2) + i2, t2[1] = o2 * a2 * s2 + l2 * n2, t2[2] = l2 * a2 * s2 - o2 * n2, t2[3] = 0, t2[4] = a2 * o2 * s2 - l2 * n2, t2[5] = o2 * o2 * s2 + i2, t2[6] = l2 * o2 * s2 + a2 * n2, t2[7] = 0, t2[8] = a2 * l2 * s2 + o2 * n2, t2[9] = o2 * l2 * s2 - a2 * n2, t2[10] = l2 * l2 * s2 + i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e2 = arguments.length; e2--; )
          t2 += arguments[e2] * arguments[e2];
        return Math.sqrt(t2);
      });
      var Uo = Po;
      function $o() {
        var t2 = new To(3);
        return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
      }
      function Oo(t2) {
        var e2 = new To(3);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
      }
      function qo(t2) {
        return Math.hypot(t2[0], t2[1], t2[2]);
      }
      function No(t2, e2, r2) {
        var n2 = new To(3);
        return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
      }
      function Go(t2, e2, r2) {
        return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
      }
      function Xo(t2, e2, r2) {
        return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
      }
      function Zo(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
      }
      function Ko(t2, e2, r2) {
        return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2;
      }
      function Yo(t2, e2, r2) {
        return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2;
      }
      function Ho(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
      }
      function Wo(t2, e2, r2, n2) {
        return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
      }
      function Jo(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
      }
      function Qo(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
      }
      function tl(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
        return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
      }
      function el(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
        return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
      }
      function rl(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = e2[0], o2 = e2[1], l2 = e2[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h4 = n2 * o2 - i2 * a2, p2 = i2 * h4 - s2 * c2, f2 = s2 * u2 - n2 * h4, d2 = n2 * c2 - i2 * u2, y2 = 2 * r2[3];
        return c2 *= y2, h4 *= y2, f2 *= 2, d2 *= 2, t2[0] = a2 + (u2 *= y2) + (p2 *= 2), t2[1] = o2 + c2 + f2, t2[2] = l2 + h4 + d2, t2;
      }
      var nl, il = Xo, sl = Zo, al = qo;
      function ol(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
      }
      function ll(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
        return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
      }
      function ul(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }
      function cl() {
        var t2 = new To(4);
        return To != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
      }
      function hl(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
      }
      function pl(t2, e2, r2) {
        r2 *= 0.5;
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
      }
      function fl(t2, e2, r2) {
        r2 *= 0.5;
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 - s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = s2 * l2 + n2 * o2, t2[3] = a2 * l2 - i2 * o2, t2;
      }
      $o(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);
      var dl = ll;
      $o(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();
      const yl = na([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: ml } = yl, gl = na([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var xl = na([{ name: "a_pos", type: "Int16", components: 2 }]);
      class vl {
        constructor(t2, e2) {
          this.pos = t2, this.dir = e2;
        }
        intersectsPlane(t2, e2, r2) {
          const n2 = Qo(e2, this.dir);
          if (Math.abs(n2) < 1e-6)
            return false;
          const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
          return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
        }
        closestPointOnSphere(t2, e2, r2) {
          if (function(t3, e3) {
            var r3 = t3[0], n3 = t3[1], i3 = t3[2], s3 = e3[0], a3 = e3[1], o3 = e3[2];
            return Math.abs(r3 - s3) <= Mo * Math.max(1, Math.abs(r3), Math.abs(s3)) && Math.abs(n3 - a3) <= Mo * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= Mo * Math.max(1, Math.abs(i3), Math.abs(o3));
          }(this.pos, t2) || e2 === 0)
            return r2[0] = r2[1] = r2[2] = 0, false;
          const [n2, i2, s2] = this.dir, a2 = this.pos[0] - t2[0], o2 = this.pos[1] - t2[1], l2 = this.pos[2] - t2[2], u2 = n2 * n2 + i2 * i2 + s2 * s2, c2 = 2 * (a2 * n2 + o2 * i2 + l2 * s2), h4 = c2 * c2 - 4 * u2 * (a2 * a2 + o2 * o2 + l2 * l2 - e2 * e2);
          if (h4 < 0) {
            const t3 = Math.max(-c2 / 2, 0), u3 = a2 + n2 * t3, h5 = o2 + i2 * t3, p2 = l2 + s2 * t3, f2 = Math.hypot(u3, h5, p2);
            return r2[0] = u3 * e2 / f2, r2[1] = h5 * e2 / f2, r2[2] = p2 * e2 / f2, false;
          }
          {
            const t3 = (-c2 - Math.sqrt(h4)) / (2 * u2);
            if (t3 < 0) {
              const t4 = Math.hypot(a2, o2, l2);
              return r2[0] = a2 * e2 / t4, r2[1] = o2 * e2 / t4, r2[2] = l2 * e2 / t4, false;
            }
            return r2[0] = a2 + n2 * t3, r2[1] = o2 + i2 * t3, r2[2] = l2 + s2 * t3, true;
          }
        }
      }
      class bl {
        constructor(t2, e2, r2, n2, i2) {
          this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n2, this.horizon = i2;
        }
        static fromInvProjectionMatrix(t2, e2, r2) {
          const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = el(n2, n2, t2), l2 = el(i2, i2, t2), u2 = el(s2, s2, t2), c2 = el(a2, a2, t2);
          return new bl(o2, l2, u2, c2, e2 / r2);
        }
      }
      class wl {
        constructor(t2, e2) {
          this.points = t2, this.planes = e2;
        }
        static fromInvProjectionMatrix(t2, e2, r2, n2) {
          const i2 = Math.pow(2, r2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
            const s3 = ul([], r3, t2), a3 = 1 / s3[3] / e2 * i2;
            return function(t3, e3, r4) {
              return t3[0] = e3[0] * r4[0], t3[1] = e3[1] * r4[1], t3[2] = e3[2] * r4[2], t3[3] = e3[3] * r4[3], t3;
            }(s3, s3, [a3, a3, n2 ? 1 / s3[3] : a3, a3]);
          }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const e3 = Jo([], tl([], il([], s2[t3[0]], s2[t3[1]]), il([], s2[t3[2]], s2[t3[1]]))), r3 = -Qo(e3, s2[t3[1]]);
            return e3.concat(r3);
          });
          return new wl(s2, a2);
        }
      }
      class _l {
        static fromPoints(t2) {
          const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
          for (const n2 of t2)
            Ko(e2, e2, n2), Yo(r2, r2, n2);
          return new _l(e2, r2);
        }
        static applyTransform(t2, e2) {
          const r2 = t2.getCorners();
          for (let t3 = 0; t3 < r2.length; ++t3)
            el(r2[t3], r2[t3], e2);
          return _l.fromPoints(r2);
        }
        constructor(t2, e2) {
          this.min = t2, this.max = e2, this.center = Ho([], Go([], this.min, this.max), 0.5);
        }
        quadrant(t2) {
          const e2 = [t2 % 2 == 0, t2 < 2], r2 = Oo(this.min), n2 = Oo(this.max);
          for (let t3 = 0; t3 < e2.length; t3++)
            r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
          return n2[2] = this.max[2], new _l(r2, n2);
        }
        distanceX(t2) {
          return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
        }
        distanceY(t2) {
          return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
        }
        distanceZ(t2) {
          return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
        }
        getCorners() {
          const t2 = this.min, e2 = this.max;
          return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
        }
        intersects(t2) {
          const e2 = this.getCorners();
          let r2 = true;
          for (let n2 = 0; n2 < t2.planes.length; n2++) {
            const i2 = t2.planes[n2];
            let s2 = 0;
            for (let t3 = 0; t3 < e2.length; t3++)
              s2 += Qo(i2, e2[t3]) + i2[3] >= 0;
            if (s2 === 0)
              return 0;
            s2 !== e2.length && (r2 = false);
          }
          if (r2)
            return 2;
          for (let e3 = 0; e3 < 3; e3++) {
            let r3 = Number.MAX_VALUE, n2 = -Number.MAX_VALUE;
            for (let i2 = 0; i2 < t2.points.length; i2++) {
              const s2 = t2.points[i2][e3] - this.min[e3];
              r3 = Math.min(r3, s2), n2 = Math.max(n2, s2);
            }
            if (n2 < 0 || r3 > this.max[e3] - this.min[e3])
              return 0;
          }
          return 1;
        }
      }
      const Al = ko / Math.PI / 2, Sl = 64, kl = [Sl, 32, 16], Il = -Al, Ml = Al, Tl = [new _l([Il, Il, Il], [Ml, Ml, Ml]), new _l([Il, Il, Il], [0, 0, Ml]), new _l([0, Il, Il], [Ml, 0, Ml]), new _l([Il, 0, Il], [0, Ml, Ml]), new _l([0, 0, Il], [Ml, Ml, Ml])];
      function zl(t2) {
        return t2 * Al / tu;
      }
      function Bl(t2, e2, r2, n2 = true) {
        const i2 = Ho([], t2._camera.position, t2.worldSize), s2 = [e2, r2, 1, 1];
        ul(s2, s2, t2.pixelMatrixInverse), ol(s2, s2, 1 / s2[3]);
        const a2 = Jo([], il([], s2, i2)), o2 = t2.globeMatrix, l2 = [o2[12], o2[13], o2[14]], u2 = il([], l2, i2), c2 = qo(u2), h4 = Jo([], u2), p2 = t2.worldSize / (2 * Math.PI), f2 = Qo(h4, a2), d2 = Math.asin(p2 / c2);
        if (d2 < Math.acos(f2)) {
          if (!n2)
            return null;
          const t3 = [], e3 = [];
          Ho(t3, a2, c2 / f2), Jo(e3, il(e3, t3, u2)), Jo(a2, Go(a2, u2, Ho(a2, e3, Math.tan(d2) * c2)));
        }
        const y2 = [];
        new vl(i2, a2).closestPointOnSphere(l2, p2, y2);
        const m2 = Jo([], Y(o2, 0)), g2 = Jo([], Y(o2, 1)), x2 = Jo([], Y(o2, 2)), b2 = Qo(m2, y2), w2 = Qo(g2, y2), _2 = Qo(x2, y2), A2 = v2(Math.asin(-w2 / p2));
        let k2 = v2(Math.atan2(b2, _2));
        k2 = t2.center.lng + function(t3, e3) {
          const r3 = (e3 - t3 + 180) % 360 - 180;
          return r3 < -180 ? r3 + 360 : r3;
        }(t2.center.lng, k2);
        const I2 = iu(k2), M2 = S(su(A2), 0, 1);
        return new pu(I2, M2);
      }
      class El {
        constructor(t2, e2, r2) {
          this.a = il([], t2, r2), this.b = il([], e2, r2), this.center = r2;
          const n2 = Jo([], this.a), i2 = Jo([], this.b);
          this.angle = Math.acos(Qo(n2, i2));
        }
      }
      function Cl(t2, e2) {
        if (t2.angle === 0)
          return null;
        let r2;
        return r2 = t2.a[e2] === 0 ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
          const i2 = Math.sin(r3);
          return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
        }(t2.a[e2], t2.b[e2], t2.angle, S(r2, 0, 1)) + t2.center[e2];
      }
      function Pl(t2) {
        if (t2.z <= 1)
          return Tl[t2.z + 2 * t2.y + t2.x];
        const e2 = jl(Rl(t2));
        return _l.fromPoints(e2);
      }
      function Dl(t2, e2, r2) {
        return Ho(t2, t2, 1 - r2), Wo(t2, t2, e2, r2);
      }
      function Vl(t2, e2) {
        const r2 = Kl(e2.zoom);
        if (r2 === 0)
          return Pl(t2);
        const n2 = Rl(t2), i2 = jl(n2), s2 = iu(n2.getWest()) * e2.worldSize, a2 = iu(n2.getEast()) * e2.worldSize, o2 = su(n2.getNorth()) * e2.worldSize, l2 = su(n2.getSouth()) * e2.worldSize, u2 = [s2, o2, 0], c2 = [a2, o2, 0], h4 = [s2, l2, 0], p2 = [a2, l2, 0], f2 = Co([], e2.globeMatrix);
        return el(u2, u2, f2), el(c2, c2, f2), el(h4, h4, f2), el(p2, p2, f2), i2[0] = Dl(i2[0], h4, r2), i2[1] = Dl(i2[1], p2, r2), i2[2] = Dl(i2[2], c2, r2), i2[3] = Dl(i2[3], u2, r2), _l.fromPoints(i2);
      }
      function Ll(t2, e2, r2) {
        for (const n2 of t2)
          el(n2, n2, e2), Ho(n2, n2, r2);
      }
      function Fl(t2, e2, r2) {
        const n2 = e2 / t2.worldSize, i2 = t2.globeMatrix;
        if (r2.z <= 1) {
          const t3 = Pl(r2).getCorners();
          return Ll(t3, i2, n2), _l.fromPoints(t3);
        }
        const s2 = Rl(r2), a2 = jl(s2);
        Ll(a2, i2, n2);
        const o2 = Number.MAX_VALUE, l2 = [-o2, -o2, -o2], u2 = [o2, o2, o2];
        if (s2.contains(t2.center)) {
          for (const t3 of a2)
            Ko(u2, u2, t3), Yo(l2, l2, t3);
          l2[2] = 0;
          const e3 = t2.point, r3 = [e3.x * n2, e3.y * n2, 0];
          return Ko(u2, u2, r3), Yo(l2, l2, r3), new _l(u2, l2);
        }
        const c2 = [i2[12] * n2, i2[13] * n2, i2[14] * n2], h4 = s2.getCenter(), p2 = S(t2.center.lat, -cu, cu), f2 = S(h4.lat, -cu, cu), d2 = iu(t2.center.lng), y2 = su(p2);
        let m2 = d2 - iu(h4.lng);
        const g2 = y2 - su(f2);
        m2 > 0.5 ? m2 -= 1 : m2 < -0.5 && (m2 += 1);
        let v3 = 0;
        Math.abs(m2) > Math.abs(g2) ? v3 = m2 >= 0 ? 1 : 3 : (v3 = g2 >= 0 ? 0 : 2, Wo(c2, c2, [i2[4] * n2, i2[5] * n2, i2[6] * n2], -Math.sin(x(g2 >= 0 ? s2.getSouth() : s2.getNorth())) * Al));
        const b2 = a2[v3], w2 = a2[(v3 + 1) % 4], _2 = new El(b2, w2, c2), A2 = [Cl(_2, 0) || b2[0], Cl(_2, 1) || b2[1], Cl(_2, 2) || b2[2]], k2 = Kl(t2.zoom);
        if (k2 > 0) {
          const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, a3) {
            const o3 = 1 / (1 << r3);
            let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h5 = c3 + o3, p3 = 0;
            const f3 = (l3 + u3) / 2 - s3;
            return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h5 = (h5 * n4 - a3) * i4 + a3, [[l3, h5, 0], [u3, h5, 0], [u3, c3, 0], [l3, c3, 0]];
          }(r2, e2, t2._pixelsPerMercatorPixel, d2, y2);
          for (let t3 = 0; t3 < a2.length; t3++)
            Dl(a2[t3], n3[t3], k2);
          const i3 = Go([], n3[v3], n3[(v3 + 1) % 4]);
          Ho(i3, i3, 0.5), Dl(A2, i3, k2);
        }
        for (const t3 of a2)
          Ko(u2, u2, t3), Yo(l2, l2, t3);
        return u2[2] = Math.min(b2[2], w2[2]), Ko(u2, u2, A2), Yo(l2, l2, A2), new _l(u2, l2);
      }
      function Rl({ x: t2, y: e2, z: r2 }) {
        const n2 = 1 / (1 << r2), i2 = new ru(ou(t2 * n2), lu((e2 + 1) * n2)), s2 = new ru(ou((t2 + 1) * n2), lu(e2 * n2));
        return new Io(i2, s2);
      }
      function jl(t2) {
        const e2 = x(t2.getNorth()), r2 = x(t2.getSouth()), n2 = Math.cos(e2), i2 = Math.cos(r2), s2 = Math.sin(e2), a2 = Math.sin(r2), o2 = t2.getWest(), l2 = t2.getEast();
        return [Ul(i2, a2, o2), Ul(i2, a2, l2), Ul(n2, s2, l2), Ul(n2, s2, o2)];
      }
      function Ul(t2, e2, r2, n2 = Al) {
        return r2 = x(r2), [t2 * Math.sin(r2) * n2, -e2 * n2, t2 * Math.cos(r2) * n2];
      }
      function $l(t2, e2, r2) {
        return Ul(Math.cos(x(t2)), Math.sin(x(t2)), e2, r2);
      }
      function Ol(t2, e2, r2, n2) {
        const i2 = 1 << r2.z, s2 = (t2 / ko + r2.x) / i2;
        return $l(lu((e2 / ko + r2.y) / i2), ou(s2), n2);
      }
      function ql({ min: t2, max: e2 }) {
        return 16383 / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
      }
      const Nl = new Float64Array(16);
      function Gl(t2) {
        const e2 = ql(t2), r2 = Ro(Nl, [e2, e2, e2]);
        return Do(r2, r2, ((n2 = [])[0] = -(i2 = t2.min)[0], n2[1] = -i2[1], n2[2] = -i2[2], n2));
        var n2, i2;
      }
      function Xl(t2) {
        const e2 = (n2 = t2.min, (r2 = Nl)[0] = 1, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = 1, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 1, r2[11] = 0, r2[12] = n2[0], r2[13] = n2[1], r2[14] = n2[2], r2[15] = 1, r2);
        var r2, n2;
        const i2 = 1 / ql(t2);
        return Vo(e2, e2, [i2, i2, i2]);
      }
      function Zl(t2, e2, r2, n2, i2) {
        const s2 = function(t3) {
          const e3 = ko / (2 * Math.PI);
          return t3 / (2 * Math.PI) / e3;
        }(r2), a2 = [t2, e2, -r2 / (2 * Math.PI)], o2 = Eo(new Float64Array(16));
        return Do(o2, o2, a2), Vo(o2, o2, [s2, s2, s2]), Lo(o2, o2, x(-i2)), Fo(o2, o2, x(-n2)), o2;
      }
      function Kl(t2) {
        return k(5, 6, t2);
      }
      function Yl(t2, e2) {
        const r2 = $l(e2.lat, e2.lng), n2 = function(t3) {
          const e3 = $l(t3._center.lat, t3._center.lng);
          let r3 = tl([], No(0, 1, 0), e3);
          const n3 = jo([], -t3.angle, e3);
          r3 = el(r3, r3, n3), jo(n3, -t3._pitch, r3);
          const i3 = Jo([], e3);
          return Ho(i3, i3, zl(t3.cameraToCenterDistance / t3.pixelsPerMeter)), el(i3, i3, n3), Go([], e3, i3);
        }(t2);
        return a2 = (i2 = Xo([], n2, r2))[0], o2 = i2[1], l2 = i2[2], u2 = (s2 = r2)[0], c2 = s2[1], h4 = s2[2], f2 = (p2 = Math.sqrt(a2 * a2 + o2 * o2 + l2 * l2) * Math.sqrt(u2 * u2 + c2 * c2 + h4 * h4)) && Qo(i2, s2) / p2, Math.acos(Math.min(Math.max(f2, -1), 1));
        var i2, s2, a2, o2, l2, u2, c2, h4, p2, f2;
      }
      function Hl(t2, e2) {
        return Yl(t2, e2) > Math.PI / 2 * 1.01;
      }
      const Wl = x(85), Jl = Math.cos(Wl), Ql = Math.sin(Wl), tu = 63710088e-1, eu = 2 * Math.PI * tu;
      class ru {
        constructor(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new ru(I(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
          return tu * Math.acos(Math.min(i2, 1));
        }
        toBounds(t2 = 0) {
          const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
          return new Io(new ru(this.lng - r2, this.lat - e2), new ru(this.lng + r2, this.lat + e2));
        }
        toEcef(t2) {
          const e2 = zl(t2);
          return $l(this.lat, this.lng, Al + e2);
        }
        static convert(t2) {
          if (t2 instanceof ru)
            return t2;
          if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
            return new ru(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
            return new ru(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      function nu(t2) {
        return eu * Math.cos(t2 * Math.PI / 180);
      }
      function iu(t2) {
        return (180 + t2) / 360;
      }
      function su(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function au(t2, e2) {
        return t2 / nu(e2);
      }
      function ou(t2) {
        return 360 * t2 - 180;
      }
      function lu(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }
      function uu(t2, e2) {
        return t2 * nu(lu(e2));
      }
      const cu = 85.051129;
      function hu(t2) {
        return 1 / Math.cos(t2 * Math.PI / 180);
      }
      class pu {
        constructor(t2, e2, r2 = 0) {
          this.x = +t2, this.y = +e2, this.z = +r2;
        }
        static fromLngLat(t2, e2 = 0) {
          const r2 = ru.convert(t2);
          return new pu(iu(r2.lng), su(r2.lat), au(e2, r2.lat));
        }
        toLngLat() {
          return new ru(ou(this.x), lu(this.y));
        }
        toAltitude() {
          return uu(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / eu * hu(lu(this.y));
        }
      }
      function fu(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = (e2 + n2) / 2, c2 = (r2 + i2) / 2, h4 = new d(u2, c2);
        o2(h4), function(t3, e3, r3, n3, i3, s3) {
          const a3 = r3 - i3, o3 = n3 - s3;
          return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
        }(h4.x, h4.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? (fu(t2, e2, r2, u2, c2, s2, h4, o2, l2), fu(t2, u2, c2, n2, i2, h4, a2, o2, l2)) : t2.push(a2);
      }
      function du(t2, e2, r2) {
        let n2 = t2[0], i2 = n2.x, s2 = n2.y;
        e2(n2);
        const a2 = [n2];
        for (let o2 = 1; o2 < t2.length; o2++) {
          const l2 = t2[o2], { x: u2, y: c2 } = l2;
          e2(l2), fu(a2, i2, s2, u2, c2, n2, l2, e2, r2), i2 = u2, s2 = c2, n2 = l2;
        }
        return a2;
      }
      function yu(t2, e2, r2, n2) {
        if (n2(e2, r2)) {
          const i2 = e2.add(r2)._mult(0.5);
          yu(t2, e2, i2, n2), yu(t2, i2, r2, n2);
        } else
          t2.push(r2);
      }
      function mu(t2, e2) {
        let r2 = t2[0];
        const n2 = [r2];
        for (let i2 = 1; i2 < t2.length; i2++) {
          const s2 = t2[i2];
          yu(n2, r2, s2, e2), r2 = s2;
        }
        return n2;
      }
      const gu = Math.pow(2, 14) - 1, xu = -gu - 1;
      function vu(t2, e2) {
        const r2 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
        return t2.x = S(r2, xu, gu), t2.y = S(n2, xu, gu), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && $("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
      }
      function bu(t2, e2, r2) {
        const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = ko / i2;
        if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
          const s3 = 1 << e2.z, { scale: a2, x: o2, y: l2, projection: u2 } = r2, c2 = (t3) => {
            const r3 = ou((e2.x + t3.x / i2) / s3), n3 = lu((e2.y + t3.y / i2) / s3), c3 = u2.project(r3, n3);
            t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
          };
          for (let e3 = 0; e3 < n2.length; e3++)
            if (t2.type !== 1)
              n2[e3] = du(n2[e3], c2, 1);
            else {
              const t3 = [];
              for (const r3 of n2[e3])
                r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
              n2[e3] = t3;
            }
        }
        for (const t3 of n2)
          for (const e3 of t3)
            vu(e3, s2);
        return n2;
      }
      function wu(t2, e2) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? bu(t2) : [] };
      }
      function _u(t2, e2, r2, n2, i2) {
        t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }
      function Au(t2, e2, r2) {
        const n2 = 16384;
        t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
      }
      class Su {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.segments = new So(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2, n2) {
          const i2 = this.layers[0], s2 = [];
          let a2 = null;
          i2.type === "circle" && (a2 = i2.layout.get("circle-sort-key"));
          for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u2, r2))
              continue;
            const c2 = a2 ? a2.evaluate(u2, {}, r2) : void 0, h4 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o3, geometry: t3 ? u2.geometry : bu(e3, r2, n2), patterns: {}, sortKey: c2 };
            s2.push(h4);
          }
          a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          let o2 = null;
          n2.projection.name === "globe" && (this.globeExtVertexArray = new pa(), o2 = n2.projection);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
            this.addFeature(n3, i3, s3, e2.availableImages, r2, o2), e2.featureIndex.insert(l2, i3, s3, a3, this.index);
          }
        }
        update(t2, e2, r2, n2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t2, e2, r2, n2, i2, s2) {
          for (const r3 of e2)
            for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= ko || n3 < 0 || n3 >= ko)
                continue;
              if (s2) {
                const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), a3 = this.globeExtVertexArray;
                Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4), Au(a3, t3, e4);
              }
              const a2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a2.vertexLength;
              _u(this.layoutVertexArray, r4, n3, -1, -1), _u(this.layoutVertexArray, r4, n3, 1, -1), _u(this.layoutVertexArray, r4, n3, 1, 1), _u(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a2.vertexLength += 4, a2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2);
        }
      }
      function ku(t2, e2) {
        for (let r2 = 0; r2 < t2.length; r2++)
          if (Du(e2, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e2.length; r2++)
          if (Du(t2, e2[r2]))
            return true;
        return !!zu(t2, e2);
      }
      function Iu(t2, e2, r2) {
        return !!Du(t2, e2) || !!Eu(e2, t2, r2);
      }
      function Mu(t2, e2) {
        if (t2.length === 1)
          return Pu(e2, t2[0]);
        for (let r2 = 0; r2 < e2.length; r2++) {
          const n2 = e2[r2];
          for (let e3 = 0; e3 < n2.length; e3++)
            if (Du(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0; r2 < t2.length; r2++)
          if (Pu(e2, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e2.length; r2++)
          if (zu(t2, e2[r2]))
            return true;
        return false;
      }
      function Tu(t2, e2, r2) {
        if (t2.length > 1) {
          if (zu(t2, e2))
            return true;
          for (let n2 = 0; n2 < e2.length; n2++)
            if (Eu(e2[n2], t2, r2))
              return true;
        }
        for (let n2 = 0; n2 < t2.length; n2++)
          if (Eu(t2[n2], e2, r2))
            return true;
        return false;
      }
      function zu(t2, e2) {
        if (t2.length === 0 || e2.length === 0)
          return false;
        for (let r2 = 0; r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0; t3 < e2.length - 1; t3++)
            if (Bu(n2, i2, e2[t3], e2[t3 + 1]))
              return true;
        }
        return false;
      }
      function Bu(t2, e2, r2, n2) {
        return O(t2, r2, n2) !== O(e2, r2, n2) && O(t2, e2, r2) !== O(t2, e2, n2);
      }
      function Eu(t2, e2, r2) {
        const n2 = r2 * r2;
        if (e2.length === 1)
          return t2.distSqr(e2[0]) < n2;
        for (let r3 = 1; r3 < e2.length; r3++)
          if (Cu(t2, e2[r3 - 1], e2[r3]) < n2)
            return true;
        return false;
      }
      function Cu(t2, e2, r2) {
        const n2 = e2.distSqr(r2);
        if (n2 === 0)
          return t2.distSqr(e2);
        const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function Pu(t2, e2) {
        let r2, n2, i2, s2 = false;
        for (let a2 = 0; a2 < t2.length; a2++) {
          r2 = t2[a2];
          for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
            n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
        }
        return s2;
      }
      function Du(t2, e2) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function Vu(t2, e2, r2, n2, i2) {
        for (const s3 of t2)
          if (e2 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y)
            return true;
        const s2 = [new d(e2, r2), new d(e2, i2), new d(n2, i2), new d(n2, r2)];
        if (t2.length > 2) {
          for (const e3 of s2)
            if (Du(t2, e3))
              return true;
        }
        for (let e3 = 0; e3 < t2.length - 1; e3++)
          if (Lu(t2[e3], t2[e3 + 1], s2))
            return true;
        return false;
      }
      function Lu(t2, e2, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = O(t2, e2, r2[0]);
        return s2 !== O(t2, e2, r2[1]) || s2 !== O(t2, e2, r2[2]) || s2 !== O(t2, e2, r2[3]);
      }
      function Fu(t2, e2, r2) {
        const n2 = e2.paint.get(t2).value;
        return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function Ru(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function ju(t2, e2, r2, n2, i2) {
        if (!e2[0] && !e2[1])
          return t2;
        const s2 = d.convert(e2)._mult(i2);
        r2 === "viewport" && s2._rotate(-n2);
        const a2 = [];
        for (let e3 = 0; e3 < t2.length; e3++)
          a2.push(t2[e3].sub(s2));
        return a2;
      }
      function Uu(t2, e2, r2, n2) {
        const i2 = d.convert(t2)._mult(n2);
        return e2 === "viewport" && i2._rotate(-r2), i2;
      }
      Oi(Su, "CircleBucket", { omit: ["layers"] });
      const $u = new Js({ "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"]) });
      var Ou = { paint: new Js({ "circle-radius": new Hs(Ht.paint_circle["circle-radius"]), "circle-color": new Hs(Ht.paint_circle["circle-color"]), "circle-blur": new Hs(Ht.paint_circle["circle-blur"]), "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]), "circle-translate": new Ys(Ht.paint_circle["circle-translate"]), "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"]) }), layout: $u };
      function qu(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        if (s2 && t2.queryGeometry.isAboveHorizon)
          return false;
        s2 && (l2 *= t2.pixelToTileUnitsFactor);
        const u2 = t2.tileID.canonical, c2 = r2.projection.upVectorScale(u2, r2.center.lat, r2.worldSize).metersToTile;
        for (const h4 of e2)
          for (const e3 of h4) {
            const h5 = e3.add(o2), p2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h5.x, h5.y, true) : 0, f2 = r2.projection.projectTilePoint(h5.x, h5.y, u2);
            if (p2 > 0) {
              const t3 = r2.projection.upVector(u2, h5.x, h5.y);
              f2.x += t3[0] * c2 * p2, f2.y += t3[1] * c2 * p2, f2.z += t3[2] * c2 * p2;
            }
            const d2 = s2 ? h5 : Nu(f2.x, f2.y, f2.z, n2), y2 = s2 ? t2.tilespaceRays.map((t3) => Zu(t3, p2)) : t2.queryGeometry.screenGeometry, m2 = ul([], [f2.x, f2.y, f2.z, 1], n2);
            if (!a2 && s2 ? l2 *= m2[3] / r2.cameraToCenterDistance : a2 && !s2 && (l2 *= r2.cameraToCenterDistance / m2[3]), s2) {
              const t3 = lu((e3.y / ko + u2.y) / (1 << u2.z));
              l2 /= r2.projection.pixelsPerMeter(t3, 1) / au(1, t3);
            }
            if (Iu(y2, d2, l2))
              return true;
          }
        return false;
      }
      function Nu(t2, e2, r2, n2) {
        const i2 = ul([], [t2, e2, r2, 1], n2);
        return new d(i2[0] / i2[3], i2[1] / i2[3]);
      }
      const Gu = No(0, 0, 0), Xu = No(0, 0, 1);
      function Zu(t2, e2) {
        const r2 = $o();
        return Gu[2] = e2, t2.intersectsPlane(Gu, Xu, r2), new d(r2[0], r2[1]);
      }
      class Ku extends Su {
      }
      function Yu(t2, { width: e2, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r2 * n2)
            throw new RangeError("mismatched image size");
        } else
          i2 = new Uint8Array(e2 * r2 * n2);
        return t2.width = e2, t2.height = r2, t2.data = i2, t2;
      }
      function Hu(t2, e2, r2) {
        const { width: n2, height: i2 } = e2;
        n2 === t2.width && i2 === t2.height || (Wu(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = e2.data);
      }
      function Wu(t2, e2, r2, n2, i2, s2) {
        if (i2.width === 0 || i2.height === 0)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t2.data, o2 = e2.data;
        for (let l2 = 0; l2 < i2.height; l2++) {
          const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
          for (let t3 = 0; t3 < i2.width * s2; t3++)
            o2[c2 + t3] = a2[u2 + t3];
        }
        return e2;
      }
      Oi(Ku, "HeatmapBucket", { omit: ["layers"] });
      class Ju {
        constructor(t2, e2) {
          Yu(this, t2, 1, e2);
        }
        resize(t2) {
          Hu(this, new Ju(t2), 1);
        }
        clone() {
          return new Ju({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          Wu(t2, e2, r2, n2, i2, 1);
        }
      }
      class Qu {
        constructor(t2, e2) {
          Yu(this, t2, 4, e2);
        }
        resize(t2) {
          Hu(this, new Qu(t2), 4);
        }
        replace(t2, e2) {
          e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new Qu({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          Wu(t2, e2, r2, n2, i2, 4);
        }
      }
      Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");
      var tc = { paint: new Js({ "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"]) }) };
      function ec(t2) {
        const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Qu({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
          e2[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u2 * o2);
            }
        else
          for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      var rc = { paint: new Js({ "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"]) }) };
      const nc = na([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ic } = nc;
      var sc = {};
      function ac(t2, e2, r2) {
        r2 = r2 || 2;
        var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h4 = c2 ? e2[0] * r2 : t2.length, p2 = oc(t2, 0, h4, r2, true), f2 = [];
        if (!p2 || p2.next === p2.prev)
          return f2;
        if (c2 && (p2 = function(t3, e3, r3, n3) {
          var i3, s3, a3, o3 = [];
          for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
            (a3 = oc(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(xc(a3));
          for (o3.sort(dc), i3 = 0; i3 < o3.length; i3++)
            r3 = yc(o3[i3], r3);
          return r3;
        }(t2, e2, p2, r2)), t2.length > 80 * r2) {
          n2 = s2 = t2[0], i2 = a2 = t2[1];
          for (var d2 = r2; d2 < h4; d2 += r2)
            (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
          u2 = (u2 = Math.max(s2 - n2, a2 - i2)) !== 0 ? 32767 / u2 : 0;
        }
        return uc(p2, f2, r2, n2, i2, u2, 0), f2;
      }
      function oc(t2, e2, r2, n2, i2) {
        var s2, a2;
        if (i2 === Ec(t2, e2, r2, n2) > 0)
          for (s2 = e2; s2 < r2; s2 += n2)
            a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
        else
          for (s2 = r2 - n2; s2 >= e2; s2 -= n2)
            a2 = Tc(s2, t2[s2], t2[s2 + 1], a2);
        return a2 && _c(a2, a2.next) && (zc(a2), a2 = a2.next), a2;
      }
      function lc(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        var r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !_c(n2, n2.next) && wc(n2.prev, n2, n2.next) !== 0)
            n2 = n2.next;
          else {
            if (zc(n2), (n2 = e2 = n2.prev) === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function uc(t2, e2, r2, n2, i2, s2, a2) {
        if (t2) {
          !a2 && s2 && function(t3, e3, r3, n3) {
            var i3 = t3;
            do {
              i3.z === 0 && (i3.z = gc(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
              do {
                for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                  for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                    ;
                  for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                    o3 !== 0 && (l3 === 0 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                  r4 = n4;
                }
                s3.nextZ = null, u3 *= 2;
              } while (a3 > 1);
            }(i3);
          }(t2, n2, i2, s2);
          for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
            if (o2 = t2.prev, l2 = t2.next, s2 ? hc(t2, n2, i2, s2) : cc(t2))
              e2.push(o2.i / r2 | 0), e2.push(t2.i / r2 | 0), e2.push(l2.i / r2 | 0), zc(t2), t2 = l2.next, u2 = l2.next;
            else if ((t2 = l2) === u2) {
              a2 ? a2 === 1 ? uc(t2 = pc(lc(t2), e2, r2), e2, r2, n2, i2, s2, 2) : a2 === 2 && fc(t2, e2, r2, n2, i2, s2) : uc(lc(t2), e2, r2, n2, i2, s2, 1);
              break;
            }
        }
      }
      function cc(t2) {
        var e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (wc(e2, r2, n2) >= 0)
          return false;
        for (var i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h4 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
          if (d2.x >= c2 && d2.x <= p2 && d2.y >= h4 && d2.y <= f2 && vc(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && wc(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function hc(t2, e2, r2, n2) {
        var i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (wc(i2, s2, a2) >= 0)
          return false;
        for (var o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h4 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h4 ? c2 < p2 ? c2 : p2 : h4 < p2 ? h4 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h4 ? c2 > p2 ? c2 : p2 : h4 > p2 ? h4 : p2, g2 = gc(f2, d2, e2, r2, n2), x2 = gc(y2, m2, e2, r2, n2), v3 = t2.prevZ, b2 = t2.nextZ; v3 && v3.z >= g2 && b2 && b2.z <= x2; ) {
          if (v3.x >= f2 && v3.x <= y2 && v3.y >= d2 && v3.y <= m2 && v3 !== i2 && v3 !== a2 && vc(o2, c2, l2, h4, u2, p2, v3.x, v3.y) && wc(v3.prev, v3, v3.next) >= 0)
            return false;
          if (v3 = v3.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h4, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (; v3 && v3.z >= g2; ) {
          if (v3.x >= f2 && v3.x <= y2 && v3.y >= d2 && v3.y <= m2 && v3 !== i2 && v3 !== a2 && vc(o2, c2, l2, h4, u2, p2, v3.x, v3.y) && wc(v3.prev, v3, v3.next) >= 0)
            return false;
          v3 = v3.prevZ;
        }
        for (; b2 && b2.z <= x2; ) {
          if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && vc(o2, c2, l2, h4, u2, p2, b2.x, b2.y) && wc(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function pc(t2, e2, r2) {
        var n2 = t2;
        do {
          var i2 = n2.prev, s2 = n2.next.next;
          !_c(i2, s2) && Ac(i2, n2, n2.next, s2) && Ic(i2, s2) && Ic(s2, i2) && (e2.push(i2.i / r2 | 0), e2.push(n2.i / r2 | 0), e2.push(s2.i / r2 | 0), zc(n2), zc(n2.next), n2 = t2 = s2), n2 = n2.next;
        } while (n2 !== t2);
        return lc(n2);
      }
      function fc(t2, e2, r2, n2, i2, s2) {
        var a2 = t2;
        do {
          for (var o2 = a2.next.next; o2 !== a2.prev; ) {
            if (a2.i !== o2.i && bc(a2, o2)) {
              var l2 = Mc(a2, o2);
              return a2 = lc(a2, a2.next), l2 = lc(l2, l2.next), uc(a2, e2, r2, n2, i2, s2, 0), void uc(l2, e2, r2, n2, i2, s2, 0);
            }
            o2 = o2.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function dc(t2, e2) {
        return t2.x - e2.x;
      }
      function yc(t2, e2) {
        var r2 = function(t3, e3) {
          var r3, n3 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
          do {
            if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
              var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
              if (o2 <= i2 && o2 > a2 && (a2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                return r3;
            }
            n3 = n3.next;
          } while (n3 !== e3);
          if (!r3)
            return null;
          var l2, u2 = r3, c2 = r3.x, h4 = r3.y, p2 = 1 / 0;
          n3 = r3;
          do {
            i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && vc(s2 < h4 ? i2 : a2, s2, c2, h4, s2 < h4 ? a2 : i2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i2 - n3.x), Ic(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && mc(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
          } while (n3 !== u2);
          return r3;
        }(t2, e2);
        if (!r2)
          return e2;
        var n2 = Mc(r2, t2);
        return lc(n2, n2.next), lc(r2, r2.next);
      }
      function mc(t2, e2) {
        return wc(t2.prev, t2, e2.prev) < 0 && wc(e2.next, t2, t2.next) < 0;
      }
      function gc(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function xc(t2) {
        var e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function vc(t2, e2, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
      }
      function bc(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          var r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ac(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (Ic(t2, e2) && Ic(e2, t2) && function(t3, e3) {
          var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (wc(t2.prev, t2, e2.prev) || wc(t2, e2.prev, e2)) || _c(t2, e2) && wc(t2.prev, t2, t2.next) > 0 && wc(e2.prev, e2, e2.next) > 0);
      }
      function wc(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function _c(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function Ac(t2, e2, r2, n2) {
        var i2 = kc(wc(t2, e2, r2)), s2 = kc(wc(t2, e2, n2)), a2 = kc(wc(r2, n2, t2)), o2 = kc(wc(r2, n2, e2));
        return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Sc(t2, r2, e2)) || !(s2 !== 0 || !Sc(t2, n2, e2)) || !(a2 !== 0 || !Sc(r2, t2, n2)) || !(o2 !== 0 || !Sc(r2, e2, n2));
      }
      function Sc(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function kc(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Ic(t2, e2) {
        return wc(t2.prev, t2, t2.next) < 0 ? wc(t2, e2, t2.next) >= 0 && wc(t2, t2.prev, e2) >= 0 : wc(t2, e2, t2.prev) < 0 || wc(t2, t2.next, e2) < 0;
      }
      function Mc(t2, e2) {
        var r2 = new Bc(t2.i, t2.x, t2.y), n2 = new Bc(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function Tc(t2, e2, r2, n2) {
        var i2 = new Bc(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function zc(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Bc(t2, e2, r2) {
        this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Ec(t2, e2, r2, n2) {
        for (var i2 = 0, s2 = e2, a2 = r2 - n2; s2 < r2; s2 += n2)
          i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
        return i2;
      }
      function Cc(t2, e2, r2, n2, i2) {
        Pc(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || Vc);
      }
      function Pc(t2, e2, r2, n2, i2) {
        for (; n2 > r2; ) {
          if (n2 - r2 > 600) {
            var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            Pc(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
          }
          var c2 = t2[e2], h4 = r2, p2 = n2;
          for (Dc(t2, r2, e2), i2(t2[n2], c2) > 0 && Dc(t2, r2, n2); h4 < p2; ) {
            for (Dc(t2, h4, p2), h4++, p2--; i2(t2[h4], c2) < 0; )
              h4++;
            for (; i2(t2[p2], c2) > 0; )
              p2--;
          }
          i2(t2[r2], c2) === 0 ? Dc(t2, r2, p2) : Dc(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
        }
      }
      function Dc(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function Vc(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Lc(t2, e2) {
        const r2 = t2.length;
        if (r2 <= 1)
          return [t2];
        const n2 = [];
        let i2, s2;
        for (let e3 = 0; e3 < r2; e3++) {
          const r3 = q(t2[e3]);
          r3 !== 0 && (t2[e3].area = Math.abs(r3), s2 === void 0 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
        }
        if (i2 && n2.push(i2), e2 > 1)
          for (let t3 = 0; t3 < n2.length; t3++)
            n2[t3].length <= e2 || (Cc(n2[t3], e2, 1, n2[t3].length - 1, Fc), n2[t3] = n2[t3].slice(0, e2));
        return n2;
      }
      function Fc(t2, e2) {
        return e2.area - t2.area;
      }
      function Rc(t2, e2, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e2) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2] = true);
        }
        return i2;
      }
      function jc(t2, e2, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if (e3.kind !== "constant") {
            let t3 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r2.patterns[a2.id] = t3;
          }
        }
        return r2;
      }
      ({ get exports() {
        return sc;
      }, set exports(t2) {
        sc = t2;
      } }).exports = ac, sc.default = ac, ac.deviation = function(t2, e2, r2, n2) {
        var i2 = e2 && e2.length, s2 = Math.abs(Ec(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
        if (i2)
          for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
            s2 -= Math.abs(Ec(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
        var l2 = 0;
        for (a2 = 0; a2 < n2.length; a2 += 3) {
          var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h4 = n2[a2 + 2] * r2;
          l2 += Math.abs((t2[u2] - t2[h4]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h4 + 1] - t2[u2 + 1]));
        }
        return s2 === 0 && l2 === 0 ? 0 : Math.abs((l2 - s2) / s2);
      }, ac.flatten = function(t2) {
        for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
          for (var s2 = 0; s2 < t2[i2].length; s2++)
            for (var a2 = 0; a2 < e2; a2++)
              r2.vertices.push(t2[i2][s2][a2]);
          i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
        }
        return r2;
      };
      class Uc {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.indexArray2 = new Ma(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.segments2 = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
        }
        populate(t2, e2, r2, n2) {
          this.hasPattern = Rc("fill", this.layers, e2);
          const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
          for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c2 = wu(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), c2, r2))
              continue;
            const h4 = i2 ? i2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : bu(a2, r2, n2), patterns: {}, sortKey: h4 };
            s2.push(p2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = jc("fill", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {}, e2.availableImages);
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2, n2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
        }
        addFeatures(t2, e2, r2, n2, i2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e2, r2, n2, i2, s2 = []) {
          for (const t3 of Lc(e2, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s3 = [];
            for (const e4 of t3) {
              if (e4.length === 0)
                continue;
              e4 !== t3[0] && s3.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1; t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a2 = sc(i3, s3);
            for (let t4 = 0; t4 < a2.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
        }
      }
      Oi(Uc, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const $c = new Js({ "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"]) });
      var Oc = { paint: new Js({ "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]), "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]), "fill-color": new Hs(Ht.paint_fill["fill-color"]), "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]), "fill-translate": new Ys(Ht.paint_fill["fill-translate"]), "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]), "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"]) }), layout: $c };
      const qc = na([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Nc = na([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Gc = na([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Xc } = qc;
      var Zc = {}, Kc = d, Yc = Hc;
      function Hc(t2, e2, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Wc, this, e2);
      }
      function Wc(t2, e2, r2) {
        t2 == 1 ? e2.id = r2.readVarint() : t2 == 2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e2) : t2 == 3 ? e2.type = r2.readVarint() : t2 == 4 && (e2._geometry = r2.pos);
      }
      function Jc(t2) {
        for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
        return n2;
      }
      Hc.types = ["Unknown", "Point", "LineString", "Polygon"], Hc.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
          if (i2 <= 0) {
            var l2 = t2.readVarint();
            n2 = 7 & l2, i2 = l2 >> 3;
          }
          if (i2--, n2 === 1 || n2 === 2)
            s2 += t2.readSVarint(), a2 += t2.readSVarint(), n2 === 1 && (e2 && o2.push(e2), e2 = []), e2.push(new Kc(s2, a2));
          else {
            if (n2 !== 7)
              throw new Error("unknown command " + n2);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && o2.push(e2), o2;
      }, Hc.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
          if (n2 <= 0) {
            var c2 = t2.readVarint();
            r2 = 7 & c2, n2 = c2 >> 3;
          }
          if (n2--, r2 === 1 || r2 === 2)
            (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
          else if (r2 !== 7)
            throw new Error("unknown command " + r2);
        }
        return [a2, l2, o2, u2];
      }, Hc.prototype.toGeoJSON = function(t2, e2, r2) {
        var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = Hc.types[this.type];
        function c2(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h4 = [];
            for (n2 = 0; n2 < l2.length; n2++)
              h4[n2] = l2[n2][0];
            c2(l2 = h4);
            break;
          case 2:
            for (n2 = 0; n2 < l2.length; n2++)
              c2(l2[n2]);
            break;
          case 3:
            for (l2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                var a3 = Jc(t3[s3]);
                a3 !== 0 && (n3 === void 0 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
              }
              return r3 && i3.push(r3), i3;
            }(l2), n2 = 0; n2 < l2.length; n2++)
              for (i2 = 0; i2 < l2[n2].length; i2++)
                c2(l2[n2][i2]);
        }
        l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
        var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
        return "id" in this && (p2.id = this.id), p2;
      };
      var Qc = Yc, th = eh;
      function eh(t2, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(rh, this, e2), this.length = this._features.length;
      }
      function rh(t2, e2, r2) {
        t2 === 15 ? e2.version = r2.readVarint() : t2 === 1 ? e2.name = r2.readString() : t2 === 5 ? e2.extent = r2.readVarint() : t2 === 2 ? e2._features.push(r2.pos) : t2 === 3 ? e2._keys.push(r2.readString()) : t2 === 4 && e2._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      eh.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new Qc(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var nh = th;
      function ih(t2, e2, r2) {
        if (t2 === 3) {
          var n2 = new nh(r2, r2.readVarint() + r2.pos);
          n2.length && (e2[n2.name] = n2);
        }
      }
      var sh = Zc.VectorTile = function(t2, e2) {
        this.layers = t2.readFields(ih, {}, e2);
      }, ah = Zc.VectorTileFeature = Yc;
      function oh(t2, e2, r2, n2) {
        const i2 = [], s2 = n2 === 0 ? (t3, e3, r3, n3, i3, s3) => {
          t3.push(new d(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
        } : (t3, e3, r3, n3, i3, s3) => {
          t3.push(new d(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
        };
        for (const a2 of t2) {
          const t3 = [];
          for (const i3 of a2) {
            if (i3.length <= 2)
              continue;
            const a3 = [];
            for (let t4 = 0; t4 < i3.length - 1; t4++) {
              const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h4 = n2 === 0 ? o3 : l3, p2 = n2 === 0 ? u2 : c2;
              h4 < e2 ? p2 > e2 && s2(a3, o3, l3, u2, c2, e2) : h4 > r2 ? p2 < r2 && s2(a3, o3, l3, u2, c2, r2) : a3.push(i3[t4]), p2 < e2 && h4 >= e2 && s2(a3, o3, l3, u2, c2, e2), p2 > r2 && h4 <= r2 && s2(a3, o3, l3, u2, c2, r2);
            }
            let o2 = i3[i3.length - 1];
            const l2 = n2 === 0 ? o2.x : o2.y;
            l2 >= e2 && l2 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
          }
          t3.length && i2.push(t3);
        }
        return i2;
      }
      Zc.VectorTileLayer = th;
      const lh = ah.types, uh = Math.pow(2, 13);
      function ch(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * uh) << 1) + i2, Math.round(o2));
      }
      function hh(t2, e2, r2) {
        const n2 = 16384;
        t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
      }
      class ph {
        constructor() {
          this.acc = new d(0, 0), this.polyCount = [];
        }
        startRing(t2) {
          this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t2.x, t2.y), this.max = new d(t2.x, t2.y));
        }
        append(t2, e2) {
          this.currentPolyCount.edges++, this.acc._add(t2);
          const r2 = this.min, n2 = this.max;
          t2.x < r2.x ? r2.x = t2.x : t2.x > n2.x && (n2.x = t2.x), t2.y < r2.y ? r2.y = t2.y : t2.y > n2.y && (n2.y = t2.y), ((t2.x === 0 || t2.x === ko) && t2.x === e2.x) != ((t2.y === 0 || t2.y === ko) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, Mr(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > ko != t2.x > ko && this.addBorderIntersection(1, Mr(e2.y, t2.y, (ko - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, Mr(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > ko != t2.y > ko && this.addBorderIntersection(3, Mr(e2.x, t2.x, (ko - e2.y) / (t2.y - e2.y)));
        }
        addBorderIntersection(t2, e2) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r2 = this.borders[t2];
          e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
        }
        processBorderOverlap(t2, e2) {
          if (t2.x === e2.x) {
            if (t2.y === e2.y)
              return;
            const r2 = t2.x === 0 ? 0 : 1;
            this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
          } else {
            const r2 = t2.y === 0 ? 2 : 3;
            this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
          }
        }
        centroid() {
          const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
          return t2 !== 0 ? this.acc.div(t2)._round() : new d(0, 0);
        }
        span() {
          return new d(this.max.x - this.min.x, this.max.y - this.min.y);
        }
        intersectsCount() {
          return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
        }
      }
      class fh {
        constructor(t2) {
          this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.layoutVertexArray = new oa(), this.centroidVertexArray = new Ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
        }
        populate(t2, e2, r2, n2) {
          this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t3) {
            const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
            return 80150034 * e3 / (e3 * e3 + 1) / ko / (1 << t3.z);
          }(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l2 = wu(i2, t3);
            if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), l2, r2))
              continue;
            const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : bu(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u2, this.zoom, e2)) : this.addFeature(u2, u2.geometry, a2, r2, {}, e2.availableImages, n2), e2.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
          }
          this.sortBorders();
        }
        addFeatures(t2, e2, r2, n2, i2) {
          for (const t3 of this.features) {
            const { geometry: s2 } = t3;
            this.addFeature(t3, s2, t3.index, e2, r2, n2, i2);
          }
          this.sortBorders();
        }
        update(t2, e2, r2, n2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Xc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Gc.members, true))), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        uploadCentroid(t2) {
          this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Nc.members, true), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = [new d(0, 0), new d(ko, ko)], l2 = a2.projection, u2 = l2.name === "globe", c2 = this.enableTerrain && !u2 ? new ph() : null, h4 = lh[t2.type] === "Polygon";
          u2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa());
          const p2 = Lc(e2, 500);
          for (let t3 = p2.length - 1; t3 >= 0; t3--) {
            const e3 = p2[t3];
            (e3.length === 0 || (f2 = e3[0]).every((t4) => t4.x <= 0) || f2.every((t4) => t4.x >= ko) || f2.every((t4) => t4.y <= 0) || f2.every((t4) => t4.y >= ko)) && p2.splice(t3, 1);
          }
          var f2;
          let y2;
          if (u2)
            y2 = wh(p2, o2, n2);
          else {
            y2 = [];
            for (const t3 of p2)
              y2.push({ polygon: t3, bounds: o2 });
          }
          const m2 = h4 ? this.edgeRadius : 0;
          for (const { polygon: t3, bounds: e3 } of y2) {
            let r3 = 0, i3 = 0;
            for (const e4 of t3)
              h4 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += h4 ? e4.length - 1 : e4.length;
            const s3 = this.segments.prepareSegment((h4 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
            if (h4) {
              const e4 = [], i4 = [];
              r3 = s3.vertexLength;
              for (const r4 of t3) {
                let a4, o3;
                r4.length && r4 !== t3[0] && i4.push(e4.length / 2), a4 = r4[1].sub(r4[0])._perp()._unit();
                for (let t4 = 1; t4 < r4.length; t4++) {
                  const i5 = r4[t4], c3 = r4[t4 === r4.length - 1 ? 1 : t4 + 1];
                  let { x: h5, y: p3 } = i5;
                  if (m2) {
                    o3 = c3.sub(i5)._perp()._unit();
                    const t5 = a4.add(o3)._unit(), e5 = m2 * Math.min(4, 1 / (a4.x * t5.x + a4.y * t5.y));
                    h5 += e5 * t5.x, p3 += e5 * t5.y, a4 = o3;
                  }
                  ch(this.layoutVertexArray, h5, p3, 0, 0, 1, 1, 0), s3.vertexLength++, e4.push(i5.x, i5.y), u2 && hh(this.layoutVertexExtArray, l2.projectTilePoint(h5, p3, n2), l2.upVector(n2, h5, p3));
                }
              }
              const a3 = sc(e4, i4);
              for (let t4 = 0; t4 < a3.length; t4 += 3)
                this.indexArray.emplaceBack(r3 + a3[t4], r3 + a3[t4 + 2], r3 + a3[t4 + 1]), s3.primitiveLength++;
            }
            for (const i4 of t3) {
              c2 && i4.length && c2.startRing(i4[0]);
              let t4, a3, o3, p3 = i4.length > 4 && xh(i4[i4.length - 2], i4[0], i4[1]), f3 = m2 ? yh(i4[i4.length - 2], i4[0], i4[1], m2) : 0;
              a3 = i4[1].sub(i4[0])._perp()._unit();
              let d2 = true;
              for (let y3 = 1, g2 = 0; y3 < i4.length; y3++) {
                let x2 = i4[y3 - 1], v3 = i4[y3];
                const b2 = i4[y3 === i4.length - 1 ? 1 : y3 + 1];
                if (c2 && h4 && c2.currentPolyCount.top++, gh(v3, x2, e3)) {
                  m2 && (a3 = b2.sub(v3)._perp()._unit(), d2 = !d2);
                  continue;
                }
                c2 && c2.append(v3, x2);
                const w2 = v3.sub(x2)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x2.dist(v3);
                if (g2 + S2 > 32768 && (g2 = 0), m2) {
                  o3 = b2.sub(v3)._perp()._unit();
                  let t5 = mh(x2, v3, b2, dh(a3, o3), m2);
                  isNaN(t5) && (t5 = 0);
                  const e4 = v3.sub(x2)._unit();
                  x2 = x2.add(e4.mult(f3))._round(), v3 = v3.add(e4.mult(-t5))._round(), f3 = t5, a3 = o3;
                }
                const k2 = s3.vertexLength, I2 = i4.length > 4 && xh(x2, v3, b2);
                let M2 = vh(g2, p3, d2);
                if (ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 1, M2), g2 += S2, M2 = vh(g2, I2, !d2), p3 = I2, ch(this.layoutVertexArray, v3.x, v3.y, _2, A2, 0, 0, M2), ch(this.layoutVertexArray, v3.x, v3.y, _2, A2, 0, 1, M2), s3.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s3.primitiveLength += 2, m2) {
                  const n3 = r3 + (y3 === 1 ? i4.length - 2 : y3 - 2), a4 = y3 === 1 ? r3 : n3 + 1;
                  if (this.indexArray.emplaceBack(k2 + 1, n3, k2 + 3), this.indexArray.emplaceBack(n3, a4, k2 + 3), s3.primitiveLength += 2, t4 === void 0 && (t4 = k2), !gh(b2, i4[y3], e3)) {
                    const e4 = y3 === i4.length - 1 ? t4 : s3.vertexLength;
                    this.indexArray.emplaceBack(k2 + 2, k2 + 3, e4), this.indexArray.emplaceBack(k2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(k2 + 3, a4, e4 + 1), s3.primitiveLength += 3;
                  }
                  d2 = !d2;
                }
                if (u2) {
                  const t5 = this.layoutVertexExtArray, e4 = l2.projectTilePoint(x2.x, x2.y, n2), r4 = l2.projectTilePoint(v3.x, v3.y, n2), i5 = l2.upVector(n2, x2.x, x2.y), s4 = l2.upVector(n2, v3.x, v3.y);
                  hh(t5, e4, i5), hh(t5, e4, i5), hh(t5, r4, s4), hh(t5, r4, s4);
                }
              }
              h4 && (r3 += i4.length - 1);
            }
          }
          if (c2 && c2.polyCount.length > 0) {
            if (c2.borders) {
              c2.vertexArrayOffset = this.centroidVertexArray.length;
              const t3 = c2.borders, e3 = this.featuresOnBorder.push(c2) - 1;
              for (let r3 = 0; r3 < 4; r3++)
                t3[r3][0] !== Number.MAX_VALUE && this.borders[r3].push(e3);
            }
            this.encodeCentroid(c2.borders ? void 0 : c2.centroid(), c2);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
        }
        sortBorders() {
          for (let t2 = 0; t2 < 4; t2++)
            this.borders[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
        }
        encodeCentroid(t2, e2, r2 = true) {
          let n2, i2;
          if (t2)
            if (t2.y !== 0) {
              const r3 = e2.span()._mult(this.tileToMeter);
              n2 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r3.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r3.y / 10));
            } else
              n2 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
          else
            n2 = 0, i2 = +r2;
          let s2 = r2 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
          for (const t3 of e2.polyCount) {
            r2 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
            for (let e3 = 0; e3 < t3.top; e3++)
              this.centroidVertexArray.emplace(s2++, n2, i2);
            for (let e3 = 0; e3 < 2 * t3.edges; e3++)
              this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n2, i2);
          }
        }
      }
      function dh(t2, e2) {
        const r2 = t2.add(e2)._unit();
        return t2.x * r2.x + t2.y * r2.y;
      }
      function yh(t2, e2, r2, n2) {
        const i2 = e2.sub(t2)._perp()._unit(), s2 = r2.sub(e2)._perp()._unit();
        return mh(t2, e2, r2, dh(i2, s2), n2);
      }
      function mh(t2, e2, r2, n2, i2) {
        const s2 = Math.sqrt(1 - n2 * n2);
        return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s2 / n2);
      }
      function gh(t2, e2, r2) {
        return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
      }
      function xh(t2, e2, r2) {
        if (t2.x < 0 || t2.x >= ko || e2.x < 0 || e2.x >= ko || r2.x < 0 || r2.x >= ko)
          return false;
        const n2 = r2.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
        return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
      }
      function vh(t2, e2, r2) {
        const n2 = e2 ? 2 | t2 : -3 & t2;
        return r2 ? 1 | n2 : -2 & n2;
      }
      function bh() {
        const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = tu;
        return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
      }
      function wh(t2, e2, r2) {
        const n2 = 1 << r2.z, i2 = ou(r2.x / n2), s2 = ou((r2.x + 1) / n2), a2 = lu(r2.y / n2), o2 = lu((r2.y + 1) / n2);
        return function(t3, e3, r3, n3, i3 = 0, s3) {
          const a3 = [];
          if (!t3.length || !r3 || !n3)
            return a3;
          const o3 = (t4, e4) => {
            for (const r4 of t4)
              a3.push({ polygon: r4, bounds: e4 });
          }, l2 = Math.ceil(Math.log2(r3)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h4 = [];
          for (let t4 = 0; t4 < Math.abs(c2); t4++)
            h4.push(c2 > 0 ? 0 : 1);
          for (let t4 = 0; t4 < Math.min(l2, u2); t4++)
            h4.push(0), h4.push(1);
          let p2 = t3;
          if (p2 = oh(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = oh(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length)
            return a3;
          const f2 = [];
          for (h4.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); f2.length; ) {
            const t4 = f2.pop(), e4 = t4.depth, r4 = h4[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = r4 === 0 ? n4.x : n4.y, u3 = r4 === 0 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = oh(t4.polygons, l3 - i3, c3 + i3, r4), y2 = oh(t4.polygons, c3 - i3, u3 + i3, r4);
            if (p3.length) {
              const t5 = [n4, new d(r4 === 0 ? c3 : a4.x, r4 === 1 ? c3 : a4.y)];
              h4.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
            }
            if (y2.length) {
              const t5 = [new d(r4 === 0 ? c3 : n4.x, r4 === 1 ? c3 : n4.y), a4];
              h4.length > e4 + 1 ? f2.push({ polygons: y2, bounds: t5, depth: e4 + 1 }) : o3(y2, t5);
            }
          }
          return a3;
        }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
          if (t3 === 0)
            return 0.5 * (e3 + i3);
          {
            const t4 = lu((r2.y + e3 / ko) / n2);
            return (su(0.5 * (lu((r2.y + i3 / ko) / n2) + t4)) * n2 - r2.y) * ko;
          }
        });
      }
      Oi(fh, "FillExtrusionBucket", { omit: ["layers", "features"] }), Oi(ph, "PartMetadata");
      const _h = new Js({ "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var Ah = { paint: new Js({ "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: _h };
      function Sh(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
      }
      class kh {
        constructor(t2, e2, r2) {
          this.z = t2, this.x = e2, this.y = r2, this.key = Th(0, t2, t2, e2, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e2) {
          const r2 = function(t3, e3, r3) {
            var n3 = Sh(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i2 = Sh(256 * (t3 + 1), 256 * (e3 + 1), r3);
            return n3[0] + "," + n3[1] + "," + i2[0] + "," + i2[1];
          }(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
            let n3, i2 = "";
            for (let s2 = t3; s2 > 0; s2--)
              n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i2;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(e2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Ih {
        constructor(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = Th(t2, e2.z, e2.z, e2.x, e2.y);
        }
      }
      class Mh {
        constructor(t2, e2, r2, n2, i2) {
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new kh(r2, +n2, +i2), this.key = e2 === 0 && t2 === r2 ? this.canonical.key : Th(e2, t2, r2, n2, i2);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          const e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new Mh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t2, e2 = true) {
          if (this.overscaledZ === t2 && e2)
            return this.key;
          if (t2 > this.canonical.z)
            return Th(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r2 = this.canonical.z - t2;
            return Th(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t2.canonical.z;
          return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new Mh(e2, this.wrap, e2, r2, n2), new Mh(e2, this.wrap, e2, r2 + 1, n2), new Mh(e2, this.wrap, e2, r2, n2 + 1), new Mh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new Mh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Ih(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Th(t2, e2, r2, n2, i2) {
        const s2 = 1 << Math.min(r2, 22);
        let a2 = s2 * (i2 % s2) + n2 % s2;
        return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
      }
      Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", { omit: ["projMatrix"] });
      class zh extends d {
        constructor(t2, e2, r2) {
          super(t2, e2), this.z = r2;
        }
      }
      function Bh(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function Eh(t2, e2) {
        if (t2.length === 1) {
          let r2 = 0;
          const n2 = e2[r2++];
          let i2;
          for (; !i2 || n2.equals(i2); )
            if (i2 = e2[r2++], !i2)
              return 1 / 0;
          for (; r2 < e2.length; r2++) {
            const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Bh(o2, o2), h4 = Bh(o2, l2), p2 = Bh(l2, l2), f2 = Bh(u2, o2), d2 = Bh(u2, l2), y2 = c2 * p2 - h4 * h4, m2 = (p2 * f2 - h4 * d2) / y2, g2 = (c2 * d2 - h4 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e2)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      function Ch(t2, e2, r2, n2, i2, s2, a2, o2) {
        const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = s2[0] !== 0, c2 = u2 ? s2[1] === 0 ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
          const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h4 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r4, n4, i4) {
            return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
          }(t3, h4.x - u3, h4.y - c3, p2, f2), y2 = Math.abs(d2[0] - d2[1]), m2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (y2 + m2) / p2), v3 = Math.min(0.25, 0.5 * l3 * g2 / f2);
          return o3 + Math.max(x2 * s3, v3 * a3);
        }(i2, s2, o2) : l2;
        return { base: l2 + (r2 === 0) ? -1 : r2, top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
      }
      const Ph = na([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: Dh } = Ph, Vh = na([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Lh } = Vh, Fh = ah.types, Rh = Math.cos(Math.PI / 180 * 37.5);
      class jh {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t2.layers, t2.zoom), this.segments = new So(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2, n2) {
          this.hasPattern = Rc("line", this.layers, e2);
          const i2 = this.layers[0].layout.get("line-sort-key"), s2 = [];
          for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l3 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = wu(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u2, r2))
              continue;
            const c2 = i2 ? i2.evaluate(u2, {}, r2) : void 0, h4 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : bu(e3, r2, n2), patterns: {}, sortKey: c2 };
            s2.push(h4);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          const { lineAtlas: a2, featureIndex: o2 } = e2, l2 = this.addConstantDashes(a2);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: u2 } = n3;
            if (l2 && this.addFeatureDashes(n3, a2), this.hasPattern) {
              const t3 = jc("line", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, a2.positions, e2.availableImages);
            o2.insert(t2[s3].feature, i3, s3, u2, this.index);
          }
        }
        addConstantDashes(t2) {
          let e2 = false;
          for (const r2 of this.layers) {
            const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
            if (n2.kind !== "constant" || i2.kind !== "constant")
              e2 = true;
            else {
              const e3 = i2.value, r3 = n2.value;
              if (!r3)
                continue;
              t2.addDash(r3, e3);
            }
          }
          return e2;
        }
        addFeatureDashes(t2, e2) {
          const r2 = this.zoom;
          for (const n2 of this.layers) {
            const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
            if (i2.kind === "constant" && s2.kind === "constant")
              continue;
            let a2, o2;
            if (i2.kind === "constant") {
              if (a2 = i2.value, !a2)
                continue;
            } else
              a2 = i2.evaluate({ zoom: r2 }, t2);
            o2 = s2.kind === "constant" ? s2.value : s2.evaluate({ zoom: r2 }, t2), e2.addDash(a2, o2), t2.patterns[n2.id] = e2.getKey(a2, o2);
          }
        }
        update(t2, e2, r2, n2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n2);
        }
        addFeatures(t2, e2, r2, n2, i2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
        }
        addFeature(t2, e2, r2, n2, i2, s2) {
          const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l2 = a2.get("line-cap").evaluate(t2, {}), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e2)
            this.addLine(r3, t2, o2, l2, u2, c2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2);
        }
        addLine(t2, e2, r2, n2, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = Fh[e2.type] === "Polygon";
          let o2 = t2.length;
          for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
            o2--;
          let l2 = 0;
          for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
            l2++;
          if (o2 < (a2 ? 3 : 2))
            return;
          r2 === "bevel" && (i2 = 1.05);
          const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h4, p2, f2, d2, y2;
          this.e1 = this.e2 = -1, a2 && (h4 = t2[o2 - 2], y2 = t2[l2].sub(h4)._unit()._perp());
          for (let e3 = l2; e3 < o2; e3++) {
            if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
              continue;
            y2 && (d2 = y2), h4 && (p2 = h4), h4 = t2[e3], y2 = f2 ? f2.sub(h4)._unit()._perp() : d2, d2 = d2 || y2;
            let m2 = d2.add(y2);
            m2.x === 0 && m2.y === 0 || m2._unit();
            const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v3 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rh && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
            if (w2 && e3 > l2) {
              const t3 = h4.dist(p2);
              if (t3 > 2 * u2) {
                const e4 = h4.sub(h4.sub(p2)._mult(u2 / t3)._round());
                this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
              }
            }
            const A2 = p2 && f2;
            let S2 = A2 ? r2 : a2 ? "butt" : n2;
            if (A2 && S2 === "round" && (v3 < s2 ? S2 = "miter" : v3 <= 2 && (S2 = "fakeround")), S2 === "miter" && v3 > i2 && (S2 = "bevel"), S2 === "bevel" && (v3 > 2 && (S2 = "flipbevel"), v3 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h4), S2 === "miter")
              m2._mult(v3), this.addCurrentVertex(h4, m2, 0, 0, c2);
            else if (S2 === "flipbevel") {
              if (v3 > 100)
                m2 = y2.mult(-1);
              else {
                const t3 = v3 * d2.add(y2).mag() / d2.sub(y2).mag();
                m2._perp()._mult(t3 * (_2 ? -1 : 1));
              }
              this.addCurrentVertex(h4, m2, 0, 0, c2), this.addCurrentVertex(h4, m2.mult(-1), 0, 0, c2);
            } else if (S2 === "bevel" || S2 === "fakeround") {
              const t3 = -Math.sqrt(v3 * v3 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
              if (p2 && this.addCurrentVertex(h4, d2, e4, r3, c2), S2 === "fakeround") {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1; e5 < t4; e5++) {
                  let r4 = e5 / t4;
                  if (r4 !== 0.5) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                  this.addHalfVertex(h4, n3.x, n3.y, false, _2, 0, c2);
                }
              }
              f2 && this.addCurrentVertex(h4, y2, -e4, -r3, c2);
            } else if (S2 === "butt")
              this.addCurrentVertex(h4, m2, 0, 0, c2);
            else if (S2 === "square") {
              const t3 = p2 ? 1 : -1;
              p2 || this.addCurrentVertex(h4, m2, t3, t3, c2), this.addCurrentVertex(h4, m2, 0, 0, c2), p2 && this.addCurrentVertex(h4, m2, t3, t3, c2);
            } else
              S2 === "round" && (p2 && (this.addCurrentVertex(h4, d2, 0, 0, c2), this.addCurrentVertex(h4, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h4, y2, -1, -1, c2, true), this.addCurrentVertex(h4, y2, 0, 0, c2)));
            if (w2 && e3 < o2 - 1) {
              const t3 = h4.dist(f2);
              if (t3 > 2 * u2) {
                const e4 = h4.add(f2.sub(h4)._mult(u2 / t3)._round());
                this.updateDistance(h4, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h4 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
          const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
        }
        addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const l2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(t2, e2) {
          this.distance += t2.dist(e2), this.updateScaledDistance();
        }
      }
      Oi(jh, "LineBucket", { omit: ["layers", "patternFeatures"] });
      const Uh = new Js({ "line-cap": new Hs(Ht.layout_line["line-cap"]), "line-join": new Hs(Ht.layout_line["line-join"]), "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]), "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]), "line-sort-key": new Hs(Ht.layout_line["line-sort-key"]) });
      var $h = { paint: new Js({ "line-opacity": new Hs(Ht.paint_line["line-opacity"]), "line-color": new Hs(Ht.paint_line["line-color"]), "line-translate": new Ys(Ht.paint_line["line-translate"]), "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]), "line-width": new Hs(Ht.paint_line["line-width"]), "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]), "line-offset": new Hs(Ht.paint_line["line-offset"]), "line-blur": new Hs(Ht.paint_line["line-blur"]), "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]), "line-pattern": new Hs(Ht.paint_line["line-pattern"]), "line-gradient": new Ws(Ht.paint_line["line-gradient"]), "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"]) }), layout: Uh };
      const Oh = new class extends Hs {
        possiblyEvaluate(t2, e2) {
          return e2 = new Us(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
        }
        evaluate(t2, e2, r2, n2) {
          return e2 = z({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
        }
      }($h.paint.properties["line-width"].specification);
      function qh(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      Oh.useIntegerZoom = true;
      const Nh = na([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Gh = na([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Xh = na([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      na([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Zh = na([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Kh = na([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
      na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Yh = na([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Hh = na([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      na([{ name: "triangle", components: 3, type: "Uint16" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), na([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), na([{ type: "Float32", name: "offsetX" }]), na([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var Wh = 24;
      const Jh = 128;
      function Qh(t2, e2) {
        const { expression: r2 } = e2;
        if (r2.kind === "constant")
          return { kind: "constant", layoutSize: r2.evaluate(new Us(t2 + 1)) };
        if (r2.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (; i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (; s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return r2.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Us(a2)), maxSize: r2.evaluate(new Us(o2)), interpolationType: n2 };
        }
      }
      function tp(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return t2.kind === "source" ? n2 / Jh : t2.kind === "composite" ? Mr(n2 / Jh, i2 / Jh, r2) : e2;
      }
      function ep(t2, e2) {
        let r2 = 0, n2 = 0;
        if (t2.kind === "constant")
          n2 = t2.layoutSize;
        else if (t2.kind !== "source") {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? S(Kr.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          t2.kind === "camera" ? n2 = Mr(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }
      var rp = Object.freeze({ __proto__: null, getSizeData: Qh, evaluateSizeForFeature: tp, evaluateSizeForZoom: ep, SIZE_PACK_FACTOR: Jh });
      function np(t2, e2, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), js.applyArabicShaping && (t4 = js.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      const ip = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
      function sp(t2) {
        return t2 === "\uFE36" || t2 === "\uFE48" || t2 === "\uFE38" || t2 === "\uFE44" || t2 === "\uFE42" || t2 === "\uFE3E" || t2 === "\uFE3C" || t2 === "\uFE3A" || t2 === "\uFE18" || t2 === "\uFE40" || t2 === "\uFE10" || t2 === "\uFE13" || t2 === "\uFE14" || t2 === "\uFF40" || t2 === "\uFFE3" || t2 === "\uFE11" || t2 === "\uFE12";
      }
      function ap(t2) {
        return t2 === "\uFE35" || t2 === "\uFE47" || t2 === "\uFE37" || t2 === "\uFE43" || t2 === "\uFE41" || t2 === "\uFE3D" || t2 === "\uFE3B" || t2 === "\uFE39" || t2 === "\uFE17" || t2 === "\uFE3F";
      }
      var op = cp, lp = function(t2, e2, r2, n2, i2) {
        var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h4 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h4];
        for (h4 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h4], h4 += p2, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h4], h4 += p2, c2 -= 8)
          ;
        if (s2 === 0)
          s2 = 1 - u2;
        else {
          if (s2 === l2)
            return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          a2 += Math.pow(2, n2), s2 -= u2;
        }
        return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
      }, up = function(t2, e2, r2, n2, i2, s2) {
        var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h4 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h4 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h4)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h4 >= c2 ? (o2 = 0, a2 = c2) : a2 + h4 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h4) : (o2 = e2 * Math.pow(2, h4 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
          ;
        for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
          ;
        t2[r2 + f2 - d2] |= 128 * y2;
      };
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function cp(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;
      var hp = 4294967296, pp = 1 / hp, fp = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
      function dp(t2) {
        return t2.type === cp.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function yp(t2, e2, r2) {
        return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function mp(t2, e2, r2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1; i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function gp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeVarint(t2[r2]);
      }
      function xp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSVarint(t2[r2]);
      }
      function vp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFloat(t2[r2]);
      }
      function bp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeDouble(t2[r2]);
      }
      function wp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeBoolean(t2[r2]);
      }
      function _p(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed32(t2[r2]);
      }
      function Ap(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed32(t2[r2]);
      }
      function Sp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed64(t2[r2]);
      }
      function kp(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed64(t2[r2]);
      }
      function Ip(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function Mp(t2, e2, r2) {
        t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
      }
      function Tp(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      function zp(t2, e2, r2) {
        e2.glyphs = [], t2 === 1 && r2.readMessage(Bp, e2);
      }
      function Bp(t2, e2, r2) {
        if (t2 === 3) {
          const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Ep, {});
          e2.glyphs.push({ id: t3, bitmap: new Ju({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
        } else
          t2 === 4 ? e2.ascender = r2.readSVarint() : t2 === 5 && (e2.descender = r2.readSVarint());
      }
      function Ep(t2, e2, r2) {
        t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
      }
      function Cp(t2) {
        let e2 = 0, r2 = 0;
        for (const n3 of t2)
          e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      cp.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e2, r2) {
        for (r2 = r2 || this.length; this.pos < r2; ) {
          var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
          this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
        }
        return e2;
      }, readMessage: function(t2, e2) {
        return this.readFields(t2, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = Ip(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = Tp(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = lp(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = lp(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e2, r2, n2 = this.buf;
        return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
          var n3, i2, s2 = r3.buf;
          if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
            return yp(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
            return yp(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
            return yp(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
            return yp(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
            return yp(t3, n3, e3);
          if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
            return yp(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t2, t2 - e2 >= 12 && fp ? function(t3, e3, r2) {
          return fp.decode(t3.subarray(e3, r2));
        }(this.buf, e2, t2) : function(t3, e3, r2) {
          for (var n2 = "", i2 = e3; i2 < r2; ) {
            var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (i2 + c2 > r2)
              break;
            c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (s2 = t3[i2 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : c2 === 3 ? (a2 = t3[i2 + 2], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
          }
          return n2;
        }(this.buf, e2, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e2;
      }, readPackedVarint: function(t2, e2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readVarint(e2));
        var r2 = dp(this);
        for (t2 = t2 || []; this.pos < r2; )
          t2.push(this.readVarint(e2));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readSVarint());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readBoolean());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readFloat());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readDouble());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readFixed32());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readSFixed32());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readFixed64());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== cp.Bytes)
          return t2.push(this.readSFixed64());
        var e2 = dp(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e2 = 7 & t2;
        if (e2 === cp.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e2 === cp.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === cp.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== cp.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t2, e2) {
        this.writeVarint(t2 << 3 | e2);
      }, realloc: function(t2) {
        for (var e2 = this.length || 16; e2 < this.pos + t2; )
          e2 *= 2;
        if (e2 !== this.length) {
          var r2 = new Uint8Array(e2);
          r2.set(this.buf), this.buf = r2, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), Mp(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), Mp(this.buf, -1 & t2, this.pos), Mp(this.buf, Math.floor(t2 * pp), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
          var r2, n2;
          if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t4, e3, r3) {
            r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
          }(r2, 0, e2), function(t4, e3) {
            var r3 = (7 & t4) << 4;
            e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
          }(n2, e2);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t3, e3, r3) {
          for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
            if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
              if (!i2) {
                n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                continue;
              }
              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
            } else
              i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
            n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
          }
          return r3;
        }(this.buf, t2, this.pos);
        var r2 = this.pos - e2;
        r2 >= 128 && mp(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeFloat: function(t2) {
        this.realloc(4), up(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), up(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e2 = t2.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r2 = 0; r2 < e2; r2++)
          this.buf[this.pos++] = t2[r2];
      }, writeRawMessage: function(t2, e2) {
        this.pos++;
        var r2 = this.pos;
        t2(e2, this);
        var n2 = this.pos - r2;
        n2 >= 128 && mp(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e2, r2) {
        this.writeTag(t2, cp.Bytes), this.writeRawMessage(e2, r2);
      }, writePackedVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, gp, e2);
      }, writePackedSVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, xp, e2);
      }, writePackedBoolean: function(t2, e2) {
        e2.length && this.writeMessage(t2, wp, e2);
      }, writePackedFloat: function(t2, e2) {
        e2.length && this.writeMessage(t2, vp, e2);
      }, writePackedDouble: function(t2, e2) {
        e2.length && this.writeMessage(t2, bp, e2);
      }, writePackedFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, _p, e2);
      }, writePackedSFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, Ap, e2);
      }, writePackedFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, Sp, e2);
      }, writePackedSFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, kp, e2);
      }, writeBytesField: function(t2, e2) {
        this.writeTag(t2, cp.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t2, e2) {
        this.writeTag(t2, cp.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t2, e2) {
        this.writeTag(t2, cp.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t2, e2) {
        this.writeTag(t2, cp.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t2, e2) {
        this.writeTag(t2, cp.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t2, e2) {
        this.writeTag(t2, cp.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t2, e2) {
        this.writeTag(t2, cp.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t2, e2) {
        this.writeTag(t2, cp.Bytes), this.writeString(e2);
      }, writeFloatField: function(t2, e2) {
        this.writeTag(t2, cp.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t2, e2) {
        this.writeTag(t2, cp.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t2, e2) {
        this.writeVarintField(t2, Boolean(e2));
      } };
      class Pp {
        constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
          this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      class Dp {
        constructor(t2, e2) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          const { w: s2, h: a2 } = Cp(i2), o2 = new Qu({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            Qu.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
          }
          for (const t3 in e2) {
            const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
            Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Qu.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Qu.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Qu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e2, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
            r2.push(s2), e2[n2] = new Pp(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e2) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r2 in t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }
        patchUpdatedImage(t2, e2, r2) {
          if (!t2 || !e2)
            return;
          if (t2.version === e2.version)
            return;
          t2.version = e2.version;
          const [n2, i2] = t2.tl;
          r2.update(e2.data, void 0, { x: n2, y: i2 });
        }
      }
      Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");
      const Vp = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class Lp {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t2, e2) {
          const r2 = new Lp();
          return r2.scale = t2 || 1, r2.fontStack = e2, r2;
        }
        static forImage(t2) {
          const e2 = new Lp();
          return e2.imageName = t2, e2;
        }
      }
      class Fp {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e2) {
          const r2 = new Fp();
          for (let n2 = 0; n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCharCode(t2) {
          return this.text.charCodeAt(t2);
        }
        verticalizePunctuation(t2) {
          this.text = function(t3, e2) {
            let r2 = "";
            for (let n2 = 0; n2 < t3.length; n2++) {
              const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
              r2 += !e2 && (i2 && Ss(i2) && !ip[t3[n2 + 1]] || s2 && Ss(s2) && !ip[t3[n2 - 1]]) || !ip[t3[n2]] ? t3[n2] : ip[t3[n2]];
            }
            return r2;
          }(this.text, t2);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0; e3 < this.text.length && jp[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e2 = this.text.length;
          for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && jp[this.text.charCodeAt(r2)]; r2--)
            e2--;
          this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
        }
        substring(t2, e2) {
          const r2 = new Fp();
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
        }
        addTextSection(t2, e2) {
          this.text += t2.text, this.sections.push(Lp.forText(t2.scale, t2.fontStack || e2));
          const r2 = this.sections.length - 1;
          for (let e3 = 0; e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e2 = t2.image ? t2.image.name : "";
          if (e2.length === 0)
            return void $("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Lp.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : $("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Rp(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, d2) {
        const y2 = Fp.fromFeature(t2, i2);
        h4 === Vp.vertical && y2.verticalizePunctuation(p2);
        let m2 = [];
        const g2 = function(t3, e3, r3, n3, i3, s3) {
          if (!t3)
            return [];
          const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
            let a4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const o4 = t4.getSection(r5);
              a4 += $p(t4.getCharCode(r5), o4, n4, i4, e4, s4);
            }
            return a4 / Math.max(1, Math.ceil(a4 / r4));
          }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("\u200B") >= 0;
          let u3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const h5 = t3.getSection(r4), p3 = t3.getCharCode(r4);
            if (jp[p3] || (u3 += $p(p3, h5, n3, i3, e3, s3)), r4 < t3.length() - 1) {
              const e4 = !((c3 = p3) < 11904 || !(ns(c3) || rs(c3) || ms(c3) || fs2(c3) || os2(c3) || Hi(c3) || is(c3) || Qi(c3) || ls(c3) || us(c3) || as(c3) || vs(c3) || ts(c3) || Ji(c3) || Wi(c3) || ss(c3) || es(c3) || ys(c3) || hs(c3) || cs(c3)));
              (Up[p3] || e4 || h5.imageName) && a3.push(Np(r4 + 1, u3, o3, a3, qp(p3, t3.getCharCode(r4 + 1), e4 && l3), false));
            }
          }
          var c3;
          return Gp(Np(t3.length(), u3, o3, a3, 0, true));
        }(y2, u2, s2, e2, n2, f2), { processBidirectionalText: x2, processStyledBidirectionalText: v3 } = js;
        if (x2 && y2.sections.length === 1) {
          const t3 = x2(y2.toString(), g2);
          for (const e3 of t3) {
            const t4 = new Fp();
            t4.text = e3, t4.sections = y2.sections;
            for (let r3 = 0; r3 < e3.length; r3++)
              t4.sectionIndex.push(0);
            m2.push(t4);
          }
        } else if (v3) {
          const t3 = v3(y2.text, y2.sectionIndex, g2);
          for (const e3 of t3) {
            const t4 = new Fp();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, m2.push(t4);
          }
        } else
          m2 = function(t3, e3) {
            const r3 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(y2, g2);
        const b2 = [], w2 = { positionedLines: b2, text: y2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h4, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h5) {
          let p3 = 0, f3 = 0, d3 = 0;
          const y3 = o3 === "right" ? 1 : o3 === "left" ? 0 : 0.5;
          let m3 = false;
          for (const t4 of i3) {
            const r4 = t4.getSections();
            for (const t5 of r4) {
              if (t5.imageName)
                continue;
              const r5 = e3[t5.fontStack];
              if (r5 && (m3 = r5.ascender !== void 0 && r5.descender !== void 0, !m3))
                break;
            }
            if (!m3)
              break;
          }
          let g3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = (i4 - 1) * Wh, v5 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[g3] = v5;
            const b4 = v5.positionedGlyphs;
            let w4 = 0;
            if (!a4.length()) {
              f3 += s3, ++g3;
              continue;
            }
            let _2 = 0, A2 = 0;
            for (let s4 = 0; s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4);
              let g4 = o5.scale, v6 = null, S3 = null, k2 = null, I2 = Wh, M2 = 0;
              const T2 = !(l3 === Vp.horizontal || !c3 && !As(y4) || c3 && (jp[y4] || (x3 = y4, Zi(x3) || Ki(x3) || Yi(x3) || ds(x3) || xs(x3))));
              if (o5.imageName) {
                const e4 = n3[o5.imageName];
                if (!e4)
                  continue;
                k2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, S3 = e4.paddedRect;
                const r4 = e4.displaySize;
                g4 = g4 * Wh / h5, v6 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: T2 ? r4[1] : r4[0], localGlyph: false }, M2 = m3 ? -v6.height * g4 : i4 * Wh - 17 - r4[1] * g4, I2 = v6.advance;
                const s5 = (T2 ? r4[0] : r4[1]) * g4 - Wh * i4;
                s5 > 0 && s5 > w4 && (w4 = s5);
              } else {
                const t4 = r3[o5.fontStack];
                if (!t4)
                  continue;
                t4[y4] && (S3 = t4[y4]);
                const n4 = e3[o5.fontStack];
                if (!n4)
                  continue;
                const s5 = n4.glyphs[y4];
                if (!s5)
                  continue;
                if (v6 = s5.metrics, I2 = y4 !== 8203 ? Wh : 0, m3) {
                  const t5 = n4.ascender !== void 0 ? Math.abs(n4.ascender) : 0, e4 = n4.descender !== void 0 ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                  _2 < r4 && (_2 = r4, A2 = (t5 - e4) / 2 * g4), M2 = -t5 * g4;
                } else
                  M2 = (i4 - g4) * Wh - 17;
              }
              T2 ? (t3.verticalizable = true, b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v6.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v6, rect: S3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: y4, imageName: k2, x: p3, y: f3 + M2, vertical: T2, scale: g4, localGlyph: v6.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v6, rect: S3 }), p3 += v6.advance * g4 + u3);
            }
            b4.length !== 0 && (d3 = Math.max(p3 - u3, d3), m3 ? Zp(b4, y3, w4, A2, s3 * i4 / 2) : Zp(b4, y3, w4, 0, s3 / 2)), p3 = 0;
            const S2 = s3 * i4 + w4;
            v5.lineOffset = Math.max(w4, o4), f3 += S2, ++g3;
          }
          var x3;
          const v4 = f3, { horizontalAlign: b3, verticalAlign: w3 } = Xp(a3);
          ((function(t4, e4, r4, n4, i4, s4) {
            const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
            for (const e5 of t4)
              for (const t5 of e5.positionedGlyphs)
                t5.x += a4, t5.y += o4;
          }))(t3.positionedLines, y3, b3, w3, d3, v4), t3.top += -w3 * v4, t3.bottom = t3.top + v4, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = m3;
        }(w2, e2, r2, n2, m2, a2, o2, l2, h4, u2, p2, d2), !function(t3) {
          for (const e3 of t3)
            if (e3.positionedGlyphs.length !== 0)
              return false;
          return true;
        }(b2) && w2;
      }
      const jp = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Up = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function $p(t2, e2, r2, n2, i2, s2) {
        if (e2.imageName) {
          const t3 = n2[e2.imageName];
          return t3 ? t3.displaySize[0] * e2.scale * Wh / s2 + i2 : 0;
        }
        {
          const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function Op(t2, e2, r2, n2) {
        const i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function qp(t2, e2, r2) {
        let n2 = 0;
        return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
      }
      function Np(t2, e2, r2, n2, i2, s2) {
        let a2 = null, o2 = Op(e2, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = Op(e2 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e2, priorBreak: a2, badness: o2 };
      }
      function Gp(t2) {
        return t2 ? Gp(t2.priorBreak).concat(t2.index) : [];
      }
      function Xp(t2) {
        let e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function Zp(t2, e2, r2, n2, i2) {
        if (!(e2 || r2 || n2 || i2))
          return;
        const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
        for (let e3 = 0; e3 <= s2; e3++)
          t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
      }
      function Kp(t2, e2, r2) {
        const { horizontalAlign: n2, verticalAlign: i2 } = Xp(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
        return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
      }
      function Yp(t2, e2, r2, n2, i2, s2) {
        const a2 = t2.image;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l2 = e2.left * s2, u2 = e2.right * s2;
        let c2, h4, p2, f2;
        r2 === "width" || r2 === "both" ? (f2 = i2[0] + l2 - n2[3], h4 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h4 = f2 + a2.displaySize[0]);
        const d2 = e2.top * s2, y2 = e2.bottom * s2;
        return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h4, bottom: p2, left: f2, collisionPadding: o2 };
      }
      class Hp extends d {
        constructor(t2, e2, r2, n2, i2) {
          super(t2, e2), this.angle = n2, this.z = r2, i2 !== void 0 && (this.segment = i2);
        }
        clone() {
          return new Hp(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function Wp(t2, e2, r2, n2, i2) {
        if (e2.segment === void 0)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (; o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l2 = [];
        let u2 = 0;
        for (; o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
            u2 -= l2.shift().angleDelta;
          if (u2 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Jp(t2) {
        let e2 = 0;
        for (let r2 = 0; r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function Qp(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function tf(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function ef(t2, e2, r2, n2, i2, s2) {
        const a2 = Qp(r2, i2, s2), o2 = tf(r2, n2) * s2;
        let l2 = 0;
        const u2 = Jp(t2) / 2;
        for (let r3 = 0; r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l2 + s3 > u2) {
            const c2 = (u2 - l2) / s3, h4 = Mr(n3.x, i3.x, c2), p2 = Mr(n3.y, i3.y, c2), f2 = new Hp(h4, p2, 0, i3.angleTo(n3), r3);
            return !a2 || Wp(t2, f2, o2, a2, e2) ? f2 : void 0;
          }
          l2 += s3;
        }
      }
      function rf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = Qp(n2, s2, a2), c2 = tf(n2, i2), h4 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
        return e2 - h4 < e2 / 4 && (e2 = h4 + e2 / 4), nf(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h4, p2, false, l2);
      }
      function nf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = s2 / 2, c2 = Jp(t2);
        let h4 = 0, p2 = e2 - r2, f2 = [];
        for (let e3 = 0; e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
          for (; p2 + r2 < h4 + d2; ) {
            p2 += r2;
            const m2 = (p2 - h4) / d2, g2 = Mr(a3.x, o3.x, m2), x2 = Mr(a3.y, o3.y, m2);
            if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
              const r3 = new Hp(g2, x2, 0, y2, e3);
              r3._round(), n2 && !Wp(t2, r3, s2, n2, i2) || f2.push(r3);
            }
          }
          h4 += d2;
        }
        return o2 || f2.length || a2 || (f2 = nf(t2, h4 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
      }
      function sf(t2, e2, r2, n2, i2) {
        const s2 = [];
        for (let a2 = 0; a2 < t2.length; a2++) {
          const o2 = t2[a2];
          let l2;
          for (let t3 = 0; t3 < o2.length - 1; t3++) {
            let a3 = o2[t3], u2 = o2[t3 + 1];
            a3.x < e2 && u2.x < e2 || (a3.x < e2 ? a3 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e2 && (u2 = new d(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new d(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new d(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new d(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new d(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
          }
        }
        return s2;
      }
      Oi(Hp, "Anchor");
      const af = 1e20;
      function of(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        for (let u2 = e2; u2 < e2 + n2; u2++)
          lf(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
        for (let u2 = r2; u2 < r2 + i2; u2++)
          lf(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
      }
      function lf(t2, e2, r2, n2, i2, s2, a2) {
        s2[0] = 0, a2[0] = -af, a2[1] = af, i2[0] = t2[e2];
        for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
          i2[o2] = t2[e2 + o2 * r2];
          const n3 = o2 * o2;
          do {
            const t3 = s2[l2];
            u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
          } while (u2 <= a2[l2] && --l2 > -1);
          l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = af;
        }
        for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
          for (; a2[l2 + 1] < o2; )
            l2++;
          const n3 = s2[l2], u2 = o2 - n3;
          t2[e2 + o2 * r2] = i2[n3] + u2 * u2;
        }
      }
      const uf = { none: 0, ideographs: 1, all: 2 };
      class cf {
        constructor(t2, e2, r2) {
          this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t2) {
          this.url = t2;
        }
        getGlyphs(t2, e2) {
          const r2 = [];
          for (const e3 in t2)
            for (const n2 of t2[e3])
              r2.push({ stack: e3, id: n2 });
          M(r2, ({ stack: t3, id: e3 }, r3) => {
            let n2 = this.entries[t3];
            n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let i2 = n2.glyphs[e3];
            if (i2 !== void 0)
              return void r3(null, { stack: t3, id: e3, glyph: i2 });
            if (i2 = this._tinySDF(n2, t3, e3), i2)
              return n2.glyphs[e3] = i2, void r3(null, { stack: t3, id: e3, glyph: i2 });
            const s2 = Math.floor(e3 / 256);
            if (256 * s2 > 65535)
              return void r3(new Error("glyphs > 65535 not supported"));
            if (n2.ranges[s2])
              return void r3(null, { stack: t3, id: e3, glyph: i2 });
            let a2 = n2.requests[s2];
            a2 || (a2 = n2.requests[s2] = [], cf.loadGlyphRange(t3, s2, this.url, this.requestManager, (t4, e4) => {
              if (e4) {
                n2.ascender = e4.ascender, n2.descender = e4.descender;
                for (const t5 in e4.glyphs)
                  this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                n2.ranges[s2] = true;
              }
              for (const r4 of a2)
                r4(t4, e4);
              delete n2.requests[s2];
            })), a2.push((n3, i3) => {
              n3 ? r3(n3) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
            });
          }, (t3, r3) => {
            if (t3)
              e2(t3);
            else if (r3) {
              const t4 = {};
              for (const { stack: e3, id: n2, glyph: i2 } of r3)
                t4[e3] === void 0 && (t4[e3] = {}), t4[e3].glyphs === void 0 && (t4[e3].glyphs = {}), t4[e3].glyphs[n2] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
              e2(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(t2) {
          return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t2) || ps(t2) || ts(t2) || es(t2) || Qi(t2)));
        }
        _tinySDF(t2, e2, r2) {
          const n2 = this.localFontFamily;
          if (!n2 || !this._doesCharSupportLocalGlyph(r2))
            return;
          let i2 = t2.tinySDF;
          if (!i2) {
            let r3 = "400";
            /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new cf.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r3;
          }
          if (this.localGlyphs[i2.fontWeight][r2])
            return this.localGlyphs[i2.fontWeight][r2];
          const s2 = String.fromCharCode(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h4, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
          return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new Ju({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h4 / 2, top: p2 / 2 - 27, advance: f2 / 2, localGlyph: true } };
        }
      }
      function hf(t2, e2, r2, n2) {
        const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2, l2 = s2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h4 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = h4.reduce(f2, 0), m2 = p2.reduce(f2, 0), g2 = o2 - y2, x2 = l2 - m2;
        let v3 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, S2 = g2, k2 = 0, I2 = x2;
        if (s2.content && n2) {
          const t3 = s2.content;
          v3 = pf(h4, 0, t3[0]), w2 = pf(p2, 0, t3[1]), b2 = pf(h4, t3[0], t3[2]), _2 = pf(p2, t3[1], t3[3]), A2 = t3[0] - v3, k2 = t3[1] - w2, S2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - _2;
        }
        const M2 = (n3, i3, o3, l3) => {
          const h5 = df(n3.stretch - v3, b2, u2, t2.left), p3 = yf(n3.fixed - A2, S2, n3.stretch, y2), f3 = df(i3.stretch - w2, _2, c2, t2.top), g3 = yf(i3.fixed - k2, I2, i3.stretch, m2), x3 = df(o3.stretch - v3, b2, u2, t2.left), M3 = yf(o3.fixed - A2, S2, o3.stretch, y2), T2 = df(l3.stretch - w2, _2, c2, t2.top), z2 = yf(l3.fixed - k2, I2, l3.stretch, m2), B2 = new d(h5, f3), E2 = new d(x3, f3), C2 = new d(x3, T2), P2 = new d(h5, T2), D2 = new d(p3 / a2, g3 / a2), V2 = new d(M3 / a2, z2 / a2), L2 = e2 * Math.PI / 180;
          if (L2) {
            const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
            B2._matMult(r3), E2._matMult(r3), P2._matMult(r3), C2._matMult(r3);
          }
          const F2 = n3.stretch + n3.fixed, R3 = i3.stretch + i3.fixed;
          return { tl: B2, tr: E2, bl: P2, br: C2, tex: { x: s2.paddedRect.x + 1 + F2, y: s2.paddedRect.y + 1 + R3, w: o3.stretch + o3.fixed - F2, h: l3.stretch + l3.fixed - R3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: S2 / a2 / u2, minFontScaleY: I2 / a2 / c2, isSDF: r2 };
        };
        if (n2 && (s2.stretchX || s2.stretchY)) {
          const t3 = ff(h4, g2, y2), e3 = ff(p2, x2, m2);
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              i2.push(M2(n3, e3[t4], s3, e3[t4 + 1]));
          }
        } else
          i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
        return i2;
      }
      function pf(t2, e2, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
        return n2;
      }
      function ff(t2, e2, r2) {
        const n2 = [{ fixed: -1, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
      }
      function df(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function yf(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }
      function mf(t2, e2, r2, n2) {
        const i2 = e2 + t2.positionedLines[n2].lineOffset;
        return n2 === 0 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
      }
      cf.loadGlyphRange = function(t2, e2, r2, n2, i2) {
        const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), st.Glyphs);
        ut(o2, (t3, e3) => {
          if (t3)
            i2(t3);
          else if (e3) {
            const t4 = {}, r3 = function(t5) {
              return new op(t5).readFields(zp, {});
            }(e3);
            for (const e4 of r3.glyphs)
              t4[e4.id] = e4;
            i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
          }
        });
      }, cf.TinySDF = class {
        constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
          this.buffer = e2, this.cutoff = n2, this.radius = r2;
          const o2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
        }
        _createCanvas(t2) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t2, e2;
        }
        draw(t2) {
          const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h4 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h4), f2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
          if (o2 === 0 || l2 === 0)
            return f2;
          const { ctx: d2, buffer: y2, gridInner: m2, gridOuter: g2 } = this;
          d2.clearRect(y2, y2, o2, l2), d2.fillText(t2, y2, y2 + a2);
          const x2 = d2.getImageData(y2, y2, o2, l2);
          g2.fill(af, 0, h4), m2.fill(0, 0, h4);
          for (let t3 = 0; t3 < l2; t3++)
            for (let e3 = 0; e3 < o2; e3++) {
              const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (r3 === 0)
                continue;
              const n3 = (t3 + y2) * u2 + e3 + y2;
              if (r3 === 1)
                g2[n3] = 0, m2[n3] = af;
              else {
                const t4 = 0.5 - r3;
                g2[n3] = t4 > 0 ? t4 * t4 : 0, m2[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          of(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), of(m2, y2, y2, o2, l2, u2, this.f, this.v, this.z);
          for (let t3 = 0; t3 < h4; t3++) {
            const e3 = Math.sqrt(g2[t3]) - Math.sqrt(m2[t3]);
            p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return f2;
        }
      };
      class gf {
        constructor(t2 = [], e2 = xf) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (; t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (; t2 < n2; ) {
            let n3 = 1 + (t2 << 1), s2 = e2[n3];
            const a2 = n3 + 1;
            if (a2 < this.length && r2(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r2(s2, i2) >= 0)
              break;
            e2[t2] = s2, t2 = n3;
          }
          e2[t2] = i2;
        }
      }
      function xf(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function vf(t2, e2 = 1, r2 = false) {
        let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
        const o2 = t2[0];
        for (let t3 = 0; t3 < o2.length; t3++) {
          const e3 = o2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
        }
        const l2 = Math.min(s2 - n2, a2 - i2);
        let u2 = l2 / 2;
        const c2 = new gf([], bf);
        if (l2 === 0)
          return new d(n2, i2);
        for (let e3 = n2; e3 < s2; e3 += l2)
          for (let r3 = i2; r3 < a2; r3 += l2)
            c2.push(new wf(e3 + u2, r3 + u2, u2, t2));
        let h4 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
            const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
            r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new wf(r3 / e3, n3 / e3, 0, t3);
        }(t2), p2 = c2.length;
        for (; c2.length; ) {
          const n3 = c2.pop();
          (n3.d > h4.d || !h4.d) && (h4 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h4.d <= e2 || (u2 = n3.h / 2, c2.push(new wf(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new wf(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new wf(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
        }
        return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h4.d}`)), h4.p;
      }
      function bf(t2, e2) {
        return e2.max - t2.max;
      }
      function wf(t2, e2, r2, n2) {
        this.p = new d(t2, e2), this.h = r2, this.d = function(t3, e3) {
          let r3 = false, n3 = 1 / 0;
          for (let i2 = 0; i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Cu(t3, i4, o2));
            }
          }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      const _f = Number.POSITIVE_INFINITY, Af = Math.sqrt(2);
      function Sf(t2, [e2, r2]) {
        let n2 = 0, i2 = 0;
        if (r2 === _f) {
          e2 < 0 && (e2 = 0);
          const r3 = e2 / Af;
          switch (t2) {
            case "top-right":
            case "top-left":
              i2 = r3 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              i2 = 7 - r3;
              break;
            case "bottom":
              i2 = 7 - e2;
              break;
            case "top":
              i2 = e2 - 7;
          }
          switch (t2) {
            case "top-right":
            case "bottom-right":
              n2 = -r3;
              break;
            case "top-left":
            case "bottom-left":
              n2 = r3;
              break;
            case "left":
              n2 = e2;
              break;
            case "right":
              n2 = -e2;
          }
        } else {
          switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = 7 - r2;
          }
          switch (t2) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e2;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e2;
          }
        }
        return [n2, i2];
      }
      function kf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
        t2.createArrays(), t2.tilePixelRatio = ko / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
        const c2 = t2.layers[0].layout, h4 = t2.layers[0]._unevaluatedLayout._values, p2 = {};
        if (t2.textSizeData.kind === "composite") {
          const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
          p2.compositeTextSizes = [h4["text-size"].possiblyEvaluate(new Us(e3), o2), h4["text-size"].possiblyEvaluate(new Us(r3), o2)];
        }
        if (t2.iconSizeData.kind === "composite") {
          const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
          p2.compositeIconSizes = [h4["icon-size"].possiblyEvaluate(new Us(e3), o2), h4["icon-size"].possiblyEvaluate(new Us(r3), o2)];
        }
        p2.layoutTextSize = h4["text-size"].possiblyEvaluate(new Us(l2 + 1), o2), p2.layoutIconSize = h4["icon-size"].possiblyEvaluate(new Us(l2 + 1), o2), p2.textMaxSize = h4["text-size"].possiblyEvaluate(new Us(18), o2);
        const f2 = c2.get("text-rotation-alignment") === "map" && c2.get("symbol-placement") !== "point", d2 = c2.get("text-size");
        for (const s3 of t2.features) {
          const l3 = c2.get("text-font").evaluate(s3, {}, o2).join(","), h5 = d2.evaluate(s3, {}, o2), y2 = p2.layoutTextSize.evaluate(s3, {}, o2), m2 = (p2.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s3.text;
          let x2, v3 = [0, 0];
          if (g2) {
            const n3 = g2.toString(), a3 = c2.get("text-letter-spacing").evaluate(s3, {}, o2) * Wh, u3 = c2.get("text-line-height").evaluate(s3, {}, o2) * Wh, p3 = ws(n3) ? a3 : 0, d3 = c2.get("text-anchor").evaluate(s3, {}, o2), x3 = c2.get("text-variable-anchor");
            if (!x3) {
              const t3 = c2.get("text-radial-offset").evaluate(s3, {}, o2);
              v3 = t3 ? Sf(d3, [t3 * Wh, _f]) : c2.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * Wh);
            }
            let b3 = f2 ? "center" : c2.get("text-justify").evaluate(s3, {}, o2);
            const w3 = c2.get("symbol-placement") === "point", _2 = w3 ? c2.get("text-max-width").evaluate(s3, {}, o2) * Wh : 1 / 0, A2 = (s4) => {
              t2.allowVerticalPlacement && bs(n3) && (m2.vertical = Rp(g2, e2, r2, i2, l3, _2, u3, d3, s4, p3, v3, Vp.vertical, true, y2, h5));
            };
            if (!f2 && x3) {
              const t3 = b3 === "auto" ? x3.map((t4) => If(t4)) : [b3];
              let n4 = false;
              for (let s4 = 0; s4 < t3.length; s4++) {
                const a4 = t3[s4];
                if (!m2.horizontal[a4])
                  if (n4)
                    m2.horizontal[a4] = m2.horizontal[0];
                  else {
                    const t4 = Rp(g2, e2, r2, i2, l3, _2, u3, "center", a4, p3, v3, Vp.horizontal, false, y2, h5);
                    t4 && (m2.horizontal[a4] = t4, n4 = t4.positionedLines.length === 1);
                  }
              }
              A2("left");
            } else {
              if (b3 === "auto" && (b3 = If(d3)), w3 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n3)) {
                const t3 = Rp(g2, e2, r2, i2, l3, _2, u3, d3, b3, p3, v3, Vp.horizontal, false, y2, h5);
                t3 && (m2.horizontal[b3] = t3);
              }
              A2(w3 ? "left" : b3);
            }
          }
          let b2 = false;
          if (s3.icon && s3.icon.name) {
            const e3 = n2[s3.icon.name];
            e3 && (x2 = Kp(i2[s3.icon.name], c2.get("icon-offset").evaluate(s3, {}, o2), c2.get("icon-anchor").evaluate(s3, {}, o2)), b2 = e3.sdf, t2.sdfIcons === void 0 ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && $("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || c2.get("icon-rotate").constantOr(1) !== 0) && (t2.iconsNeedLinear = true));
          }
          const w2 = Bf(m2.horizontal) || m2.vertical;
          t2.iconsInText || (t2.iconsInText = !!w2 && w2.iconsInText), (w2 || x2) && Mf(t2, s3, m2, x2, n2, p2, y2, 0, v3, b2, a2, o2, u2);
        }
        s2 && t2.generateCollisionDebugBuffers(l2, t2.collisionBoxArray);
      }
      function If(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Mf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2) {
        let f2 = s2.textMaxSize.evaluate(e2, {}, h4);
        f2 === void 0 && (f2 = a2);
        const d2 = t2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(e2, {}, h4), m2 = Bf(r2.horizontal) || r2.vertical, g2 = p2.name === "globe", v3 = a2 / 24, b2 = t2.tilePixelRatio * f2 / 24, w2 = (z2 = t2.overscaling, t2.zoom > 18 && z2 > 2 && (z2 >>= 1), Math.max(ko / (512 * z2), 1) * d2.get("symbol-spacing")), _2 = d2.get("text-padding") * t2.tilePixelRatio, A2 = d2.get("icon-padding") * t2.tilePixelRatio, S2 = x(d2.get("text-max-angle")), k2 = d2.get("text-rotation-alignment") === "map" && d2.get("symbol-placement") !== "point", I2 = d2.get("icon-rotation-alignment") === "map" && d2.get("symbol-placement") !== "point", M2 = d2.get("symbol-placement"), T2 = w2 / 2;
        var z2;
        const B2 = d2.get("icon-text-fit");
        let E2;
        n2 && B2 !== "none" && (t2.allowVerticalPlacement && r2.vertical && (E2 = Yp(n2, r2.vertical, B2, d2.get("icon-text-fit-padding"), y2, v3)), m2 && (n2 = Yp(n2, m2, B2, d2.get("icon-text-fit-padding"), y2, v3)));
        const C2 = (a3, o3, f3) => {
          if (o3.x < 0 || o3.x >= ko || o3.y < 0 || o3.y >= ko)
            return;
          let d3 = null;
          if (g2) {
            const { x: t3, y: e3, z: r3 } = p2.projectTilePoint(o3.x, o3.y, f3);
            d3 = { anchor: new Hp(t3, e3, r3, 0, void 0), up: p2.upVector(f3, o3.x, o3.y) };
          }
          !function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c3, h5, p3, f4, d4, y3, m3, g3, x2, v4, b3, w3, _3, A3, S3) {
            const k3 = t3.addToLineVertexArray(e3, n3);
            let I3, M3, T3, z3, B3, E3, C3, P2 = 0, D2 = 0, V2 = 0, L2 = 0, F2 = -1, R3 = -1;
            const j2 = {};
            let U2 = qa("");
            const O2 = r3 ? r3.anchor : e3;
            let q2 = 0, N2 = 0;
            if (l3._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [q2, N2] = l3.layout.get("text-offset").evaluate(b3, {}, S3).map((t4) => t4 * Wh) : (q2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, S3) * Wh, N2 = _f), t3.allowVerticalPlacement && i3.vertical) {
              const t4 = i3.vertical;
              if (d4)
                E3 = Cf(t4), o4 && (C3 = Cf(o4));
              else {
                const r4 = l3.layout.get("text-rotate").evaluate(b3, {}, S3) + 90;
                T3 = Ef(u3, O2, e3, c3, h5, p3, t4, f4, r4, y3), o4 && (z3 = Ef(u3, O2, e3, c3, h5, p3, o4, g3, r4));
              }
            }
            if (s3) {
              const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, S3), i4 = l3.layout.get("icon-text-fit") !== "none", a5 = hf(s3, n4, _3, i4), f5 = o4 ? hf(o4, n4, _3, i4) : void 0;
              M3 = Ef(u3, O2, e3, c3, h5, p3, s3, g3, n4), P2 = 4 * a5.length;
              const d5 = t3.iconSizeData;
              let y4 = null;
              d5.kind === "source" ? (y4 = [Jh * l3.layout.get("icon-size").evaluate(b3, {}, S3)], y4[0] > Tf && $(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : d5.kind === "composite" && (y4 = [Jh * w3.compositeIconSizes[0].evaluate(b3, {}, S3), Jh * w3.compositeIconSizes[1].evaluate(b3, {}, S3)], (y4[0] > Tf || y4[1] > Tf) && $(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, a5, y4, v4, x2, b3, false, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F2 = t3.icon.placedSymbolArray.length - 1, f5 && (D2 = 4 * f5.length, t3.addSymbols(t3.icon, f5, y4, v4, x2, b3, Vp.vertical, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R3 = t3.icon.placedSymbolArray.length - 1);
            }
            for (const n4 in i3.horizontal) {
              const s4 = i3.horizontal[n4];
              I3 || (U2 = qa(s4.text), d4 ? B3 = Cf(s4) : I3 = Ef(u3, O2, e3, c3, h5, p3, s4, f4, l3.layout.get("text-rotate").evaluate(b3, {}, S3), y3));
              const o5 = s4.positionedLines.length === 1;
              if (V2 += zf(t3, r3, e3, s4, a4, l3, d4, b3, y3, k3, i3.vertical ? Vp.horizontal : Vp.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], j2, F2, w3, A3, S3), o5)
                break;
            }
            i3.vertical && (L2 += zf(t3, r3, e3, i3.vertical, a4, l3, d4, b3, y3, k3, Vp.vertical, ["vertical"], j2, R3, w3, A3, S3));
            let G2 = -1;
            const X2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
            G2 = X2(B3, G2), G2 = X2(E3, G2), G2 = X2(C3, G2);
            const Z2 = G2 > -1 ? 1 : 0;
            t3.glyphOffsetArray.length >= hd.MAX_GLYPHS && $("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), b3.sortKey !== void 0 && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(O2.x, O2.y, O2.z, e3.x, e3.y, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, F2, R3, U2, I3 !== void 0 ? I3 : t3.collisionBoxArray.length, I3 !== void 0 ? I3 + 1 : t3.collisionBoxArray.length, T3 !== void 0 ? T3 : t3.collisionBoxArray.length, T3 !== void 0 ? T3 + 1 : t3.collisionBoxArray.length, M3 !== void 0 ? M3 : t3.collisionBoxArray.length, M3 !== void 0 ? M3 + 1 : t3.collisionBoxArray.length, z3 || t3.collisionBoxArray.length, z3 ? z3 + 1 : t3.collisionBoxArray.length, c3, V2, L2, P2, D2, Z2, 0, q2, N2, G2);
          }(t2, o3, d3, a3, r2, n2, i2, E2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, _2, k2, l2, 0, A2, I2, y2, e2, s2, u2, c2, h4);
        };
        if (M2 === "line")
          for (const i3 of sf(e2.geometry, 0, 0, ko, ko)) {
            const e3 = rf(i3, w2, S2, r2.vertical || m2, n2, 24, b2, t2.overscaling, ko);
            for (const r3 of e3) {
              const e4 = m2;
              e4 && Pf(t2, e4.text, T2, r3) || C2(i3, r3, h4);
            }
          }
        else if (M2 === "line-center") {
          for (const t3 of e2.geometry)
            if (t3.length > 1) {
              const e3 = ef(t3, S2, r2.vertical || m2, n2, 24, b2);
              e3 && C2(t3, e3, h4);
            }
        } else if (e2.type === "Polygon")
          for (const t3 of Lc(e2.geometry, 0)) {
            const e3 = vf(t3, 16);
            C2(t3[0], new Hp(e3.x, e3.y, 0, 0, void 0), h4);
          }
        else if (e2.type === "LineString")
          for (const t3 of e2.geometry)
            C2(t3, new Hp(t3[0].x, t3[0].y, 0, 0, void 0), h4);
        else if (e2.type === "Point")
          for (const t3 of e2.geometry)
            for (const e3 of t3)
              C2([e3], new Hp(e3.x, e3.y, 0, 0, void 0), h4);
      }
      const Tf = 32640;
      function zf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2, y2, m2, g2) {
        const x2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          const l3 = [];
          if (e3.positionedLines.length === 0)
            return l3;
          const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
            const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
            return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : e4 === 0 ? [r4, e4] : [r4, -e4];
          }(r3);
          let h5 = Math.abs(e3.top - e3.bottom);
          for (const t4 of e3.positionedLines)
            h5 -= t4.lineOffset;
          const p3 = e3.positionedLines.length, f3 = h5 / p3;
          let y3 = e3.top - r3[1];
          for (let t4 = 0; t4 < p3; ++t4) {
            const n4 = e3.positionedLines[t4];
            y3 = mf(e3, f3, y3, t4);
            for (const t5 of n4.positionedGlyphs) {
              if (!t5.rect)
                continue;
              const n5 = t5.rect || {};
              let s4 = 4, h6 = true, p4 = 1, f4 = 0;
              if (t5.imageName) {
                const e4 = a3[t5.imageName];
                if (!e4)
                  continue;
                if (e4.sdf) {
                  $("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                h6 = false, p4 = e4.pixelRatio, s4 = 1 / p4;
              }
              const m3 = (i3 || o3) && t5.vertical, g3 = t5.metrics.advance * t5.scale / 2, x3 = t5.metrics, v4 = t5.rect;
              if (v4 === null)
                continue;
              o3 && e3.verticalizable && (f4 = t5.imageName ? g3 - t5.metrics.width * t5.scale / 2 : 0);
              const b3 = i3 ? [t5.x + g3, t5.y] : [0, 0];
              let w2 = [0, 0], _2 = [0, 0], A2 = false;
              i3 || (m3 ? (_2 = [t5.x + g3 + c3[0], t5.y + c3[1] - f4], A2 = true) : w2 = [t5.x + g3 + r3[0], t5.y + r3[1] - f4]);
              const S2 = v4.w * t5.scale / (p4 * (t5.localGlyph ? 2 : 1)), k2 = v4.h * t5.scale / (p4 * (t5.localGlyph ? 2 : 1));
              let I2, M2, T2, z2;
              if (m3) {
                const e4 = t5.y - y3, r4 = new d(-g3, g3 - e4), n6 = -Math.PI / 2, i4 = new d(..._2);
                I2 = new d(-g3 + w2[0], w2[1]), I2._rotateAround(n6, r4)._add(i4), I2.x += -e4 + g3, I2.y -= (x3.left - s4) * t5.scale;
                const a4 = t5.imageName ? x3.advance * t5.scale : Wh * t5.scale, o4 = String.fromCharCode(t5.glyph);
                sp(o4) ? I2.x += (1 - s4) * t5.scale : ap(o4) ? I2.x += a4 - x3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.imageName || x3.width + 2 * s4 === v4.w && x3.height + 2 * s4 === v4.h ? (a4 - k2) / 2 : (a4 - (x3.height + 2 * s4) * t5.scale) / 2, M2 = new d(I2.x, I2.y - S2), T2 = new d(I2.x + k2, I2.y), z2 = new d(I2.x + k2, I2.y - S2);
              } else {
                const e4 = (x3.left - s4) * t5.scale - g3 + w2[0], r4 = (-x3.top - s4) * t5.scale + w2[1], n6 = e4 + S2, i4 = r4 + k2;
                I2 = new d(e4, r4), M2 = new d(n6, r4), T2 = new d(e4, i4), z2 = new d(n6, i4);
              }
              if (u3) {
                let t6;
                t6 = i3 ? new d(0, 0) : A2 ? new d(c3[0], c3[1]) : new d(r3[0], r3[1]), I2._rotateAround(u3, t6), M2._rotateAround(u3, t6), T2._rotateAround(u3, t6), z2._rotateAround(u3, t6);
              }
              const B2 = new d(0, 0), E2 = new d(0, 0);
              l3.push({ tl: I2, tr: M2, bl: T2, br: z2, tex: n5, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h6, pixelOffsetTL: B2, pixelOffsetBR: E2, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return l3;
        }(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), v3 = t2.textSizeData;
        let b2 = null;
        v3.kind === "source" ? (b2 = [Jh * s2.layout.get("text-size").evaluate(o2, {}, g2)], b2[0] > Tf && $(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : v3.kind === "composite" && (b2 = [Jh * y2.compositeTextSizes[0].evaluate(o2, {}, g2), Jh * y2.compositeTextSizes[1].evaluate(o2, {}, g2)], (b2[0] > Tf || b2[1] > Tf) && $(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, x2, b2, l2, a2, o2, c2, e2, r2, u2.lineStartIndex, u2.lineLength, f2, m2, g2);
        for (const e3 of h4)
          p2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * x2.length;
      }
      function Bf(t2) {
        for (const e2 in t2)
          return t2[e2];
        return null;
      }
      function Ef(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
        let c2 = a2.top, h4 = a2.bottom, p2 = a2.left, f2 = a2.right;
        const y2 = a2.collisionPadding;
        if (y2 && (p2 -= y2[0], c2 -= y2[1], f2 += y2[2], h4 += y2[3]), l2) {
          const t3 = new d(p2, c2), e3 = new d(f2, c2), r3 = new d(p2, h4), n3 = new d(f2, h4), i3 = x(l2);
          let s3 = new d(0, 0);
          u2 && (s3 = new d(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), c2 = Math.min(t3.y, e3.y, r3.y, n3.y), h4 = Math.max(t3.y, e3.y, r3.y, n3.y);
        }
        return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, p2, c2, f2, h4, o2, n2, i2, s2), t2.length - 1;
      }
      function Cf(t2) {
        t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
        const e2 = t2.bottom - t2.top;
        return e2 > 0 ? Math.max(10, e2) : null;
      }
      function Pf(t2, e2, r2, n2) {
        const i2 = t2.compareText;
        if (e2 in i2) {
          const t3 = i2[e2];
          for (let e3 = t3.length - 1; e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      function Df(t2, e2) {
        const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01)), a2 = Math.sin(t2._pitch) * s2 + i2;
        return Math.min(1.01 * a2, i2 * (1 / t2._horizonShift));
      }
      function Vf(t2, e2) {
        if (!e2.isReprojectedInTileSpace)
          return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
        const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = ou(n2), l2 = ou(i2), u2 = lu(s2), c2 = lu(a2), h4 = e2.project(o2, u2), p2 = e2.project(l2, u2), f2 = e2.project(l2, c2), d2 = e2.project(o2, c2);
        let y2 = Math.min(h4.x, p2.x, f2.x, d2.x), m2 = Math.min(h4.y, p2.y, f2.y, d2.y), g2 = Math.max(h4.x, p2.x, f2.x, d2.x), x2 = Math.max(h4.y, p2.y, f2.y, d2.y);
        const v3 = r2 / 16;
        function b2(t3, r3, n3, i3, s3, a3) {
          const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e2.project(ou(o3), lu(l3)), c3 = Math.max(0, y2 - u3.x, m2 - u3.y, u3.x - g2, u3.y - x2);
          y2 = Math.min(y2, u3.x), g2 = Math.max(g2, u3.x), m2 = Math.min(m2, u3.y), x2 = Math.max(x2, u3.y), c3 > v3 && (b2(t3, u3, n3, i3, o3, l3), b2(u3, r3, o3, l3, s3, a3));
        }
        b2(h4, p2, n2, s2, i2, s2), b2(p2, f2, i2, s2, i2, a2), b2(f2, d2, i2, a2, n2, a2), b2(d2, h4, n2, a2, n2, s2), y2 -= v3, m2 -= v3, g2 += v3, x2 += v3;
        const w2 = 1 / Math.max(g2 - y2, x2 - m2);
        return { scale: w2, x: y2 * w2, y: m2 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
      }
      const Lf = Eo(new Float32Array(16));
      class Ff {
        constructor(t2) {
          this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(t2, e2) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t2, e2) {
          return new ru(0, 0);
        }
        projectTilePoint(t2, e2, r2) {
          return { x: t2, y: e2, z: 0 };
        }
        locationPoint(t2, e2, r2 = true) {
          return t2._coordinatePoint(t2.locationCoordinate(e2), r2);
        }
        pixelsPerMeter(t2, e2) {
          return au(1, t2) * e2;
        }
        pixelSpaceConversion(t2, e2, r2) {
          return 1;
        }
        farthestPixelDistance(t2) {
          return Df(t2, t2.pixelsPerMeter);
        }
        pointCoordinate(t2, e2, r2, n2) {
          const i2 = t2.horizonLineFromTop(false), s2 = new d(e2, Math.max(i2, r2));
          return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
        }
        pointCoordinate3D(t2, e2, r2) {
          const n2 = new d(e2, r2);
          if (t2.elevation)
            return t2.elevation.pointCoordinate(n2);
          {
            const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
            return [e3.x, e3.y, e3.z];
          }
        }
        isPointAboveHorizon(t2, e2) {
          if (t2.elevation)
            return !this.pointCoordinate3D(t2, e2.x, e2.y);
          const r2 = t2.horizonLineFromTop();
          return e2.y < r2;
        }
        createInversionMatrix(t2, e2) {
          return Lf;
        }
        createTileMatrix(t2, e2, r2) {
          let n2, i2, s2;
          const a2 = r2.canonical, o2 = Eo(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l2 = Vf(a2, this);
            n2 = 1, i2 = l2.x + r2.wrap * l2.scale, s2 = l2.y, Vo(o2, o2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
          } else
            n2 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r2.wrap) * n2, s2 = a2.y * n2;
          return Do(o2, o2, [i2, s2, 0]), Vo(o2, o2, [n2 / ko, n2 / ko, 1]), o2;
        }
        upVector(t2, e2, r2) {
          return [0, 0, 1];
        }
        upVectorScale(t2, e2, r2) {
          return { metersToTile: 1 };
        }
      }
      class Rf extends Ff {
        constructor(t2) {
          super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
          const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(x(e2));
          this.n = (n2 + Math.sin(x(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(t2, e2) {
          const { n: r2, c: n2, r0: i2 } = this, s2 = x(t2 - this.center[0]), a2 = x(e2), o2 = Math.sqrt(n2 - 2 * r2 * Math.sin(a2)) / r2;
          return { x: o2 * Math.sin(s2 * r2), y: o2 * Math.cos(s2 * r2) - i2, z: 0 };
        }
        unproject(t2, e2) {
          const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e2;
          let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
          s2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
          const o2 = x(this.center[0]) * r2;
          a2 = I(a2, -Math.PI - o2, Math.PI - o2);
          const l2 = S(v2(a2 / r2) + this.center[0], -180, 180), u2 = Math.asin(S((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = S(v2(u2), -cu, cu);
          return new ru(l2, c2);
        }
      }
      const jf = 1.340264, Uf = -0.081106, $f = 893e-6, Of = 3796e-6, qf = Math.sqrt(3) / 2;
      class Nf extends Ff {
        project(t2, e2) {
          e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
          const r2 = Math.asin(qf * Math.sin(e2)), n2 = r2 * r2, i2 = n2 * n2 * n2;
          return { x: 0.5 * (t2 * Math.cos(r2) / (qf * (jf + 3 * Uf * n2 + i2 * (7 * $f + 9 * Of * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (jf + Uf * n2 + i2 * ($f + Of * n2)) / Math.PI + 1), z: 0 };
        }
        unproject(t2, e2) {
          t2 = (2 * t2 - 0.5) * Math.PI;
          let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
          for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r2 * (jf + Uf * n2 + i2 * ($f + Of * n2)) - e2, a3 = jf + 3 * Uf * n2 + i2 * (7 * $f + 9 * Of * n2), t3 = s3 / a3, r2 = S(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3)
            ;
          const s2 = qf * t2 * (jf + 3 * Uf * n2 + i2 * (7 * $f + 9 * Of * n2)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / qf), o2 = S(180 * s2 / Math.PI, -180, 180), l2 = S(180 * a2 / Math.PI, -cu, cu);
          return new ru(o2, l2);
        }
      }
      class Gf extends Ff {
        constructor(t2) {
          super(t2), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t2, e2) {
          return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
        }
        unproject(t2, e2) {
          const r2 = 360 * (t2 - 0.5), n2 = S(360 * (0.5 - e2), -cu, cu);
          return new ru(r2, n2);
        }
      }
      const Xf = Math.PI / 2;
      function Zf(t2) {
        return Math.tan((Xf + t2) / 2);
      }
      class Kf extends Ff {
        constructor(t2) {
          super(t2), this.center = t2.center || [0, 30];
          const [e2, r2] = this.parallels = t2.parallels || [30, 30];
          let n2 = x(e2), i2 = x(r2);
          this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
          const s2 = Math.cos(n2), a2 = Zf(n2);
          this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(Zf(i2) / a2), this.f = s2 * Math.pow(Zf(n2), this.n) / this.n;
        }
        project(t2, e2) {
          e2 = x(e2), this.southernCenter && (e2 = -e2), t2 = x(t2 - this.center[0]);
          const r2 = 1e-6, { n: n2, f: i2 } = this;
          i2 > 0 ? e2 < -Xf + r2 && (e2 = -Xf + r2) : e2 > Xf - r2 && (e2 = Xf - r2);
          const s2 = i2 / Math.pow(Zf(e2), n2);
          let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
          return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
        }
        unproject(t2, e2) {
          t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
          const { n: r2, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
          let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
          i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
          const l2 = S(v2(o2 / r2) + this.center[0], -180, 180), u2 = S(v2(2 * Math.atan(Math.pow(n2 / a2, 1 / r2)) - Xf), -cu, cu);
          return new ru(l2, this.southernCenter ? -u2 : u2);
        }
      }
      class Yf extends Ff {
        constructor(t2) {
          super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(t2, e2) {
          return { x: iu(t2), y: su(e2), z: 0 };
        }
        unproject(t2, e2) {
          const r2 = ou(t2), n2 = lu(e2);
          return new ru(r2, n2);
        }
      }
      const Hf = x(cu);
      class Wf extends Ff {
        project(t2, e2) {
          const r2 = (e2 = x(e2)) * e2, n2 = r2 * r2;
          return { x: 0.5 * ((t2 = x(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
        }
        unproject(t2, e2) {
          t2 = (2 * t2 - 0.5) * Math.PI;
          let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
          do {
            s2 = r2 * r2;
            const t3 = s2 * s2;
            i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = S(r2 - i2, -Hf, Hf);
          } while (Math.abs(i2) > 1e-6 && --n2 > 0);
          s2 = r2 * r2;
          const a2 = S(v2(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = v2(r2);
          return new ru(a2, o2);
        }
      }
      const Jf = x(cu);
      class Qf extends Ff {
        project(t2, e2) {
          e2 = x(e2), t2 = x(t2);
          const r2 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
        }
        unproject(t2, e2) {
          let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
          const s2 = 1e-6;
          let a2 = 0, o2 = 0;
          do {
            const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h4 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), f2 = 2 * h4 * p2, d2 = p2 * p2, y2 = 1 - c2 * h4 * h4, m2 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i3 * h4) * Math.sqrt(1 / y2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, v3 = 0.5 * (g2 * s3 + n2) - e2, b2 = 0.5 * m2 * (c2 * d2 + g2 * i3 * h4 * u2) + 1 / Math.PI, w2 = m2 * (f2 * l2 / 4 - g2 * s3 * p2), _2 = 0.125 * m2 * (l2 * p2 - g2 * s3 * c2 * f2), A2 = 0.5 * m2 * (u2 * h4 + g2 * d2 * i3) + 0.5, k2 = w2 * _2 - A2 * b2;
            a2 = (v3 * w2 - x2 * A2) / k2, o2 = (x2 * _2 - v3 * b2) / k2, r2 = S(r2 - a2, -Math.PI, Math.PI), n2 = S(n2 - o2, -Jf, Jf);
          } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
          return new ru(v2(r2), v2(n2));
        }
      }
      class td extends Ff {
        constructor(t2) {
          super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t2, e2) {
          const { scale: r2, cosPhi: n2 } = this;
          return { x: x(t2) * n2 * r2 + 0.5, y: -Math.sin(x(e2)) / n2 * r2 + 0.5, z: 0 };
        }
        unproject(t2, e2) {
          const { scale: r2, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r2, s2 = S(v2((t2 - 0.5) / r2) / n2, -180, 180), a2 = Math.asin(S(i2 * n2, -1, 1)), o2 = S(v2(a2), -cu, cu);
          return new ru(s2, o2);
        }
      }
      class ed extends Yf {
        constructor(t2) {
          super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(t2, e2, r2) {
          const n2 = Ol(t2, e2, r2);
          return el(n2, n2, Gl(Pl(r2))), { x: n2[0], y: n2[1], z: n2[2] };
        }
        locationPoint(t2, e2) {
          const r2 = $l(e2.lat, e2.lng), n2 = Jo([], r2), i2 = t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
          Wo(r2, r2, n2, au(1, 0) * ko * i2);
          const s2 = Eo(new Float64Array(16));
          return Po(s2, t2.pixelMatrix, t2.globeMatrix), el(r2, r2, s2), new d(r2[0], r2[1]);
        }
        pixelsPerMeter(t2, e2) {
          return au(1, 0) * e2;
        }
        pixelSpaceConversion(t2, e2, r2) {
          const n2 = au(1, t2) * e2, i2 = Mr(au(1, 45) * e2, n2, r2);
          return this.pixelsPerMeter(t2, e2) / i2;
        }
        createTileMatrix(t2, e2, r2) {
          const n2 = Xl(Pl(r2.canonical));
          return Po(new Float64Array(16), t2.globeMatrix, n2);
        }
        createInversionMatrix(t2, e2) {
          const { center: r2 } = t2, n2 = Gl(Pl(e2));
          return Fo(n2, n2, x(r2.lng)), Lo(n2, n2, x(r2.lat)), Vo(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
        }
        pointCoordinate(t2, e2, r2, n2) {
          return Bl(t2, e2, r2, true) || new pu(0, 0);
        }
        pointCoordinate3D(t2, e2, r2) {
          const n2 = this.pointCoordinate(t2, e2, r2, 0);
          return [n2.x, n2.y, n2.z];
        }
        isPointAboveHorizon(t2, e2) {
          return !Bl(t2, e2.x, e2.y, false);
        }
        farthestPixelDistance(t2) {
          const e2 = function(t3, e3) {
            const r3 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = Go([], Ho([], s2, -r3), [0, 0, n2]), o2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -o2], u2 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h4 = Ho([], i2.up(), c2), p2 = Ho([], i2.right(), c2 * u2), f2 = Jo([], Go([], Go([], s2, h4), p2)), d2 = [];
            let y2;
            if (new vl(a2, f2).closestPointOnSphere(l2, o2, d2)) {
              const e4 = Go([], d2, l2), r4 = il([], e4, a2);
              y2 = Math.cos(t3.fovAboveCenter) * qo(r4);
            } else {
              const t4 = il([], a2, l2), e4 = il([], l2, a2);
              Jo(e4, e4);
              const r4 = qo(t4) - o2;
              y2 = Math.sqrt(r4 * (r4 + 2 * o2));
              const n3 = Math.acos(y2 / (o2 + r4)) - Math.acos(Qo(s2, e4));
              y2 *= Math.cos(n3);
            }
            return 1.01 * y2;
          }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Kl(t2.zoom);
          if (r2 > 0) {
            const n2 = Df(t2, au(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
            return Mr(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r2, 10));
          }
          return e2;
        }
        upVector(t2, e2, r2) {
          return Ol(e2, r2, t2, 1);
        }
        upVectorScale(t2) {
          return { metersToTile: zl(ql(Pl(t2))) };
        }
      }
      function rd(t2) {
        const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
        switch (t2.name) {
          case "mercator":
            return new Yf(t2);
          case "equirectangular":
            return new Gf(t2);
          case "naturalEarth":
            return new Wf(t2);
          case "equalEarth":
            return new Nf(t2);
          case "winkelTripel":
            return new Qf(t2);
          case "albers":
            return r2 ? new td(t2) : new Rf(t2);
          case "lambertConformalConic":
            return r2 ? new td(t2) : new Kf(t2);
          case "globe":
            return new ed(t2);
        }
        throw new Error(`Invalid projection name: ${t2.name}`);
      }
      const nd = ah.types, id = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function sd(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2) {
        const f2 = o2 ? Math.min(Tf, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Tf, Math.round(o2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h4, 256 * p2);
      }
      function ad(t2, e2, r2, n2, i2, s2, a2) {
        t2.emplaceBack(e2, r2, n2, i2, s2, a2);
      }
      function od(t2, e2, r2, n2, i2) {
        t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2);
      }
      function ld(t2) {
        for (const e2 of t2.sections)
          if (Ms(e2.text))
            return true;
        return false;
      }
      class ud {
        constructor(t2) {
          this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t2, this.segments = new So(), this.dynamicLayoutVertexArray = new ua(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Pa(), this.globeExtVertexArray = new da();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t2, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Xh.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, id, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Gh.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
      }
      Oi(ud, "SymbolBuffers");
      class cd {
        constructor(t2, e2, r2) {
          this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new So(), this.collisionVertexArray = new va(), this.collisionVertexArrayExt = new ba();
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Zh.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Oi(cd, "CollisionBuffers");
      class hd {
        constructor(t2) {
          this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);
          const e2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Qh(this.zoom, e2["text-size"]), this.iconSizeData = Qh(this.zoom, e2["icon-size"]);
          const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
          this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = i2 !== "viewport-y" && n2.constantOr(1) !== void 0, this.sortFeaturesByY = (i2 === "viewport-y" || i2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => Vp[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection;
        }
        createArrays() {
          this.text = new ud(new fo(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new ud(new fo(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new La(), this.lineVertexArray = new Fa(), this.symbolInstances = new Va();
        }
        calculateGlyphDependencies(t2, e2, r2, n2, i2) {
          for (let r3 = 0; r3 < t2.length; r3++)
            if (e2[t2.charCodeAt(r3)] = true, n2 && i2) {
              const n3 = ip[t2.charAt(r3)];
              n3 && (e2[n3.charCodeAt(0)] = true);
            }
        }
        populate(t2, e2, r2, n2) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = this.projection.name === "globe", o2 = s2.get("text-font"), l2 = s2.get("text-field"), u2 = s2.get("icon-image"), c2 = (l2.value.kind !== "constant" || l2.value.value instanceof Be && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && (o2.value.kind !== "constant" || o2.value.value.length > 0), h4 = u2.value.kind !== "constant" || !!u2.value.value || Object.keys(u2.parameters).length > 0, p2 = s2.get("symbol-sort-key");
          if (this.features = [], !c2 && !h4)
            return;
          const f2 = e2.iconDependencies, d2 = e2.glyphDependencies, y2 = e2.availableImages, m2 = new Us(this.zoom);
          for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: g2 } of t2) {
            const t3 = i2._featureFilter.needGeometry, x2 = wu(e3, t3);
            if (!i2._featureFilter.filter(m2, x2, r2))
              continue;
            if (t3 || (x2.geometry = bu(e3, r2, n2)), a2 && e3.type !== 1 && r2.z <= 5) {
              const t4 = x2.geometry, e4 = 0.98078528056, n3 = (t5, n4) => Qo(Ol(t5.x, t5.y, r2, 1), Ol(n4.x, n4.y, r2, 1)) < e4;
              for (let e5 = 0; e5 < t4.length; e5++)
                t4[e5] = mu(t4[e5], n3);
            }
            let v3, b2;
            if (c2) {
              const t4 = i2.getValueAndResolveTokens("text-field", x2, r2, y2), e4 = Be.factory(t4);
              ld(e4) && (this.hasRTLText = true), (!this.hasRTLText || Fs() === "unavailable" || this.hasRTLText && js.isParsed()) && (v3 = np(e4, i2, x2));
            }
            if (h4) {
              const t4 = i2.getValueAndResolveTokens("icon-image", x2, r2, y2);
              b2 = t4 instanceof Ee ? t4 : Ee.fromString(t4);
            }
            if (!v3 && !b2)
              continue;
            const w2 = this.sortFeaturesByKey ? p2.evaluate(x2, {}, r2) : void 0;
            if (this.features.push({ id: l3, text: v3, icon: b2, index: u3, sourceLayerIndex: g2, geometry: x2.geometry, properties: e3.properties, type: nd[e3.type], sortKey: w2 }), b2 && (f2[b2.name] = true), v3) {
              const t4 = o2.evaluate(x2, {}, r2).join(","), e4 = s2.get("text-rotation-alignment") === "map" && s2.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;
              for (const r3 of v3.sections)
                if (r3.image)
                  f2[r3.image.name] = true;
                else {
                  const n3 = bs(v3.toString()), i3 = r3.fontStack || t4, s3 = d2[i3] = d2[i3] || {};
                  this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                }
            }
          }
          s2.get("symbol-placement") === "line" && (this.features = function(t3) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t3[e4]), i3++;
            }
            function a3(t4, e4, i4) {
              const s4 = r3[t4];
              return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t4, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t4, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t4}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0; u3 < t3.length; u3++) {
              const c3 = t3[u3], h5 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l3(p3, h5), d3 = l3(p3, h5, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t4 = o3(f3, d3, h5), i4 = a3(f3, d3, n3[t4].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h5) : d3 in e3 ? o3(f3, d3, h5) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t4) => t4.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
        }
        update(t2, e2, r2, n2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n2));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e2) {
          const r2 = this.lineVertexArray.length;
          if (t2.segment !== void 0)
            for (const { x: t3, y: r3 } of e2)
              this.lineVertexArray.emplaceBack(t3, r3);
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h4, p2, f2) {
          const d2 = t2.indexArray, y2 = t2.layoutVertexArray, m2 = t2.globeExtVertexArray, g2 = t2.segments.prepareSegment(4 * e2.length, y2, d2, this.canOverlap ? s2.sortKey : void 0), x2 = this.glyphOffsetArray.length, v3 = g2.vertexLength, b2 = this.allowVerticalPlacement && a2 === Vp.vertical ? Math.PI / 2 : 0, w2 = s2.text && s2.text.sections;
          for (let n3 = 0; n3 < e2.length; n3++) {
            const { tl: i3, tr: a3, bl: u3, br: c3, tex: h5, pixelOffsetTL: x3, pixelOffsetBR: v4, minFontScaleX: _3, minFontScaleY: A2, glyphOffset: S2, isSDF: k2, sectionIndex: I2 } = e2[n3], M2 = g2.vertexLength, T2 = S2[1];
            if (sd(y2, l2.x, l2.y, i3.x, T2 + i3.y, h5.x, h5.y, r2, k2, x3.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, a3.x, T2 + a3.y, h5.x + h5.w, h5.y, r2, k2, v4.x, x3.y, _3, A2), sd(y2, l2.x, l2.y, u3.x, T2 + u3.y, h5.x, h5.y + h5.h, r2, k2, x3.x, v4.y, _3, A2), sd(y2, l2.x, l2.y, c3.x, T2 + c3.y, h5.x + h5.w, h5.y + h5.h, r2, k2, v4.x, v4.y, _3, A2), o2) {
              const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
              ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), ad(m2, e3, r3, n4, i4, s3, a4), od(t2.dynamicLayoutVertexArray, e3, r3, n4, b2);
            } else
              od(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, b2);
            d2.emplaceBack(M2, M2 + 1, M2 + 2), d2.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n3 !== e2.length - 1 && I2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(y2.length, s2, s2.index, {}, p2, f2, w2 && w2[I2]);
          }
          const _2 = o2 ? o2.anchor : l2;
          t2.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l2.x, l2.y, x2, this.glyphOffsetArray.length - x2, v3, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, false, 0, h4, 0);
        }
        _commitLayoutVertex(t2, e2, r2, n2, i2, s2, a2) {
          t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
        }
        _addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
          for (let t3 = 0; t3 < 4; t3++)
            r2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new d(t2.x1, t2.y2)), o2.vertexLength += 4;
          const h4 = r2.indexArray;
          h4.emplaceBack(l2, l2 + 1), h4.emplaceBack(l2 + 1, l2 + 2), h4.emplaceBack(l2 + 2, l2 + 3), h4.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
            this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
            this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t2, e2) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);
          const r2 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t2, e2, r2, n2) {
          const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = tp(this.textSizeData, t2, i2) / Wh;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t2, e2, r2) {
          const n2 = this.icon.placedSymbolArray.get(r2), i2 = tp(this.iconSizeData, t2, n2);
          return this.tilePixelRatio * i2;
        }
        _commitDebugCollisionVertexUpdate(t2, e2, r2) {
          t2.emplaceBack(e2, -r2, -r2), t2.emplaceBack(e2, r2, -r2), t2.emplaceBack(e2, r2, r2), t2.emplaceBack(e2, -r2, r2);
        }
        _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding);
          }
        }
        _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding);
          }
        }
        updateCollisionDebugBuffers(t2, e2) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r2 = ep(this.iconSizeData, t2), n2 = ep(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2.placedIconSymbolIndex);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = {};
          if (e2 < r2) {
            const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2, featureIndex: f2 } = t2.get(e2);
            u2.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2 }, u2.textFeatureIndex = f2;
          }
          if (n2 < i2) {
            const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
            u2.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = f2;
          }
          if (s2 < a2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
            u2.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2 }, u2.iconFeatureIndex = f2;
          }
          if (o2 < l2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2, featureIndex: f2 } = t2.get(o2);
            u2.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h4, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = f2;
          }
          return u2;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
            const r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t2, e2) {
          const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        addToSortKeyRanges(t2, e2) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e2.featureIndex);
              const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
              r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Oi(hd, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;
      const pd = new Js({ "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]), "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]), "icon-size": new Hs(Ht.layout_symbol["icon-size"]), "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]), "icon-image": new Hs(Ht.layout_symbol["icon-image"]), "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]), "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]), "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]), "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]), "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]), "text-field": new Hs(Ht.layout_symbol["text-field"]), "text-font": new Hs(Ht.layout_symbol["text-font"]), "text-size": new Hs(Ht.layout_symbol["text-size"]), "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]), "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]), "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]), "text-justify": new Hs(Ht.layout_symbol["text-justify"]), "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]), "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]), "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]), "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]), "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]), "text-padding": new Ys(Ht.layout_symbol["text-padding"]), "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]), "text-transform": new Hs(Ht.layout_symbol["text-transform"]), "text-offset": new Hs(Ht.layout_symbol["text-offset"]), "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]), "text-optional": new Ys(Ht.layout_symbol["text-optional"]) });
      var fd = { paint: new Js({ "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]), "icon-color": new Hs(Ht.paint_symbol["icon-color"]), "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]), "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]), "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]), "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]), "text-color": new Hs(Ht.paint_symbol["text-color"], { runtimeType: le, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]), "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]), "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]), "text-translate": new Ys(Ht.paint_symbol["text-translate"]), "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"]) }), layout: pd };
      class dd {
        constructor(t2) {
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ie, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      Oi(dd, "FormatSectionOverride", { omit: ["defaultValue"] });
      class yd extends wo {
        constructor(t2) {
          super(t2, fd);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r2 = this.layout.get("text-writing-mode");
          if (r2) {
            const t3 = [];
            for (const e3 of r2)
              t3.indexOf(e3) < 0 && t3.push(e3);
            this.layout._values["text-writing-mode"] = t3;
          } else
            this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e2, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || Nn(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
          }(e2.properties, i2);
        }
        createBucket(t2) {
          return new hd(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t2 of fd.paint.overridableProperties) {
            if (!yd.hasPaintOverride(this.layout, t2))
              continue;
            const e2 = this.paint.get(t2), r2 = new dd(e2), n2 = new qn(r2, e2.property.specification);
            let i2 = null;
            i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new Xn("source", n2) : new Zn("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new Zs(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && yd.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e2) {
          const r2 = t2.get("text-field"), n2 = fd.paint.properties[e2];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if (r2.value.kind === "constant" && r2.value.value instanceof Be)
            s2(r2.value.value.sections);
          else if (r2.value.kind === "source") {
            const t3 = (e4) => {
              i2 || (e4 instanceof Fe && De(e4.value) === pe ? s2(e4.value.sections) : e4 instanceof Oe ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
      }
      var md = { paint: new Js({ "background-color": new Ys(Ht.paint_background["background-color"]), "background-pattern": new Ys(Ht.paint_background["background-pattern"]), "background-opacity": new Ys(Ht.paint_background["background-opacity"]) }) }, gd = { paint: new Js({ "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]), "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]), "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]), "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]), "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"]) }) };
      class xd extends wo {
        constructor(t2) {
          super(t2, {}), this.implementation = t2;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        isLayerDraped() {
          return this.implementation.renderToTile !== void 0;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(t2) {
          this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
        }
        onRemove(t2) {
          this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
        }
      }
      var vd = { paint: new Js({ "sky-type": new Ys(Ht.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"]) }) };
      function bd(t2, e2, r2) {
        const n2 = [0, 0, 1], i2 = hl([]);
        return fl(i2, i2, r2 ? -x(t2) + Math.PI : x(t2)), pl(i2, i2, -x(e2)), rl(n2, n2, i2), Jo(n2, n2);
      }
      const wd = { circle: class extends wo {
        constructor(t2) {
          super(t2, Ou);
        }
        createBucket(t2) {
          return new Su(t2);
        }
        queryRadius(t2) {
          const e2 = t2;
          return Fu("circle-radius", this, e2) + Fu("circle-stroke-width", this, e2) + Ru(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = Uu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
          return qu(t2, n2, s2, a2, o2, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", l2, u2);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
      }, heatmap: class extends wo {
        createBucket(t2) {
          return new Ku(t2);
        }
        constructor(t2) {
          super(t2, tc), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          t2 === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ec({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t2) {
          return Fu("heatmap-radius", this, t2);
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
          return qu(t2, n2, s2, a2, o2, true, true, new d(0, 0), l2);
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
      }, hillshade: class extends wo {
        constructor(t2) {
          super(t2, rc);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
      }, fill: class extends wo {
        constructor(t2) {
          super(t2, Oc);
        }
        getProgramIds() {
          const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2);
          const r2 = this.paint._values["fill-outline-color"];
          r2.value.kind === "constant" && r2.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new Uc(t2);
        }
        queryRadius() {
          return Ru(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
          return !t2.queryGeometry.isAboveHorizon && Mu(ju(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class extends wo {
        constructor(t2) {
          super(t2, Ah);
        }
        createBucket(t2) {
          return new fh(t2);
        }
        queryRadius() {
          return Ru(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = Uu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h4 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = [0, 0], f2 = o2 && s2.elevation, y2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
          if (f2 && m2 instanceof fh) {
            const t3 = m2.centroidVertexArray, e3 = l2 + 1;
            e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
          }
          if (p2[0] === 0 && p2[1] === 1)
            return false;
          s2.projection.name === "globe" && (n2 = wh([n2], [new d(0, 0), new d(ko, ko)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
          const g2 = f2 ? o2 : null, [x2, v3] = function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) {
            return t3.projection.name === "globe" ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4, u4, c4) {
              const h5 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d2 = [0, 0, 0, 1], y3 = [0, 0, 0, 1], m3 = (t5, e5, r5, n5) => {
                t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
              }, g3 = bh();
              r4 > 0 && (r4 += g3), n4 += g3;
              for (const g4 of e4) {
                const e5 = [], x3 = [];
                for (const h6 of g4) {
                  const p4 = h6.x + i4.x, g5 = h6.y + i4.y, v4 = t4.projection.projectTilePoint(p4, g5, c4), b3 = t4.projection.upVector(c4, h6.x, h6.y);
                  let w2 = r4, _2 = n4;
                  if (a4) {
                    const t5 = Ch(p4, g5, r4, n4, a4, o4, l4, u4);
                    w2 += t5.base, _2 += t5.top;
                  }
                  r4 !== 0 ? m3(d2, v4.x + b3[0] * f3 * w2, v4.y + b3[1] * f3 * w2, v4.z + b3[2] * f3 * w2) : m3(d2, v4.x, v4.y, v4.z), m3(y3, v4.x + b3[0] * f3 * _2, v4.y + b3[1] * f3 * _2, v4.z + b3[2] * f3 * _2), el(d2, d2, s4), el(y3, y3, s4), e5.push(new zh(d2[0], d2[1], d2[2])), x3.push(new zh(y3[0], y3[1], y3[2]));
                }
                h5.push(e5), p3.push(x3);
              }
              return [h5, p3];
            }(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) : a3 ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4) {
              const u4 = [], c4 = [], h5 = [0, 0, 0, 1];
              for (const p3 of t4) {
                const t5 = [], f3 = [];
                for (const u5 of p3) {
                  const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d2 = Ch(c5, p4, e4, r4, s4, a4, o4, l4);
                  h5[0] = c5, h5[1] = p4, h5[2] = d2.base, h5[3] = 1, ul(h5, h5, i4), h5[3] = Math.max(h5[3], 1e-5);
                  const y3 = new zh(h5[0] / h5[3], h5[1] / h5[3], h5[2] / h5[3]);
                  h5[0] = c5, h5[1] = p4, h5[2] = d2.top, h5[3] = 1, ul(h5, h5, i4), h5[3] = Math.max(h5[3], 1e-5);
                  const m3 = new zh(h5[0] / h5[3], h5[1] / h5[3], h5[2] / h5[3]);
                  t5.push(y3), f3.push(m3);
                }
                u4.push(t5), c4.push(f3);
              }
              return [u4, c4];
            }(e3, r3, n3, i3, s3, a3, o3, l3, u3) : function(t4, e4, r4, n4, i4) {
              const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h5 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d2 = i4[11] * r4;
              for (const e5 of t4) {
                const t5 = [], r5 = [];
                for (const s5 of e5) {
                  const e6 = s5.x + n4.x, a5 = s5.y + n4.y, y3 = i4[0] * e6 + i4[4] * a5 + i4[12], m3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x3 = i4[3] * e6 + i4[7] * a5 + i4[15], v4 = y3 + o4, b3 = m3 + l4, w2 = g3 + u4, _2 = Math.max(x3 + c4, 1e-5), A2 = y3 + h5, S2 = m3 + p3, k2 = g3 + f3, I2 = Math.max(x3 + d2, 1e-5);
                  t5.push(new zh(v4 / _2, b3 / _2, w2 / _2)), r5.push(new zh(A2 / I2, S2 / I2, k2 / I2));
                }
                s4.push(t5), a4.push(r5);
              }
              return [s4, a4];
            }(e3, r3, n3, i3, s3);
          }(s2, n2, h4, c2, u2, a2, g2, p2, y2, s2.center.lat, t2.tileID.canonical), b2 = t2.queryGeometry;
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Mu(r3, e3) && (n3 = Eh(r3, e3[0]));
            for (let i3 = 0; i3 < e3.length; i3++) {
              const s3 = e3[i3], a3 = t3[i3];
              for (let t4 = 0; t4 < s3.length - 1; t4++) {
                const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                ku(r3, i4) && (n3 = Math.min(n3, Eh(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(x2, v3, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
        }
      }, line: class extends wo {
        constructor(t2) {
          super(t2, $h), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if (t2 === "line-gradient") {
            const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new jh(t2);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(t2) {
          return new po(this, t2);
        }
        queryRadius(t2) {
          const e2 = t2, r2 = qh(Fu("line-width", this, e2), Fu("line-gap-width", this, e2)), n2 = Fu("line-offset", this, e2);
          return r2 / 2 + Math.abs(n2) + Ru(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
          if (t2.queryGeometry.isAboveHorizon)
            return false;
          const a2 = ju(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l2 = this.paint.get("line-offset").evaluate(e2, r2);
          return l2 && (n2 = function(t3, e3) {
            const r3 = [], n3 = new d(0, 0);
            for (let i3 = 0; i3 < t3.length; i3++) {
              const s3 = t3[i3], a3 = [];
              for (let t4 = 0; t4 < s3.length; t4++) {
                const r4 = s3[t4 - 1], i4 = s3[t4], o3 = s3[t4 + 1], l3 = t4 === 0 ? n3 : i4.sub(r4)._unit()._perp(), u2 = t4 === s3.length - 1 ? n3 : o3.sub(i4)._unit()._perp(), c2 = l3._add(u2)._unit();
                c2._mult(1 / (c2.x * u2.x + c2.y * u2.y)), a3.push(c2._mult(e3)._add(i4));
              }
              r3.push(a3);
            }
            return r3;
          }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0; e4 < i3.length; e4++)
                  if (Du(t3, i3[e4]))
                    return true;
              }
              if (Tu(t3, i3, r3))
                return true;
            }
            return false;
          }(a2, n2, o2);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: yd, background: class extends wo {
        constructor(t2) {
          super(t2, md);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      }, raster: class extends wo {
        constructor(t2) {
          super(t2, gd);
        }
        getProgramIds() {
          return ["raster"];
        }
      }, sky: class extends wo {
        constructor(t2) {
          super(t2, vd), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          t2 === "sky-gradient" ? this._updateColorRamp() : t2 !== "sky-atmosphere-sun" && t2 !== "sky-atmosphere-halo-color" && t2 !== "sky-atmosphere-color" && t2 !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = ec({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t2) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e2 = t2.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
          }
          return false;
        }
        getCenter(t2, e2) {
          if (this.paint.get("sky-type") === "atmosphere") {
            const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
            return n2 && i2.properties.get("anchor") === "viewport" && $("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? bd(s2.azimuthal, 90 - s2.polar, e2) : bd(r3[0], 90 - r3[1], e2);
          }
          const r2 = this.paint.get("sky-gradient-center");
          return bd(r2[0], 90 - r2[1], e2);
        }
        is3D() {
          return false;
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t2) {
          this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t2 = this.paint.get("sky-type");
          return t2 === "atmosphere" ? ["skyboxCapture", "skybox"] : t2 === "gradient" ? ["skyboxGradient"] : null;
        }
      } };
      class _d {
        constructor(t2, e2, r2, n2) {
          this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
        }
        update(t2, r2, n2) {
          const { width: i2, height: s2 } = t2, { context: a2 } = this, { gl: o2 } = a2, { HTMLImageElement: l2, HTMLCanvasElement: u2, HTMLVideoElement: c2, ImageData: h4, ImageBitmap: p2 } = e;
          if (o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!r2 || r2.premultiply !== false)), n2 || this.size && this.size[0] === i2 && this.size[1] === s2) {
            const { x: e2, y: r3 } = n2 || { x: 0, y: 0 };
            t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h4 || p2 && t2 instanceof p2 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, i2, s2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
          } else
            this.size = [i2, s2], t2 instanceof l2 || t2 instanceof u2 || t2 instanceof c2 || t2 instanceof h4 || p2 && t2 instanceof p2 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, i2, s2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
          this.useMipmap = Boolean(r2 && r2.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o2.generateMipmap(o2.TEXTURE_2D);
        }
        bind(t2, e2) {
          const { context: r2 } = this, { gl: n2 } = r2;
          n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === n2.NEAREST ? n2.NEAREST_MIPMAP_NEAREST : n2.LINEAR_MIPMAP_NEAREST : t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t2 } = this.context;
          t2.deleteTexture(this.texture), this.texture = null;
        }
      }
      class Ad {
        constructor(t2) {
          this._callback = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class Sd {
        constructor() {
          this.tasks = {}, this.taskQueue = [], V(["process"], this), this.invoker = new Ad(this.process), this.nextId = 0;
        }
        add(t2, e2) {
          const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
            return r3 = r3 || 0, t3 === "message" ? 0 : t3 !== "maybePrepare" || e3 ? t3 !== "parseTile" || e3 ? t3 === "parseTile" && e3 ? 300 - r3 : t3 === "maybePrepare" && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
          }(e2);
          if (n2 === 0) {
            N();
            try {
              t2();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r2];
          } };
        }
        process() {
          N();
          try {
            if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
              return;
            const t2 = this.pick();
            if (t2 === null)
              return;
            const e2 = this.tasks[t2];
            if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
              return;
            e2.fn();
          } finally {
          }
        }
        pick() {
          let t2 = null, e2 = 1 / 0;
          for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
            const n2 = this.tasks[this.taskQueue[r3]];
            n2.priority < e2 && (e2 = n2.priority, t2 = r3);
          }
          if (t2 === null)
            return null;
          const r2 = this.taskQueue[t2];
          return this.taskQueue.splice(t2, 1), r2;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class kd {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0; e2 < t2.length; e2++) {
            const r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          return this._numberToString[t2];
        }
      }
      const Id = ["tile", "layer", "source", "sourceLayer", "state"];
      class Md {
        constructor(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { type: "Feature", geometry: this.geometry, properties: this.properties };
          this.id !== void 0 && (t2.id = this.id);
          for (const e2 of Id)
            this[e2] !== void 0 && (t2[e2] = this[e2]);
          return t2;
        }
      }
      const Td = 32, zd = 33, Bd = new Uint16Array(8184);
      for (let t2 = 0; t2 < 2046; t2++) {
        let e2 = t2 + 2, r2 = 0, n2 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
        for (1 & e2 ? i2 = s2 = a2 = Td : r2 = n2 = o2 = Td; (e2 >>= 1) > 1; ) {
          const t3 = r2 + i2 >> 1, l3 = n2 + s2 >> 1;
          1 & e2 ? (i2 = r2, s2 = n2, r2 = a2, n2 = o2) : (r2 = i2, n2 = s2, i2 = a2, s2 = o2), a2 = t3, o2 = l3;
        }
        const l2 = 4 * t2;
        Bd[l2 + 0] = r2, Bd[l2 + 1] = n2, Bd[l2 + 2] = i2, Bd[l2 + 3] = s2;
      }
      const Ed = new Uint16Array(2178), Cd = new Uint8Array(1089), Pd = new Uint16Array(1089);
      function Dd(t2) {
        return t2 === 0 ? -0.03125 : t2 === 32 ? 0.03125 : 0;
      }
      var Vd = na([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const Ld = { type: 2, extent: ko, loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]] };
      class Fd {
        constructor(t2, e2, r2, n2, i2) {
          this.tileID = t2, this.uid = E(), this.uses = 0, this.tileSize = e2, this.tileZoom = r2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, this.expiredRequestCount = 0, this.state = "loading", n2 && n2.transform && (this.projection = n2.transform.projection);
        }
        registerFadeDuration(t2) {
          const e2 = t2 + this.timeAdded;
          e2 < Nt.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t2, e2, r2) {
          if (this.unloadVectorData(), this.state = "loaded", t2) {
            t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
              const r3 = {};
              if (!e3)
                return r3;
              for (const n2 of t3) {
                const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                if (t4.length !== 0) {
                  n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                  for (const e4 of t4)
                    r3[e4.id] = n2;
                }
              }
              return r3;
            }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const e3 = this.buckets[t3];
              if (e3 instanceof hd) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                e3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof hd && e3.hasRTLText) {
                  this.hasRTLText = true, js.isLoading() || js.isLoaded() || Fs() !== "deferred" || Rs();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const r3 = this.buckets[t3];
              this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r3));
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
          } else
            this.collisionBoxArray = new Ea();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(t2) {
          return this.buckets[t2.id];
        }
        upload(t2) {
          for (const e3 in this.buckets) {
            const r2 = this.buckets[e3];
            r2.uploadPending() && r2.upload(t2);
          }
          const e2 = t2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
        }
        prepare(t2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2, tileTransform: this.tileTransform }, t2, e2, r2) : {};
        }
        querySourceFeatures(t2, e2) {
          const r2 = this.latestFeatureIndex;
          if (!r2 || !r2.rawTileData)
            return;
          const n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
          if (!s2)
            return;
          const a2 = ai(e2 && e2.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
          for (let e3 = 0; e3 < s2.length; e3++) {
            const n3 = s2.feature(e3);
            if (a2.needGeometry) {
              const t3 = wu(n3, true);
              if (!a2.filter(new Us(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!a2.filter(new Us(this.tileID.overscaledZ), n3))
              continue;
            const h4 = r2.getId(n3, i2), p2 = new Md(n3, o2, l2, u2, h4);
            p2.tile = c2, t2.push(p2);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t2) {
          const e2 = this.expirationTime;
          if (t2.cacheControl) {
            const e3 = G(t2.cacheControl);
            e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let r2 = false;
            if (this.expirationTime > t3)
              r2 = false;
            else if (e2)
              if (this.expirationTime < e2)
                r2 = true;
              else {
                const n2 = this.expirationTime - e2;
                n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r2 = true;
              }
            else
              r2 = true;
            r2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t2, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0 || !e2)
            return;
          const r2 = this.latestFeatureIndex.loadVTLayers(), n2 = e2.style.listImages();
          for (const i2 in this.buckets) {
            if (!e2.style.hasLayer(i2))
              continue;
            const s2 = this.buckets[i2], a2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], l2 = t2[a2];
            if (!o2 || !l2 || Object.keys(l2).length === 0)
              continue;
            if (s2.update(l2, o2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}), s2 instanceof jh || s2 instanceof Uc) {
              const t3 = e2.style._getSourceCache(s2.layers[0].source);
              e2._terrain && e2._terrain.enabled && t3 && s2.programConfigurations.needsUpload && e2._terrain._clearRenderCacheForTile(t3.id, this.tileID);
            }
            const u2 = e2 && e2.style && e2.style.getLayer(i2);
            u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(s2)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t2) {
          this.symbolFadeHoldUntil = Nt.now() + t2;
        }
        setTexture(t2, e2) {
          const r2 = e2.context, n2 = r2.gl;
          this.texture = this.texture || e2.getTileTexture(t2.width), this.texture ? this.texture.update(t2, { useMipmap: true }) : (this.texture = new _d(r2, t2, n2.RGBA, { useMipmap: true }), this.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), r2.extTextureFilterAnisotropic && n2.texParameterf(n2.TEXTURE_2D, r2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r2.extTextureFilterAnisotropicMax));
        }
        setDependencies(t2, e2) {
          const r2 = {};
          for (const t3 of e2)
            r2[t3] = true;
          this.dependencies[t2] = r2;
        }
        hasDependency(t2, e2) {
          for (const r2 of t2) {
            const t3 = this.dependencies[r2];
            if (t3) {
              for (const r3 of e2)
                if (t3[r3])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t2, e2) {
          if (!e2 || e2.name === "mercator" || this._tileDebugBuffer)
            return;
          const r2 = bu(Ld, this.tileID.canonical, this.tileTransform)[0], n2 = new sa(), i2 = new Ta();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const { x: e3, y: s2 } = r2[t3];
            n2.emplaceBack(e3, s2), i2.emplaceBack(t3);
          }
          i2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(i2), this._tileDebugBuffer = t2.createVertexBuffer(n2, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n2.length, i2.length);
        }
        _makeTileBoundsBuffers(t2, e2) {
          if (this._tileBoundsBuffer || !e2 || e2.name === "mercator")
            return;
          const r2 = bu(Ld, this.tileID.canonical, this.tileTransform)[0];
          let n2, i2;
          if (this.isRaster) {
            const t3 = function(t4, e3) {
              const r3 = Vf(t4, e3), n3 = Math.pow(2, t4.z);
              for (let i4 = 0; i4 < zd; i4++)
                for (let s3 = 0; s3 < zd; s3++) {
                  const a3 = ou((t4.x + (s3 + Dd(s3)) / Td) / n3), o3 = lu((t4.y + (i4 + Dd(i4)) / Td) / n3), l3 = e3.project(a3, o3), u2 = i4 * zd + s3;
                  Ed[2 * u2 + 0] = Math.round((l3.x * r3.scale - r3.x) * ko), Ed[2 * u2 + 1] = Math.round((l3.y * r3.scale - r3.y) * ko);
                }
              Cd.fill(0), Pd.fill(0);
              for (let t5 = 2045; t5 >= 0; t5--) {
                const e4 = 4 * t5, r4 = Bd[e4 + 0], n4 = Bd[e4 + 1], i4 = Bd[e4 + 2], s3 = Bd[e4 + 3], a3 = r4 + i4 >> 1, o3 = n4 + s3 >> 1, l3 = a3 + o3 - n4, u2 = o3 + r4 - a3, c2 = n4 * zd + r4, h4 = s3 * zd + i4, p2 = o3 * zd + a3, f2 = Math.hypot((Ed[2 * c2 + 0] + Ed[2 * h4 + 0]) / 2 - Ed[2 * p2 + 0], (Ed[2 * c2 + 1] + Ed[2 * h4 + 1]) / 2 - Ed[2 * p2 + 1]) >= 16;
                if (Cd[p2] = Cd[p2] || (f2 ? 1 : 0), t5 < 1022) {
                  const t6 = (n4 + u2 >> 1) * zd + (r4 + l3 >> 1), e5 = (s3 + u2 >> 1) * zd + (i4 + l3 >> 1);
                  Cd[p2] = Cd[p2] || Cd[t6] || Cd[e5];
                }
              }
              const i3 = new oa(), s2 = new wa();
              let a2 = 0;
              function o2(t5, e4) {
                const r4 = e4 * zd + t5;
                return Pd[r4] === 0 && (i3.emplaceBack(Ed[2 * r4 + 0], Ed[2 * r4 + 1], t5 * ko / Td, e4 * ko / Td), Pd[r4] = ++a2), Pd[r4] - 1;
              }
              function l2(t5, e4, r4, n4, i4, a3) {
                const u2 = t5 + r4 >> 1, c2 = e4 + n4 >> 1;
                if (Math.abs(t5 - i4) + Math.abs(e4 - a3) > 1 && Cd[c2 * zd + u2])
                  l2(i4, a3, t5, e4, u2, c2), l2(r4, n4, i4, a3, u2, c2);
                else {
                  const l3 = o2(t5, e4), u3 = o2(r4, n4), c3 = o2(i4, a3);
                  s2.emplaceBack(l3, u3, c3);
                }
              }
              return l2(0, 0, Td, Td, Td, 0), l2(Td, Td, 0, 0, 0, Td), { vertices: i3, indices: s2 };
            }(this.tileID.canonical, e2);
            n2 = t3.vertices, i2 = t3.indices;
          } else {
            n2 = new oa(), i2 = new wa();
            for (const { x: t4, y: e3 } of r2)
              n2.emplaceBack(t4, e3, 0, 0);
            const t3 = sc(n2.int16, void 0, 4);
            for (let e3 = 0; e3 < t3.length; e3 += 3)
              i2.emplaceBack(t3[e3], t3[e3 + 1], t3[e3 + 2]);
          }
          this._tileBoundsBuffer = t2.createVertexBuffer(n2, Vd.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(i2), this._tileBoundsSegments = So.simpleSegment(0, 0, n2.length, i2.length);
        }
        _makeGlobeTileDebugBuffers(t2, e2) {
          const r2 = e2.projection;
          if (!r2 || r2.name !== "globe" || e2.freezeTileCoverage)
            return;
          const n2 = this.tileID.canonical, i2 = Gl(Vl(n2, e2)), s2 = Kl(e2.zoom);
          let a2;
          s2 > 0 && (a2 = Co(new Float64Array(16), e2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, n2, e2, i2, a2, s2), this._makeGlobeTileDebugTextBuffer(t2, n2, e2, i2, a2, s2);
        }
        _globePoint(t2, e2, r2, n2, i2, s2, a2) {
          let o2 = Ol(t2, e2, r2);
          if (s2) {
            const i3 = 1 << r2.z, l2 = iu(n2.center.lng), u2 = su(n2.center.lat), c2 = (r2.x + 0.5) / i3 - l2;
            let h4 = 0;
            c2 > 0.5 ? h4 = -1 : c2 < -0.5 && (h4 = 1);
            let p2 = (t2 / ko + r2.x) / i3 + h4, f2 = (e2 / ko + r2.y) / i3;
            p2 = (p2 - l2) * n2._pixelsPerMercatorPixel + l2, f2 = (f2 - u2) * n2._pixelsPerMercatorPixel + u2;
            const d2 = [p2 * n2.worldSize, f2 * n2.worldSize, 0];
            el(d2, d2, s2), o2 = Dl(o2, d2, a2);
          }
          return el(o2, o2, i2);
        }
        _makeGlobeTileDebugBorderBuffer(t2, e2, r2, n2, i2, s2) {
          const a2 = new sa(), o2 = new Ta(), l2 = new aa(), u2 = (t3, u3, c3, h4, p2) => {
            const f2 = (c3 - t3) / (p2 - 1), d2 = (h4 - u3) / (p2 - 1), y2 = a2.length;
            for (let c4 = 0; c4 < p2; c4++) {
              const h5 = t3 + c4 * f2, p3 = u3 + c4 * d2;
              a2.emplaceBack(h5, p3);
              const m2 = this._globePoint(h5, p3, e2, r2, n2, i2, s2);
              l2.emplaceBack(m2[0], m2[1], m2[2]), o2.emplaceBack(y2 + c4);
            }
          }, c2 = ko;
          u2(0, 0, c2, 0, 16), u2(c2, 0, c2, c2, 16), u2(c2, c2, 0, c2, 16), u2(0, c2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a2.length, o2.length);
        }
        _makeGlobeTileDebugTextBuffer(t2, e2, r2, n2, i2, s2) {
          const a2 = new sa(), o2 = new wa(), l2 = new aa(), u2 = 25;
          o2.reserve(32), a2.reserve(u2), l2.reserve(u2);
          const c2 = (t3, e3) => u2 * t3 + e3;
          for (let t3 = 0; t3 < u2; t3++) {
            const o3 = 2048 * t3;
            for (let t4 = 0; t4 < u2; t4++) {
              const u3 = 2048 * t4;
              a2.emplaceBack(u3, o3);
              const c3 = this._globePoint(u3, o3, e2, r2, n2, i2, s2);
              l2.emplaceBack(c3[0], c3[1], c3[2]);
            }
          }
          for (let t3 = 0; t3 < 4; t3++)
            for (let e3 = 0; e3 < 4; e3++) {
              const r3 = c2(t3, e3), n3 = c2(t3, e3 + 1), i3 = c2(t3 + 1, e3), s3 = c2(t3 + 1, e3 + 1);
              o2.emplaceBack(r3, n3, i3), o2.emplaceBack(i3, n3, s3);
            }
          this._tileDebugTextIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugTextBuffer = t2.createVertexBuffer(a2, xl.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(l2, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u2, 32);
        }
      }
      class Rd {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t2, e2, r2) {
          const n2 = String(e2);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, z(this.stateChanges[t2][n2], r2), this.deletedStates[t2] === null) {
            this.deletedStates[t2] = {};
            for (const e3 in this.state[t2])
              e3 !== n2 && (this.deletedStates[t2][e3] = null);
          } else if (this.deletedStates[t2] && this.deletedStates[t2][n2] === null) {
            this.deletedStates[t2][n2] = {};
            for (const e3 in this.state[t2][n2])
              r2[e3] || (this.deletedStates[t2][n2][e3] = null);
          } else
            for (const e3 in r2)
              this.deletedStates[t2] && this.deletedStates[t2][n2] && this.deletedStates[t2][n2][e3] === null && delete this.deletedStates[t2][n2][e3];
        }
        removeFeatureState(t2, e2, r2) {
          if (this.deletedStates[t2] === null)
            return;
          const n2 = String(e2);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && e2 !== void 0)
            this.deletedStates[t2][n2] !== null && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
          else if (e2 !== void 0)
            if (this.stateChanges[t2] && this.stateChanges[t2][n2])
              for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                this.deletedStates[t2][n2][r2] = null;
            else
              this.deletedStates[t2][n2] = null;
          else
            this.deletedStates[t2] = null;
        }
        getState(t2, e2) {
          const r2 = String(e2), n2 = z({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
          if (this.deletedStates[t2] === null)
            return {};
          if (this.deletedStates[t2]) {
            const r3 = this.deletedStates[t2][e2];
            if (r3 === null)
              return {};
            for (const t3 in r3)
              delete n2[t3];
          }
          return n2;
        }
        initializeTileState(t2, e2) {
          t2.setFeatureState(this.state, e2);
        }
        coalesceChanges(t2, e2) {
          const r2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            for (const r3 in this.stateChanges[t3])
              this.state[t3][r3] || (this.state[t3][r3] = {}), z(this.state[t3][r3], this.stateChanges[t3][r3]), e3[r3] = this.state[t3][r3];
            r2[t3] = e3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            if (this.deletedStates[t3] === null)
              for (const r3 in this.state[t3])
                e3[r3] = {}, this.state[t3][r3] = {};
            else
              for (const r3 in this.deletedStates[t3]) {
                if (this.deletedStates[t3][r3] === null)
                  this.state[t3][r3] = {};
                else if (this.state[t3][r3])
                  for (const e4 of Object.keys(this.deletedStates[t3][r3]))
                    delete this.state[t3][r3][e4];
                e3[r3] = this.state[t3][r3];
              }
            r2[t3] = r2[t3] || {}, z(r2[t3], e3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r2).length !== 0)
            for (const n2 in t2)
              t2[n2].setFeatureState(r2, e2);
        }
      }
      class jd {
        constructor(t2) {
          this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t2, e2) {
          const r2 = this.toIdx(t2, e2);
          return { min: this.minimums[r2], max: this.maximums[r2] };
        }
        isLeaf(t2, e2) {
          return this.leaves[this.toIdx(t2, e2)];
        }
        toIdx(t2, e2) {
          return e2 * this.size + t2;
        }
      }
      function Ud(t2, e2, r2, n2) {
        let i2 = 0, s2 = Number.MAX_VALUE;
        for (let a2 = 0; a2 < 3; a2++)
          if (Math.abs(n2[a2]) < 1e-15) {
            if (r2[a2] < t2[a2] || r2[a2] > e2[a2])
              return null;
          } else {
            const o2 = 1 / n2[a2];
            let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e2[a2] - r2[a2]) * o2;
            if (l2 > u2) {
              const t3 = l2;
              l2 = u2, u2 = t3;
            }
            if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
              return null;
          }
        return i2;
      }
      function $d(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
        const h4 = n2 - t2, p2 = i2 - e2, f2 = s2 - r2, d2 = a2 - t2, y2 = o2 - e2, m2 = l2 - r2, g2 = c2[1] * m2 - c2[2] * y2, x2 = c2[2] * d2 - c2[0] * m2, v3 = c2[0] * y2 - c2[1] * d2, b2 = h4 * g2 + p2 * x2 + f2 * v3;
        if (Math.abs(b2) < 1e-15)
          return null;
        const w2 = 1 / b2, _2 = u2[0] - t2, A2 = u2[1] - e2, S2 = u2[2] - r2, k2 = (_2 * g2 + A2 * x2 + S2 * v3) * w2;
        if (k2 < 0 || k2 > 1)
          return null;
        const I2 = A2 * f2 - S2 * p2, M2 = S2 * h4 - _2 * f2, T2 = _2 * p2 - A2 * h4, z2 = (c2[0] * I2 + c2[1] * M2 + c2[2] * T2) * w2;
        return z2 < 0 || k2 + z2 > 1 ? null : (d2 * I2 + y2 * M2 + m2 * T2) * w2;
      }
      function Od(t2, e2, r2) {
        return (t2 - e2) / (r2 - e2);
      }
      function qd(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = 1 << r2, c2 = s2 - n2, h4 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, f2 = (e2 + 0) / u2 * h4 + i2, d2 = (e2 + 1) / u2 * h4 + i2;
        o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = f2, l2[0] = p2, l2[1] = d2;
      }
      class Nd {
        constructor(t2) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const e2 = function(t3) {
            const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
            let n3 = Math.ceil(Math.pow(2, e3));
            const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
              const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
              i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
            };
            let a2 = new jd(n3);
            const o2 = [];
            for (let e4 = 0; e4 < n3 * n3; e4++) {
              s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
              const r4 = Xd(o2[0], o2[1], t3), l2 = Xd(o2[2], o2[1], t3), u2 = Xd(o2[2], o2[3], t3), c2 = Xd(o2[0], o2[3], t3);
              a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
            }
            for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
              const t4 = r3[r3.length - 1];
              a2 = new jd(n3);
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h4 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), f2 = t4.isLeaf(o2[0], o2[3]), d2 = Math.min(r4.min, i3.min, l2.min, u2.min), y2 = Math.max(r4.max, i3.max, l2.max, u2.max), m2 = c2 && h4 && p2 && f2;
                a2.maximums.push(y2), a2.minimums.push(d2), a2.leaves.push(y2 - d2 <= 5 && m2 ? 1 : 0);
              }
              r3.push(a2);
            }
            return r3;
          }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
          this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
        }
        raycastRoot(t2, e2, r2, n2, i2, s2, a2 = 1) {
          return Ud([t2, e2, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
        }
        raycast(t2, e2, r2, n2, i2, s2, a2 = 1) {
          if (!this.nodeCount)
            return null;
          const o2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, a2);
          if (o2 == null)
            return null;
          const l2 = [], u2 = [], c2 = [], h4 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
          for (; p2.length > 0; ) {
            const { idx: o3, t: f2, nodex: d2, nodey: y2, depth: m2 } = p2.pop();
            if (this.leaves[o3]) {
              qd(d2, y2, m2, t2, e2, r2, n2, c2, h4);
              const o4 = 1 << m2, l3 = (d2 + 0) / o4, u3 = (d2 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x2 = Xd(l3, p3, this.dem) * a2, v3 = Xd(u3, p3, this.dem) * a2, b2 = Xd(u3, g3, this.dem) * a2, w2 = Xd(l3, g3, this.dem) * a2, _2 = $d(c2[0], c2[1], x2, h4[0], c2[1], v3, h4[0], h4[1], b2, i2, s2), A2 = $d(h4[0], h4[1], b2, c2[0], h4[1], w2, c2[0], c2[1], x2, i2, s2), S2 = Math.min(_2 !== null ? _2 : Number.MAX_VALUE, A2 !== null ? A2 : Number.MAX_VALUE);
              if (S2 !== Number.MAX_VALUE)
                return S2;
              {
                const t3 = Wo([], i2, s2, f2);
                if (Gd(x2, v3, w2, b2, Od(t3[0], c2[0], h4[0]), Od(t3[1], c2[1], h4[1])) >= t3[2])
                  return f2;
              }
              continue;
            }
            let g2 = 0;
            for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
              qd((d2 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m2 + 1, t2, e2, r2, n2, c2, h4), c2[2] = -100, h4[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
              const f3 = Ud(c2, h4, i2, s2);
              if (f3 != null) {
                const t3 = f3;
                l2[p3] = t3;
                let e3 = false;
                for (let r3 = 0; r3 < g2 && !e3; r3++)
                  t3 >= l2[u2[r3]] && (u2.splice(r3, 0, p3), e3 = true);
                e3 || (u2[g2] = p3), g2++;
              }
            }
            for (let t3 = 0; t3 < g2; t3++) {
              const e3 = u2[t3];
              p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m2 + 1 });
            }
          }
          return null;
        }
        _addNode(t2, e2, r2) {
          return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t2, e2, r2, n2, i2) {
          if (t2[n2].isLeaf(e2, r2) === 1)
            return;
          this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
          const s2 = n2 - 1, a2 = t2[s2];
          let o2 = 0, l2 = 0;
          for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
            const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
            u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
          }
          for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
            o2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
        }
      }
      function Gd(t2, e2, r2, n2, i2, s2) {
        return Mr(Mr(t2, r2, s2), Mr(e2, n2, s2), i2);
      }
      function Xd(t2, e2, r2) {
        const n2 = r2.dim, i2 = S(t2 * n2 - 0.5, 0, n2 - 1), s2 = S(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
        return Gd(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
      }
      const Zd = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      class Kd {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t2, e2, r2, n2 = false, i2 = false) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && r2 !== "mapbox" && r2 !== "terrarium")
            return $(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = e2.height;
          const s2 = this.dim = e2.height - 2, a2 = new Uint32Array(e2.data.buffer);
          if (this.pixels = new Uint8Array(e2.data.buffer), this.encoding = r2 || "mapbox", this.borderReady = n2, !n2) {
            for (let t3 = 0; t3 < s2; t3++)
              a2[this._idx(-1, t3)] = a2[this._idx(0, t3)], a2[this._idx(s2, t3)] = a2[this._idx(s2 - 1, t3)], a2[this._idx(t3, -1)] = a2[this._idx(t3, 0)], a2[this._idx(t3, s2)] = a2[this._idx(t3, s2 - 1)];
            a2[this._idx(-1, -1)] = a2[this._idx(0, 0)], a2[this._idx(s2, -1)] = a2[this._idx(s2 - 1, 0)], a2[this._idx(-1, s2)] = a2[this._idx(0, s2 - 1)], a2[this._idx(s2, s2)] = a2[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
          }
        }
        _buildQuadTree() {
          this._tree = new Nd(this);
        }
        get(t2, e2, r2 = false) {
          r2 && (t2 = S(t2, -1, this.dim), e2 = S(e2, -1, this.dim));
          const n2 = 4 * this._idx(t2, e2);
          return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n2], this.pixels[n2 + 1], this.pixels[n2 + 2]);
        }
        static getUnpackVector(t2) {
          return Zd[t2];
        }
        get unpackVector() {
          return Zd[this.encoding];
        }
        _idx(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }
        _unpackMapbox(t2, e2, r2) {
          return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }
        _unpackTerrarium(t2, e2, r2) {
          return 256 * t2 + e2 + r2 / 256 - 32768;
        }
        static pack(t2, e2) {
          const r2 = [0, 0, 0, 0], n2 = Kd.getUnpackVector(e2);
          let i2 = Math.floor((t2 + n2[3]) / n2[2]);
          return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
        }
        getPixels() {
          return new Qu({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
          for (let e3 = s2; e3 < a2; e3++)
            for (let r3 = n2; r3 < i2; r3++) {
              const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l2);
              this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      Oi(Kd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", { omit: ["dem"] });
      class Yd {
        constructor(t2, e2) {
          this.max = t2, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t2 in this.data)
            for (const e2 of this.data[t2])
              e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t2, e2, r2) {
          const n2 = t2.wrapped().key;
          this.data[n2] === void 0 && (this.data[n2] = []);
          const i2 = { value: e2, timeout: void 0 };
          if (r2 !== void 0 && (i2.timeout = setTimeout(() => {
            this.remove(t2, i2);
          }, r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        has(t2) {
          return t2.wrapped().key in this.data;
        }
        getAndRemove(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }
        _getAndRemoveByKey(t2) {
          const e2 = this.data[t2].shift();
          return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
        }
        getByKey(t2) {
          const e2 = this.data[t2];
          return e2 ? e2[0].value : null;
        }
        get(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }
        remove(t2, e2) {
          if (!this.has(t2))
            return this;
          const r2 = t2.wrapped().key, n2 = e2 === void 0 ? 0 : this.data[r2].indexOf(e2), i2 = this.data[r2][n2];
          return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), this.data[r2].length === 0 && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
        }
        setMaxSize(t2) {
          for (this.max = t2; this.order.length > this.max; ) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        filter(t2) {
          const e2 = [];
          for (const r2 in this.data)
            for (const n2 of this.data[r2])
              t2(n2.value) || e2.push(n2);
          for (const t3 of e2)
            this.remove(t3.value.tileID, t3);
        }
      }
      class Hd {
        constructor(t2, e2, r2) {
          this.func = t2, this.mask = e2, this.range = r2;
        }
      }
      Hd.ReadOnly = false, Hd.ReadWrite = true, Hd.disabled = new Hd(519, Hd.ReadOnly, [0, 1]);
      const Wd = 7680;
      class Jd {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.test = t2, this.ref = e2, this.mask = r2, this.fail = n2, this.depthFail = i2, this.pass = s2;
        }
      }
      Jd.disabled = new Jd({ func: 519, mask: 0 }, 0, 0, Wd, Wd, Wd);
      class Qd {
        constructor(t2, e2, r2) {
          this.blendFunction = t2, this.blendColor = e2, this.mask = r2;
        }
      }
      Qd.Replace = [1, 0], Qd.disabled = new Qd(Qd.Replace, Me.transparent, [false, false, false, false]), Qd.unblended = new Qd(Qd.Replace, Me.transparent, [true, true, true, true]), Qd.alphaBlended = new Qd([1, 771], Me.transparent, [true, true, true, true]);
      const ty = 1029, ey = 2305;
      class ry {
        constructor(t2, e2, r2) {
          this.enable = t2, this.mode = e2, this.frontFace = r2;
        }
      }
      ry.disabled = new ry(false, ty, ey), ry.backCCW = new ry(true, ty, ey), ry.backCW = new ry(true, ty, 2304), ry.frontCW = new ry(true, 1028, 2304), ry.frontCCW = new ry(true, 1028, ey);
      class ny extends Yt {
        constructor(t2, e2, r2) {
          super(), this.id = t2, this._onlySymbols = r2, e2.on("data", (t3) => {
            t3.dataType === "source" && t3.sourceDataType === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t3.dataType === "source" && t3.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
          }), e2.on("error", () => {
            this._sourceErrored = true;
          }), this._source = e2, this._tiles = {}, this._cache = new Yd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e2.minTileCacheSize, this._maxTileCacheSize = e2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "custom" && this._source._dataType === "raster";
        }
        onAdd(t2) {
          this.map = t2, this._minTileCacheSize = this._minTileCacheSize === void 0 && t2 ? t2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t2 ? t2._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2];
            if (e2.state !== "loaded" && e2.state !== "errored")
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t2, e2) {
          return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
        }
        _unloadTile(t2) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t2, () => {
            });
        }
        _abortTile(t2) {
          if (this._source.abortTile)
            return this._source.abortTile(t2, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e2 in this._tiles) {
            const r2 = this._tiles[e2];
            r2.upload(t2), r2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return T(this._tiles).map((t2) => t2.tileID).sort(iy).map((t2) => t2.key);
        }
        getRenderableIds(t2) {
          const e2 = [];
          for (const r2 in this._tiles)
            this._isIdRenderable(+r2, t2) && e2.push(this._tiles[r2]);
          return t2 ? e2.sort((t3, e3) => {
            const r2 = t3.tileID, n2 = e3.tileID, i2 = new d(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle), s2 = new d(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
            return r2.overscaledZ - n2.overscaledZ || s2.y - i2.y || s2.x - i2.x;
          }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(iy).map((t3) => t3.key);
        }
        hasRenderableParent(t2) {
          const e2 = this.findLoadedParent(t2, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t2, e2) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              this._tiles[t2].state !== "errored" && this._reloadTile(+t2, "reloading");
          }
        }
        _reloadTile(t2, e2) {
          const r2 = this._tiles[t2];
          r2 && (r2.state !== "loading" && (r2.state = e2), this._loadTile(r2, this._tileLoaded.bind(this, r2, t2, e2)));
        }
        _tileLoaded(t2, e2, r2, n2) {
          if (n2)
            if (t2.state = "errored", n2.status !== 404)
              this._source.fire(new Kt(n2, { tile: t2 }));
            else if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
              const t3 = this.map.painter.terrain;
              this.update(this.transform, t3.getScaledDemTileSize(), true), t3.resetTileLookupCache(this.id);
            } else
              this.update(this.transform);
          else
            t2.timeAdded = Nt.now(), r2 === "expired" && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), this._source.type === "raster-dem" && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Zt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t2) {
          const e2 = this.getRenderableIds();
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
              const e3 = this.getTileByID(i2);
              r2(t2, e3), r2(e3, t2);
            }
          }
          function r2(t3, e3) {
            if (!t3.dem || t3.dem.borderReady)
              return;
            t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
            let r3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
            const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
            r3 === 0 && n2 === 0 || Math.abs(n2) > 1 || (Math.abs(r3) > 1 && (Math.abs(r3 + i2) === 1 ? r3 += i2 : Math.abs(r3 - i2) === 1 && (r3 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r3, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
          }
        }
        getTile(t2) {
          return this.getTileByID(t2.key);
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        _retainLoadedChildren(t2, e2, r2, n2) {
          for (const i2 in this._tiles) {
            let s2 = this._tiles[i2];
            if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r2)
              continue;
            let a2 = s2.tileID;
            for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
              const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
              s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
            }
            let o2 = a2;
            for (; o2.overscaledZ > e2; )
              if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                n2[a2.key] = a2;
                break;
              }
          }
        }
        findLoadedParent(t2, e2) {
          if (t2.key in this._loadedParentTiles) {
            const r2 = this._loadedParentTiles[t2.key];
            return r2 && r2.tileID.overscaledZ >= e2 ? r2 : null;
          }
          for (let r2 = t2.overscaledZ - 1; r2 >= e2; r2--) {
            const e3 = t2.scaledTo(r2), n2 = this._getLoadedTile(e3);
            if (n2)
              return n2;
          }
        }
        _getLoadedTile(t2) {
          const e2 = this._tiles[t2.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
        }
        updateCacheSize(t2, e2) {
          e2 = e2 || this._source.tileSize;
          const r2 = Math.ceil(t2.width / e2) + 1, n2 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r2 * n2 * 5), s2 = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, i2) : i2, a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(a2);
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - (this._prevLng === void 0 ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e2) {
            const t3 = {};
            for (const r2 in this._tiles) {
              const n2 = this._tiles[r2];
              n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), t3[n2.tileID.key] = n2;
            }
            this._tiles = t3;
            for (const t4 in this._timers)
              clearTimeout(this._timers[t4]), delete this._timers[t4];
            for (const t4 in this._tiles)
              this._setTileReloadTimer(+t4, this._tiles[t4]);
          }
        }
        update(t2, e2, r2) {
          if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !r2)
            return;
          let n2;
          this.updateCacheSize(t2, e2), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Mh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n2 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t3) => this._source.hasTile(t3)))) : n2 = [];
          const i2 = this._updateRetainedTiles(n2);
          if (sy(this._source.type) && n2.length !== 0) {
            const t3 = {}, e3 = {}, r3 = Object.keys(i2);
            for (const n3 of r3) {
              const r4 = i2[n3], s4 = this._tiles[n3];
              if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= Nt.now())
                continue;
              const a2 = this.findLoadedParent(r4, Math.max(r4.overscaledZ - ny.maxOverzooming, this._source.minzoom));
              a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n3] = r4;
            }
            const s3 = n2[n2.length - 1].overscaledZ;
            for (const t4 in this._tiles) {
              const r4 = this._tiles[t4];
              if (i2[t4] || !r4.hasData())
                continue;
              let n3 = r4.tileID;
              for (; n3.overscaledZ > s3; ) {
                n3 = n3.scaledTo(n3.overscaledZ - 1);
                const s4 = this._tiles[n3.key];
                if (s4 && s4.hasData() && e3[n3.key]) {
                  i2[t4] = r4.tileID;
                  break;
                }
              }
            }
            for (const e4 in t3)
              i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
          }
          for (const t3 in i2)
            this._tiles[t3].clearFadeHold();
          const s2 = function(t3, e3) {
            const r3 = [];
            for (const n3 in t3)
              n3 in e3 || r3.push(n3);
            return r3;
          }(this._tiles, i2);
          for (const t3 of s2) {
            const e3 = this._tiles[t3];
            e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(+t2);
        }
        _updateRetainedTiles(t2) {
          const e2 = {};
          if (t2.length === 0)
            return e2;
          const r2 = {}, n2 = t2.reduce((t3, e3) => Math.min(t3, e3.overscaledZ), 1 / 0), i2 = t2[0].overscaledZ, s2 = Math.max(i2 - ny.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + ny.maxUnderzooming, this._source.minzoom), o2 = {};
          for (const r3 of t2) {
            const t3 = this._addTile(r3);
            e2[r3.key] = r3, t3.hasData() || n2 < this._source.maxzoom && (o2[r3.key] = r3);
          }
          this._retainLoadedChildren(o2, n2, a2, e2);
          for (const n3 of t2) {
            let t3 = this._tiles[n3.key];
            if (t3.hasData())
              continue;
            if (n3.canonical.z >= this._source.maxzoom) {
              const t4 = n3.children(this._source.maxzoom)[0], r3 = this.getTile(t4);
              if (r3 && r3.hasData()) {
                e2[t4.key] = t4;
                continue;
              }
            } else {
              const t4 = n3.children(this._source.maxzoom);
              if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key])
                continue;
            }
            let i3 = t3.wasRequested();
            for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
              const s3 = n3.scaledTo(a3);
              if (r2[s3.key])
                break;
              if (r2[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e2[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData()))
                break;
            }
          }
          return e2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t2 in this._tiles) {
            const e2 = [];
            let r2, n2 = this._tiles[t2].tileID;
            for (; n2.overscaledZ > 0; ) {
              if (n2.key in this._loadedParentTiles) {
                r2 = this._loadedParentTiles[n2.key];
                break;
              }
              e2.push(n2.key);
              const t3 = n2.scaledTo(n2.overscaledZ - 1);
              if (r2 = this._getLoadedTile(t3), r2)
                break;
              n2 = t3;
            }
            for (const t3 of e2)
              this._loadedParentTiles[t3] = r2;
          }
        }
        _addTile(t2) {
          let e2 = this._tiles[t2.key];
          if (e2)
            return e2;
          e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
          const r2 = Boolean(e2);
          if (!r2) {
            const r3 = this.map ? this.map.painter : null;
            e2 = new Fd(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom, r3, this._isRaster), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state));
          }
          return e2 ? (e2.uses++, this._tiles[t2.key] = e2, r2 || this._source.fire(new Zt("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
        }
        _setTileReloadTimer(t2, e2) {
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          const r2 = e2.getExpiryTimeout();
          r2 && (this._timers[t2] = setTimeout(() => {
            this._reloadTile(t2, "expired"), delete this._timers[t2];
          }, r2));
        }
        _removeTile(t2) {
          const e2 = this._tiles[t2];
          e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t2 in this._tiles)
            this._removeTile(+t2);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t2, e2, r2) {
          const n2 = [], i2 = this.transform;
          if (!i2)
            return n2;
          const s2 = i2.projection.name === "globe", a2 = iu(i2.center.lng);
          for (const o2 in this._tiles) {
            const l2 = this._tiles[o2];
            if (r2 && l2.clearQueryDebugViz(), l2.holdingForFade())
              continue;
            let u2;
            if (s2) {
              const t3 = l2.tileID.canonical;
              if (t3.z === 0) {
                const e3 = [Math.abs(S(a2, ...ay(t3, -1)) - a2), Math.abs(S(a2, ...ay(t3, 1)) - a2)];
                u2 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
              } else {
                const e3 = [Math.abs(S(a2, ...ay(t3, -1)) - a2), Math.abs(S(a2, ...ay(t3, 0)) - a2), Math.abs(S(a2, ...ay(t3, 1)) - a2)];
                u2 = [e3.indexOf(Math.min(...e3)) - 1];
              }
            } else
              u2 = [0];
            for (const r3 of u2) {
              const s3 = t2.containsTile(l2, i2, e2, r3);
              s3 && n2.push(s3);
            }
          }
          return n2;
        }
        getVisibleCoordinates(t2) {
          const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
          for (const t3 of e2)
            t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (sy(this._source.type))
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if (e2.fadeEndTime !== void 0 && e2.fadeEndTime >= Nt.now())
                return true;
            }
          return false;
        }
        setFeatureState(t2, e2, r2) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r2);
        }
        removeFeatureState(t2, e2, r2) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r2);
        }
        getFeatureState(t2, e2) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
        }
        setDependencies(t2, e2, r2) {
          const n2 = this._tiles[t2];
          n2 && n2.setDependencies(e2, r2);
        }
        reloadTilesForDependencies(t2, e2) {
          for (const r2 in this._tiles)
            this._tiles[r2].hasDependency(t2, e2) && this._reloadTile(+r2, "reloading");
          this._cache.filter((r2) => !r2.hasDependency(t2, e2));
        }
        _preloadTiles(t2, e2) {
          const r2 = /* @__PURE__ */ new Map(), n2 = Array.isArray(t2) ? t2 : [t2], i2 = this.map.painter.terrain, s2 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
          for (const t3 of n2) {
            const e3 = t3.coveringTiles({ tileSize: s2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const t4 of e3)
              r2.set(t4.key, t4);
            this.usedForTerrain && t3.updateElevation(false);
          }
          M(Array.from(r2.values()), (t3, e3) => {
            const r3 = new Fd(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(r3, (t4) => {
              this._source.type === "raster-dem" && r3.dem && this._backfillDEM(r3), e3(t4, r3);
            });
          }, e2);
        }
      }
      function iy(t2, e2) {
        const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t2.overscaledZ - e2.overscaledZ || n2 - r2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
      }
      function sy(t2) {
        return t2 === "raster" || t2 === "image" || t2 === "video" || t2 === "custom";
      }
      function ay(t2, e2) {
        const r2 = 1 << t2.z;
        return [t2.x / r2 + e2, (t2.x + 1) / r2 + e2];
      }
      ny.maxOverzooming = 10, ny.maxUnderzooming = 3;
      class oy {
        constructor(t2, e2, r2) {
          this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
        }
        static create(t2, e2, r2) {
          const n2 = r2 || t2.findDEMTileFor(e2);
          if (!n2 || !n2.dem)
            return;
          const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
          return new oy(n2, n2.tileSize / ko / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
        }
        tileCoordToPixel(t2, e2) {
          const r2 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
          return new d(n2, i2);
        }
        getElevationAt(t2, e2, r2, n2) {
          const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
          return n2 = !!n2, r2 ? Mr(Mr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), Mr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
        }
        getElevationAtPixel(t2, e2, r2) {
          return this._dem.get(t2, e2, !!r2);
        }
        getMeterToDEM(t2) {
          return (1 << this._demTile.tileID.canonical.z) * au(1, t2) * this._dem.stride;
        }
      }
      class ly {
        constructor(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja(), this.promoteId = e2;
        }
        insert(t2, e2, r2, n2, i2, s2 = 0) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
          const o2 = this.grid;
          for (let t3 = 0; t3 < e2.length; t3++) {
            const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0; t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < ko && n3[1] < ko && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const t2 in this.vtLayers)
              this.vtFeatures[t2] = [];
          }
          return this.vtLayers;
        }
        query(t2, e2, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params || {}, s2 = ai(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r3, n3) => Vu(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
          u2.sort(cy);
          let c2 = null;
          o2.elevation && u2.length > 0 && (c2 = oy.create(o2.elevation, this.tileID));
          const h4 = {};
          let p2;
          for (let o3 = 0; o3 < u2.length; o3++) {
            const l3 = u2[o3];
            if (l3 === p2)
              continue;
            p2 = l3;
            const f2 = this.featureIndexArray.get(l3);
            let d2 = null;
            this.loadMatchingFeature(h4, f2, s2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3, i3 = 0) => (d2 || (d2 = bu(e3, this.tileID.canonical, t2.tileTransform)), r3.queryIntersectsFeature(a2, e3, n3, d2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
          }
          return h4;
        }
        loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h4, layoutVertexArrayOffset: p2 } = e2, f2 = this.bucketLayerIDs[c2];
          if (n2 && !function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(n2, f2))
            return;
          const d2 = this.sourceLayerCoder.decode(h4), y2 = this.vtLayers[d2].feature(u2);
          if (r2.needGeometry) {
            const t3 = wu(y2, true);
            if (!r2.filter(new Us(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!r2.filter(new Us(this.tileID.overscaledZ), y2))
            return;
          const m2 = this.getId(y2, d2);
          for (let e3 = 0; e3 < f2.length; e3++) {
            const r3 = f2[e3];
            if (n2 && n2.indexOf(r3) < 0)
              continue;
            const c3 = s2[r3];
            if (!c3)
              continue;
            let h5 = {};
            m2 !== void 0 && o2 && (h5 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m2));
            const d3 = z({}, a2[r3]);
            d3.paint = uy(d3.paint, c3.paint, y2, h5, i2), d3.layout = uy(d3.layout, c3.layout, y2, h5, i2);
            const g2 = !l2 || l2(y2, c3, h5, p2);
            if (!g2)
              continue;
            const x2 = new Md(y2, this.z, this.x, this.y, m2);
            x2.layer = d3;
            let v3 = t2[r3];
            v3 === void 0 && (v3 = t2[r3] = []), v3.push({ featureIndex: u2, feature: x2, intersectionZ: g2 });
          }
        }
        lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = {};
          this.loadVTLayers();
          const u2 = ai(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l2, { bucketIndex: r2, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
          return l2;
        }
        loadFeature(t2) {
          const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
          this.loadVTLayers();
          const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
          if (i2[e2])
            return i2[e2];
          const s2 = this.vtLayers[n2].feature(e2);
          return i2[e2] = s2, s2;
        }
        hasLayer(t2) {
          for (const e2 of this.bucketLayerIDs)
            for (const r2 of e2)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e2) {
          let r2 = t2.id;
          if (this.promoteId) {
            const n2 = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2];
            n2 != null && (r2 = t2.properties[n2]), typeof r2 == "boolean" && (r2 = Number(r2));
          }
          return r2;
        }
      }
      function uy(t2, e2, r2, n2, i2) {
        return F(t2, (t3, s2) => {
          const a2 = e2 instanceof Ks ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function cy(t2, e2) {
        return e2 - t2;
      }
      Oi(ly, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      class hy {
        constructor(t2, e2) {
          this.width = t2, this.height = e2, this.nextRow = 0, this.image = new Ju({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t2, e2) {
          const r2 = this.getKey(t2, e2);
          return this.positions[r2];
        }
        trim() {
          const t2 = this.width, e2 = this.height = P(this.nextRow);
          this.image.resize({ width: t2, height: e2 });
        }
        getKey(t2, e2) {
          return t2.join(",") + e2;
        }
        getDashRanges(t2, e2, r2) {
          const n2 = [];
          let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
          n2.push({ left: i2, right: s2, isDash: a2, zeroLength: t2[0] === 0 });
          let o2 = t2[0];
          for (let e3 = 1; e3 < t2.length; e3++) {
            a2 = !a2;
            const l2 = t2[e3];
            i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: l2 === 0 });
          }
          return n2;
        }
        addRoundDash(t2, e2, r2) {
          const n2 = e2 / 2;
          for (let e3 = -r2; e3 <= r2; e3++) {
            const i2 = this.width * (this.nextRow + r2 + e3);
            let s2 = 0, a2 = t2[s2];
            for (let o2 = 0; o2 < this.width; o2++) {
              o2 / a2.right > 1 && (a2 = t2[++s2]);
              const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
              let h4;
              const p2 = e3 / r2 * (n2 + 1);
              if (a2.isDash) {
                const t3 = n2 - Math.abs(p2);
                h4 = Math.sqrt(c2 * c2 + t3 * t3);
              } else
                h4 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
              this.image.data[i2 + o2] = Math.max(0, Math.min(255, h4 + 128));
            }
          }
        }
        addRegularDash(t2, e2) {
          for (let e3 = t2.length - 1; e3 >= 0; --e3) {
            const r3 = t2[e3], n3 = t2[e3 + 1];
            r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
          }
          const r2 = t2[0], n2 = t2[t2.length - 1];
          r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
          const i2 = this.width * this.nextRow;
          let s2 = 0, a2 = t2[s2];
          for (let r3 = 0; r3 < this.width; r3++) {
            r3 / a2.right > 1 && (a2 = t2[++s2]);
            const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
            this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
          }
        }
        addDash(t2, e2) {
          const r2 = this.getKey(t2, e2);
          if (this.positions[r2])
            return this.positions[r2];
          const n2 = e2 === "round", i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
          if (this.nextRow + s2 > this.height)
            return $("LineAtlas out of space"), null;
          t2.length === 0 && t2.push(1);
          let a2 = 0;
          for (let e3 = 0; e3 < t2.length; e3++)
            t2[e3] < 0 && ($("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
          if (a2 !== 0) {
            const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
            n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, e2 === "square" ? 0.5 * r3 : 0);
          }
          const o2 = this.nextRow + i2;
          this.nextRow += s2;
          const l2 = { tl: [o2, i2], br: [a2, 0] };
          return this.positions[r2] = l2, l2;
        }
      }
      Oi(hy, "LineAtlas");
      class py {
        constructor(t2) {
          const e2 = {}, r2 = [];
          for (const n3 in t2) {
            const i3 = t2[n3], s3 = e2[n3] = {};
            for (const t3 in i3.glyphs) {
              const e3 = i3.glyphs[+t3];
              if (!e3 || e3.bitmap.width === 0 || e3.bitmap.height === 0)
                continue;
              const n4 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
              r2.push(a2), s3[t3] = a2;
            }
          }
          const { w: n2, h: i2 } = Cp(r2), s2 = new Ju({ width: n2 || 1, height: i2 || 1 });
          for (const r3 in t2) {
            const n3 = t2[r3];
            for (const t3 in n3.glyphs) {
              const i3 = n3.glyphs[+t3];
              if (!i3 || i3.bitmap.width === 0 || i3.bitmap.height === 0)
                continue;
              const a2 = e2[r3][t3], o2 = i3.metrics.localGlyph ? 2 : 1;
              Ju.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
            }
          }
          this.image = s2, this.positions = e2;
        }
      }
      Oi(py, "GlyphAtlas");
      class fy {
        constructor(t2) {
          this.tileID = new Mh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = Vf(t2.tileID.canonical, t2.projection), this.projection = t2.projection;
        }
        parse(t2, e2, r2, n2, i2) {
          this.status = "parsing", this.data = t2, this.collisionBoxArray = new Ea();
          const s2 = new kd(Object.keys(t2.layers).sort()), a2 = new ly(this.tileID, this.promoteId);
          a2.bucketLayerIDs = [];
          const o2 = {}, l2 = new hy(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r2 }, c2 = e2.familiesBySource[this.source];
          for (const e3 in c2) {
            const n3 = t2.layers[e3];
            if (!n3)
              continue;
            let i3 = false, l3 = false;
            for (const t3 of c2[e3])
              t3[0].type === "symbol" ? i3 = true : l3 = true;
            if (this.isSymbolTile === true && !i3)
              continue;
            if (this.isSymbolTile === false && !l3)
              continue;
            n3.version === 1 && $(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const h5 = s2.encode(e3), p3 = [];
            for (let t3 = 0; t3 < n3.length; t3++) {
              const r3 = n3.feature(t3), i4 = a2.getId(r3, e3);
              p3.push({ feature: r3, id: i4, index: t3, sourceLayerIndex: h5 });
            }
            for (const t3 of c2[e3]) {
              const e4 = t3[0];
              this.isSymbolTile !== void 0 && e4.type === "symbol" !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || e4.visibility !== "none" && (dy(t3, this.zoom, r2), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h5, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r2 })).populate(p3, u2, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
            }
          }
          let h4, p2, f2, d2;
          l2.trim();
          const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m2 = F(u2.glyphDependencies, (t3) => Object.keys(t3).map(Number));
          Object.keys(m2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m2 }, (t3, e3) => {
            h4 || (h4 = t3, p2 = e3, v3.call(this));
          }, void 0, false, y2) : p2 = {};
          const g2 = Object.keys(u2.iconDependencies);
          g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
            h4 || (h4 = t3, f2 = e3, v3.call(this));
          }, void 0, false, y2) : f2 = {};
          const x2 = Object.keys(u2.patternDependencies);
          function v3() {
            if (h4)
              return i2(h4);
            if (p2 && f2 && d2) {
              const t3 = new py(p2), e3 = new Dp(f2, d2);
              for (const n3 in o2) {
                const i3 = o2[n3];
                i3 instanceof hd ? (dy(i3.layers, this.zoom, r2), kf(i3, p2, t3.positions, f2, e3.iconPositions, this.showCollisionBoxes, r2, this.tileID.canonical, this.tileZoom, this.projection)) : i3.hasPattern && (i3 instanceof jh || i3 instanceof Uc || i3 instanceof fh) && (dy(i3.layers, this.zoom, r2), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions, r2, this.tileTransform));
              }
              this.status = "done", i2(null, { buckets: T(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
            }
          }
          x2.length ? n2.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
            h4 || (h4 = t3, d2 = e3, v3.call(this));
          }, void 0, false, y2) : d2 = {}, v3.call(this);
        }
      }
      function dy(t2, e2, r2) {
        const n2 = new Us(e2);
        for (const e3 of t2)
          e3.recalculate(n2, r2);
      }
      class yy {
        constructor(t2) {
          this.entries = {}, this.scheduler = t2;
        }
        request(t2, e2, r2, n2) {
          const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
          if (i2.result) {
            const [t3, r3] = i2.result;
            return this.scheduler ? this.scheduler.add(() => {
              n2(t3, r3);
            }, e2) : n2(t3, r3), () => {
            };
          }
          return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
            i2.result = [r3, n3];
            for (const t3 of i2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                t3(r3, n3);
              }, e2) : t3(r3, n3);
            setTimeout(() => delete this.entries[t2], 3e3);
          })), () => {
            i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
          };
        }
      }
      function my(t2, e2, r2) {
        const n2 = JSON.stringify(t2.request);
        return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
          const n3 = ut(t2.request, (t3, n4, i2, s2) => {
            t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new sh(new op(n4)), rawData: n4, cacheControl: i2, expires: s2 });
          });
          return () => {
            n3.cancel(), e3();
          };
        }, e2);
      }
      t.ARRAY_TYPE = To, t.AUTH_ERR_MSG = yt, t.Aabb = _l, t.Actor = class {
        constructor(t2, r2, n2) {
          this.target = t2, this.parent = r2, this.mapId = n2, this.callbacks = {}, this.cancelCallbacks = {}, V(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = N() ? t2 : e, this.scheduler = new Sd();
        }
        send(t2, e2, r2, n2, i2 = false, s2) {
          const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
          const o2 = Z(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Gi(e2, o2) }, o2), { cancel: () => {
            r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
          } };
        }
        receive(t2) {
          const e2 = t2.data, r2 = e2.id;
          if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
            if (e2.type === "<cancel>") {
              const t3 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], t3 && t3.cancel();
            } else if (e2.mustQueue || N()) {
              const t3 = this.callbacks[r2];
              this.cancelCallbacks[r2] = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
            } else
              this.processTask(r2, e2);
        }
        processTask(t2, e2) {
          if (e2.type === "<response>") {
            const r2 = this.callbacks[t2];
            delete this.callbacks[t2], r2 && (e2.error ? r2(Xi(e2.error)) : r2(null, Xi(e2.data)));
          } else {
            const r2 = Z(this.globalScope) ? void 0 : [], n2 = e2.hasCallback ? (e3, n3) => {
              delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Gi(e3) : null, data: Gi(n3, r2) }, r2);
            } : (t3) => {
            }, i2 = Xi(e2.data);
            if (this.parent[e2.type])
              this.parent[e2.type](e2.sourceMapId, i2, n2);
            else if (this.parent.getWorkerSource) {
              const t3 = e2.type.split(".");
              this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n2);
            } else
              n2(new Error(`Could not find function ${e2.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }, t.CanonicalTileID = kh, t.Color = Me, t.ColorMode = Qd, t.CullFaceMode = ry, t.DEMData = Kd, t.DataConstantProperty = Ys, t.DedupedRequest = yy, t.DepthMode = Hd, t.EXTENT = ko, t.Elevation = class {
        isDataAvailableAtPoint(t2) {
          const e2 = this._source();
          if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1)
            return false;
          const r2 = e2.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new Mh(r2, i2, r2, s2, a2));
          return !(!o2 || !o2.dem);
        }
        getAtPointOrZero(t2, e2 = 0) {
          return this.getAtPoint(t2, e2) || 0;
        }
        getAtPoint(t2, e2, r2 = true) {
          if (this.isUsingMockSource())
            return null;
          e2 == null && (e2 = null);
          const n2 = this._source();
          if (!n2)
            return e2;
          if (t2.y < 0 || t2.y > 1)
            return e2;
          const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Mh(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
          if (!u2 || !u2.dem)
            return e2;
          const c2 = u2.dem, h4 = 1 << u2.tileID.canonical.z, p2 = (o2 * h4 - u2.tileID.canonical.x) * c2.dim, f2 = (t2.y * h4 - u2.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), y2 = Math.floor(f2);
          return (r2 ? this.exaggeration() : 1) * Mr(Mr(c2.get(d2, y2), c2.get(d2, y2 + 1), f2 - y2), Mr(c2.get(d2 + 1, y2), c2.get(d2 + 1, y2 + 1), f2 - y2), p2 - d2);
        }
        getAtTileOffset(t2, e2, r2) {
          const n2 = 1 << t2.canonical.z;
          return this.getAtPointOrZero(new pu(t2.wrap + (t2.canonical.x + e2 / ko) / n2, (t2.canonical.y + r2 / ko) / n2));
        }
        getAtTileOffsetFunc(t2, e2, r2, n2) {
          return (i2) => {
            const s2 = this.getAtTileOffset(t2, i2.x, i2.y), a2 = n2.upVector(t2.canonical, i2.x, i2.y);
            return Ho(a2, a2, s2 * n2.upVectorScale(t2.canonical, e2, r2).metersToTile), a2;
          };
        }
        getForTilePoints(t2, e2, r2, n2) {
          if (this.isUsingMockSource())
            return false;
          const i2 = oy.create(this, t2, n2);
          return !!i2 && (e2.forEach((t3) => {
            t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
          }), true);
        }
        getMinMaxForTile(t2) {
          if (this.isUsingMockSource())
            return null;
          const e2 = this.findDEMTileFor(t2);
          if (!e2 || !e2.dem)
            return null;
          const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
          let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
          for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
            s2 *= 2, a2 *= 2;
            const t3 = 2 * Math.floor(a2) + Math.floor(s2);
            o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
          }
          return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t2, e2, r2) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t2) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t2) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
      }, t.ErrorEvent = Kt, t.EvaluationParameters = Us, t.Event = Zt, t.Evented = Yt, t.FillExtrusionBucket = fh, t.Frustum = wl, t.FrustumCorners = bl, t.GLOBE_RADIUS = Al, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = 6, t.GLOBE_ZOOM_THRESHOLD_MIN = 5, t.GlobeSharedBuffers = class {
        constructor(t2) {
          this._createGrid(t2), this._createPoles(t2);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t2 of this._poleSegments)
            t2.destroy();
          for (const t2 of this._gridSegments)
            t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
          if (this._wireframeIndexBuffer) {
            this._wireframeIndexBuffer.destroy();
            for (const t2 of this._wireframeSegments)
              t2.destroy();
          }
        }
        _fillGridMeshWithLods(t2, e2) {
          const r2 = new sa(), n2 = new wa(), i2 = [], s2 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r3) => {
            let n3 = t3 === s2 - 1 ? t3 - 2 : t3 === 0 ? t3 : t3 - 1;
            return n3 += r3 ? 24575 : 0, [n3, e3];
          };
          for (let t3 = 0; t3 < s2; ++t3)
            r2.emplaceBack(...l2(t3, 0, true));
          for (let t3 = 0; t3 < a2; ++t3)
            for (let e3 = 0; e3 < s2; ++e3)
              r2.emplaceBack(...l2(e3, t3, (e3 === 0 || e3 === s2 - 1) && true));
          for (let t3 = 0; t3 < e2.length; ++t3) {
            const n3 = e2[t3];
            for (let t4 = 0; t4 < s2; ++t4)
              r2.emplaceBack(...l2(t4, n3, true));
          }
          for (let t3 = 0; t3 < e2.length; ++t3) {
            const a3 = n2.length, l3 = e2[t3] + 1 + 2, u2 = new wa();
            for (let r3 = 0; r3 < l3 - 1; r3++) {
              const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e2.length + t3 - r3) : s2;
              for (let t4 = 0; t4 < s2 - 1; t4++) {
                const e3 = r3 * s2 + t4;
                r3 === 0 || i3 || t4 === 0 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
              }
            }
            const c2 = So.simpleSegment(0, a3, r2.length, n2.length - a3);
            for (let t4 = 0; t4 < u2.uint16.length; t4 += 3)
              n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
            const h4 = So.simpleSegment(0, a3, r2.length, n2.length - a3);
            i2.push({ withoutSkirts: c2, withSkirts: h4 });
          }
          return { vertices: r2, indices: n2, segments: i2 };
        }
        _createGrid(t2) {
          const e2 = this._fillGridMeshWithLods(Sl, kl);
          this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, xl.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
        }
        _createPoles(t2) {
          const e2 = new wa();
          for (let t3 = 0; t3 <= Sl; t3++)
            e2.emplaceBack(0, t3 + 1, t3 + 2);
          this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
          const r2 = new ka(), n2 = new ka();
          this._poleSegments = [];
          for (let t3 = 0, e3 = 0; t3 < 5; t3++) {
            const i2 = 360 / (1 << t3);
            r2.emplaceBack(0, -Al, 0, 0.5, 0), n2.emplaceBack(0, -Al, 0, 0.5, 1);
            for (let t4 = 0; t4 <= Sl; t4++) {
              const e4 = t4 / Sl, s2 = Mr(0, i2, e4), [a2, o2, l2] = Ul(Jl, Ql, s2, Al);
              r2.emplaceBack(a2, o2, l2, e4, 0), n2.emplaceBack(a2, o2, l2, e4, 1);
            }
            this._poleSegments.push(So.simpleSegment(e3, 0, 66, 64)), e3 += 66;
          }
          this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, ml, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, ml, false);
        }
        getGridBuffers(t2, e2) {
          return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
        }
        getPoleBuffers(t2) {
          return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
        }
        getWirefameBuffers(t2, e2) {
          if (!this._wireframeSegments) {
            const e3 = new Ma(), r2 = Sl, n2 = r2 + 1 + 2, i2 = 1;
            this._wireframeSegments = [];
            for (let t3 = 0, s2 = 0; t3 < kl.length; t3++) {
              const a2 = kl[t3];
              for (let t4 = i2; t4 < a2 + i2; t4++)
                for (let s3 = i2; s3 < r2 + i2; s3++) {
                  const r3 = t4 * n2 + s3;
                  e3.emplaceBack(r3, r3 + 1), e3.emplaceBack(r3, r3 + n2), e3.emplaceBack(r3, r3 + n2 + 1);
                }
              const o2 = a2 * r2 * 3;
              this._wireframeSegments.push(So.simpleSegment(0, s2, (a2 + 1) * n2, o2)), s2 += o2;
            }
            this._wireframeIndexBuffer = t2.createIndexBuffer(e3);
          }
          return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e2]];
        }
      }, t.GlyphManager = cf, t.ImagePosition = Pp, t.LivePerformanceUtils = Lt, t.LngLat = ru, t.LngLatBounds = Io, t.LocalGlyphMode = uf, t.MAX_MERCATOR_LATITUDE = cu, t.MercatorCoordinate = pu, t.ONE_EM = Wh, t.OverscaledTileID = Mh, t.PerformanceMarkers = Vt, t.Properties = Js, t.RGBAImage = Qu, t.Ray = vl, t.RequestManager = class {
        constructor(t2, e2, r2) {
          this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r2, this._createSkuToken();
        }
        _createSkuToken() {
          const t2 = function() {
            let t3 = "";
            for (let e2 = 0; e2 < 10; e2++)
              t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", h3, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t2, e2) {
          return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
        }
        normalizeStyleURL(t2, e2) {
          if (!mt(t2))
            return t2;
          const r2 = _t(t2);
          return r2.path = `/styles/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
        }
        normalizeGlyphsURL(t2, e2) {
          if (!mt(t2))
            return t2;
          const r2 = _t(t2);
          return r2.path = `/fonts/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
        }
        normalizeSourceURL(t2, e2, r2, n2) {
          if (!mt(t2))
            return t2;
          const i2 = _t(t2);
          return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r2 && i2.params.push(`language=${r2}`), n2 && i2.params.push(`worldview=${n2}`), this._makeAPIURL(i2, this._customAccessToken || e2);
        }
        normalizeSpriteURL(t2, e2, r2, n2) {
          const i2 = _t(t2);
          return mt(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r2}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e2}${r2}`, At(i2));
        }
        normalizeTileURL(t2, e2, r2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !mt(t2))
            return t2;
          const n2 = _t(t2);
          n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r2 && n2.authority !== "raster" && r2 === 512 ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), n2.authority === "raster" ? n2.path = `/${i.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${i.TILE_URL_VERSION}${n2.path}`);
          const a2 = this._customAccessToken || function(t3) {
            for (const e3 of t3) {
              const t4 = e3.match(/^access_token=(.*)$/);
              if (t4)
                return t4[1];
            }
            return null;
          }(n2.params) || i.ACCESS_TOKEN;
          return i.REQUIRE_ACCESS_TOKEN && a2 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, a2);
        }
        canonicalizeTileURL(t2, e2) {
          const r2 = _t(t2);
          if (!r2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r2.path.match(/\.[\w]+$/))
            return t2;
          let n2 = "mapbox://";
          r2.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r2.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r2.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
          let s2 = r2.params;
          return e2 && (s2 = s2.filter((t3) => !t3.match(/^access_token=/))), s2.length && (n2 += `?${s2.join("&")}`), n2;
        }
        canonicalizeTileset(t2, e2) {
          const r2 = !!e2 && mt(e2), n2 = [];
          for (const e3 of t2.tiles || [])
            gt(e3) ? n2.push(this.canonicalizeTileURL(e3, r2)) : n2.push(e3);
          return n2;
        }
        _makeAPIURL(t2, e2) {
          const r2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n2 = _t(i.API_URL);
          if (t2.protocol = n2.protocol, t2.authority = n2.authority, t2.protocol === "http") {
            const e3 = t2.params.indexOf("secure");
            e3 >= 0 && t2.params.splice(e3, 1);
          }
          if (n2.path !== "/" && (t2.path = `${n2.path}${t2.path}`), !i.REQUIRE_ACCESS_TOKEN)
            return At(t2);
          if (e2 = e2 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!e2)
              throw new Error(`An API access token is required to use Mapbox GL. ${r2}`);
            if (e2[0] === "s")
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r2}`);
          }
          return t2.params = t2.params.filter((t3) => t3.indexOf("access_token") === -1), t2.params.push(`access_token=${e2 || ""}`), At(t2);
        }
      }, t.ResourceType = st, t.SegmentVector = So, t.SourceCache = ny, t.StencilMode = Jd, t.StructArrayLayout1ui2 = Ta, t.StructArrayLayout2f1f2i16 = xa, t.StructArrayLayout2i4 = sa, t.StructArrayLayout2ui4 = Ma, t.StructArrayLayout3f12 = ba, t.StructArrayLayout3ui6 = wa, t.StructArrayLayout4i8 = oa, t.StructArrayLayout5f20 = ka, t.Texture = _d, t.Tile = Fd, t.Transitionable = qs, t.Uniform1f = to2, t.Uniform1i = class extends Qa {
        constructor(t2) {
          super(t2), this.current = 0;
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
        }
      }, t.Uniform2f = class extends Qa {
        constructor(t2) {
          super(t2), this.current = [0, 0];
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
        }
      }, t.Uniform3f = class extends Qa {
        constructor(t2) {
          super(t2), this.current = [0, 0, 0];
        }
        set(t2, e2, r2) {
          this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
        }
      }, t.Uniform4f = eo, t.UniformColor = ro, t.UniformMatrix2f = class extends Qa {
        constructor(t2) {
          super(t2), this.current = so;
        }
        set(t2, e2, r2) {
          if (this.fetchUniformLocation(t2, e2)) {
            for (let t3 = 0; t3 < 4; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                break;
              }
          }
        }
      }, t.UniformMatrix3f = class extends Qa {
        constructor(t2) {
          super(t2), this.current = io;
        }
        set(t2, e2, r2) {
          if (this.fetchUniformLocation(t2, e2)) {
            for (let t3 = 0; t3 < 9; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                break;
              }
          }
        }
      }, t.UniformMatrix4f = class extends Qa {
        constructor(t2) {
          super(t2), this.current = no;
        }
        set(t2, e2, r2) {
          if (this.fetchUniformLocation(t2, e2)) {
            if (r2[12] !== this.current[12] || r2[0] !== this.current[0])
              return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
            for (let t3 = 1; t3 < 16; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                break;
              }
          }
        }
      }, t.UnwrappedTileID = Ih, t.ValidationError = Wn, t.VectorTileFeature = ah, t.VectorTileWorkerSource = class extends Yt {
        constructor(t2, e2, r2, n2, i2) {
          super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r2, this.loadVectorData = i2 || my, this.loading = {}, this.loaded = {}, this.deduped = new yy(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler;
        }
        loadTile(t2, e2) {
          const r2 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r2] = new fy(t2);
          s2.abort = this.loadVectorData(t2, (a2, o2) => {
            const l2 = !this.loading[r2];
            if (delete this.loading[r2], l2 || a2 || !o2)
              return s2.status = "done", l2 || (this.loaded[r2] = s2), e2(a2);
            const u2 = o2.rawData, c2 = {};
            o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new sh(new op(u2));
            const h4 = () => {
              s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r3) => {
                if (t3 || !r3)
                  return e2(t3);
                const s3 = {};
                if (i2) {
                  const t4 = jt(n2);
                  t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                }
                e2(null, z({ rawTileData: u2.slice(0) }, r3, c2, s3));
              });
            };
            this.isSpriteLoaded ? h4() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(h4, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h4();
            }), this.loaded = this.loaded || {}, this.loaded[r2] = s2;
          });
        }
        reloadTile(t2, e2) {
          const r2 = this.loaded, n2 = t2.uid, i2 = this;
          if (r2 && r2[n2]) {
            const s2 = r2[n2];
            s2.showCollisionBoxes = t2.showCollisionBoxes, s2.enableTerrain = !!t2.enableTerrain, s2.projection = t2.projection, s2.tileTransform = Vf(t2.tileID.canonical, t2.projection);
            const a2 = (t3, r3) => {
              const n3 = s2.reloadCallback;
              n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e2(t3, r3);
            };
            s2.status === "parsing" ? s2.reloadCallback = a2 : s2.status === "done" && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
          }
        }
        abortTile(t2, e2) {
          const r2 = t2.uid, n2 = this.loading[r2];
          n2 && (n2.abort && n2.abort(), delete this.loading[r2]), e2();
        }
        removeTile(t2, e2) {
          const r2 = this.loaded, n2 = t2.uid;
          r2 && r2[n2] && delete r2[n2], e2();
        }
      }, t.WritingMode = Vp, t.ZoomDependentExpression = Zn, t.add = Go, t.addDynamicAttributes = od, t.adjoint = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8];
        return t2[0] = a2 * c2 - o2 * u2, t2[1] = i2 * u2 - n2 * c2, t2[2] = n2 * o2 - i2 * a2, t2[3] = o2 * l2 - s2 * c2, t2[4] = r2 * c2 - i2 * l2, t2[5] = i2 * s2 - r2 * o2, t2[6] = s2 * u2 - a2 * l2, t2[7] = n2 * l2 - r2 * u2, t2[8] = r2 * a2 - n2 * s2, t2;
      }, t.asyncAll = M, t.bezier = _, t.bindAll = V, t.boundsAttributes = Vd, t.bufferConvexPolygon = function(t2, e2) {
        const r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const i2 = I(n2 - 1, -1, t2.length - 1), s2 = I(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h4 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
          r2.push(a2.add(h4));
        }
        return r2;
      }, t.cacheEntryPossiblyAdded = function(t2) {
        it++, it > tt && (t2.getActor().send("enforceCacheSizeLimit", Q), it = 0);
      }, t.calculateGlobeLabelMatrix = function(t2, e2) {
        const { x: r2, y: n2 } = t2.point, i2 = Zl(r2, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
        return Po(i2, i2, Xl(Pl(e2)));
      }, t.calculateGlobeMatrix = function(t2) {
        const { x: e2, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
        return Zl(e2, r2, t2.worldSize, n2, i2);
      }, t.calculateGlobeMercatorMatrix = function(t2) {
        const e2 = t2.pixelsPerMeter, r2 = e2 / au(1, t2.center.lat), n2 = Eo(new Float64Array(16));
        return Do(n2, n2, [t2.point.x, t2.point.y, 0]), Vo(n2, n2, [r2, r2, e2]), Float32Array.from(n2);
      }, t.circumferenceAtLatitude = nu, t.clamp = S, t.clearTileCache = function(t2) {
        if (!et())
          return;
        const r2 = e.caches.delete(H);
        t2 && r2.catch(t2).then(() => t2());
      }, t.clipLine = sf, t.clone = function(t2) {
        var e2 = new To(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.clone$1 = j, t.collisionCircleLayout = Hh, t.config = i, t.conjugate = function(t2, e2) {
        return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
      }, t.create = function() {
        var t2 = new To(16);
        return To != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.create$1 = zo, t.createExpression = Gn, t.createLayout = na, t.createStyleLayer = function(t2) {
        return t2.type === "custom" ? new xd(t2) : new wd[t2.type](t2);
      }, t.cross = tl, t.degToRad = x, t.distance = function(t2, e2) {
        return Math.hypot(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
      }, t.div = function(t2, e2, r2) {
        return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
      }, t.dot = Qo, t.earthRadius = tu, t.ease = A, t.easeCubicInOut = w, t.ecefToLatLng = function([t2, e2, r2]) {
        const n2 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
        return new ru(v2(i2), v2(s2));
      }, t.emitValidationErrors = Ri, t.endsWith = L, t.enforceCacheSizeLimit = function(t2) {
        rt(), W && W.then((e2) => {
          e2.keys().then((r2) => {
            for (let n2 = 0; n2 < r2.length - t2; n2++)
              e2.delete(r2[n2]);
          });
        });
      }, t.evaluateSizeForFeature = tp, t.evaluateSizeForZoom = ep, t.evaluateVariableOffset = Sf, t.evented = Ls, t.exactEquals = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
      }, t.exactEquals$1 = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
      }, t.exported = Nt, t.exported$1 = s, t.extend = z, t.extend$1 = Wt, t.fillExtrusionHeightLift = bh, t.filterObject = R2, t.fromMat4 = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
      }, t.fromQuat = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h4 = n2 * o2, p2 = i2 * a2, f2 = i2 * o2, d2 = i2 * l2, y2 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
        return t2[0] = 1 - h4 - d2, t2[1] = c2 + g2, t2[2] = p2 - m2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - d2, t2[6] = f2 + y2, t2[7] = 0, t2[8] = p2 + m2, t2[9] = f2 - y2, t2[10] = 1 - u2 - h4, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.fromRotation = function(t2, e2) {
        var r2 = Math.sin(e2), n2 = Math.cos(e2);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, t.fromScaling = Ro, t.furthestTileCorner = function(t2) {
        const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
        return b[e2];
      }, t.getAABBPointSquareDist = function(t2, e2, r2) {
        let n2 = 0;
        for (let i2 = 0; i2 < 2; ++i2) {
          const s2 = r2 ? r2[i2] : 0;
          t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e2[i2] < s2 && (n2 += (s2 - e2[i2]) * (s2 - e2[i2]));
        }
        return n2;
      }, t.getAnchorAlignment = Xp, t.getAnchorJustification = If, t.getBounds = function(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return { min: new d(e2, r2), max: new d(n2, i2) };
      }, t.getColumn = Y, t.getGridMatrix = function(t2, e2, r2, n2) {
        const i2 = e2.getNorth(), s2 = e2.getSouth(), a2 = e2.getWest(), o2 = e2.getEast(), l2 = 1 << t2.z, u2 = o2 - a2, c2 = i2 - s2, h4 = u2 / Sl, p2 = -c2 / kl[r2], f2 = [0, h4, 0, p2, 0, 0, i2, a2, 0];
        if (t2.z > 0) {
          const t3 = 180 / n2;
          Bo(f2, f2, [t3 / u2 + 1, 0, 0, 0, t3 / c2 + 1, 0, -0.5 * t3 / h4, 0.5 * t3 / p2, 1]);
        }
        return f2[2] = l2, f2[5] = t2.x, f2[8] = t2.y, f2;
      }, t.getImage = dt, t.getJSON = function(t2, e2) {
        return lt(z(t2, { type: "json" }), e2);
      }, t.getLatitudinalLod = function(t2) {
        const e2 = cu - 5;
        t2 = S(t2, -e2, e2) / e2 * 90;
        const r2 = Math.pow(Math.abs(Math.sin(x(t2))), 3);
        return Math.round(r2 * (kl.length - 1));
      }, t.getMapSessionAPI = Pt, t.getPerformanceMeasurement = jt, t.getProjection = rd, t.getRTLTextPluginStatus = Fs, t.getReferrer = ot, t.getTilePoint = function(t2, { x: e2, y: r2 }, n2 = 0) {
        return new d(((e2 - n2) * t2.scale - t2.x) * ko, (r2 * t2.scale - t2.y) * ko);
      }, t.getTileVec3 = function(t2, e2, r2 = 0) {
        return No(((e2.x - r2) * t2.scale - t2.x) * ko, (e2.y * t2.scale - t2.y) * ko, uu(e2.z, e2.y));
      }, t.getVideo = function(t2, r2) {
        const n2 = e.document.createElement("video");
        n2.muted = true, n2.onloadstart = function() {
          r2(null, n2);
        };
        for (let r3 = 0; r3 < t2.length; r3++) {
          const i2 = e.document.createElement("source");
          ct(t2[r3]) || (n2.crossOrigin = "Anonymous"), i2.src = t2[r3], n2.appendChild(i2);
        }
        return { cancel: () => {
        } };
      }, t.globeCenterToScreenPoint = function(t2) {
        const e2 = [0, 0, 0], r2 = Eo(new Float64Array(16));
        return Po(r2, t2.pixelMatrix, t2.globeMatrix), el(e2, e2, r2), new d(e2[0], e2[1]);
      }, t.globeDenormalizeECEF = Xl, t.globeECEFOrigin = function(t2, e2) {
        const r2 = [0, 0, 0];
        return el(r2, r2, Gl(Pl(e2.canonical))), el(r2, r2, t2), r2;
      }, t.globeMetersToEcef = zl, t.globeNormalizeECEF = Gl, t.globePixelsToTileUnits = function(t2, e2) {
        return ko / (512 * Math.pow(2, t2)) * ql(Pl(e2));
      }, t.globePoleMatrixForTile = function(t2, e2, r2) {
        const n2 = Eo(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
        return Fo(n2, r2.globeMatrix, i2), Float32Array.from(n2);
      }, t.globeTileBounds = Pl, t.globeTiltAtLngLat = Yl, t.globeToMercatorTransition = Kl, t.globeUseCustomAntiAliasing = function(t2, e2, r2) {
        const n2 = Kl(r2.zoom), i2 = t2.style.map._antialias, s2 = !!e2.extStandardDerivatives, a2 = e2.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
        return n2 === 0 && !i2 && !a2 && s2;
      }, t.identity = Eo, t.identity$1 = hl, t.invert = Co, t.isFullscreen = function() {
        return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
      }, t.isLngLatBehindGlobe = Hl, t.isMapAuthenticated = function(t2) {
        return Dt.has(t2);
      }, t.isMapboxURL = mt, t.isSafariWithAntialiasingBug = function(t2) {
        const e2 = t2.navigator ? t2.navigator.userAgent : null;
        return !!Z(t2) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, t.latFromMercatorY = lu, t.latLngToECEF = $l, t.len = al, t.length = qo, t.length$1 = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
      }, t.lngFromMercatorX = ou, t.loadVectorTile = my, t.makeRequest = lt, t.mapValue = function(t2, e2, r2, n2, i2) {
        return S((t2 - e2) / (r2 - e2) * (i2 - n2) + n2, n2, i2);
      }, t.mercatorScale = hu, t.mercatorXfromLng = iu, t.mercatorYfromLat = su, t.mercatorZfromAltitude = au, t.mul = Uo, t.mul$1 = sl, t.multiply = Po, t.multiply$1 = Bo, t.multiply$2 = Zo, t.nextPowerOfTwo = P, t.normalize = Jo, t.normalize$1 = dl, t.normalize$2 = ll, t.number = Mr, t.ortho = function(t2, e2, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
      }, t.pbf = op, t.perspective = function(t2, e2, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.pick = function(t2, e2) {
        const r2 = {};
        for (let n2 = 0; n2 < e2.length; n2++) {
          const i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.plugin = js, t.pointGeometry = d, t.polesInViewport = function(t2) {
        const e2 = Eo(new Float64Array(16));
        Po(e2, t2.pixelMatrix, t2.globeMatrix);
        const r2 = [0, Il, 0], n2 = [0, Ml, 0];
        return el(r2, r2, e2), el(n2, n2, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Hl(t2, new ru(t2.center.lat, -90))];
      }, t.polygonContainsPoint = Du, t.polygonIntersectsBox = Vu, t.polygonIntersectsPolygon = ku, t.polygonizeBounds = function(t2, e2, r2 = 0, n2 = true) {
        const i2 = new d(r2, r2), s2 = t2.sub(i2), a2 = e2.add(i2), o2 = [s2, new d(a2.x, s2.y), a2, new d(s2.x, a2.y)];
        return n2 && o2.push(s2.clone()), o2;
      }, t.posAttributes = xl, t.postMapLoadEvent = zt, t.postPerformanceEvent = Et, t.postTurnstileEvent = Mt, t.potpack = Cp, t.prevPowerOfTwo = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }, t.radToDeg = v2, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
        return t2({ pluginStatus: Cs, pluginURL: Ps }), Ls.on("pluginStateChange", t2), t2;
      }, t.removeAuthState = function(t2) {
        Dt.delete(t2);
      }, t.renderColorRamp = ec, t.resample = du, t.rotateX = Lo, t.rotateX$1 = pl, t.rotateY = Fo, t.rotateY$1 = fl, t.rotateZ = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h4 = e2[6], p2 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h4 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h4 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
      }, t.rotateZ$1 = function(t2, e2, r2) {
        r2 *= 0.5;
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
      }, t.scale = Vo, t.scale$1 = ol, t.scale$2 = Ho, t.scaleAndAdd = Wo, t.set = function(t2, e2, r2, n2) {
        return t2[0] = e2, t2[1] = r2, t2[2] = n2, t2;
      }, t.setCacheLimits = function(t2, e2) {
        Q = t2, tt = e2;
      }, t.setColumn = function(t2, e2, r2) {
        t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
      }, t.setRTLTextPlugin = function(t2, e2, r2 = false) {
        if (Cs === Ts || Cs === zs || Cs === Bs)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Ps = Nt.resolveURL(t2), Cs = Ts, Es = e2, Vs(), r2 || Rs();
      }, t.smoothstep = k, t.spec = Ht, t.squaredLength = function(t2) {
        var e2 = t2[0], r2 = t2[1], n2 = t2[2];
        return e2 * e2 + r2 * r2 + n2 * n2;
      }, t.storeAuthState = function(t2, e2) {
        e2 ? Dt.add(t2) : Dt.delete(t2);
      }, t.sub = il, t.subtract = Xo, t.symbolSize = rp, t.tileAABB = function(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        if (l2.name === "globe")
          return Fl(t2, e2, new kh(r2, n2, i2));
        const u2 = Vf({ z: r2, x: n2, y: i2 }, l2);
        return new _l([(s2 + u2.x / u2.scale) * e2, e2 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e2, e2 * (u2.y2 / u2.scale), o2]);
      }, t.tileCornersToBounds = Rl, t.tileTransform = Vf, t.transformMat3 = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2];
        return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
      }, t.transformMat4 = el, t.transformMat4$1 = ul, t.transformQuat = rl, t.transitionTileAABBinECEF = Vl, t.translate = Do, t.transpose = function(t2, e2) {
        if (t2 === e2) {
          var r2 = e2[1], n2 = e2[2], i2 = e2[5];
          t2[1] = e2[3], t2[2] = e2[6], t2[3] = r2, t2[5] = e2[7], t2[6] = n2, t2[7] = i2;
        } else
          t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8];
        return t2;
      }, t.triggerPluginCompletionEvent = Ds, t.uniqueId = E, t.updateGlobeVertexNormal = function(t2, e2, r2, n2, i2) {
        const s2 = 5 * e2 + 2;
        t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
      }, t.validateCustomStyleLayer = function(t2) {
        const e2 = [], r2 = t2.id;
        return r2 === void 0 && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === void 0 && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t.validateFilter = (t2) => Fi(xi(t2)), t.validateFog = (t2) => Fi(Bi(t2)), t.validateLayer = (t2) => Fi(Ai(t2)), t.validateLight = (t2) => Fi(Ti(t2)), t.validateSource = (t2) => Fi(Ii(t2)), t.validateStyle = Di, t.validateTerrain = (t2) => Fi(zi(t2)), t.values = T, t.vectorTile = Zc, t.version = r, t.warnOnce = $, t.window = e, t.wrap = I;
    });
    define(["./shared"], function(e) {
      function t(e2) {
        if (typeof e2 == "number" || typeof e2 == "boolean" || typeof e2 == "string" || e2 == null)
          return JSON.stringify(e2);
        if (Array.isArray(e2)) {
          let r3 = "[";
          for (const o2 of e2)
            r3 += `${t(o2)},`;
          return `${r3}]`;
        }
        let r2 = "{";
        for (const o2 of Object.keys(e2).sort())
          r2 += `${o2}:${t(e2[o2])},`;
        return `${r2}}`;
      }
      function r(r2) {
        let o2 = "";
        for (const n2 of e.refProperties)
          o2 += `/${t(r2[n2])}`;
        return o2;
      }
      class o {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t2, o2) {
          for (const r2 of t2)
            this._layerConfigs[r2.id] = r2, (this._layers[r2.id] = e.createStyleLayer(r2)).compileFilter(), this.keyCache[r2.id] && delete this.keyCache[r2.id];
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const n2 = function(e2, t3) {
            const o3 = {};
            for (let n4 = 0; n4 < e2.length; n4++) {
              const i2 = t3 && t3[e2[n4].id] || r(e2[n4]);
              t3 && (t3[e2[n4].id] = i2);
              let s2 = o3[i2];
              s2 || (s2 = o3[i2] = []), s2.push(e2[n4]);
            }
            const n3 = [];
            for (const e3 in o3)
              n3.push(o3[e3]);
            return n3;
          }(e.values(this._layerConfigs), this.keyCache);
          for (const e2 of n2) {
            const t3 = e2.map((e3) => this._layers[e3.id]), r2 = t3[0];
            if (r2.visibility === "none")
              continue;
            const o3 = r2.source || "";
            let n3 = this.familiesBySource[o3];
            n3 || (n3 = this.familiesBySource[o3] = {});
            const i2 = r2.sourceLayer || "_geojsonTileLayer";
            let s2 = n3[i2];
            s2 || (s2 = n3[i2] = []), s2.push(t3);
          }
        }
      }
      class n {
        loadTile(t2, r2) {
          const { uid: o2, encoding: n2, rawImageData: i2, padding: s2, buildQuadTree: a2 } = t2, l2 = e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? this.getImageData(i2, s2) : i2;
          r2(null, new e.DEMData(o2, l2, n2, s2 < 1, a2));
        }
        getImageData(e2, t2) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
          const r2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r2;
        }
      }
      var i = function e2(t2, r2) {
        var o2, n2 = t2 && t2.type;
        if (n2 === "FeatureCollection")
          for (o2 = 0; o2 < t2.features.length; o2++)
            e2(t2.features[o2], r2);
        else if (n2 === "GeometryCollection")
          for (o2 = 0; o2 < t2.geometries.length; o2++)
            e2(t2.geometries[o2], r2);
        else if (n2 === "Feature")
          e2(t2.geometry, r2);
        else if (n2 === "Polygon")
          s(t2.coordinates, r2);
        else if (n2 === "MultiPolygon")
          for (o2 = 0; o2 < t2.coordinates.length; o2++)
            s(t2.coordinates[o2], r2);
        return t2;
      };
      function s(e2, t2) {
        if (e2.length !== 0) {
          a(e2[0], t2);
          for (var r2 = 1; r2 < e2.length; r2++)
            a(e2[r2], !t2);
        }
      }
      function a(e2, t2) {
        for (var r2 = 0, o2 = 0, n2 = 0, i2 = e2.length, s2 = i2 - 1; n2 < i2; s2 = n2++) {
          var a2 = (e2[n2][0] - e2[s2][0]) * (e2[s2][1] + e2[n2][1]), l2 = r2 + a2;
          o2 += Math.abs(r2) >= Math.abs(a2) ? r2 - l2 + a2 : a2 - l2 + r2, r2 = l2;
        }
        r2 + o2 >= 0 != !!t2 && e2.reverse();
      }
      const l = e.VectorTileFeature.prototype.toGeoJSON;
      class u {
        constructor(t2) {
          this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const t2 = [];
            for (const r2 of this._feature.geometry)
              t2.push([new e.pointGeometry(r2[0], r2[1])]);
            return t2;
          }
          {
            const t2 = [];
            for (const r2 of this._feature.geometry) {
              const o2 = [];
              for (const t3 of r2)
                o2.push(new e.pointGeometry(t3[0], t3[1]));
              t2.push(o2);
            }
            return t2;
          }
        }
        toGeoJSON(e2, t2, r2) {
          return l.call(this, e2, t2, r2);
        }
      }
      class h3 {
        constructor(t2) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
        }
        feature(e2) {
          return new u(this._features[e2]);
        }
      }
      var c = {}, f = { get exports() {
        return c;
      }, set exports(e2) {
        c = e2;
      } }, p = e.pointGeometry, g = e.vectorTile.VectorTileFeature, d = m;
      function m(e2, t2) {
        this.options = t2 || {}, this.features = e2, this.length = e2.length;
      }
      function y(e2, t2) {
        this.id = typeof e2.id == "number" ? e2.id : void 0, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
      }
      m.prototype.feature = function(e2) {
        return new y(this.features[e2], this.options.extent);
      }, y.prototype.loadGeometry = function() {
        var e2 = this.rawGeometry;
        this.geometry = [];
        for (var t2 = 0; t2 < e2.length; t2++) {
          for (var r2 = e2[t2], o2 = [], n2 = 0; n2 < r2.length; n2++)
            o2.push(new p(r2[n2][0], r2[n2][1]));
          this.geometry.push(o2);
        }
        return this.geometry;
      }, y.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i2 = 0; i2 < e2.length; i2++)
          for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
            var l2 = s2[a2];
            t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
          }
        return [t2, o2, r2, n2];
      }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;
      var v2 = e.pbf, x = d;
      function w(e2) {
        var t2 = new v2();
        return function(e3, t3) {
          for (var r2 in e3.layers)
            t3.writeMessage(3, S, e3.layers[r2]);
        }(e2, t2), t2.finish();
      }
      function S(e2, t2) {
        var r2;
        t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
        var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r2 = 0; r2 < e2.length; r2++)
          o2.feature = e2.feature(r2), t2.writeMessage(2, M, o2);
        var n2 = o2.keys;
        for (r2 = 0; r2 < n2.length; r2++)
          t2.writeStringField(3, n2[r2]);
        var i2 = o2.values;
        for (r2 = 0; r2 < i2.length; r2++)
          t2.writeMessage(4, T, i2[r2]);
      }
      function M(e2, t2) {
        var r2 = e2.feature;
        r2.id !== void 0 && t2.writeVarintField(1, r2.id), t2.writeMessage(2, P, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, I, r2);
      }
      function P(e2, t2) {
        var r2 = e2.feature, o2 = e2.keys, n2 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
        for (var a2 in r2.properties) {
          var l2 = r2.properties[a2], u2 = i2[a2];
          if (l2 !== null) {
            u2 === void 0 && (o2.push(a2), i2[a2] = u2 = o2.length - 1), t2.writeVarint(u2);
            var h4 = typeof l2;
            h4 !== "string" && h4 !== "boolean" && h4 !== "number" && (l2 = JSON.stringify(l2));
            var c2 = h4 + ":" + l2, f2 = s2[c2];
            f2 === void 0 && (n2.push(l2), s2[c2] = f2 = n2.length - 1), t2.writeVarint(f2);
          }
        }
      }
      function b(e2, t2) {
        return (t2 << 3) + (7 & e2);
      }
      function k(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function I(e2, t2) {
        for (var r2 = e2.loadGeometry(), o2 = e2.type, n2 = 0, i2 = 0, s2 = r2.length, a2 = 0; a2 < s2; a2++) {
          var l2 = r2[a2], u2 = 1;
          o2 === 1 && (u2 = l2.length), t2.writeVarint(b(1, u2));
          for (var h4 = o2 === 3 ? l2.length - 1 : l2.length, c2 = 0; c2 < h4; c2++) {
            c2 === 1 && o2 !== 1 && t2.writeVarint(b(2, h4 - 1));
            var f2 = l2[c2].x - n2, p2 = l2[c2].y - i2;
            t2.writeVarint(k(f2)), t2.writeVarint(k(p2)), n2 += f2, i2 += p2;
          }
          o2 === 3 && t2.writeVarint(b(7, 1));
        }
      }
      function T(e2, t2) {
        var r2 = typeof e2;
        r2 === "string" ? t2.writeStringField(1, e2) : r2 === "boolean" ? t2.writeBooleanField(7, e2) : r2 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
      }
      function _(e2, t2, r2, o2, n2, i2) {
        if (n2 - o2 <= r2)
          return;
        const s2 = o2 + n2 >> 1;
        L(e2, t2, s2, o2, n2, i2 % 2), _(e2, t2, r2, o2, s2 - 1, i2 + 1), _(e2, t2, r2, s2 + 1, n2, i2 + 1);
      }
      function L(e2, t2, r2, o2, n2, i2) {
        for (; n2 > o2; ) {
          if (n2 - o2 > 600) {
            const s3 = n2 - o2 + 1, a3 = r2 - o2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), h4 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
            L(e2, t2, r2, Math.max(o2, Math.floor(r2 - a3 * u2 / s3 + h4)), Math.min(n2, Math.floor(r2 + (s3 - a3) * u2 / s3 + h4)), i2);
          }
          const s2 = t2[2 * r2 + i2];
          let a2 = o2, l2 = n2;
          for (C(e2, t2, o2, r2), t2[2 * n2 + i2] > s2 && C(e2, t2, o2, n2); a2 < l2; ) {
            for (C(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + i2] < s2; )
              a2++;
            for (; t2[2 * l2 + i2] > s2; )
              l2--;
          }
          t2[2 * o2 + i2] === s2 ? C(e2, t2, o2, l2) : (l2++, C(e2, t2, l2, n2)), l2 <= r2 && (o2 = l2 + 1), r2 <= l2 && (n2 = l2 - 1);
        }
      }
      function C(e2, t2, r2, o2) {
        O(e2, r2, o2), O(t2, 2 * r2, 2 * o2), O(t2, 2 * r2 + 1, 2 * o2 + 1);
      }
      function O(e2, t2, r2) {
        const o2 = e2[t2];
        e2[t2] = e2[r2], e2[r2] = o2;
      }
      function z(e2, t2, r2, o2) {
        const n2 = e2 - r2, i2 = t2 - o2;
        return n2 * n2 + i2 * i2;
      }
      f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function(e2, t2) {
        t2 = t2 || {};
        var r2 = {};
        for (var o2 in e2)
          r2[o2] = new x(e2[o2].features, t2), r2[o2].name = o2, r2[o2].version = t2.version, r2[o2].extent = t2.extent;
        return w({ layers: r2 });
      }, c.GeoJSONWrapper = x;
      const E = (e2) => e2[0], F = (e2) => e2[1];
      class N {
        constructor(e2, t2 = E, r2 = F, o2 = 64, n2 = Float64Array) {
          this.nodeSize = o2, this.points = e2;
          const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n2(2 * e2.length);
          for (let o3 = 0; o3 < e2.length; o3++)
            s2[o3] = o3, a2[2 * o3] = t2(e2[o3]), a2[2 * o3 + 1] = r2(e2[o3]);
          _(s2, a2, o2, 0, s2.length - 1, 0);
        }
        range(e2, t2, r2, o2) {
          return function(e3, t3, r3, o3, n2, i2, s2) {
            const a2 = [0, e3.length - 1, 0], l2 = [];
            let u2, h4;
            for (; a2.length; ) {
              const c2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
              if (f2 - p2 <= s2) {
                for (let s3 = p2; s3 <= f2; s3++)
                  u2 = t3[2 * s3], h4 = t3[2 * s3 + 1], u2 >= r3 && u2 <= n2 && h4 >= o3 && h4 <= i2 && l2.push(e3[s3]);
                continue;
              }
              const g2 = Math.floor((p2 + f2) / 2);
              u2 = t3[2 * g2], h4 = t3[2 * g2 + 1], u2 >= r3 && u2 <= n2 && h4 >= o3 && h4 <= i2 && l2.push(e3[g2]);
              const d2 = (c2 + 1) % 2;
              (c2 === 0 ? r3 <= u2 : o3 <= h4) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (c2 === 0 ? n2 >= u2 : i2 >= h4) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
            }
            return l2;
          }(this.ids, this.coords, e2, t2, r2, o2, this.nodeSize);
        }
        within(e2, t2, r2) {
          return function(e3, t3, r3, o2, n2, i2) {
            const s2 = [0, e3.length - 1, 0], a2 = [], l2 = n2 * n2;
            for (; s2.length; ) {
              const u2 = s2.pop(), h4 = s2.pop(), c2 = s2.pop();
              if (h4 - c2 <= i2) {
                for (let n3 = c2; n3 <= h4; n3++)
                  z(t3[2 * n3], t3[2 * n3 + 1], r3, o2) <= l2 && a2.push(e3[n3]);
                continue;
              }
              const f2 = Math.floor((c2 + h4) / 2), p2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
              z(p2, g2, r3, o2) <= l2 && a2.push(e3[f2]);
              const d2 = (u2 + 1) % 2;
              (u2 === 0 ? r3 - n2 <= p2 : o2 - n2 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (u2 === 0 ? r3 + n2 >= p2 : o2 + n2 >= g2) && (s2.push(f2 + 1), s2.push(h4), s2.push(d2));
            }
            return a2;
          }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
        }
      }
      const j = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, Z = Math.fround || (G = new Float32Array(1), (e2) => (G[0] = +e2, G[0]));
      var G;
      class J {
        constructor(e2) {
          this.options = B(Object.create(j), e2), this.trees = new Array(this.options.maxZoom + 1);
        }
        load(e2) {
          const { log: t2, minZoom: r2, maxZoom: o2, nodeSize: n2 } = this.options;
          t2 && console.time("total time");
          const i2 = `prepare ${e2.length} points`;
          t2 && console.time(i2), this.points = e2;
          let s2 = [];
          for (let t3 = 0; t3 < e2.length; t3++)
            e2[t3].geometry && s2.push(Y(e2[t3], t3));
          this.trees[o2 + 1] = new N(s2, R2, q, n2, Float32Array), t2 && console.timeEnd(i2);
          for (let e3 = o2; e3 >= r2; e3--) {
            const r3 = +Date.now();
            s2 = this._cluster(s2, e3), this.trees[e3] = new N(s2, R2, q, n2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const o2 = Math.max(-90, Math.min(90, e2[1]));
          let n2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            r2 = -180, n2 = 180;
          else if (r2 > n2) {
            const e3 = this.getClusters([r2, o2, 180, i2], t2), s3 = this.getClusters([-180, o2, n2, i2], t2);
            return e3.concat(s3);
          }
          const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(A(r2), D(i2), A(n2), D(o2)), l2 = [];
          for (const e3 of a2) {
            const t3 = s2.points[e3];
            l2.push(t3.numPoints ? X(t3) : this.points[t3.index]);
          }
          return l2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n2 = this.trees[r2];
          if (!n2)
            throw new Error(o2);
          const i2 = n2.points[t2];
          if (!i2)
            throw new Error(o2);
          const s2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = n2.within(i2.x, i2.y, s2), l2 = [];
          for (const t3 of a2) {
            const r3 = n2.points[t3];
            r3.parentId === e2 && l2.push(r3.numPoints ? X(r3) : this.points[r3.index]);
          }
          if (l2.length === 0)
            throw new Error(o2);
          return l2;
        }
        getLeaves(e2, t2, r2) {
          const o2 = [];
          return this._appendLeaves(o2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), o2;
        }
        getTile(e2, t2, r2) {
          const o2 = this.trees[this._limitZoom(e2)], n2 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l2 = (r2 - a2) / n2, u2 = (r2 + 1 + a2) / n2, h4 = { features: [] };
          return this._addTileFeatures(o2.range((t2 - a2) / n2, l2, (t2 + 1 + a2) / n2, u2), o2.points, t2, r2, n2, h4), t2 === 0 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r2, n2, h4), t2 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r2, n2, h4), h4.features.length ? h4 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (; t2 <= this.options.maxZoom; ) {
            const r2 = this.getChildren(e2);
            if (t2++, r2.length !== 1)
              break;
            e2 = r2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, r2, o2, n2) {
          const i2 = this.getChildren(t2);
          for (const t3 of i2) {
            const i3 = t3.properties;
            if (i3 && i3.cluster ? n2 + i3.point_count <= o2 ? n2 += i3.point_count : n2 = this._appendLeaves(e2, i3.cluster_id, r2, o2, n2) : n2 < o2 ? n2++ : e2.push(t3), e2.length === r2)
              break;
          }
          return n2;
        }
        _addTileFeatures(e2, t2, r2, o2, n2, i2) {
          for (const s2 of e2) {
            const e3 = t2[s2], a2 = e3.numPoints;
            let l2, u2, h4;
            if (a2)
              l2 = V(e3), u2 = e3.x, h4 = e3.y;
            else {
              const t3 = this.points[e3.index];
              l2 = t3.properties, u2 = A(t3.geometry.coordinates[0]), h4 = D(t3.geometry.coordinates[1]);
            }
            const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r2)), Math.round(this.options.extent * (h4 * n2 - o2))]], tags: l2 };
            let f2;
            a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), f2 !== void 0 && (c2.id = f2), i2.features.push(c2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const r2 = [], { radius: o2, extent: n2, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n2 * Math.pow(2, t2));
          for (let o3 = 0; o3 < e2.length; o3++) {
            const n3 = e2[o3];
            if (n3.zoom <= t2)
              continue;
            n3.zoom = t2;
            const l2 = this.trees[t2 + 1], u2 = l2.within(n3.x, n3.y, a2), h4 = n3.numPoints || 1;
            let c2 = h4;
            for (const e3 of u2) {
              const r3 = l2.points[e3];
              r3.zoom > t2 && (c2 += r3.numPoints || 1);
            }
            if (c2 > h4 && c2 >= s2) {
              let e3 = n3.x * h4, s3 = n3.y * h4, a3 = i2 && h4 > 1 ? this._map(n3, true) : null;
              const f2 = (o3 << 5) + (t2 + 1) + this.points.length;
              for (const r3 of u2) {
                const o4 = l2.points[r3];
                if (o4.zoom <= t2)
                  continue;
                o4.zoom = t2;
                const u3 = o4.numPoints || 1;
                e3 += o4.x * u3, s3 += o4.y * u3, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n3, true)), i2(a3, this._map(o4)));
              }
              n3.parentId = f2, r2.push(W(e3 / c2, s3 / c2, f2, c2, a3));
            } else if (r2.push(n3), c2 > 1)
              for (const e3 of u2) {
                const o4 = l2.points[e3];
                o4.zoom <= t2 || (o4.zoom = t2, r2.push(o4));
              }
          }
          return r2;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2) {
          if (e2.numPoints)
            return t2 ? B({}, e2.properties) : e2.properties;
          const r2 = this.points[e2.index].properties, o2 = this.options.map(r2);
          return t2 && o2 === r2 ? B({}, o2) : o2;
        }
      }
      function W(e2, t2, r2, o2, n2) {
        return { x: Z(e2), y: Z(t2), zoom: 1 / 0, id: r2, parentId: -1, numPoints: o2, properties: n2 };
      }
      function Y(e2, t2) {
        const [r2, o2] = e2.geometry.coordinates;
        return { x: Z(A(r2)), y: Z(D(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
      }
      function X(e2) {
        return { type: "Feature", id: e2.id, properties: V(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), $(e2.y)] } };
        var t2;
      }
      function V(e2) {
        const t2 = e2.numPoints, r2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
        return B(B({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
      }
      function A(e2) {
        return e2 / 360 + 0.5;
      }
      function D(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function $(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function B(e2, t2) {
        for (const r2 in t2)
          e2[r2] = t2[r2];
        return e2;
      }
      function R2(e2) {
        return e2.x;
      }
      function q(e2) {
        return e2.y;
      }
      function U(e2, t2, r2, o2) {
        for (var n2, i2 = o2, s2 = r2 - t2 >> 1, a2 = r2 - t2, l2 = e2[t2], u2 = e2[t2 + 1], h4 = e2[r2], c2 = e2[r2 + 1], f2 = t2 + 3; f2 < r2; f2 += 3) {
          var p2 = Q(e2[f2], e2[f2 + 1], l2, u2, h4, c2);
          if (p2 > i2)
            n2 = f2, i2 = p2;
          else if (p2 === i2) {
            var g2 = Math.abs(f2 - s2);
            g2 < a2 && (n2 = f2, a2 = g2);
          }
        }
        i2 > o2 && (n2 - t2 > 3 && U(e2, t2, n2, o2), e2[n2 + 2] = i2, r2 - n2 > 3 && U(e2, n2, r2, o2));
      }
      function Q(e2, t2, r2, o2, n2, i2) {
        var s2 = n2 - r2, a2 = i2 - o2;
        if (s2 !== 0 || a2 !== 0) {
          var l2 = ((e2 - r2) * s2 + (t2 - o2) * a2) / (s2 * s2 + a2 * a2);
          l2 > 1 ? (r2 = n2, o2 = i2) : l2 > 0 && (r2 += s2 * l2, o2 += a2 * l2);
        }
        return (s2 = e2 - r2) * s2 + (a2 = t2 - o2) * a2;
      }
      function H(e2, t2, r2, o2) {
        var n2 = { id: e2 === void 0 ? null : e2, type: t2, geometry: r2, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(e3) {
          var t3 = e3.geometry, r3 = e3.type;
          if (r3 === "Point" || r3 === "MultiPoint" || r3 === "LineString")
            K(e3, t3);
          else if (r3 === "Polygon" || r3 === "MultiLineString")
            for (var o3 = 0; o3 < t3.length; o3++)
              K(e3, t3[o3]);
          else if (r3 === "MultiPolygon")
            for (o3 = 0; o3 < t3.length; o3++)
              for (var n3 = 0; n3 < t3[o3].length; n3++)
                K(e3, t3[o3][n3]);
        }(n2), n2;
      }
      function K(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2 += 3)
          e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
      }
      function ee(e2, t2, r2, o2) {
        if (t2.geometry) {
          var n2 = t2.geometry.coordinates, i2 = t2.geometry.type, s2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), a2 = [], l2 = t2.id;
          if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = o2 || 0), i2 === "Point")
            te(n2, a2);
          else if (i2 === "MultiPoint")
            for (var u2 = 0; u2 < n2.length; u2++)
              te(n2[u2], a2);
          else if (i2 === "LineString")
            re(n2, a2, s2, false);
          else if (i2 === "MultiLineString") {
            if (r2.lineMetrics) {
              for (u2 = 0; u2 < n2.length; u2++)
                re(n2[u2], a2 = [], s2, false), e2.push(H(l2, "LineString", a2, t2.properties));
              return;
            }
            oe(n2, a2, s2, false);
          } else if (i2 === "Polygon")
            oe(n2, a2, s2, true);
          else {
            if (i2 !== "MultiPolygon") {
              if (i2 === "GeometryCollection") {
                for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                  ee(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, o2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (u2 = 0; u2 < n2.length; u2++) {
              var h4 = [];
              oe(n2[u2], h4, s2, true), a2.push(h4);
            }
          }
          e2.push(H(l2, i2, a2, t2.properties));
        }
      }
      function te(e2, t2) {
        t2.push(ne(e2[0])), t2.push(ie(e2[1])), t2.push(0);
      }
      function re(e2, t2, r2, o2) {
        for (var n2, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
          var l2 = ne(e2[a2][0]), u2 = ie(e2[a2][1]);
          t2.push(l2), t2.push(u2), t2.push(0), a2 > 0 && (s2 += o2 ? (n2 * u2 - l2 * i2) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i2, 2))), n2 = l2, i2 = u2;
        }
        var h4 = t2.length - 3;
        t2[2] = 1, U(t2, 0, h4, r2), t2[h4 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
      }
      function oe(e2, t2, r2, o2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          var i2 = [];
          re(e2[n2], i2, r2, o2), t2.push(i2);
        }
      }
      function ne(e2) {
        return e2 / 360 + 0.5;
      }
      function ie(e2) {
        var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function se(e2, t2, r2, o2, n2, i2, s2, a2) {
        if (o2 /= t2, i2 >= (r2 /= t2) && s2 < o2)
          return e2;
        if (s2 < r2 || i2 >= o2)
          return null;
        for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
          var h4 = e2[u2], c2 = h4.geometry, f2 = h4.type, p2 = n2 === 0 ? h4.minX : h4.minY, g2 = n2 === 0 ? h4.maxX : h4.maxY;
          if (p2 >= r2 && g2 < o2)
            l2.push(h4);
          else if (!(g2 < r2 || p2 >= o2)) {
            var d2 = [];
            if (f2 === "Point" || f2 === "MultiPoint")
              ae(c2, d2, r2, o2, n2);
            else if (f2 === "LineString")
              le(c2, d2, r2, o2, n2, false, a2.lineMetrics);
            else if (f2 === "MultiLineString")
              he(c2, d2, r2, o2, n2, false);
            else if (f2 === "Polygon")
              he(c2, d2, r2, o2, n2, true);
            else if (f2 === "MultiPolygon")
              for (var m2 = 0; m2 < c2.length; m2++) {
                var y2 = [];
                he(c2[m2], y2, r2, o2, n2, true), y2.length && d2.push(y2);
              }
            if (d2.length) {
              if (a2.lineMetrics && f2 === "LineString") {
                for (m2 = 0; m2 < d2.length; m2++)
                  l2.push(H(h4.id, f2, d2[m2], h4.tags));
                continue;
              }
              f2 !== "LineString" && f2 !== "MultiLineString" || (d2.length === 1 ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), f2 !== "Point" && f2 !== "MultiPoint" || (f2 = d2.length === 3 ? "Point" : "MultiPoint"), l2.push(H(h4.id, f2, d2, h4.tags));
            }
          }
        }
        return l2.length ? l2 : null;
      }
      function ae(e2, t2, r2, o2, n2) {
        for (var i2 = 0; i2 < e2.length; i2 += 3) {
          var s2 = e2[i2 + n2];
          s2 >= r2 && s2 <= o2 && (t2.push(e2[i2]), t2.push(e2[i2 + 1]), t2.push(e2[i2 + 2]));
        }
      }
      function le(e2, t2, r2, o2, n2, i2, s2) {
        for (var a2, l2, u2 = ue(e2), h4 = n2 === 0 ? fe : pe, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
          var p2 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v3 = n2 === 0 ? p2 : g2, x2 = n2 === 0 ? m2 : y2, w2 = false;
          s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(g2 - y2, 2))), v3 < r2 ? x2 > r2 && (l2 = h4(u2, p2, g2, m2, y2, r2), s2 && (u2.start = c2 + a2 * l2)) : v3 > o2 ? x2 < o2 && (l2 = h4(u2, p2, g2, m2, y2, o2), s2 && (u2.start = c2 + a2 * l2)) : ce(u2, p2, g2, d2), x2 < r2 && v3 >= r2 && (l2 = h4(u2, p2, g2, m2, y2, r2), w2 = true), x2 > o2 && v3 <= o2 && (l2 = h4(u2, p2, g2, m2, y2, o2), w2 = true), !i2 && w2 && (s2 && (u2.end = c2 + a2 * l2), t2.push(u2), u2 = ue(e2)), s2 && (c2 += a2);
        }
        var S2 = e2.length - 3;
        p2 = e2[S2], g2 = e2[S2 + 1], d2 = e2[S2 + 2], (v3 = n2 === 0 ? p2 : g2) >= r2 && v3 <= o2 && ce(u2, p2, g2, d2), S2 = u2.length - 3, i2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && ce(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
      }
      function ue(e2) {
        var t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function he(e2, t2, r2, o2, n2, i2) {
        for (var s2 = 0; s2 < e2.length; s2++)
          le(e2[s2], t2, r2, o2, n2, i2, false);
      }
      function ce(e2, t2, r2, o2) {
        e2.push(t2), e2.push(r2), e2.push(o2);
      }
      function fe(e2, t2, r2, o2, n2, i2) {
        var s2 = (i2 - t2) / (o2 - t2);
        return e2.push(i2), e2.push(r2 + (n2 - r2) * s2), e2.push(1), s2;
      }
      function pe(e2, t2, r2, o2, n2, i2) {
        var s2 = (i2 - r2) / (n2 - r2);
        return e2.push(t2 + (o2 - t2) * s2), e2.push(i2), e2.push(1), s2;
      }
      function ge(e2, t2) {
        for (var r2 = [], o2 = 0; o2 < e2.length; o2++) {
          var n2, i2 = e2[o2], s2 = i2.type;
          if (s2 === "Point" || s2 === "MultiPoint" || s2 === "LineString")
            n2 = de(i2.geometry, t2);
          else if (s2 === "MultiLineString" || s2 === "Polygon") {
            n2 = [];
            for (var a2 = 0; a2 < i2.geometry.length; a2++)
              n2.push(de(i2.geometry[a2], t2));
          } else if (s2 === "MultiPolygon")
            for (n2 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
              for (var l2 = [], u2 = 0; u2 < i2.geometry[a2].length; u2++)
                l2.push(de(i2.geometry[a2][u2], t2));
              n2.push(l2);
            }
          r2.push(H(i2.id, s2, n2, i2.tags));
        }
        return r2;
      }
      function de(e2, t2) {
        var r2 = [];
        r2.size = e2.size, e2.start !== void 0 && (r2.start = e2.start, r2.end = e2.end);
        for (var o2 = 0; o2 < e2.length; o2 += 3)
          r2.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
        return r2;
      }
      function me(e2, t2) {
        if (e2.transformed)
          return e2;
        var r2, o2, n2, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
        for (r2 = 0; r2 < e2.features.length; r2++) {
          var l2 = e2.features[r2], u2 = l2.geometry, h4 = l2.type;
          if (l2.geometry = [], h4 === 1)
            for (o2 = 0; o2 < u2.length; o2 += 2)
              l2.geometry.push(ye(u2[o2], u2[o2 + 1], t2, i2, s2, a2));
          else
            for (o2 = 0; o2 < u2.length; o2++) {
              var c2 = [];
              for (n2 = 0; n2 < u2[o2].length; n2 += 2)
                c2.push(ye(u2[o2][n2], u2[o2][n2 + 1], t2, i2, s2, a2));
              l2.geometry.push(c2);
            }
        }
        return e2.transformed = true, e2;
      }
      function ye(e2, t2, r2, o2, n2, i2) {
        return [Math.round(r2 * (e2 * o2 - n2)), Math.round(r2 * (t2 * o2 - i2))];
      }
      function ve(e2, t2, r2, o2, n2) {
        for (var i2 = t2 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t2) * n2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
          s2.numFeatures++, xe(s2, e2[a2], i2, n2);
          var l2 = e2[a2].minX, u2 = e2[a2].minY, h4 = e2[a2].maxX, c2 = e2[a2].maxY;
          l2 < s2.minX && (s2.minX = l2), u2 < s2.minY && (s2.minY = u2), h4 > s2.maxX && (s2.maxX = h4), c2 > s2.maxY && (s2.maxY = c2);
        }
        return s2;
      }
      function xe(e2, t2, r2, o2) {
        var n2 = t2.geometry, i2 = t2.type, s2 = [];
        if (i2 === "Point" || i2 === "MultiPoint")
          for (var a2 = 0; a2 < n2.length; a2 += 3)
            s2.push(n2[a2]), s2.push(n2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
        else if (i2 === "LineString")
          we(s2, n2, e2, r2, false, false);
        else if (i2 === "MultiLineString" || i2 === "Polygon")
          for (a2 = 0; a2 < n2.length; a2++)
            we(s2, n2[a2], e2, r2, i2 === "Polygon", a2 === 0);
        else if (i2 === "MultiPolygon")
          for (var l2 = 0; l2 < n2.length; l2++) {
            var u2 = n2[l2];
            for (a2 = 0; a2 < u2.length; a2++)
              we(s2, u2[a2], e2, r2, true, a2 === 0);
          }
        if (s2.length) {
          var h4 = t2.tags || null;
          if (i2 === "LineString" && o2.lineMetrics) {
            for (var c2 in h4 = {}, t2.tags)
              h4[c2] = t2.tags[c2];
            h4.mapbox_clip_start = n2.start / n2.size, h4.mapbox_clip_end = n2.end / n2.size;
          }
          var f2 = { geometry: s2, type: i2 === "Polygon" || i2 === "MultiPolygon" ? 3 : i2 === "LineString" || i2 === "MultiLineString" ? 2 : 1, tags: h4 };
          t2.id !== null && (f2.id = t2.id), e2.features.push(f2);
        }
      }
      function we(e2, t2, r2, o2, n2, i2) {
        var s2 = o2 * o2;
        if (o2 > 0 && t2.size < (n2 ? s2 : o2))
          r2.numPoints += t2.length / 3;
        else {
          for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
            (o2 === 0 || t2[l2 + 2] > s2) && (r2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r2.numPoints++;
          n2 && function(e3, t3) {
            for (var r3 = 0, o3 = 0, n3 = e3.length, i3 = n3 - 2; o3 < n3; i3 = o3, o3 += 2)
              r3 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
            if (r3 > 0 === t3)
              for (o3 = 0, n3 = e3.length; o3 < n3 / 2; o3 += 2) {
                var s3 = e3[o3], a3 = e3[o3 + 1];
                e3[o3] = e3[n3 - 2 - o3], e3[o3 + 1] = e3[n3 - 1 - o3], e3[n3 - 2 - o3] = s3, e3[n3 - 1 - o3] = a3;
              }
          }(a2, i2), e2.push(a2);
        }
      }
      function Se(e2, t2) {
        var r2 = (t2 = this.options = function(e3, t3) {
          for (var r3 in t3)
            e3[r3] = t3[r3];
          return e3;
        }(Object.create(this.options), t2)).debug;
        if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (t2.promoteId && t2.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var o2 = function(e3, t3) {
          var r3 = [];
          if (e3.type === "FeatureCollection")
            for (var o3 = 0; o3 < e3.features.length; o3++)
              ee(r3, e3.features[o3], t3, o3);
          else
            ee(r3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
          return r3;
        }(e2, t2);
        this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t3) {
          var r3 = t3.buffer / t3.extent, o3 = e3, n2 = se(e3, 1, -1 - r3, r3, 0, -1, 2, t3), i2 = se(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
          return (n2 || i2) && (o3 = se(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], n2 && (o3 = ge(n2, 1).concat(o3)), i2 && (o3 = o3.concat(ge(i2, -1)))), o3;
        }(o2, t2), o2.length && this.splitTile(o2, 0, 0, 0), r2 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function Me(e2, t2, r2) {
        return 32 * ((1 << e2) * r2 + t2) + e2;
      }
      function Pe(e2, t2) {
        const r2 = e2.tileID.canonical;
        if (!this._geoJSONIndex)
          return t2(null, null);
        const o2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
        if (!o2)
          return t2(null, null);
        const n2 = new h3(o2.features);
        let i2 = c(n2);
        i2.byteOffset === 0 && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t2(null, { vectorTile: n2, rawData: i2.buffer });
      }
      Se.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, Se.prototype.splitTile = function(e2, t2, r2, o2, n2, i2, s2) {
        for (var a2 = [e2, t2, r2, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
          o2 = a2.pop(), r2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
          var h4 = 1 << t2, c2 = Me(t2, r2, o2), f2 = this.tiles[c2];
          if (!f2 && (u2 > 1 && console.time("creation"), f2 = this.tiles[c2] = ve(e2, t2, r2, o2, l2), this.tileCoords.push({ z: t2, x: r2, y: o2 }), u2)) {
            u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
            var p2 = "z" + t2;
            this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
          }
          if (f2.source = e2, n2) {
            if (t2 === l2.maxZoom || t2 === n2)
              continue;
            var g2 = 1 << n2 - t2;
            if (r2 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2))
              continue;
          } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints)
            continue;
          if (f2.source = null, e2.length !== 0) {
            u2 > 1 && console.time("clipping");
            var d2, m2, y2, v3, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
            d2 = m2 = y2 = v3 = null, x2 = se(e2, h4, r2 - S2, r2 + P2, 0, f2.minX, f2.maxX, l2), w2 = se(e2, h4, r2 + M2, r2 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x2 && (d2 = se(x2, h4, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), m2 = se(x2, h4, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), x2 = null), w2 && (y2 = se(w2, h4, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), v3 = se(w2, h4, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t2 + 1, 2 * r2, 2 * o2), a2.push(m2 || [], t2 + 1, 2 * r2, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * o2), a2.push(v3 || [], t2 + 1, 2 * r2 + 1, 2 * o2 + 1);
          }
        }
      }, Se.prototype.getTile = function(e2, t2, r2) {
        var o2 = this.options, n2 = o2.extent, i2 = o2.debug;
        if (e2 < 0 || e2 > 24)
          return null;
        var s2 = 1 << e2, a2 = Me(e2, t2 = (t2 % s2 + s2) % s2, r2);
        if (this.tiles[a2])
          return me(this.tiles[a2], n2);
        i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
        for (var l2, u2 = e2, h4 = t2, c2 = r2; !l2 && u2 > 0; )
          u2--, h4 = Math.floor(h4 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[Me(u2, h4, c2)];
        return l2 && l2.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h4, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h4, c2, e2, t2, r2), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? me(this.tiles[a2], n2) : null) : null;
      };
      class be extends e.VectorTileWorkerSource {
        constructor(e2, t2, r2, o2, n2) {
          super(e2, t2, r2, o2, Pe), n2 && (this.loadGeoJSON = n2);
        }
        loadData(t2, r2) {
          const o2 = t2 && t2.request, n2 = o2 && o2.collectResourceTiming;
          this.loadGeoJSON(t2, (s2, a2) => {
            if (s2 || !a2)
              return r2(s2);
            if (typeof a2 != "object")
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            {
              i(a2, true);
              try {
                if (t2.filter) {
                  const r3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if (r3.result === "error")
                    throw new Error(r3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const o3 = a2.features.filter((e2) => r3.value.evaluate({ zoom: 0 }, e2));
                  a2 = { type: "FeatureCollection", features: o3 };
                }
                this._geoJSONIndex = t2.cluster ? new J(function({ superclusterOptions: t3, clusterProperties: r3 }) {
                  if (!r3 || !t3)
                    return t3;
                  const o3 = {}, n3 = {}, i2 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a3 = Object.keys(r3);
                  for (const t4 of a3) {
                    const [i3, s4] = r3[t4], a4 = e.createExpression(s4), l3 = e.createExpression(typeof i3 == "string" ? [i3, ["accumulated"], ["get", t4]] : i3);
                    o3[t4] = a4.value, n3[t4] = l3.value;
                  }
                  return t3.map = (e2) => {
                    s3.properties = e2;
                    const t4 = {};
                    for (const e3 of a3)
                      t4[e3] = o3[e3].evaluate(i2, s3);
                    return t4;
                  }, t3.reduce = (e2, t4) => {
                    s3.properties = t4;
                    for (const t5 of a3)
                      i2.accumulated = e2[t5], e2[t5] = n3[t5].evaluate(i2, s3);
                  }, t3;
                }(t2)).load(a2.features) : function(e2, t3) {
                  return new Se(e2, t3);
                }(a2, t2.geojsonVtOptions);
              } catch (s3) {
                return r2(s3);
              }
              this.loaded = {};
              const l2 = {};
              if (n2) {
                const r3 = e.getPerformanceMeasurement(o2);
                r3 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r3)));
              }
              r2(null, l2);
            }
          });
        }
        reloadTile(e2, t2) {
          const r2 = this.loaded;
          return r2 && r2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
        }
        loadGeoJSON(t2, r2) {
          if (t2.request)
            e.getJSON(t2.request, r2);
          else {
            if (typeof t2.data != "string")
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            try {
              return r2(null, JSON.parse(t2.data));
            } catch (e2) {
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterChildren(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterLeaves(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          } catch (e3) {
            t2(e3);
          }
        }
      }
      class ke {
        constructor(t2) {
          this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: be }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
            if (this.workerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.workerSourceTypes[e2] = t3;
          }, this.self.registerRTLTextPlugin = (t3) => {
            if (e.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        }
        clearCaches(e2, t2, r2) {
          delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], r2();
        }
        checkIfReady(e2, t2, r2) {
          r2();
        }
        setReferrer(e2, t2) {
          this.referrer = t2;
        }
        spriteLoaded(t2, r2) {
          this.isSpriteLoaded[t2] = r2;
          for (const o2 in this.workerSources[t2]) {
            const n2 = this.workerSources[t2][o2];
            for (const t3 in n2)
              n2[t3] instanceof e.VectorTileWorkerSource && (n2[t3].isSpriteLoaded = r2, n2[t3].fire(new e.Event("isSpriteLoaded")));
          }
        }
        setImages(e2, t2, r2) {
          this.availableImages[e2] = t2;
          for (const r3 in this.workerSources[e2]) {
            const o2 = this.workerSources[e2][r3];
            for (const e3 in o2)
              o2[e3].availableImages = t2;
          }
          r2();
        }
        enableTerrain(e2, t2, r2) {
          this.terrain = t2, r2();
        }
        setProjection(t2, r2) {
          this.projections[t2] = e.getProjection(r2);
        }
        setLayers(e2, t2, r2) {
          this.getLayerIndex(e2).replace(t2), r2();
        }
        updateLayers(e2, t2, r2) {
          this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
        }
        loadTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
          n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).loadTile(n2, o2);
        }
        loadDEMTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r2) : r2;
          this.getDEMWorkerSource(t2, r2.source).loadTile(n2, o2);
        }
        reloadTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
          n2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).reloadTile(n2, o2);
        }
        abortTile(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
        }
        removeTile(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
        }
        removeSource(e2, t2, r2) {
          if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
            return;
          const o2 = this.workerSources[e2][t2.type][t2.source];
          delete this.workerSources[e2][t2.type][t2.source], o2.removeSource !== void 0 ? o2.removeSource(t2, r2) : r2();
        }
        loadWorkerSource(e2, t2, r2) {
          try {
            this.self.importScripts(t2.url), r2();
          } catch (e3) {
            r2(e3.toString());
          }
        }
        syncRTLPluginState(t2, r2, o2) {
          try {
            e.plugin.setState(r2);
            const t3 = e.plugin.getPluginURL();
            if (e.plugin.isLoaded() && !e.plugin.isParsed() && t3 != null) {
              this.self.importScripts(t3);
              const r3 = e.plugin.isParsed();
              o2(r3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r3);
            }
          } catch (e2) {
            o2(e2.toString());
          }
        }
        getAvailableImages(e2) {
          let t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }
        getLayerIndex(e2) {
          let t2 = this.layerIndexes[e2];
          return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
        }
        getWorkerSource(e2, t2, r2) {
          if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r2]) {
            const o2 = { send: (t3, r3, o3, n2, i2, s2) => {
              this.actor.send(t3, r3, o3, e2, i2, s2);
            }, scheduler: this.actor.scheduler };
            this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2](o2, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded[e2]);
          }
          return this.workerSources[e2][t2][r2];
        }
        getDEMWorkerSource(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
        }
        enforceCacheSizeLimit(t2, r2) {
          e.enforceCacheSizeLimit(r2);
        }
        getWorkerPerformanceMetrics(e2, t2, r2) {
          r2(void 0, void 0);
        }
      }
      return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
    });
    define(["./shared"], function(e) {
      function t(e2, i2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(i2) || e2.length !== i2.length)
            return false;
          for (let o2 = 0; o2 < e2.length; o2++)
            if (!t(e2[o2], i2[o2]))
              return false;
          return true;
        }
        if (typeof e2 == "object" && e2 !== null && i2 !== null) {
          if (typeof i2 != "object")
            return false;
          if (Object.keys(e2).length !== Object.keys(i2).length)
            return false;
          for (const o2 in e2)
            if (!t(e2[o2], i2[o2]))
              return false;
          return true;
        }
        return e2 === i2;
      }
      var i = o;
      function o(e2) {
        return !function(e3) {
          return "not a browser";
        }();
      }
      function n(t2, i2, o2) {
        const r = e.window.document.createElement(t2);
        return i2 !== void 0 && (r.className = i2), o2 && o2.appendChild(r), r;
      }
      function s(t2, i2, o2) {
        const r = e.window.document.createElementNS("http://www.w3.org/2000/svg", t2);
        for (const e2 of Object.keys(i2))
          r.setAttributeNS(null, e2, i2[e2]);
        return o2 && o2.appendChild(r), r;
      }
      o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const a = e.window.document && e.window.document.documentElement.style, l = a && a.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
      let c;
      function h3() {
        a && l && (c = a[l], a[l] = "none");
      }
      function u() {
        a && l && (a[l] = c);
      }
      function _(t2) {
        t2.preventDefault(), t2.stopPropagation(), e.window.removeEventListener("click", _, true);
      }
      function d() {
        e.window.addEventListener("click", _, true), e.window.setTimeout(() => {
          e.window.removeEventListener("click", _, true);
        }, 0);
      }
      function p(e2, t2) {
        const i2 = e2.getBoundingClientRect();
        return g(e2, i2, t2);
      }
      function m(e2, t2) {
        const i2 = e2.getBoundingClientRect(), o2 = [];
        for (let r = 0; r < t2.length; r++)
          o2.push(g(e2, i2, t2[r]));
        return o2;
      }
      function f(t2) {
        return e.window.InstallTrigger !== void 0 && t2.button === 2 && t2.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
      }
      function g(t2, i2, o2) {
        const r = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
        return new e.pointGeometry((o2.clientX - i2.left) * r, (o2.clientY - i2.top) * r);
      }
      function v2(e2, t2) {
        var i2 = t2[0], o2 = t2[1], r = t2[2], n2 = t2[3], s2 = i2 * n2 - r * o2;
        return s2 ? (e2[0] = n2 * (s2 = 1 / s2), e2[1] = -o2 * s2, e2[2] = -r * s2, e2[3] = i2 * s2, e2) : null;
      }
      function x(e2) {
        const { userImage: t2 } = e2;
        return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
      }
      class y extends e.Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e2) {
          if (this.loaded !== e2 && (this.loaded = e2, e2)) {
            for (const { ids: e3, callback: t2 } of this.requestors)
              this._notify(e3, t2);
            this.requestors = [];
          }
        }
        hasImage(e2) {
          return !!this.getImage(e2);
        }
        getImage(e2) {
          return this.images[e2];
        }
        addImage(e2, t2) {
          this._validate(e2, t2) && (this.images[e2] = t2);
        }
        _validate(t2, i2) {
          let o2 = true;
          return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
        }
        _validateStretch(e2, t2) {
          if (!e2)
            return true;
          let i2 = 0;
          for (const o2 of e2) {
            if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
              return false;
            i2 = o2[1];
          }
          return true;
        }
        _validateContent(e2, t2) {
          return !(e2 && (e2.length !== 4 || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
        }
        updateImage(e2, t2) {
          t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
        }
        removeImage(e2) {
          const t2 = this.images[e2];
          delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e2, t2) {
          let i2 = true;
          if (!this.isLoaded())
            for (const t3 of e2)
              this.images[t3] || (i2 = false);
          this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
        }
        _notify(t2, i2) {
          const o2 = {};
          for (const i3 of t2) {
            this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
            const t3 = this.images[i3];
            t3 ? o2[i3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          i2(null, o2);
        }
        getPixelSize() {
          const { width: e2, height: t2 } = this.atlasImage;
          return { width: e2, height: t2 };
        }
        getPattern(t2) {
          const i2 = this.patterns[t2], o2 = this.getImage(t2);
          if (!o2)
            return null;
          if (i2 && i2.position.version === o2.version)
            return i2.position;
          if (i2)
            i2.position.version = o2.version;
          else {
            const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r = new e.ImagePosition(i3, o2);
            this.patterns[t2] = { bin: i3, position: r };
          }
          return this._updatePatternAtlas(), this.patterns[t2].position;
        }
        bind(t2) {
          const i2 = t2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t2, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t2 = [];
          for (const e2 in this.patterns)
            t2.push(this.patterns[e2].bin);
          const { w: i2, h: o2 } = e.potpack(t2), r = this.atlasImage;
          r.resize({ width: i2 || 1, height: o2 || 1 });
          for (const t3 in this.patterns) {
            const { bin: i3 } = this.patterns[t3], o3 = i3.x + 1, n2 = i3.y + 1, s2 = this.images[t3].data, a2 = s2.width, l2 = s2.height;
            e.RGBAImage.copy(s2, r, { x: 0, y: 0 }, { x: o3, y: n2 }, { width: a2, height: l2 }), e.RGBAImage.copy(s2, r, { x: 0, y: l2 - 1 }, { x: o3, y: n2 - 1 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r, { x: 0, y: 0 }, { x: o3, y: n2 + l2 }, { width: a2, height: 1 }), e.RGBAImage.copy(s2, r, { x: a2 - 1, y: 0 }, { x: o3 - 1, y: n2 }, { width: 1, height: l2 }), e.RGBAImage.copy(s2, r, { x: 0, y: 0 }, { x: o3 + a2, y: n2 }, { width: 1, height: l2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const t2 of e2) {
            if (this.callbackDispatchedThisFrame[t2])
              continue;
            this.callbackDispatchedThisFrame[t2] = true;
            const e3 = this.images[t2];
            x(e3) && this.updateImage(t2, e3);
          }
        }
      }
      const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
        constructor() {
          this.specification = e.spec.light.position;
        }
        possiblyEvaluate(t2, i2) {
          return function([t3, i3, o2]) {
            const r = e.degToRad(i3 + 90), n2 = e.degToRad(o2);
            return { x: t3 * Math.cos(r) * Math.sin(n2), y: t3 * Math.sin(r) * Math.sin(n2), z: t3 * Math.cos(n2), azimuthal: i3, polar: o2 };
          }(t2.expression.evaluate(i2));
        }
        interpolate(t2, i2, o2) {
          return { x: e.number(t2.x, i2.x, o2), y: e.number(t2.y, i2.y, o2), z: e.number(t2.z, i2.z, o2), azimuthal: e.number(t2.azimuthal, i2.azimuthal, o2), polar: e.number(t2.polar, i2.polar, o2) };
        }
      }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), w = "-transition";
      class T extends e.Evented {
        constructor(t2) {
          super(), this._transitionable = new e.Transitionable(b), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t2, i2 = {}) {
          if (!this._validate(e.validateLight, t2, i2))
            for (const i3 in t2) {
              const o2 = t2[i3];
              e.endsWith(i3, w) ? this._transitionable.setTransition(i3.slice(0, -w.length), o2) : this._transitionable.setValue(i3, o2);
            }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t2, i2, o2) {
          return (!o2 || o2.validate !== false) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      const E = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), C = "-transition";
      class M extends e.Evented {
        constructor(t2, i2) {
          super(), this._transitionable = new e.Transitionable(E), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t2) {
          for (const i2 in t2) {
            const o2 = t2[i2];
            e.endsWith(i2, C) ? this._transitionable.setTransition(i2.slice(0, -C.length), o2) : this._transitionable.setValue(i2, o2);
          }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
      }
      function I(t2, i2, o2, r) {
        const n2 = e.smoothstep(45, 65, o2), [s2, a2] = S(t2, r), l2 = e.length(i2);
        let c2 = 1 - Math.min(1, Math.exp((l2 - s2) / (a2 - s2) * -6));
        return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n2 * t2.alpha;
      }
      function S(e2, t2) {
        const i2 = 0.5 / Math.tan(0.5 * t2);
        return [e2.range[0] + i2, e2.range[1] + i2];
      }
      const D = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }), L = "-transition";
      class A extends e.Evented {
        constructor(t2, i2) {
          super(), this._transitionable = new e.Transitionable(D), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
        }
        get state() {
          const t2 = this._transform, i2 = t2.projection.name === "globe", o2 = e.globeToMercatorTransition(t2.zoom), r = this.properties.get("range"), n2 = [0.5, 3];
          return { range: i2 ? [e.number(n2[0], r[0], o2), e.number(n2[1], r[1], o2)] : r, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t2, i2 = {}) {
          if (!this._validate(e.validateFog, t2, i2)) {
            for (const i3 of Object.keys(e.spec.fog))
              t2 && t2[i3] === void 0 && (t2[i3] = e.spec.fog[i3].default);
            for (const i3 in t2) {
              const o2 = t2[i3];
              e.endsWith(i3, L) ? this._transitionable.setTransition(i3.slice(0, -L.length), o2) : this._transitionable.setValue(i3, o2);
            }
          }
        }
        getOpacity(t2) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const i2 = this.properties && this.properties.get("color") || 1;
          return (this._transform.projection.name === "globe" ? 1 : e.smoothstep(45, 65, t2)) * i2.a;
        }
        getOpacityAtLatLng(t2, i2) {
          return this._transform.projection.supportsFog ? function(t3, i3, o2) {
            const r = e.MercatorCoordinate.fromLngLat(i3), n2 = o2.elevation ? o2.elevation.getAtPointOrZero(r) : 0, s2 = [r.x, r.y, n2];
            return e.transformMat4(s2, s2, o2.mercatorFogMatrix), I(t3, s2, o2.pitch, o2._fov);
          }(this.state, t2, i2) : 0;
        }
        getFovAdjustedRange(e2) {
          return this._transform.projection.supportsFog ? S(this.state, e2) : [0, 1];
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t2, i2, o2) {
          return (!o2 || o2.validate !== false) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      class z {
        constructor(t2, i2) {
          this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
          const o2 = this.workerPool.acquire(this.id);
          for (let e2 = 0; e2 < o2.length; e2++) {
            const t3 = new z.Actor(o2[e2], i2, this.id);
            t3.name = `Worker ${e2}`, this.actors.push(t3);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t2, i2, o2) {
          e.asyncAll(this.actors, (e2, o3) => {
            e2.send(t2, i2, o3);
          }, o2 = o2 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e2) => {
            e2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function P(t2, i2, o2) {
        return i2 * (e.EXTENT / (t2.tileSize * Math.pow(2, o2 - t2.tileID.overscaledZ)));
      }
      z.Actor = e.Actor;
      class R2 {
        constructor(e2, t2, i2, o2) {
          this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
        }
        static createFromScreenPoints(t2, i2) {
          let o2, r;
          if (t2 instanceof e.pointGeometry || typeof t2[0] == "number") {
            const n2 = e.pointGeometry.convert(t2);
            o2 = [n2], r = i2.isPointAboveHorizon(n2);
          } else {
            const n2 = e.pointGeometry.convert(t2[0]), s2 = e.pointGeometry.convert(t2[1]);
            o2 = [n2, s2], r = e.polygonizeBounds(n2, s2).every((e2) => i2.isPointAboveHorizon(e2));
          }
          return new R2(o2, i2.getCameraPoint(), r, i2);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(t2) {
          return e.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t2);
        }
        bufferedCameraGeometry(t2) {
          const i2 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r = e.polygonizeBounds(i2, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t2);
        }
        bufferedCameraGeometryGlobe(t2) {
          const i2 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r = e.polygonizeBounds(i2, o2, t2), n2 = this.cameraPoint.clone();
          switch (3 * ((n2.y > i2.y) + (n2.y > o2.y)) + ((n2.x > i2.x) + (n2.x > o2.x))) {
            case 0:
              r[0] = n2, r[4] = n2.clone();
              break;
            case 1:
              r.splice(1, 0, n2);
              break;
            case 2:
              r[1] = n2;
              break;
            case 3:
              r.splice(4, 0, n2);
              break;
            case 5:
              r.splice(2, 0, n2);
              break;
            case 6:
              r[3] = n2;
              break;
            case 7:
              r.splice(3, 0, n2);
              break;
            case 8:
              r[2] = n2;
          }
          return r;
        }
        containsTile(t2, i2, o2, r = 0) {
          const n2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, s2 = o2 ? this._bufferedCameraMercator(n2, i2) : this._bufferedScreenMercator(n2, i2);
          let a2 = t2.tileID.wrap + (s2.unwrapped ? r : 0);
          const l2 = s2.polygon.map((i3) => e.getTilePoint(t2.tileTransform, i3, a2));
          if (!e.polygonIntersectsBox(l2, 0, 0, e.EXTENT, e.EXTENT))
            return;
          a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
          const c2 = this.screenGeometryMercator.polygon.map((i3) => e.getTileVec3(t2.tileTransform, i3, a2)), h4 = c2.map((t3) => new e.pointGeometry(t3[0], t3[1])), u2 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), _2 = e.getTileVec3(t2.tileTransform, u2, a2), d2 = c2.map((t3) => {
            const i3 = e.sub(t3, t3, _2);
            return e.normalize(i3, i3), new e.Ray(_2, i3);
          }), p2 = P(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: h4, tilespaceRays: d2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m2 = e.getBounds(l2), m2.min.x = e.clamp(m2.min.x, 0, e.EXTENT), m2.min.y = e.clamp(m2.min.y, 0, e.EXTENT), m2.max.x = e.clamp(m2.max.x, 0, e.EXTENT), m2.max.y = e.clamp(m2.max.y, 0, e.EXTENT), m2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
          var m2;
        }
        _bufferedScreenMercator(e2, t2) {
          const i2 = k(e2);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            let o2;
            return o2 = t2.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
          }
        }
        _bufferedCameraMercator(e2, t2) {
          const i2 = k(e2);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            let o2;
            return o2 = t2.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
          }
        }
        _projectAndResample(t2, i2) {
          const o2 = function(t3, i3) {
            const o3 = e.multiply([], i3.pixelMatrix, i3.globeMatrix), r2 = [0, -e.GLOBE_RADIUS, 0, 1], n2 = [0, e.GLOBE_RADIUS, 0, 1], s2 = [0, 0, 0, 1];
            e.transformMat4$1(r2, r2, o3), e.transformMat4$1(n2, n2, o3), e.transformMat4$1(s2, s2, o3);
            const a2 = new e.pointGeometry(r2[0] / r2[3], r2[1] / r2[3]), l2 = new e.pointGeometry(n2[0] / n2[3], n2[1] / n2[3]), c2 = e.polygonContainsPoint(t3, a2) && r2[3] < s2[3], h4 = e.polygonContainsPoint(t3, l2) && n2[3] < s2[3];
            if (!c2 && !h4)
              return null;
            const u2 = function(e2, t4, i4) {
              for (let o4 = 1; o4 < e2.length; o4++) {
                const r3 = B(t4.pointCoordinate3D(e2[o4 - 1]).x), n3 = B(t4.pointCoordinate3D(e2[o4]).x);
                if (i4 < 0) {
                  if (r3 < n3)
                    return { idx: o4, t: -r3 / (n3 - 1 - r3) };
                } else if (n3 < r3)
                  return { idx: o4, t: (1 - r3) / (n3 + 1 - r3) };
              }
              return null;
            }(t3, i3, c2 ? -1 : 1);
            if (!u2)
              return null;
            const { idx: _2, t: d2 } = u2;
            let p2 = _2 > 1 ? O(t3.slice(0, _2), i3) : [], m2 = _2 < t3.length ? O(t3.slice(_2), i3) : [];
            p2 = p2.map((t4) => new e.pointGeometry(B(t4.x), t4.y)), m2 = m2.map((t4) => new e.pointGeometry(B(t4.x), t4.y));
            const f2 = [...p2];
            f2.length === 0 && f2.push(m2[m2.length - 1]);
            const g2 = e.number(f2[f2.length - 1].y, (m2.length === 0 ? p2[0] : m2[0]).y, d2);
            let v3;
            return v3 = c2 ? [new e.pointGeometry(0, g2), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g2)] : [new e.pointGeometry(1, g2), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g2)], f2.push(...v3), m2.length === 0 ? f2.push(p2[0]) : f2.push(...m2), { polygon: f2.map((t4) => new e.MercatorCoordinate(t4.x, t4.y)), unwrapped: false };
          }(t2, i2);
          if (o2)
            return o2;
          const r = function(t3, i3) {
            let o3 = false, r2 = -1 / 0, n2 = 0;
            for (let e2 = 0; e2 < t3.length - 1; e2++)
              t3[e2].x > r2 && (r2 = t3[e2].x, n2 = e2);
            for (let e2 = 0; e2 < t3.length - 1; e2++) {
              const i4 = (n2 + e2) % (t3.length - 1), r3 = t3[i4], s3 = t3[i4 + 1];
              Math.abs(r3.x - s3.x) > 0.5 && (r3.x < s3.x ? (r3.x += 1, i4 === 0 && (t3[t3.length - 1].x += 1)) : (s3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
            }
            const s2 = e.mercatorXfromLng(i3.center.lng);
            return o3 && s2 < Math.abs(s2 - 1) && t3.forEach((e2) => {
              e2.x -= 1;
            }), { polygon: t3, unwrapped: o3 };
          }(O(t2, i2).map((t3) => new e.pointGeometry(B(t3.x), t3.y)), i2);
          return { polygon: r.polygon.map((t3) => new e.MercatorCoordinate(t3.x, t3.y)), unwrapped: r.unwrapped };
        }
      }
      function O(t2, i2) {
        return e.resample(t2, (e2) => {
          const t3 = i2.pointCoordinate3D(e2);
          e2.x = t3.x, e2.y = t3.y;
        }, 1 / 256);
      }
      function B(e2) {
        return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
      }
      function k(e2) {
        return 100 * e2 | 0;
      }
      function F(t2, i2, o2, r, n2) {
        const s2 = function(o3, r2) {
          if (o3)
            return n2(o3);
          if (r2) {
            t2.url && r2.tiles && t2.tiles && delete t2.tiles;
            const o4 = e.pick(e.extend(r2, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r2.vector_layers && (o4.vectorLayers = r2.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), n2(null, o4);
          }
        };
        return t2.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r), e.ResourceType.Source), s2) : e.exported.frame(() => s2(null, t2));
      }
      class U {
        constructor(t2, i2, o2) {
          this.bounds = e.LngLatBounds.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e2) {
          return Array.isArray(e2) && e2.length === 4 ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
        }
        contains(t2) {
          const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n2 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), s2 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
          return t2.x >= o2 && t2.x < n2 && t2.y >= r && t2.y < s2;
        }
      }
      class N {
        constructor(e2, t2, i2) {
          this.context = e2;
          const o2 = e2.gl;
          this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const G = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class j {
        constructor(e2, t2, i2, o2) {
          this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
          const r = e2.gl;
          this.buffer = r.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t2.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        enableAttributes(e2, t2) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const o2 = t2.attributes[this.attributes[i2].name];
            o2 !== void 0 && e2.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e2, t2, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r = this.attributes[o2], n2 = t2.attributes[r.name];
            n2 !== void 0 && e2.vertexAttribPointer(n2, r.components, e2[G[r.type]], false, this.itemSize, r.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Z {
        constructor(e2) {
          this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class V extends Z {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class W extends Z {
        getDefault() {
          return 1;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
        }
      }
      class X extends Z {
        getDefault() {
          return 0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
        }
      }
      class q extends Z {
        getDefault() {
          return [true, true, true, true];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class $ extends Z {
        getDefault() {
          return true;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class H extends Z {
        getDefault() {
          return 255;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class Y extends Z {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e2) {
          const t2 = this.current;
          (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
        }
      }
      class K extends Z {
        getDefault() {
          const e2 = this.gl;
          return [e2.KEEP, e2.KEEP, e2.KEEP];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
        }
      }
      class J extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
        }
      }
      class Q extends Z {
        getDefault() {
          return [0, 1];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class ee extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
        }
      }
      class te extends Z {
        getDefault() {
          return this.gl.LESS;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
        }
      }
      class ie extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
        }
      }
      class oe extends Z {
        getDefault() {
          const e2 = this.gl;
          return [e2.ONE, e2.ZERO];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class re extends Z {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class ne extends Z {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
        }
      }
      class se extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
        }
      }
      class ae extends Z {
        getDefault() {
          return this.gl.BACK;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class le extends Z {
        getDefault() {
          return this.gl.CCW;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class ce extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
        }
      }
      class he extends Z {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
        }
      }
      class ue extends Z {
        getDefault() {
          const e2 = this.gl;
          return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class _e extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class de extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class pe extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
        }
      }
      class me extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class fe extends Z {
        getDefault() {
          return null;
        }
        set(e2) {
          const t2 = this.gl;
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class ge extends Z {
        constructor(e2) {
          super(e2), this.vao = e2.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(e2) {
          this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
        }
      }
      class ve extends Z {
        getDefault() {
          return 4;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
        }
      }
      class xe extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class ye extends Z {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class be extends Z {
        constructor(e2, t2) {
          super(e2), this.context = e2, this.parent = t2;
        }
        getDefault() {
          return null;
        }
      }
      class we extends be {
        setDirty() {
          this.dirty = true;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
        }
      }
      class Te extends be {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class Ee extends Te {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class Ce {
        constructor(e2, t2, i2, o2) {
          this.context = e2, this.width = t2, this.height = i2;
          const r = this.framebuffer = e2.gl.createFramebuffer();
          this.colorAttachment = new we(e2, r), o2 && (this.depthAttachment = new Te(e2, r));
        }
        destroy() {
          const e2 = this.context.gl, t2 = this.colorAttachment.get();
          if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
            const t3 = this.depthAttachment.get();
            t3 && e2.deleteRenderbuffer(t3);
          }
          e2.deleteFramebuffer(this.framebuffer);
        }
      }
      class Me {
        constructor(e2, t2 = false) {
          if (this.gl = e2, this.isWebGL2 = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t2) {
            const t3 = e2;
            this.extVertexArrayObject = { createVertexArrayOES: t3.createVertexArray.bind(e2), deleteVertexArrayOES: t3.deleteVertexArray.bind(e2), bindVertexArrayOES: t3.bindVertexArray.bind(e2) };
          }
          this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t2 || (this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float")), (t2 || this.extTextureHalfFloat && e2.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t2 || e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e2, t2) {
          return new N(this, e2, t2);
        }
        createVertexBuffer(e2, t2, i2) {
          return new j(this, e2, t2, i2);
        }
        createRenderbuffer(e2, t2, i2) {
          const o2 = this.gl, r = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r;
        }
        createFramebuffer(e2, t2, i2) {
          return new Ce(this, e2, t2, i2);
        }
        clear({ color: e2, depth: t2, stencil: i2 }) {
          const o2 = this.gl;
          let r = 0;
          e2 && (r |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), t2 !== void 0 && (r |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), i2 !== void 0 && (r |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r);
        }
        setCullFace(e2) {
          e2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
        }
        setDepthMode(e2) {
          e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
        }
        setStencilMode(e2) {
          e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(i2) {
          t(i2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor)), this.colorMask.set(i2.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class Ie extends e.Evented {
        constructor(t2, i2, o2, r) {
          if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
        }
        load(t2) {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" }));
          const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
          this._tileJSONRequest = F(this._options, this.map._requestManager, i2, o2, (r, n2) => {
            this._tileJSONRequest = null, this._loaded = true, r ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && o2.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.ErrorEvent(r))) : n2 && (e.extend(this, n2), n2.bounds && (this.tileBounds = new U(n2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        reload() {
          this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
        }
        setTiles(e2) {
          return this._options.tiles = e2, this.reload(), this;
        }
        setUrl(e2) {
          return this.url = e2, this._options.url = e2, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e.extend({}, this._options);
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile };
          if (r.request.collectResourceTiming = this._collectResourceTiming, t2.actor && t2.state !== "expired")
            t2.state === "loading" ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r, n2.bind(this));
          else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
            t2.request = t2.actor.send("loadTile", r, n2.bind(this), void 0, true);
          else {
            const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r, (e2, i4) => {
              e2 || !i4 ? n2.call(this, e2) : (r.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r, n2.bind(this), void 0, true));
            }, true);
            t2.request = { cancel: i3 };
          }
          function n2(o3, r2) {
            return delete t2.request, t2.aborted ? i2(null) : o3 && o3.status !== 404 ? i2(o3) : (r2 && r2.resourceTiming && (t2.resourceTiming = r2.resourceTiming), this.map._refreshExpiredTiles && r2 && t2.setExpiryData(r2), t2.loadVectorData(r2, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
          }
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        unloadTile(e2) {
          e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class Se extends e.Evented {
        constructor(t2, i2, o2, r) {
          super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
        }
        load(t2) {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i2, o2) => {
            this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.ErrorEvent(i2)) : o2 && (e.extend(this, o2), o2.bounds && (this.tileBounds = new U(o2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        reload() {
          this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
        }
        setTiles(e2) {
          return this._options.tiles = e2, this.reload(), this;
        }
        setUrl(e2) {
          return this.url = e2, this._options.url = e2, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e.extend({}, this._options);
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t2, i2) {
          const o2 = e.exported.devicePixelRatio >= 2, r = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t2.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o3, r2, n2, s2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r2 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: s2 }), t2.setTexture(r2, this.map.painter), t2.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i2(null)) : i2(null)));
        }
        static loadTileData(e2, t2, i2) {
          e2.setTexture(t2, i2);
        }
        static unloadTileData(e2, t2) {
          e2.texture && t2.saveTileTexture(e2.texture);
        }
        abortTile(e2, t2) {
          e2.request && (e2.request.cancel(), delete e2.request), t2();
        }
        unloadTile(e2, t2) {
          e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
        }
        hasTransition() {
          return false;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      let De;
      function Le(t2, i2, o2, r, n2, s2, a2, l2) {
        const c2 = [t2, o2, n2, i2, r, s2, 1, 1, 1], h4 = [a2, l2, 1], u2 = e.adjoint([], c2), [_2, d2, p2] = e.transformMat3(h4, h4, e.transpose(u2, u2));
        return e.multiply$1(c2, [_2, 0, 0, 0, d2, 0, 0, 0, p2], c2);
      }
      class Ae extends e.Evented {
        constructor(e2, t2, i2, o2) {
          super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t2, this._dirty = false;
        }
        load(t2, i2) {
          this._loaded = i2 || false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i3, o2) => {
            if (this._imageRequest = null, this._loaded = true, i3)
              this.fire(new e.ErrorEvent(i3));
            else if (o2) {
              const { HTMLImageElement: i4 } = e.window;
              this.image = o2 instanceof i4 ? e.exported.getImageData(o2) : o2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e2) {
          return this.image && e2.url ? (this._imageRequest && e2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
        }
        setCoordinates(t2) {
          this.coordinates = t2, this._boundsArray = void 0;
          const i2 = t2.map(e.MercatorCoordinate.fromLngLat);
          return this.tileID = function(t3) {
            let i3 = 1 / 0, o2 = 1 / 0, r = -1 / 0, n2 = -1 / 0;
            for (const e2 of t3)
              i3 = Math.min(i3, e2.x), o2 = Math.min(o2, e2.y), r = Math.max(r, e2.x), n2 = Math.max(n2, e2.y);
            const s2 = Math.max(r - i3, n2 - o2), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, a2);
            return new e.CanonicalTileID(a2, Math.floor((i3 + r) / 2 * l2), Math.floor((o2 + n2) / 2 * l2));
          }(i2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(t2) {
          for (const e2 in this.tiles) {
            const t3 = this.tiles[e2];
            t3.state !== "loaded" && (t3.state = "loaded", t3.texture = this.texture);
          }
          if (this._boundsArray)
            return;
          const i2 = e.tileTransform(this.tileID, this.map.transform.projection), [o2, r, n2, s2] = this.coordinates.map((t3) => {
            const o3 = i2.projection.project(t3[0], t3[1]);
            return e.getTilePoint(i2, o3)._round();
          });
          this.perspectiveTransform = function(t3, i3, o3, r2, n3, s3, a3, l2, c2, h4) {
            const u2 = Le(0, 0, t3, 0, 0, i3, t3, i3), _2 = Le(o3, r2, n3, s3, a3, l2, c2, h4);
            return e.multiply$1(_2, e.adjoint(u2, u2), _2), [_2[6] / _2[8] * t3 / e.EXTENT, _2[7] / _2[8] * i3 / e.EXTENT];
          }(this.width, this.height, o2.x, o2.y, r.x, r.y, s2.x, s2.y, n2.x, n2.y);
          const a2 = this._boundsArray = new e.StructArrayLayout4i8();
          a2.emplaceBack(o2.x, o2.y, 0, 0), a2.emplaceBack(r.x, r.y, e.EXTENT, 0), a2.emplaceBack(s2.x, s2.y, 0, e.EXTENT), a2.emplaceBack(n2.x, n2.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t2.createVertexBuffer(a2, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(t2);
        }
        loadTile(e2, t2) {
          this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }
      const ze = { vector: Ie, raster: Se, "raster-dem": class extends Se {
        constructor(t2, i2, o2, r) {
          super(t2, i2, o2, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function r(e2, o3) {
            e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
          }
          t2.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), function(o3, n2, s2, a2) {
            if (delete t2.request, t2.aborted)
              t2.state = "unloaded", i2(null);
            else if (o3)
              t2.state = "errored", i2(o3);
            else if (n2) {
              this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: a2 });
              const i3 = e.window.ImageBitmap && n2 instanceof e.window.ImageBitmap && (De == null && (De = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && typeof e.window.createImageBitmap == "function"), De), o4 = 1 - (n2.width - e.prevPowerOfTwo(n2.width)) / 2;
              o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
              const l2 = i3 ? n2 : e.exported.getImageData(n2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
              t2.actor && t2.state !== "expired" || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r.bind(this), void 0, true));
            }
          }.bind(this));
        }
        _getNeighboringTiles(t2) {
          const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r = (i2.x - 1 + o2) % o2, n2 = i2.x === 0 ? t2.wrap - 1 : t2.wrap, s2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
          return l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r, i2.y).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
        }
        unloadTile(e2) {
          e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
        }
      }, geojson: class extends e.Evented {
        constructor(t2, i2, o2, r) {
          super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== void 0 && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const n2 = e.EXTENT / this.tileSize;
          this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (i2.buffer !== void 0 ? i2.buffer : 128) * n2, tolerance: (i2.tolerance !== void 0 ? i2.tolerance : 0.375) * n2, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== void 0 ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (i2.clusterRadius !== void 0 ? i2.clusterRadius : 50) * n2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
        }
        onAdd(e2) {
          this.map = e2, this.setData(this._data);
        }
        setData(e2) {
          return this._data = e2, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e2, t2) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterChildren(e2, t2) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterLeaves(e2, t2, i2, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, o2), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
          const t2 = e.extend({}, this.workerOptions), i2 = this._data;
          typeof i2 == "string" ? (t2.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
            if (this._loaded = true, this._pendingLoad = null, t3)
              this.fire(new e.ErrorEvent(t3));
            else {
              const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t4)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t2, i2) {
          const o2 = t2.actor ? "reloadTile" : "loadTile";
          t2.actor = this.actor, t2.request = this.actor.send(o2, { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r, this.map.painter, o2 === "reloadTile"), i2(null))), void 0, o2 === "loadTile");
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
        }
        unloadTile(e2) {
          e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e.extend({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends Ae {
        constructor(e2, t2, i2, o2) {
          super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
        }
        load() {
          this._loaded = false;
          const t2 = this.options;
          this.urls = [];
          for (const i2 of t2.urls)
            this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
          e.getVideo(this.urls, (t3, i2) => {
            this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t2) {
          if (this.video) {
            const i2 = this.video.seekable;
            t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e2) {
          this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: Ae, canvas: class extends Ae {
        constructor(t2, i2, o2, r) {
          super(t2, i2, o2, r), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((e2) => !Array.isArray(e2) || e2.length !== 2 || e2.some((e3) => typeof e3 != "number")) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === void 0 || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e2) {
          this.map = e2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
            return;
          if (Object.keys(this.tiles).length === 0)
            return;
          const i2 = this.map.painter.context;
          this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e2 of [this.canvas.width, this.canvas.height])
            if (isNaN(e2) || e2 <= 0)
              return true;
          return false;
        }
      }, custom: class extends e.Evented {
        constructor(t2, i2, o2, r) {
          super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t2) {
          this._map = t2, this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
        }
        onRemove(e2) {
          this._implementation.onRemove && this._implementation.onRemove(e2);
        }
        hasTile(e2) {
          if (this._implementation.hasTile) {
            const { x: t2, y: i2, z: o2 } = e2.canonical;
            return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t2, i2) {
          const { x: o2, y: r, z: n2 } = t2.tileID.canonical, s2 = new e.window.AbortController();
          t2.request = Promise.resolve(this._implementation.loadTile({ x: o2, y: r, z: n2 }, { signal: s2.signal })).then(function(o3) {
            return delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 === void 0 ? (t2.state = "errored", i2(null)) : o3 === null ? (this.loadTileData(t2, { width: this.tileSize, height: this.tileSize, data: null }), t2.state = "loaded", i2(null)) : function(t3) {
              return t3 instanceof e.window.ImageData || t3 instanceof e.window.HTMLCanvasElement || t3 instanceof e.window.ImageBitmap || t3 instanceof e.window.HTMLImageElement;
            }(o3) ? (this.loadTileData(t2, o3), t2.state = "loaded", void i2(null)) : (t2.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }.bind(this)).catch((e2) => {
            e2.code !== 20 && (t2.state = "errored", i2(e2));
          }), t2.request.cancel = () => s2.abort();
        }
        loadTileData(e2, t2) {
          Se.loadTileData(e2, t2, this._map.painter);
        }
        unloadTileData(e2) {
          Se.unloadTileData(e2, this._map.painter);
        }
        unloadTile(e2, t2) {
          if (this.unloadTileData(e2), this._implementation.unloadTile) {
            const { x: t3, y: i2, z: o2 } = e2.tileID.canonical;
            this._implementation.unloadTile({ x: t3, y: i2, z: o2 });
          }
          t2();
        }
        abortTile(e2, t2) {
          e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
        }
        _clearTiles() {
          this._map.style._clearSource(this.id);
        }
        _update() {
          this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, Pe = function(t2, i2, o2, r) {
        const n2 = new ze[i2.type](t2, i2, o2, r);
        if (n2.id !== t2)
          throw new Error(`Expected Source id to be ${t2} instead of ${n2.id}`);
        return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
      };
      function Re(t2, i2) {
        const o2 = e.identity([]);
        return e.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
      }
      function Oe(e2, t2, i2, o2, r, n2, s2, a2 = false) {
        const l2 = e2.tilesIn(o2, s2, a2);
        l2.sort(ke);
        const c2 = [];
        for (const o3 of l2)
          c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r, n2, Re(e2.transform, o3.tile.tileID), a2) });
        const h4 = function(e3) {
          const t3 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, r2 = o3.wrappedTileID, n3 = i3[r2] = i3[r2] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], r3 = n3[i4] = n3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
              for (const e5 of o4)
                r3[e5.featureIndex] || (r3[e5.featureIndex] = true, s3.push(e5));
            }
          }
          return t3;
        }(c2);
        for (const t3 in h4)
          h4[t3].forEach((t4) => {
            const i3 = t4.feature, o3 = i3.layer;
            o3 && o3.type !== "background" && o3.type !== "sky" && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = i3.id !== void 0 ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
          });
        return h4;
      }
      function Be(e2, t2) {
        const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const n2 = i2[e3], s2 = n2.tileID.canonical.key;
          r[s2] || (r[s2] = true, n2.querySourceFeatures(o2, t2));
        }
        return o2;
      }
      function ke(e2, t2) {
        const i2 = e2.tileID, o2 = t2.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      function Fe() {
        return fn.workerClass != null ? new fn.workerClass() : new e.window.Worker(fn.workerUrl);
      }
      const Ue = "mapboxgl_preloaded_worker_pool";
      class Ne {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Ne.workerCount; )
              this.workers.push(new Fe());
          return this.active[e2] = true, this.workers.slice();
        }
        release(e2) {
          delete this.active[e2], this.numActive() === 0 && (this.workers.forEach((e3) => {
            e3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Ue];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let Ge;
      function je() {
        return Ge || (Ge = new Ne()), Ge;
      }
      function Ze(t2, i2) {
        const o2 = {};
        for (const e2 in t2)
          e2 !== "ref" && (o2[e2] = t2[e2]);
        return e.refProperties.forEach((e2) => {
          e2 in i2 && (o2[e2] = i2[e2]);
        }), o2;
      }
      function Ve(e2) {
        e2 = e2.slice();
        const t2 = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < e2.length; i2++)
          t2[e2[i2].id] = e2[i2];
        for (let i2 = 0; i2 < e2.length; i2++)
          "ref" in e2[i2] && (e2[i2] = Ze(e2[i2], t2[e2[i2].ref]));
        return e2;
      }
      Ne.workerCount = 2;
      const We = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
      function Xe(e2, t2, i2) {
        i2.push({ command: We.addSource, args: [e2, t2[e2]] });
      }
      function qe(e2, t2, i2) {
        t2.push({ command: We.removeSource, args: [e2] }), i2[e2] = true;
      }
      function $e(e2, t2, i2, o2) {
        qe(e2, i2, o2), Xe(e2, t2, i2);
      }
      function He(e2, i2, o2) {
        let r;
        for (r in e2[o2])
          if (e2[o2].hasOwnProperty(r) && r !== "data" && !t(e2[o2][r], i2[o2][r]))
            return false;
        for (r in i2[o2])
          if (i2[o2].hasOwnProperty(r) && r !== "data" && !t(e2[o2][r], i2[o2][r]))
            return false;
        return true;
      }
      function Ye(e2, i2, o2, r, n2, s2) {
        let a2;
        for (a2 in i2 = i2 || {}, e2 = e2 || {})
          e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r, a2, i2[a2], n2] }));
        for (a2 in i2)
          i2.hasOwnProperty(a2) && !e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s2, args: [r, a2, i2[a2], n2] }));
      }
      function Ke(e2) {
        return e2.id;
      }
      function Je(e2, t2) {
        return e2[t2.id] = t2, e2;
      }
      class Qe {
        constructor(e2, t2) {
          this.reset(e2, t2);
        }
        reset(e2, t2) {
          this.points = e2 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t2) {
          if (this.points.length === 1)
            return this.points[0];
          t2 = e.clamp(t2, 0, 1);
          let i2 = 1, o2 = this._distances[i2];
          const r = t2 * this.paddedLength + this.padding;
          for (; o2 < r && i2 < this._distances.length; )
            o2 = this._distances[++i2];
          const n2 = i2 - 1, s2 = this._distances[n2], a2 = o2 - s2, l2 = a2 > 0 ? (r - s2) / a2 : 0;
          return this.points[n2].mult(1 - l2).add(this.points[i2].mult(l2));
        }
      }
      class et {
        constructor(e2, t2, i2) {
          const o2 = this.boxCells = [], r = this.circleCells = [];
          this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            o2.push([]), r.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e2, t2, i2, o2, r) {
          this._forEachCell(t2, i2, o2, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r);
        }
        insertCircle(e2, t2, i2, o2) {
          this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
        }
        _insertBoxCell(e2, t2, i2, o2, r, n2) {
          this.boxCells[r].push(n2);
        }
        _insertCircleCell(e2, t2, i2, o2, r, n2) {
          this.circleCells[r].push(n2);
        }
        _query(e2, t2, i2, o2, r, n2) {
          if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height)
            return !r && [];
          const s2 = [];
          if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              s2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              s2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
            }
            return n2 ? s2.filter(n2) : s2;
          }
          return this._forEachCell(e2, t2, i2, o2, this._queryCell, s2, { hitTest: r, seenUids: { box: {}, circle: {} } }, n2), r ? s2.length > 0 : s2;
        }
        _queryCircle(e2, t2, i2, o2, r) {
          const n2 = e2 - i2, s2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
          if (s2 < 0 || n2 > this.width || l2 < 0 || a2 > this.height)
            return !o2 && [];
          const c2 = [];
          return this._forEachCell(n2, a2, s2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r), o2 ? c2.length > 0 : c2;
        }
        query(e2, t2, i2, o2, r) {
          return this._query(e2, t2, i2, o2, false, r);
        }
        hitTest(e2, t2, i2, o2, r) {
          return this._query(e2, t2, i2, o2, true, r);
        }
        hitTestCircle(e2, t2, i2, o2) {
          return this._queryCircle(e2, t2, i2, true, o2);
        }
        _queryCell(e2, t2, i2, o2, r, n2, s2, a2) {
          const l2 = s2.seenUids, c2 = this.boxCells[r];
          if (c2 !== null) {
            const r2 = this.bboxes;
            for (const h5 of c2)
              if (!l2.box[h5]) {
                l2.box[h5] = true;
                const c3 = 4 * h5;
                if (e2 <= r2[c3 + 2] && t2 <= r2[c3 + 3] && i2 >= r2[c3 + 0] && o2 >= r2[c3 + 1] && (!a2 || a2(this.boxKeys[h5]))) {
                  if (s2.hitTest)
                    return n2.push(true), true;
                  n2.push({ key: this.boxKeys[h5], x1: r2[c3], y1: r2[c3 + 1], x2: r2[c3 + 2], y2: r2[c3 + 3] });
                }
              }
          }
          const h4 = this.circleCells[r];
          if (h4 !== null) {
            const r2 = this.circles;
            for (const c3 of h4)
              if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const h5 = 3 * c3;
                if (this._circleAndRectCollide(r2[h5], r2[h5 + 1], r2[h5 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                  if (s2.hitTest)
                    return n2.push(true), true;
                  {
                    const e3 = r2[h5], t3 = r2[h5 + 1], i3 = r2[h5 + 2];
                    n2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e2, t2, i2, o2, r, n2, s2, a2) {
          const l2 = s2.circle, c2 = s2.seenUids, h4 = this.boxCells[r];
          if (h4 !== null) {
            const e3 = this.bboxes;
            for (const t3 of h4)
              if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3])))
                  return n2.push(true), true;
              }
          }
          const u2 = this.circleCells[r];
          if (u2 !== null) {
            const e3 = this.circles;
            for (const t3 of u2)
              if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3])))
                  return n2.push(true), true;
              }
          }
        }
        _forEachCell(e2, t2, i2, o2, r, n2, s2, a2) {
          const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h4 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
          for (let _2 = l2; _2 <= h4; _2++)
            for (let l3 = c2; l3 <= u2; l3++)
              if (r.call(this, e2, t2, i2, o2, this.xCellCount * l3 + _2, n2, s2, a2))
                return;
        }
        _convertToXCellCoord(e2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
        }
        _convertToYCellCoord(e2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
        }
        _circlesCollide(e2, t2, i2, o2, r, n2) {
          const s2 = o2 - e2, a2 = r - t2, l2 = i2 + n2;
          return l2 * l2 > s2 * s2 + a2 * a2;
        }
        _circleAndRectCollide(e2, t2, i2, o2, r, n2, s2) {
          const a2 = (n2 - o2) / 2, l2 = Math.abs(e2 - (o2 + a2));
          if (l2 > a2 + i2)
            return false;
          const c2 = (s2 - r) / 2, h4 = Math.abs(t2 - (r + c2));
          if (h4 > c2 + i2)
            return false;
          if (l2 <= a2 || h4 <= c2)
            return true;
          const u2 = l2 - a2, _2 = h4 - c2;
          return u2 * u2 + _2 * _2 <= i2 * i2;
        }
      }
      const tt = Math.tan(85 * Math.PI / 180);
      function it(t2, i2, o2, r, n2, s2, a2) {
        const l2 = e.create();
        if (o2)
          if (s2.name === "globe") {
            const t3 = e.calculateGlobeLabelMatrix(n2, i2);
            e.multiply(l2, l2, t3);
          } else {
            const t3 = v2([], a2);
            l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], r || e.rotateZ(l2, l2, n2.angle);
          }
        else
          e.multiply(l2, n2.labelPlaneMatrix, t2);
        return l2;
      }
      function ot(e2, t2, i2, o2, r, n2, s2) {
        const a2 = it(e2, t2, i2, o2, r, n2, s2);
        return n2.name === "globe" && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
      }
      function rt(t2, i2, o2, r, n2, s2, a2) {
        if (o2) {
          if (s2.name === "globe") {
            const l2 = it(t2, i2, o2, r, n2, s2, a2);
            return e.invert(l2, l2), e.multiply(l2, t2, l2), l2;
          }
          {
            const i3 = e.clone(t2), o3 = e.identity([]);
            return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.multiply(i3, i3, o3), r || e.rotateZ(i3, i3, -n2.angle), i3;
          }
        }
        return n2.glCoordMatrix;
      }
      function nt(t2, i2, o2, r) {
        const n2 = [t2, i2, o2, 1];
        o2 ? e.transformMat4$1(n2, n2, r) : ft(n2, n2, r);
        const s2 = n2[3];
        return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
      }
      function st(e2, t2) {
        return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
      }
      function at(e2, t2) {
        const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
        return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
      }
      function lt(t2, i2, o2, r, n2, s2, a2, l2, c2, h4) {
        const u2 = o2.transform, _2 = r ? t2.textSizeData : t2.iconSizeData, d2 = e.evaluateSizeForZoom(_2, o2.transform.zoom), p2 = u2.projection.name === "globe", m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
        f2.clear();
        let g2 = null;
        p2 && (g2 = r ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
        const v3 = t2.lineVertexArray, x2 = r ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
        let b2, w2 = false;
        for (let r2 = 0; r2 < x2.length; r2++) {
          const p3 = x2.get(r2), { numGlyphs: T2, writingMode: E2 } = p3;
          if (E2 !== e.WritingMode.vertical || w2 || b2 === e.WritingMode.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.WritingMode.vertical) && !w2) {
            mt(T2, f2);
            continue;
          }
          w2 = false;
          const C2 = new e.pointGeometry(p3.tileAnchorX, p3.tileAnchorY);
          let { x: M2, y: I2, z: S2 } = u2.projection.projectTilePoint(C2.x, C2.y, h4.canonical);
          if (c2) {
            const [e2, t3, i3] = c2(C2);
            M2 += e2, I2 += t3, S2 += i3;
          }
          const D2 = [M2, I2, S2, 1];
          if (e.transformMat4$1(D2, D2, i2), !at(D2, m2)) {
            mt(T2, f2);
            continue;
          }
          const L2 = st(o2.transform.cameraToCenterDistance, D2[3]), A2 = e.evaluateSizeForFeature(_2, d2, p3), z2 = a2 ? A2 / L2 : A2 * L2, P2 = nt(M2, I2, S2, n2);
          if (P2[3] <= 0) {
            mt(T2, f2);
            continue;
          }
          let R3 = {};
          const O2 = a2 ? null : c2, B2 = ut(p3, z2, false, l2, i2, n2, s2, t2.glyphOffsetArray, v3, f2, g2, P2, C2, R3, y2, O2, u2.projection, h4, a2);
          w2 = B2.useVertical, O2 && B2.needsFlipping && (R3 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && ut(p3, z2, true, l2, i2, n2, s2, t2.glyphOffsetArray, v3, f2, g2, P2, C2, R3, y2, O2, u2.projection, h4, a2).notEnoughRoom) && mt(T2, f2);
        }
        r ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer.updateData(g2));
      }
      function ct(e2, t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2) {
        const { lineStartIndex: f2, glyphStartIndex: g2, segment: v3 } = a2, x2 = g2 + a2.numGlyphs, y2 = f2 + a2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = pt(e2 * b2, i2, o2, r, n2, s2, v3, f2, y2, l2, c2, h4, u2, _2, true, d2, p2, m2);
        if (!T2)
          return null;
        const E2 = pt(e2 * w2, i2, o2, r, n2, s2, v3, f2, y2, l2, c2, h4, u2, _2, true, d2, p2, m2);
        return E2 ? { first: T2, last: E2 } : null;
      }
      function ht(t2, i2, o2, r) {
        return t2 === e.WritingMode.horizontal && Math.abs(r) > Math.abs(o2) ? { useVertical: true } : t2 === e.WritingMode.vertical ? r > 0 ? { needsFlipping: true } : null : i2 !== 0 && function(e2, t3) {
          return e2 === 0 || Math.abs(t3 / e2) > tt;
        }(o2, r) ? i2 === 1 ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
      }
      function ut(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2, g2, v3, x2) {
        const y2 = i2 / 24, b2 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: C2, segment: M2, writingMode: I2, flipState: S2 } = t2, D2 = T2 + t2.lineLength, L2 = (t3) => {
          if (u2) {
            const [i4, o4, r3] = t3.up, n3 = h4.length;
            e.updateGlobeVertexNormal(u2, n3 + 0, i4, o4, r3), e.updateGlobeVertexNormal(u2, n3 + 1, i4, o4, r3), e.updateGlobeVertexNormal(u2, n3 + 2, i4, o4, r3), e.updateGlobeVertexNormal(u2, n3 + 3, i4, o4, r3);
          }
          const [i3, o3, r2] = t3.point;
          e.addDynamicAttributes(h4, i3, o3, r2, t3.angle);
        };
        if (C2 > 1) {
          const e2 = ct(y2, l2, b2, w2, o2, _2, d2, t2, c2, s2, p2, f2, false, g2, v3, x2);
          if (!e2)
            return { notEnoughRoom: true };
          if (r && !o2) {
            let [i3, o3, r2] = e2.first.point, [n3, s3, l3] = e2.last.point;
            [i3, o3] = nt(i3, o3, r2, a2), [n3, s3] = nt(n3, s3, l3, a2);
            const c3 = ht(I2, S2, (n3 - i3) * m2, s3 - o3);
            if (t2.flipState = c3 && c3.needsFlipping ? 1 : 2, c3)
              return c3;
          }
          L2(e2.first);
          for (let e3 = E2 + 1; e3 < E2 + C2 - 1; e3++) {
            const t3 = pt(y2 * l2.getoffsetX(e3), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v3, x2);
            if (!t3)
              return h4.length -= 4 * (e3 - E2), { notEnoughRoom: true };
            L2(t3);
          }
          L2(e2.last);
        } else {
          if (r && !o2) {
            const i4 = nt(d2.x, d2.y, 0, n2), o3 = T2 + M2 + 1, r2 = new e.pointGeometry(c2.getx(o3), c2.gety(o3)), s3 = nt(r2.x, r2.y, 0, n2), a3 = s3[3] > 0 ? s3 : dt(d2, r2, i4, 1, n2, void 0, g2, v3.canonical), l3 = ht(I2, S2, (a3[0] - i4[0]) * m2, a3[1] - i4[1]);
            if (t2.flipState = l3 && l3.needsFlipping ? 1 : 2, l3)
              return l3;
          }
          const i3 = pt(y2 * l2.getoffsetX(E2), b2, w2, o2, _2, d2, M2, T2, D2, c2, s2, p2, f2, false, false, g2, v3, x2);
          if (!i3)
            return { notEnoughRoom: true };
          L2(i3);
        }
        return {};
      }
      function _t(e2, t2, i2, o2, r) {
        const { x: n2, y: s2, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
        if (!r)
          return nt(n2, s2, a2, i2);
        const [l2, c2, h4] = r(e2);
        return nt(n2 + l2, s2 + c2, a2 + h4, i2);
      }
      function dt(t2, i2, o2, r, n2, s2, a2, l2) {
        const c2 = _t(t2.sub(i2)._unit()._add(t2), l2, n2, a2, s2);
        return e.sub(c2, o2, c2), e.normalize(c2, c2), e.scaleAndAdd(c2, o2, c2, r);
      }
      function pt(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2, g2, v3) {
        const x2 = r ? t2 - i2 : t2 + i2;
        let y2 = x2 > 0 ? 1 : -1, b2 = 0;
        r && (y2 *= -1, b2 = Math.PI), y2 < 0 && (b2 += Math.PI);
        let w2 = l2 + a2 + (y2 > 0 ? 0 : 1) | 0, T2 = n2, E2 = n2, C2 = 0, M2 = 0;
        const I2 = Math.abs(x2), S2 = [], D2 = [];
        let L2 = s2, A2 = L2;
        const z2 = () => dt(A2, L2, E2, I2 - C2 + 1, u2, d2, f2, g2.canonical);
        for (; C2 + M2 <= I2; ) {
          if (w2 += y2, w2 < l2 || w2 >= c2)
            return null;
          if (E2 = T2, A2 = L2, S2.push(E2), p2 && D2.push(A2), L2 = new e.pointGeometry(h4.getx(w2), h4.gety(w2)), T2 = _2[w2], !T2) {
            const e2 = _t(L2, g2.canonical, u2, f2, d2);
            T2 = e2[3] > 0 ? _2[w2] = e2 : z2();
          }
          C2 += M2, M2 = e.distance(E2, T2);
        }
        m2 && d2 && (_2[w2] && (T2 = z2(), M2 = e.distance(E2, T2)), _2[w2] = T2);
        const P2 = (I2 - C2) / M2, R3 = L2.sub(A2)._mult(P2)._add(A2), O2 = e.sub([], T2, E2), B2 = e.scaleAndAdd([], E2, O2, P2);
        let k2 = [0, 0, 1], F2 = O2[0], U2 = O2[1];
        if (v3 && (k2 = f2.upVector(g2.canonical, R3.x, R3.y), k2[0] !== 0 || k2[1] !== 0 || k2[2] !== 1)) {
          const t3 = [k2[2], 0, -k2[0]], i3 = e.cross([], k2, t3);
          e.normalize(t3, t3), e.normalize(i3, i3), F2 = e.dot(O2, t3), U2 = e.dot(O2, i3);
        }
        if (o2) {
          const t3 = e.cross([], k2, O2);
          e.normalize(t3, t3), e.scaleAndAdd(B2, B2, t3, o2 * y2);
        }
        const N2 = b2 + Math.atan2(U2, F2);
        return S2.push(B2), p2 && D2.push(R3), { point: B2, angle: N2, path: S2, tilePath: D2, up: k2 };
      }
      function mt(e2, t2) {
        const i2 = t2.length, o2 = i2 + 4 * e2;
        t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
      }
      function ft(e2, t2, i2) {
        const o2 = t2[0], r = t2[1];
        return e2[0] = i2[0] * o2 + i2[4] * r + i2[12], e2[1] = i2[1] * o2 + i2[5] * r + i2[13], e2[3] = i2[3] * o2 + i2[7] * r + i2[15], e2;
      }
      const gt = 100;
      class vt {
        constructor(e2, t2, i2 = new et(e2.width + 200, e2.height + 200, 25), o2 = new et(e2.width + 200, e2.height + 200, 25)) {
          this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + gt, this.screenBottomBoundary = e2.height + gt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
        }
        placeCollisionBox(e2, t2, i2, o2, r, n2, s2, a2) {
          let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h4 = i2.projectedAnchorZ;
          const u2 = i2.elevation, _2 = i2.tileID, d2 = e2.getProjection();
          if (u2 && _2) {
            const [e3, t3, o3] = d2.upVector(_2.canonical, i2.tileAnchorX, i2.tileAnchorY), r2 = d2.upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l2 += e3 * u2 * r2, c2 += t3 * u2 * r2, h4 += o3 * u2 * r2;
          }
          const p2 = this.projectAndGetPerspectiveRatio(s2, l2, c2, h4, i2.tileID, d2.name === "globe" || !!u2 || this.transform.pitch > 0, d2), m2 = n2 * p2.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m2 + p2.point.y, v3 = (i2.x2 * t2 + o2.x + i2.padding) * m2 + p2.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m2 + p2.point.y, y2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
          return !this.isInsideGrid(f2, g2, v3, x2) || !r && this.grid.hitTest(f2, g2, v3, x2, a2) || y2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [f2, g2, v3, x2], offscreen: this.isOffscreen(f2, g2, v3, x2), occluded: false };
        }
        placeCollisionCircles(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2) {
          const f2 = [], g2 = this.transform.elevation, v3 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, v3) : null, y2 = new e.pointGeometry(o2.tileAnchorX, o2.tileAnchorY);
          let { x: b2, y: w2, z: T2 } = v3.projectTilePoint(y2.x, y2.y, m2.canonical);
          if (x2) {
            const [e2, t3, i3] = x2(y2);
            b2 += e2, w2 += t3, T2 += i3;
          }
          const E2 = v3.name === "globe", C2 = this.projectAndGetPerspectiveRatio(a2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, v3), { perspectiveRatio: M2 } = C2, I2 = (u2 ? s2 / M2 : s2 * M2) / e.ONE_EM, S2 = nt(b2, w2, T2, l2), D2 = C2.signedDistanceFromCamera > 0 ? ct(I2, n2, o2.lineOffsetX * I2, o2.lineOffsetY * I2, false, S2, y2, o2, r, l2, {}, g2 && !u2 ? x2 : null, u2 && !!g2, v3, m2, u2) : null;
          let L2 = false, A2 = false, z2 = true;
          if (D2 && !C2.occluded) {
            const t3 = 0.5 * d2 * M2 + p2, o3 = new e.pointGeometry(-100, -100), r2 = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new Qe(), { first: s3, last: a3 } = D2, l3 = s3.path.length;
            let u3 = [];
            for (let e2 = l3 - 1; e2 >= 1; e2--)
              u3.push(s3.path[e2]);
            for (let e2 = 1; e2 < a3.path.length; e2++)
              u3.push(a3.path[e2]);
            const m3 = 2.5 * t3;
            c2 && (u3 = u3.map(([e2, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l3 - 1 ? s3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), nt(e2, t4, i3, c2))), u3.some((e2) => e2[3] <= 0) && (u3 = []));
            let g3 = [];
            if (u3.length > 0) {
              let t4 = 1 / 0, i3 = -1 / 0, n4 = 1 / 0, s4 = -1 / 0;
              for (const e2 of u3)
                t4 = Math.min(t4, e2[0]), n4 = Math.min(n4, e2[1]), i3 = Math.max(i3, e2[0]), s4 = Math.max(s4, e2[1]);
              i3 >= o3.x && t4 <= r2.x && s4 >= o3.y && n4 <= r2.y && (g3 = [u3.map((t5) => new e.pointGeometry(t5[0], t5[1]))], (t4 < o3.x || i3 > r2.x || n4 < o3.y || s4 > r2.y) && (g3 = e.clipLine(g3, o3.x, o3.y, r2.x, r2.y)));
            }
            for (const e2 of g3) {
              n3.reset(e2, 0.25 * t3);
              let o4 = 0;
              o4 = n3.length <= 0.5 * t3 ? 1 : Math.ceil(n3.paddedLength / m3) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const r3 = e3 / Math.max(o4 - 1, 1), s4 = n3.lerp(r3), a4 = s4.x + gt, l4 = s4.y + gt;
                f2.push(a4, l4, t3, 0);
                const c3 = a4 - t3, u4 = l4 - t3, d3 = a4 + t3, p3 = l4 + t3;
                if (z2 = z2 && this.isOffscreen(c3, u4, d3, p3), A2 = A2 || this.isInsideGrid(c3, u4, d3, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, _2) && (L2 = true, !h4))
                  return { circles: [], offscreen: false, collisionDetected: L2, occluded: false };
              }
            }
          }
          return { circles: !h4 && L2 || !A2 ? [] : f2, offscreen: z2, collisionDetected: L2, occluded: C2.occluded };
        }
        queryRenderedSymbols(t2) {
          if (t2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const i2 = [];
          let o2 = 1 / 0, r = 1 / 0, n2 = -1 / 0, s2 = -1 / 0;
          for (const a3 of t2) {
            const t3 = new e.pointGeometry(a3.x + gt, a3.y + gt);
            o2 = Math.min(o2, t3.x), r = Math.min(r, t3.y), n2 = Math.max(n2, t3.x), s2 = Math.max(s2, t3.y), i2.push(t3);
          }
          const a2 = this.grid.query(o2, r, n2, s2).concat(this.ignoredGrid.query(o2, r, n2, s2)), l2 = {}, c2 = {};
          for (const t3 of a2) {
            const o3 = t3.key;
            if (l2[o3.bucketInstanceId] === void 0 && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
              continue;
            const r2 = [new e.pointGeometry(t3.x1, t3.y1), new e.pointGeometry(t3.x2, t3.y1), new e.pointGeometry(t3.x2, t3.y2), new e.pointGeometry(t3.x1, t3.y2)];
            e.polygonIntersectsPolygon(i2, r2) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c2;
        }
        insertCollisionBox(e2, t2, i2, o2, r) {
          (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r }, e2[0], e2[1], e2[2], e2[3]);
        }
        insertCollisionCircles(e2, t2, i2, o2, r) {
          const n2 = t2 ? this.ignoredGrid : this.grid, s2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r };
          for (let t3 = 0; t3 < e2.length; t3 += 4)
            n2.insertCircle(s2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(t2, i2, o2, r, n2, s2, a2) {
          const l2 = [i2, o2, r, 1];
          let c2 = false;
          if (r || this.transform.pitch > 0) {
            e.transformMat4$1(l2, l2, t2);
            const s3 = a2.name === "globe";
            if (this.fogState && n2 && !s3) {
              const t3 = function(t4, i3, o3, r2, n3, s4) {
                const a3 = s4.calculateFogTileMatrix(n3), l3 = [i3, o3, r2];
                return e.transformMat4(l3, l3, a3), I(t4, l3, s4.pitch, s4._fov);
              }(this.fogState, i2, o2, r, n2.toUnwrapped(), this.transform);
              c2 = t3 > 0.9;
            }
          } else
            ft(l2, l2, t2);
          const h4 = l2[3];
          return { point: new e.pointGeometry((l2[0] / h4 + 1) / 2 * this.transform.width + gt, (-l2[1] / h4 + 1) / 2 * this.transform.height + gt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h4 * 0.5, 1.5), signedDistanceFromCamera: h4, occluded: s2 && l2[2] > h4 || c2 };
        }
        isOffscreen(e2, t2, i2, o2) {
          return i2 < gt || e2 >= this.screenRightBoundary || o2 < gt || t2 > this.screenBottomBoundary;
        }
        isInsideGrid(e2, t2, i2, o2) {
          return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t2 = e.identity([]);
          return e.translate(t2, t2, [-100, -100, 0]), t2;
        }
      }
      function xt(t2, i2, o2) {
        const r = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
        return e.multiply(new Float32Array(16), t2.projMatrix, r);
      }
      function yt(e2, t2, i2) {
        if (t2.projection.name === i2.projection.name)
          return e2.projMatrix;
        const o2 = i2.clone();
        return o2.setProjection(t2.projection), xt(o2, t2.getProjection(), e2);
      }
      function bt(e2, t2, i2) {
        return t2.name === i2.projection.name ? e2.projMatrix : xt(i2, t2, e2);
      }
      class wt {
        constructor(e2, t2, i2, o2) {
          this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Tt {
        constructor(e2, t2, i2, o2, r, n2 = false) {
          this.text = new wt(e2 ? e2.text : null, t2, i2, r), this.icon = new wt(e2 ? e2.icon : null, t2, o2, r), this.clipped = n2;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Et {
        constructor(e2, t2, i2, o2 = false) {
          this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
        }
      }
      class Ct {
        constructor() {
          this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
        }
      }
      class Mt {
        constructor(e2, t2, i2, o2, r) {
          this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r;
        }
      }
      class It {
        constructor(e2) {
          this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e2]) {
            const t2 = ++this.maxGroupID;
            this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
          }
          return this.collisionGroups[e2];
        }
      }
      function St(t2, i2, o2, r, n2) {
        const { horizontalAlign: s2, verticalAlign: a2 } = e.getAnchorAlignment(t2), l2 = -(s2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h4 = e.evaluateVariableOffset(t2, r);
        return new e.pointGeometry(l2 + h4[0] * n2, c2 + h4[1] * n2);
      }
      function Dt(t2, i2, o2, r, n2) {
        const s2 = new e.pointGeometry(t2, i2);
        return o2 && s2._rotate(r ? n2 : -n2), s2;
      }
      class Lt {
        constructor(e2, t2, i2, o2, r) {
          this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new vt(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new It(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t2, i2, o2, r) {
          const n2 = o2.getBucket(i2), s2 = o2.latestFeatureIndex;
          if (!n2 || !s2 || i2.id !== n2.layerIds[0])
            return;
          const a2 = n2.layers[0].layout, l2 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h4 = o2.tileSize / e.EXTENT, u2 = o2.tileID.toUnwrapped();
          this.transform.setProjection(n2.projection);
          const _2 = (d2 = o2.tileID, p2 = n2.getProjection(), m2 = this.transform, p2.name === this.projection ? m2.calculateProjMatrix(d2.toUnwrapped()) : xt(m2, p2, d2));
          var d2, p2, m2;
          const f2 = a2.get("text-pitch-alignment") === "map", g2 = a2.get("text-rotation-alignment") === "map";
          i2.compileFilter();
          const v3 = i2.dynamicFilter(), x2 = i2.dynamicFilterNeedsFeature(), y2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b2 = ot(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
          let w2 = null;
          if (f2) {
            const t3 = rt(_2, o2.tileID.canonical, f2, g2, this.transform, n2.getProjection(), y2);
            w2 = e.multiply([], this.transform.labelPlaneMatrix, t3);
          }
          let T2 = null;
          v3 && o2.latestFeatureIndex && (T2 = { unwrappedTileID: u2, dynamicFilter: v3, dynamicFilterNeedsFeature: x2, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n2.bucketInstanceId] = new Mt(n2.bucketInstanceId, s2, n2.sourceLayerIndex, n2.index, o2.tileID);
          const E2 = { bucket: n2, layout: a2, posMatrix: _2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c2, textPixelRatio: h4, holdingForFade: o2.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
          if (r)
            for (const e2 of n2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r2 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r2, parameters: E2 });
            }
          else
            t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: E2 });
        }
        attemptAnchorPlacement(e2, t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2, g2) {
          const { textOffset0: v3, textOffset1: x2, crossTileID: y2 } = u2, b2 = [v3, x2], w2 = St(e2, i2, o2, b2, r), T2 = this.collisionIndex.placeCollisionBox(d2, r, t2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h4, a2, l2, c2.predicate);
          if (m2) {
            const e3 = d2.getSymbolInstanceIconSize(g2, this.transform.zoom, u2.placedIconSymbolIndex);
            if (this.collisionIndex.placeCollisionBox(d2, e3, m2, Dt(w2.x, w2.y, n2, s2, this.transform.angle), h4, a2, l2, c2.predicate).box.length === 0)
              return;
          }
          if (T2.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b2, width: i2, height: o2, anchor: e2, textScale: r, prevAnchor: t3 }, this.markUsedJustification(d2, e2, u2, p2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, p2, u2), this.placedOrientations[y2] = p2), { shift: w2, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(t2, i2, o2, r) {
          const { bucket: n2, layout: s2, posMatrix: a2, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, clippingData: h4, textPixelRatio: u2, holdingForFade: _2, collisionBoxArray: d2, partiallyEvaluatedTextSize: p2, partiallyEvaluatedIconSize: m2, collisionGroup: f2 } = t2.parameters, g2 = s2.get("text-optional"), v3 = s2.get("icon-optional"), x2 = s2.get("text-allow-overlap"), y2 = s2.get("icon-allow-overlap"), b2 = s2.get("text-rotation-alignment") === "map", w2 = s2.get("text-pitch-alignment") === "map", T2 = s2.get("icon-text-fit") !== "none", E2 = s2.get("symbol-z-order") === "viewport-y";
          this.transform.setProjection(n2.projection);
          let C2 = x2 && (y2 || !n2.hasIconData() || v3), M2 = y2 && (x2 || !n2.hasTextData() || g2);
          !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2), o2 && r && n2.updateCollisionDebugBuffers(this.transform.zoom, d2);
          const I2 = (t3, r2, d3) => {
            const { crossTileID: E3, numVerticalGlyphVertices: I3 } = t3;
            if (h4) {
              const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let r3 = null;
              if (h4.dynamicFilterNeedsFeature) {
                const e2 = this.retainedQueryData[n2.bucketInstanceId];
                r3 = h4.featureIndex.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, h4.dynamicFilter)(o3, r3, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e.pointGeometry(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(h4.unwrappedTileID)))
                return this.placements[E3] = new Et(false, false, false, true), void (i2[E3] = true);
            }
            if (i2[E3])
              return;
            if (_2)
              return void (this.placements[E3] = new Et(false, false, false));
            let S2 = false, D2 = false, L2 = true, A2 = false, z2 = false, P2 = null, R3 = { box: null, offscreen: null, occluded: null }, O2 = { box: null, offscreen: null, occluded: null }, B2 = null, k2 = null, F2 = null, U2 = 0, N2 = 0, G2 = 0;
            d3.textFeatureIndex ? U2 = d3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), d3.verticalTextFeatureIndex && (N2 = d3.verticalTextFeatureIndex);
            const j2 = (e2) => {
              e2.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
              const t4 = this.transform.elevation;
              (t4 || e2.elevation) && (e2.elevation = t4 ? t4.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
            }, Z2 = d3.textBox;
            if (Z2) {
              j2(Z2);
              const i3 = (i4) => {
                let o4 = e.WritingMode.horizontal;
                if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.placedOrientations[E3];
                  e2 && (this.placedOrientations[E3] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                }
                return o4;
              }, o3 = (t4, i4) => {
                if (n2.allowVerticalPlacement && I3 > 0 && d3.verticalTextBox) {
                  for (const o4 of n2.writingModes)
                    if (o4 === e.WritingMode.vertical ? (R3 = i4(), O2 = R3) : R3 = t4(), R3 && R3.box && R3.box.length)
                      break;
                } else
                  R3 = t4();
              };
              if (s2.get("text-variable-anchor")) {
                let l3 = s2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[E3]) {
                  const e2 = this.prevPlacement.variableOffsets[E3];
                  l3.indexOf(e2.anchor) > 0 && (l3 = l3.filter((t4) => t4 !== e2.anchor), l3.unshift(e2.anchor));
                }
                const c3 = (e2, i4, o4) => {
                  const s3 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r2), c4 = (e2.x2 - e2.x1) * s3 + 2 * e2.padding, h6 = (e2.y2 - e2.y1) * s3 + 2 * e2.padding, _3 = T2 && !y2 ? i4 : null;
                  _3 && j2(_3);
                  let d4 = { box: [], offscreen: false, occluded: false };
                  const g3 = x2 ? 2 * l3.length : l3.length;
                  for (let i5 = 0; i5 < g3; ++i5) {
                    const g4 = this.attemptAnchorPlacement(l3[i5 % l3.length], e2, c4, h6, s3, b2, w2, u2, a2, f2, i5 >= l3.length, t3, r2, n2, o4, _3, p2, m2);
                    if (g4 && (d4 = g4.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                      S2 = true, P2 = g4.shift;
                      break;
                    }
                  }
                  return d4;
                };
                o3(() => c3(Z2, d3.iconBox, e.WritingMode.horizontal), () => {
                  const t4 = d3.verticalTextBox;
                  return t4 && j2(t4), n2.allowVerticalPlacement && !(R3 && R3.box && R3.box.length) && I3 > 0 && t4 ? c3(t4, d3.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                }), R3 && (S2 = R3.box, L2 = R3.offscreen, A2 = R3.occluded);
                const h5 = i3(R3 && R3.box);
                if (!S2 && this.prevPlacement) {
                  const e2 = this.prevPlacement.variableOffsets[E3];
                  e2 && (this.variableOffsets[E3] = e2, this.markUsedJustification(n2, e2.anchor, t3, h5));
                }
              } else {
                const s3 = (i4, o4) => {
                  const s4 = n2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r2), l3 = this.collisionIndex.placeCollisionBox(n2, s4, i4, new e.pointGeometry(0, 0), x2, u2, a2, f2.predicate);
                  return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[E3] = o4), l3;
                };
                o3(() => s3(Z2, e.WritingMode.horizontal), () => {
                  const t4 = d3.verticalTextBox;
                  return n2.allowVerticalPlacement && I3 > 0 && t4 ? (j2(t4), s3(t4, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                }), i3(R3 && R3.box && R3.box.length);
              }
            }
            if (B2 = R3, S2 = B2 && B2.box && B2.box.length > 0, L2 = B2 && B2.offscreen, A2 = B2 && B2.occluded, t3.useRuntimeCollisionCircles) {
              const i3 = n2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r3 = e.evaluateSizeForFeature(n2.textSizeData, p2, i3), h5 = s2.get("text-padding");
              k2 = this.collisionIndex.placeCollisionCircles(n2, x2, i3, n2.lineVertexArray, n2.glyphOffsetArray, r3, a2, l2, c2, o2, w2, f2.predicate, t3.collisionCircleDiameter * r3 / e.ONE_EM, h5, this.retainedQueryData[n2.bucketInstanceId].tileID), S2 = x2 || k2.circles.length > 0 && !k2.collisionDetected, L2 = L2 && k2.offscreen, A2 = k2.occluded;
            }
            if (d3.iconFeatureIndex && (G2 = d3.iconFeatureIndex), d3.iconBox) {
              const i3 = (i4) => {
                j2(i4);
                const o3 = T2 && P2 ? Dt(P2.x, P2.y, b2, w2, this.transform.angle) : new e.pointGeometry(0, 0), r3 = n2.getSymbolInstanceIconSize(m2, this.transform.zoom, t3.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(n2, r3, i4, o3, y2, u2, a2, f2.predicate);
              };
              O2 && O2.box && O2.box.length && d3.verticalIconBox ? (F2 = i3(d3.verticalIconBox), D2 = F2.box.length > 0) : (F2 = i3(d3.iconBox), D2 = F2.box.length > 0), L2 = L2 && F2.offscreen, z2 = F2.occluded;
            }
            const V2 = g2 || t3.numHorizontalGlyphVertices === 0 && I3 === 0, W2 = v3 || t3.numIconVertices === 0;
            if (V2 || W2 ? W2 ? V2 || (D2 = D2 && S2) : S2 = D2 && S2 : D2 = S2 = D2 && S2, S2 && B2 && B2.box && this.collisionIndex.insertCollisionBox(B2.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, O2 && O2.box && N2 ? N2 : U2, f2.ID), D2 && F2 && this.collisionIndex.insertCollisionBox(F2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, G2, f2.ID), k2 && (S2 && this.collisionIndex.insertCollisionCircles(k2.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, U2, f2.ID), o2)) {
              const e2 = n2.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e2];
              t4 === void 0 && (t4 = this.collisionCircleArrays[e2] = new Ct());
              for (let e3 = 0; e3 < k2.circles.length; e3 += 4)
                t4.circles.push(k2.circles[e3 + 0]), t4.circles.push(k2.circles[e3 + 1]), t4.circles.push(k2.circles[e3 + 2]), t4.circles.push(k2.collisionDetected ? 1 : 0);
            }
            const X2 = n2.projection.name !== "globe";
            C2 = C2 && (X2 || !A2), M2 = M2 && (X2 || !z2), this.placements[E3] = new Et(S2 || C2, D2 || M2, L2 || n2.justReloaded), i2[E3] = true;
          };
          if (E2) {
            const e2 = n2.getSortedSymbolIndexes(this.transform.angle);
            for (let t3 = e2.length - 1; t3 >= 0; --t3) {
              const i3 = e2[t3];
              I2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
            }
          } else
            for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
              I2(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
          if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
            e.invert(t3.invProjMatrix, a2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n2.justReloaded = false;
        }
        markUsedJustification(t2, i2, o2, r) {
          const { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: s2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h4 = e.getAnchorJustification(i2), u2 = r === e.WritingMode.vertical ? l2 : h4 === "left" ? n2 : h4 === "center" ? s2 : h4 === "right" ? a2 : -1;
          n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = u2 >= 0 && n2 !== u2 ? 0 : c2), s2 >= 0 && (t2.text.placedSymbolArray.get(s2).crossTileID = u2 >= 0 && s2 !== u2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = u2 >= 0 && a2 !== u2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = u2 >= 0 && l2 !== u2 ? 0 : c2);
        }
        markUsedOrientation(t2, i2, o2) {
          const r = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n2 = i2 === e.WritingMode.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h4 = t2.text.placedSymbolArray;
          s2 >= 0 && (h4.get(s2).placedOrientation = r), a2 >= 0 && (h4.get(a2).placedOrientation = r), l2 >= 0 && (h4.get(l2).placedOrientation = r), c2 >= 0 && (h4.get(c2).placedOrientation = n2);
        }
        commit(e2) {
          this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r = t2 ? t2.opacities : {}, n2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], n3 = r[e3];
            n3 ? (this.opacities[e3] = new Tt(n3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== n3.text.placed || t3.icon !== n3.icon.placed) : (this.opacities[e3] = new Tt(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in r) {
            const t3 = r[e3];
            if (!this.opacities[e3]) {
              const r2 = new Tt(t3, o2, false, false);
              r2.isHidden() || (this.opacities[e3] = r2, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in n2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n2[e3]);
          for (const e3 in s2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
          i2 ? this.lastPlacementChangeTime = e2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
        }
        updateLayerOpacities(e2, t2) {
          const i2 = {};
          for (const o2 of t2) {
            const t3 = o2.getBucket(e2);
            t3 && o2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, o2.collisionBoxArray);
          }
        }
        updateBucketOpacities(t2, i2, o2) {
          t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
          const r = t2.layers[0].layout, n2 = !!t2.layers[0].dynamicFilter(), s2 = new Tt(null, 0, false, false, true), a2 = r.get("text-allow-overlap"), l2 = r.get("icon-allow-overlap"), c2 = r.get("text-variable-anchor"), h4 = r.get("text-rotation-alignment") === "map", u2 = r.get("text-pitch-alignment") === "map", _2 = r.get("icon-text-fit") !== "none", d2 = new Tt(null, 0, a2 && (l2 || !t2.hasIconData() || r.get("icon-optional")), l2 && (a2 || !t2.hasTextData() || r.get("text-optional")), true);
          !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
          const p2 = (e2, t3, i3) => {
            for (let o3 = 0; o3 < t3 / 4; o3++)
              e2.opacityVertexArray.emplaceBack(i3);
          };
          let m2 = 0;
          for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
            const r2 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: l3, crossTileID: f2, numIconVertices: g2 } = r2;
            let v3 = this.opacities[f2];
            i2[f2] ? v3 = s2 : v3 || (v3 = d2, this.opacities[f2] = v3), i2[f2] = true;
            const x2 = a3 > 0 || l3 > 0, y2 = g2 > 0, b2 = this.placedOrientations[f2], w2 = b2 === e.WritingMode.vertical, T2 = b2 === e.WritingMode.horizontal || b2 === e.WritingMode.horizontalOnly;
            if (!x2 && !y2 || v3.isHidden() || m2++, x2) {
              const e2 = Ut(v3.text);
              p2(t2.text, a3, w2 ? Nt : e2), p2(t2.text, l3, T2 ? Nt : e2);
              const i3 = v3.text.isHidden(), { leftJustifiedTextSymbolIndex: o4, centerJustifiedTextSymbolIndex: n3, rightJustifiedTextSymbolIndex: s3, verticalPlacedTextSymbolIndex: c3 } = r2, h5 = t2.text.placedSymbolArray, u3 = i3 || w2 ? 1 : 0;
              o4 >= 0 && (h5.get(o4).hidden = u3), n3 >= 0 && (h5.get(n3).hidden = u3), s3 >= 0 && (h5.get(s3).hidden = u3), c3 >= 0 && (h5.get(c3).hidden = i3 || T2 ? 1 : 0);
              const _3 = this.variableOffsets[f2];
              _3 && this.markUsedJustification(t2, _3.anchor, r2, b2);
              const d3 = this.placedOrientations[f2];
              d3 && (this.markUsedJustification(t2, "left", r2, d3), this.markUsedOrientation(t2, d3, r2));
            }
            if (y2) {
              const e2 = Ut(v3.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o4 } = r2, n3 = t2.icon.placedSymbolArray, s3 = v3.icon.isHidden() ? 1 : 0;
              i3 >= 0 && (p2(t2.icon, g2, w2 ? Nt : e2), n3.get(i3).hidden = s3), o4 >= 0 && (p2(t2.icon, r2.numVerticalIconVertices, T2 ? Nt : e2), n3.get(o4).hidden = s3);
            }
            if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
              const i3 = t2.collisionArrays[o3];
              if (i3) {
                let o4 = new e.pointGeometry(0, 0), r3 = true;
                if (i3.textBox || i3.verticalTextBox) {
                  if (c2) {
                    const e2 = this.variableOffsets[f2];
                    e2 ? (o4 = St(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), h4 && o4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : r3 = false;
                  }
                  n2 && (r3 = !v3.clipped), i3.textBox && At(t2.textCollisionBox.collisionVertexArray, v3.text.placed, !r3 || w2, o4.x, o4.y), i3.verticalTextBox && At(t2.textCollisionBox.collisionVertexArray, v3.text.placed, !r3 || T2, o4.x, o4.y);
                }
                const s3 = r3 && Boolean(!T2 && i3.verticalIconBox);
                i3.iconBox && At(t2.iconCollisionBox.collisionVertexArray, v3.icon.placed, s3, _2 ? o4.x : 0, _2 ? o4.y : 0), i3.verticalIconBox && At(t2.iconCollisionBox.collisionVertexArray, v3.icon.placed, !s3, _2 ? o4.x : 0, _2 ? o4.y : 0);
              }
            }
          }
          if (t2.fullyClipped = m2 === 0, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
            const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
            t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
          }
        }
        symbolFadeChange(e2) {
          return this.fadeDuration === 0 ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e2) {
          return Math.max(0, (this.transform.zoom - e2) / 1.5);
        }
        hasTransitions(e2) {
          return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e2, t2) {
          const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
          return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function At(e2, t2, i2, o2, r) {
        e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r || 0);
      }
      const zt = Math.pow(2, 25), Pt = Math.pow(2, 24), Rt = Math.pow(2, 17), Ot = Math.pow(2, 16), Bt = Math.pow(2, 9), kt = Math.pow(2, 8), Ft = Math.pow(2, 1);
      function Ut(e2) {
        if (e2.opacity === 0 && !e2.placed)
          return 0;
        if (e2.opacity === 1 && e2.placed)
          return 4294967295;
        const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
        return i2 * zt + t2 * Pt + i2 * Rt + t2 * Ot + i2 * Bt + t2 * kt + i2 * Ft + t2;
      }
      const Nt = 0;
      class Gt {
        constructor(e2) {
          this._sortAcrossTiles = e2.layout.get("symbol-z-order") !== "viewport-y" && e2.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e2, t2, i2, o2, r) {
          const n2 = this._bucketParts;
          for (; this._currentTileIndex < e2.length; )
            if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
            const e3 = n2[this._currentPartIndex];
            if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, e3.symbolInstanceStart === 0), this._currentPartIndex++, r())
              return true;
          }
          return false;
        }
      }
      class jt {
        constructor(e2, t2, i2, o2, r, n2, s2, a2) {
          this.placement = new Lt(e2, r, n2, s2, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t2, i2, o2) {
          const r = e.exported.now(), n2 = () => {
            const t3 = e.exported.now() - r;
            return !this._forceFullPlacement && t3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const e2 = i2[t2[this._currentPlacementIndex]], r2 = this.placement.collisionIndex.transform.zoom;
            if (e2.type === "symbol" && (!e2.minzoom || e2.minzoom <= r2) && (!e2.maxzoom || e2.maxzoom > r2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new Gt(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e2) {
          return this.placement.commit(e2), this.placement;
        }
      }
      const Zt = 512 / e.EXTENT / 2;
      class Vt {
        constructor(e2, t2, i2) {
          this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
          for (let i3 = 0; i3 < t2.length; i3++) {
            const o2 = t2.get(i3), r = o2.key;
            this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e2) });
          }
        }
        getScaledCoordinates(t2, i2) {
          const o2 = Zt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((i2.canonical.x * e.EXTENT + t2.tileAnchorX) * o2), y: Math.floor((i2.canonical.y * e.EXTENT + t2.tileAnchorY) * o2) };
        }
        findMatches(e2, t2, i2) {
          const o2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
          for (let r = 0; r < e2.length; r++) {
            const n2 = e2.get(r);
            if (n2.crossTileID)
              continue;
            const s2 = this.indexedSymbolInstances[n2.key];
            if (!s2)
              continue;
            const a2 = this.getScaledCoordinates(n2, t2);
            for (const e3 of s2)
              if (Math.abs(e3.coord.x - a2.x) <= o2 && Math.abs(e3.coord.y - a2.y) <= o2 && !i2[e3.crossTileID]) {
                i2[e3.crossTileID] = true, n2.crossTileID = e3.crossTileID;
                break;
              }
          }
        }
      }
      class Wt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Xt {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - this.lng) / 360);
          if (t2 !== 0)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r = i2[e4];
                r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t2), o2[r.tileID.key] = r;
              }
              this.indexes[e3] = o2;
            }
          this.lng = e2;
        }
        addBucket(e2, t2, i2) {
          if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
            if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
            t2.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
          const o2 = this.usedCrossTileIDs[e2.overscaledZ];
          for (const i3 in this.indexes) {
            const r = this.indexes[i3];
            if (Number(i3) > e2.overscaledZ)
              for (const i4 in r) {
                const n2 = r[i4];
                n2.tileID.isChildOf(e2) && n2.findMatches(t2.symbolInstances, e2, o2);
              }
            else {
              const n2 = r[e2.scaledTo(Number(i3)).key];
              n2 && n2.findMatches(t2.symbolInstances, e2, o2);
            }
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
            const r = t2.symbolInstances.get(e3);
            r.crossTileID || (r.crossTileID = i2.generate(), o2[r.crossTileID] = true);
          }
          return this.indexes[e2.overscaledZ] === void 0 && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Vt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e2, t2) {
          for (const i2 in t2.indexedSymbolInstances)
            for (const o2 of t2.indexedSymbolInstances[i2])
              delete this.usedCrossTileIDs[e2][o2.crossTileID];
        }
        removeStaleBuckets(e2) {
          let t2 = false;
          for (const i2 in this.indexes) {
            const o2 = this.indexes[i2];
            for (const r in o2)
              e2[o2[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r]), delete o2[r], t2 = true);
          }
          return t2;
        }
      }
      class qt {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Wt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e2, t2, i2, o2) {
          let r = this.layerIndexes[e2.id];
          r === void 0 && (r = this.layerIndexes[e2.id] = new Xt());
          let n2 = false;
          const s2 = {};
          o2.name !== "globe" && r.handleWrapJump(i2);
          for (const i3 of t2) {
            const t3 = i3.getBucket(e2);
            t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i3.tileID, t3, this.crossTileIDs) && (n2 = true), s2[t3.bucketInstanceId] = true);
          }
          return r.removeStaleBuckets(s2) && (n2 = true), n2;
        }
        pruneUnusedLayers(e2) {
          const t2 = {};
          e2.forEach((e3) => {
            t2[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t2[e3] || delete this.layerIndexes[e3];
        }
      }
      const $t = (t2, i2) => e.emitValidationErrors(t2, i2 && i2.filter((e2) => e2.identifier !== "source.canvas")), Ht = e.pick(We, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Yt = e.pick(We, ["setCenter", "setZoom", "setBearing", "setPitch"]), Kt = { version: 8, layers: [], sources: {} }, Jt = { fill: true, line: true, background: true, hillshade: true, raster: true };
      class Qt extends e.Evented {
        constructor(t2, i2 = {}) {
          super(), this.map = t2, this.dispatcher = new z(je(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t2._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.crossTileSymbolIndex = new qt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
          const o2 = this;
          this._rtlTextPluginCallback = Qt.registerForPluginStateChange((t3) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
              if (e.triggerPluginCompletionEvent(t4), i3 && i3.every((e2) => e2))
                for (const e2 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                  i4 !== "vector" && i4 !== "geojson" || t5.reload();
                }
            });
          }), this.on("data", (e2) => {
            if (e2.dataType !== "source" || e2.sourceDataType !== "metadata")
              return;
            const t3 = this.getSource(e2.sourceId);
            if (t3 && t3.vectorLayerIds)
              for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
          });
        }
        loadURL(t2, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" }));
          const o2 = typeof i2.validate == "boolean" ? i2.validate : !e.isMapboxURL(t2);
          t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken);
          const r = this.map._requestManager.transformRequest(t2, e.ResourceType.Style);
          this._request = e.getJSON(r, (t3, i3) => {
            this._request = null, t3 ? this.fire(new e.ErrorEvent(t3)) : i3 && this._load(i3, o2);
          });
        }
        loadJSON(t2, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
            this._request = null, this._load(t2, i2.validate !== false);
          });
        }
        loadEmpty() {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Kt, false);
        }
        _updateLayerCount(e2, t2) {
          const i2 = t2 ? 1 : -1;
          e2.is3D() && (this._num3DLayers += i2), e2.type === "circle" && (this._numCircleLayers += i2), e2.type === "symbol" && (this._numSymbolLayers += i2);
        }
        _load(t2, i2) {
          if (i2 && $t(this, e.validateStyle(t2)))
            return;
          this._loaded = true, this.stylesheet = e.clone$1(t2), this._updateMapProjection();
          for (const e2 in t2.sources)
            this.addSource(e2, t2.sources[e2], { validate: false });
          this._changed = false, t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t2.glyphs);
          const o2 = Ve(this.stylesheet.layers);
          this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
          for (let t3 of o2)
            t3 = e.createStyleLayer(t3), t3.setEventedParent(this, { layer: { id: t3.id } }), this._layers[t3.id] = t3, this._serializedLayers[t3.id] = t3.serialize(), this._updateLayerCount(t3, true);
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        setProjection(e2) {
          e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
        }
        _loadSprite(t2) {
          this._spriteRequest = function(t3, i2, o2) {
            let r, n2, s2;
            const a2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
            let l2 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.ResourceType.SpriteJSON), (e2, t4) => {
              l2 = null, s2 || (s2 = e2, r = t4, h4());
            }), c2 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.ResourceType.SpriteImage), (e2, t4) => {
              c2 = null, s2 || (s2 = e2, n2 = t4, h4());
            });
            function h4() {
              if (s2)
                o2(s2);
              else if (r && n2) {
                const t4 = e.exported.getImageData(n2), i3 = {};
                for (const o3 in r) {
                  const { width: n3, height: s3, x: a3, y: l3, sdf: c3, pixelRatio: h5, stretchX: u2, stretchY: _2, content: d2 } = r[o3], p2 = new e.RGBAImage({ width: n3, height: s3 });
                  e.RGBAImage.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: n3, height: s3 }), i3[o3] = { data: p2, pixelRatio: h5, sdf: c3, stretchX: u2, stretchY: _2, content: d2 };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
            } };
          }(t2, this.map._requestManager, (t3, i2) => {
            if (this._spriteRequest = null, t3)
              this.fire(new e.ErrorEvent(t3));
            else if (i2)
              for (const e2 in i2)
                this.imageManager.addImage(e2, i2[e2]);
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(t2) {
          const i2 = this.getSource(t2.source);
          if (!i2)
            return;
          const o2 = t2.sourceLayer;
          o2 && (i2.type === "geojson" || i2.vectorLayerIds && i2.vectorLayerIds.indexOf(o2) === -1) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const e2 in this._sourceCaches)
            if (!this._sourceCaches[e2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(e2) {
          const t2 = [];
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            e3.type !== "custom" && t2.push(e3.serialize());
          }
          return t2;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.fog && this.fog.hasTransition())
            return true;
          for (const e2 in this._sourceCaches)
            if (this._sourceCaches[e2].hasTransition())
              return true;
          for (const e2 in this._layers)
            if (this._layers[e2].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
        }
        isLayerDraped(e2) {
          return !!this.terrain && (typeof e2.isLayerDraped == "function" ? e2.isLayerDraped() : Jt[e2.type]);
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        update(t2) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (this._changed) {
            const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
            for (const e3 in this._updatedSources) {
              const t3 = this._updatedSources[e3];
              t3 === "reload" ? this._reloadSource(e3) : t3 === "clear" && this._clearSource(e3);
            }
            this._updateTilesForChangedImages();
            for (const e3 in this._updatedPaintProps)
              this._layers[e3].updateTransitions(t2);
            this.light.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._resetUpdates();
          }
          const o2 = {};
          for (const e2 in this._sourceCaches) {
            const t3 = this._sourceCaches[e2];
            o2[e2] = t3.used, t3.used = false;
          }
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
              const e3 = this._getLayerSourceCache(i3);
              e3 && (e3.used = true);
            }
            const o3 = this.map.painter;
            if (o3) {
              const e3 = i3.getProgramIds();
              if (!e3)
                continue;
              const r = i3.getProgramConfiguration(t2.zoom);
              for (const t3 of e3)
                o3.useProgram(t3, r);
            }
          }
          for (const t3 in o2) {
            const i3 = this._sourceCaches[t3];
            o2[t3] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e2 = Object.keys(this._changedImages);
          if (e2.length) {
            for (const t2 in this._sourceCaches)
              this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(e2, t2) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setState(i2) {
          if (this._checkLoaded(), $t(this, e.validateStyle(i2)))
            return false;
          (i2 = e.clone$1(i2)).layers = Ve(i2.layers);
          const o2 = function(e2, i3) {
            if (!e2)
              return [{ command: We.setStyle, args: [i3] }];
            let o3 = [];
            try {
              if (!t(e2.version, i3.version))
                return [{ command: We.setStyle, args: [i3] }];
              t(e2.center, i3.center) || o3.push({ command: We.setCenter, args: [i3.center] }), t(e2.zoom, i3.zoom) || o3.push({ command: We.setZoom, args: [i3.zoom] }), t(e2.bearing, i3.bearing) || o3.push({ command: We.setBearing, args: [i3.bearing] }), t(e2.pitch, i3.pitch) || o3.push({ command: We.setPitch, args: [i3.pitch] }), t(e2.sprite, i3.sprite) || o3.push({ command: We.setSprite, args: [i3.sprite] }), t(e2.glyphs, i3.glyphs) || o3.push({ command: We.setGlyphs, args: [i3.glyphs] }), t(e2.transition, i3.transition) || o3.push({ command: We.setTransition, args: [i3.transition] }), t(e2.light, i3.light) || o3.push({ command: We.setLight, args: [i3.light] }), t(e2.fog, i3.fog) || o3.push({ command: We.setFog, args: [i3.fog] }), t(e2.projection, i3.projection) || o3.push({ command: We.setProjection, args: [i3.projection] });
              const r2 = {}, n2 = [];
              !function(e3, i4, o4, r3) {
                let n3;
                for (n3 in i4 = i4 || {}, e3 = e3 || {})
                  e3.hasOwnProperty(n3) && (i4.hasOwnProperty(n3) || qe(n3, o4, r3));
                for (n3 in i4)
                  i4.hasOwnProperty(n3) && (e3.hasOwnProperty(n3) ? t(e3[n3], i4[n3]) || (e3[n3].type === "geojson" && i4[n3].type === "geojson" && He(e3, i4, n3) ? o4.push({ command: We.setGeoJSONSourceData, args: [n3, i4[n3].data] }) : $e(n3, i4, o4, r3)) : Xe(n3, i4, o4));
              }(e2.sources, i3.sources, n2, r2);
              const s2 = [];
              e2.layers && e2.layers.forEach((e3) => {
                e3.source && r2[e3.source] ? o3.push({ command: We.removeLayer, args: [e3.id] }) : s2.push(e3);
              });
              let a2 = e2.terrain;
              a2 && r2[a2.source] && (o3.push({ command: We.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(n2), t(a2, i3.terrain) || o3.push({ command: We.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                i4 = i4 || [];
                const r3 = (e3 = e3 || []).map(Ke), n3 = i4.map(Ke), s3 = e3.reduce(Je, {}), a3 = i4.reduce(Je, {}), l2 = r3.slice(), c2 = /* @__PURE__ */ Object.create(null);
                let h4, u2, _2, d2, p2, m2, f2;
                for (h4 = 0, u2 = 0; h4 < r3.length; h4++)
                  _2 = r3[h4], a3.hasOwnProperty(_2) ? u2++ : (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.indexOf(_2, u2), 1));
                for (h4 = 0, u2 = 0; h4 < n3.length; h4++)
                  _2 = n3[n3.length - 1 - h4], l2[l2.length - 1 - h4] !== _2 && (s3.hasOwnProperty(_2) ? (o4.push({ command: We.removeLayer, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - u2), 1)) : u2++, m2 = l2[l2.length - h4], o4.push({ command: We.addLayer, args: [a3[_2], m2] }), l2.splice(l2.length - h4, 0, _2), c2[_2] = true);
                for (h4 = 0; h4 < n3.length; h4++)
                  if (_2 = n3[h4], d2 = s3[_2], p2 = a3[_2], !c2[_2] && !t(d2, p2))
                    if (t(d2.source, p2.source) && t(d2["source-layer"], p2["source-layer"]) && t(d2.type, p2.type)) {
                      for (f2 in Ye(d2.layout, p2.layout, o4, _2, null, We.setLayoutProperty), Ye(d2.paint, p2.paint, o4, _2, null, We.setPaintProperty), t(d2.filter, p2.filter) || o4.push({ command: We.setFilter, args: [_2, p2.filter] }), t(d2.minzoom, p2.minzoom) && t(d2.maxzoom, p2.maxzoom) || o4.push({ command: We.setLayerZoomRange, args: [_2, p2.minzoom, p2.maxzoom] }), d2)
                        d2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                      for (f2 in p2)
                        p2.hasOwnProperty(f2) && !d2.hasOwnProperty(f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? Ye(d2[f2], p2[f2], o4, _2, f2.slice(6), We.setPaintProperty) : t(d2[f2], p2[f2]) || o4.push({ command: We.setLayerProperty, args: [_2, f2, p2[f2]] }));
                    } else
                      o4.push({ command: We.removeLayer, args: [_2] }), m2 = l2[l2.lastIndexOf(_2) + 1], o4.push({ command: We.addLayer, args: [p2, m2] });
              }(s2, i3.layers, o3);
            } catch (e3) {
              console.warn("Unable to compute style diff:", e3), o3 = [{ command: We.setStyle, args: [i3] }];
            }
            return o3;
          }(this.serialize(), i2).filter((e2) => !(e2.command in Yt));
          if (o2.length === 0)
            return false;
          const r = o2.filter((e2) => !(e2.command in Ht));
          if (r.length > 0)
            throw new Error(`Unimplemented: ${r.map((e2) => e2.command).join(", ")}.`);
          return o2.forEach((e2) => {
            e2.command !== "setTransition" && e2.command !== "setProjection" && this[e2.command].apply(this, e2.args);
          }), this.stylesheet = i2, this._updateMapProjection(), true;
        }
        addImage(t2, i2) {
          return this.getImage(t2) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2), this);
        }
        updateImage(e2, t2) {
          this.imageManager.updateImage(e2, t2);
        }
        getImage(e2) {
          return this.imageManager.getImage(e2);
        }
        removeImage(t2) {
          return this.getImage(t2) ? (this.imageManager.removeImage(t2), this._afterImageUpdated(t2), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addSource(t2, i2, o2 = {}) {
          if (this._checkLoaded(), this.getSource(t2) !== void 0)
            throw new Error("There is already a source with this ID");
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateSource, `sources.${t2}`, i2, null, o2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const r = Pe(t2, i2, this.dispatcher, this);
          r.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t2), source: r.serialize(), sourceId: t2 }));
          const n2 = (i3) => {
            const o3 = (i3 ? "symbol:" : "other:") + t2, n3 = this._sourceCaches[o3] = new e.SourceCache(o3, r, i3);
            (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t2] = n3, n3.style = this, n3.onAdd(this.map);
          };
          n2(false), i2.type !== "vector" && i2.type !== "geojson" || n2(true), r.onAdd && r.onAdd(this.map), this._changed = true;
        }
        removeSource(t2) {
          this._checkLoaded();
          const i2 = this.getSource(t2);
          if (!i2)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t2)
              return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
          if (this.terrain && this.terrain.get().source === t2)
            return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
          const o2 = this._getSourceCaches(t2);
          for (const t3 of o2)
            delete this._sourceCaches[t3.id], delete this._updatedSources[t3.id], t3.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
          return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true, this;
        }
        setGeoJSONSourceData(e2, t2) {
          this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
        }
        getSource(e2) {
          const t2 = this._getSourceCache(e2);
          return t2 && t2.getSource();
        }
        _getSources() {
          const e2 = [];
          for (const t2 in this._otherSourceCaches) {
            const i2 = this._getSourceCache(t2);
            i2 && e2.push(i2.getSource());
          }
          return e2;
        }
        addLayer(t2, i2, o2 = {}) {
          this._checkLoaded();
          const r = t2.id;
          if (this.getLayer(r))
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
          let n2;
          if (t2.type === "custom") {
            if ($t(this, e.validateCustomStyleLayer(t2)))
              return;
            n2 = e.createStyleLayer(t2);
          } else {
            if (typeof t2.source == "object" && (this.addSource(r, t2.source), t2 = e.clone$1(t2), t2 = e.extend(t2, { source: r })), this._validate(e.validateLayer, `layers.${r}`, t2, { arrayIndex: -1 }, o2))
              return;
            n2 = e.createStyleLayer(t2), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
          }
          const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && s2 === -1)
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
          this._order.splice(s2, 0, r), this._layerOrderChanged = true, this._layers[r] = n2;
          const a2 = this._getLayerSourceCache(n2);
          if (this._removedLayers[r] && n2.source && a2 && n2.type !== "custom") {
            const e2 = this._removedLayers[r];
            delete this._removedLayers[r], e2.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", a2.pause());
          }
          this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
        }
        moveLayer(t2, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[t2])
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
          if (t2 === i2)
            return;
          const o2 = this._order.indexOf(t2);
          this._order.splice(o2, 1);
          const r = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && r === -1 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r, 0, t2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
        }
        removeLayer(t2) {
          this._checkLoaded();
          const i2 = this._layers[t2];
          if (!i2)
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be removed.`)));
          i2.setEventedParent(null), this._updateLayerCount(i2, false);
          const o2 = this._order.indexOf(t2);
          this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
        }
        getLayer(e2) {
          return this._layers[e2];
        }
        hasLayer(e2) {
          return e2 in this._layers;
        }
        hasLayerType(e2) {
          for (const t2 in this._layers)
            if (this._layers[t2].type === e2)
              return true;
          return false;
        }
        setLayerZoomRange(t2, i2, o2) {
          this._checkLoaded();
          const r = this.getLayer(t2);
          r ? r.minzoom === i2 && r.maxzoom === o2 || (i2 != null && (r.minzoom = i2), o2 != null && (r.maxzoom = o2), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot have zoom extent.`)));
        }
        setFilter(i2, o2, r = {}) {
          this._checkLoaded();
          const n2 = this.getLayer(i2);
          if (n2) {
            if (!t(n2.filter, o2))
              return o2 == null ? (n2.filter = void 0, void this._updateLayer(n2)) : void (this._validate(e.validateFilter, `layers.${n2.id}.filter`, o2, { layerType: n2.type }, r) || (n2.filter = e.clone$1(o2), this._updateLayer(n2)));
          } else
            this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be filtered.`)));
        }
        getFilter(t2) {
          const i2 = this.getLayer(t2);
          return i2 && e.clone$1(i2.filter);
        }
        setLayoutProperty(i2, o2, r, n2 = {}) {
          this._checkLoaded();
          const s2 = this.getLayer(i2);
          s2 ? t(s2.getLayoutProperty(o2), r) || (s2.setLayoutProperty(o2, r, n2), this._updateLayer(s2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
        }
        getLayoutProperty(t2, i2) {
          const o2 = this.getLayer(t2);
          if (o2)
            return o2.getLayoutProperty(i2);
          this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style.`)));
        }
        setPaintProperty(i2, o2, r, n2 = {}) {
          this._checkLoaded();
          const s2 = this.getLayer(i2);
          s2 ? t(s2.getPaintProperty(o2), r) || (s2.setPaintProperty(o2, r, n2) && this._updateLayer(s2), this._changed = true, this._updatedPaintProps[i2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
        }
        getPaintProperty(e2, t2) {
          const i2 = this.getLayer(e2);
          return i2 && i2.getPaintProperty(t2);
        }
        setFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r = t2.sourceLayer, n2 = this.getSource(o2);
          if (!n2)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const s2 = n2.type;
          if (s2 === "geojson" && r)
            return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if (s2 === "vector" && !r)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          t2.id === void 0 && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
          const a2 = this._getSourceCaches(o2);
          for (const e2 of a2)
            e2.setFeatureState(r, t2.id, i2);
        }
        removeFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r = this.getSource(o2);
          if (!r)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const n2 = r.type, s2 = n2 === "vector" ? t2.sourceLayer : void 0;
          if (n2 === "vector" && !s2)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i2 && typeof t2.id != "string" && typeof t2.id != "number")
            return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
          const a2 = this._getSourceCaches(o2);
          for (const e2 of a2)
            e2.removeFeatureState(s2, t2.id, i2);
        }
        getFeatureState(t2) {
          this._checkLoaded();
          const i2 = t2.source, o2 = t2.sourceLayer, r = this.getSource(i2);
          if (r) {
            if (r.type !== "vector" || o2)
              return t2.id === void 0 && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t2.id);
            this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          const t2 = {};
          for (const e2 in this._sourceCaches) {
            const i2 = this._sourceCaches[e2].getSource();
            t2[i2.id] || (t2[i2.id] = i2.serialize());
          }
          return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t2, layers: this._serializeLayers(this._order) }, (e2) => e2 !== void 0);
        }
        _updateLayer(e2) {
          this._updatedLayers[e2.id] = true;
          const t2 = this._getLayerSourceCache(e2);
          e2.source && !this._updatedSources[e2.source] && t2 && t2.getSource().type !== "raster" && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true, e2.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e2) {
          const t2 = (e3) => this._layers[e3].type === "fill-extrusion", i2 = {}, o2 = [];
          for (let r2 = this._order.length - 1; r2 >= 0; r2--) {
            const n2 = this._order[r2];
            if (t2(n2)) {
              i2[n2] = r2;
              for (const t3 of e2) {
                const e3 = t3[n2];
                if (e3)
                  for (const t4 of e3)
                    o2.push(t4);
              }
            }
          }
          o2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const r = [];
          for (let n2 = this._order.length - 1; n2 >= 0; n2--) {
            const s2 = this._order[n2];
            if (t2(s2))
              for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                const t3 = o2[e3].feature;
                if (i2[t3.layer.id] < n2)
                  break;
                r.push(t3), o2.pop();
              }
            else
              for (const t3 of e2) {
                const e3 = t3[s2];
                if (e3)
                  for (const t4 of e3)
                    r.push(t4.feature);
              }
          }
          return r;
        }
        queryRenderedFeatures(t2, i2, o2) {
          i2 && i2.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const r = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._layers[t3];
              if (!i3)
                return this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              r[i3.source] = true;
            }
          }
          const n2 = [];
          i2.availableImages = this._availableImages;
          const s2 = i2 && i2.layers ? i2.layers.some((e2) => {
            const t3 = this.getLayer(e2);
            return t3 && t3.is3D();
          }) : this.has3DLayers(), a2 = R2.createFromScreenPoints(t2, o2);
          for (const e2 in this._sourceCaches) {
            const t3 = this._sourceCaches[e2].getSource().id;
            i2.layers && !r[t3] || n2.push(Oe(this._sourceCaches[e2], this._layers, this._serializedLayers, a2, i2, o2, s2, !!this.map._showQueryGeometry));
          }
          return this.placement && n2.push(function(e2, t3, i3, o3, r2, n3, s3) {
            const a3 = {}, l2 = n3.queryRenderedSymbols(o3), c2 = [];
            for (const e3 of Object.keys(l2).map(Number))
              c2.push(s3[e3]);
            c2.sort(ke);
            for (const i4 of c2) {
              const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r2.filter, r2.layers, r2.availableImages, e2);
              for (const e3 in o4) {
                const t4 = a3[e3] = a3[e3] || [], r3 = o4[e3];
                r3.sort((e4, t5) => {
                  const o5 = i4.featureSortOrder;
                  if (o5) {
                    const i5 = o5.indexOf(e4.featureIndex);
                    return o5.indexOf(t5.featureIndex) - i5;
                  }
                  return t5.featureIndex - e4.featureIndex;
                });
                for (const e4 of r3)
                  t4.push(e4);
              }
            }
            for (const t4 in a3)
              a3[t4].forEach((o4) => {
                const r3 = o4.feature, n4 = i3(e2[t4]).getFeatureState(r3.layer["source-layer"], r3.id);
                r3.source = r3.layer.source, r3.layer["source-layer"] && (r3.sourceLayer = r3.layer["source-layer"]), r3.state = n4;
              });
            return a3;
          }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
        }
        querySourceFeatures(t2, i2) {
          i2 && i2.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i2.filter, null, i2);
          const o2 = this._getSourceCaches(t2);
          let r = [];
          for (const e2 of o2)
            r = r.concat(Be(e2, i2));
          return r;
        }
        addSourceType(e2, t2, i2) {
          return Qt.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Qt.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e2, i2 = {}) {
          this._checkLoaded();
          const o2 = this.light.getLight();
          let r = false;
          for (const i3 in e2)
            if (!t(e2[i3], o2[i3])) {
              r = true;
              break;
            }
          if (!r)
            return;
          const n2 = this._setTransitionParameters({ duration: 300, delay: 0 });
          this.light.setLight(e2, i2), this.light.updateTransitions(n2);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(i2, o2 = 1) {
          if (this._checkLoaded(), !i2)
            return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          if (o2 === 1) {
            if (typeof i2.source == "object") {
              const t2 = "terrain-dem-src";
              this.addSource(t2, i2.source), i2 = e.clone$1(i2), i2 = e.extend(i2, { source: t2 });
            }
            if (this._validate(e.validateTerrain, "terrain", i2))
              return;
          }
          if (!this.terrain || this.terrain && o2 !== this.terrain.drapeRenderMode)
            this._createTerrain(i2, o2);
          else {
            const o3 = this.terrain, r = o3.get();
            for (const t2 of Object.keys(e.spec.terrain))
              !i2.hasOwnProperty(t2) && e.spec.terrain[t2].default && (i2[t2] = e.spec.terrain[t2].default);
            for (const e2 in i2)
              if (!t(i2[e2], r[e2])) {
                o3.set(i2), this.stylesheet.terrain = i2;
                const e3 = this._setTransitionParameters({ duration: 0 });
                o3.updateTransitions(e3);
                break;
              }
          }
          this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e2) {
          const t2 = this.fog = new A(e2, this.map.transform);
          this.stylesheet.fog = e2;
          const i2 = this._setTransitionParameters({ duration: 0 });
          t2.updateTransitions(i2);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 && this.map._requestDomTask(() => {
            for (const e2 of this.map._markers)
              e2._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(e2) {
          if (this._checkLoaded(), !e2)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i2 = this.fog, o2 = i2.get();
            Object.keys(e2).length === 0 && i2.set(e2);
            for (const r in e2)
              if (!t(e2[r], o2[r])) {
                i2.set(e2), this.stylesheet.fog = e2;
                const t2 = this._setTransitionParameters({ duration: 0 });
                i2.updateTransitions(t2);
                break;
              }
          } else
            this._createFog(e2);
          this._markersNeedUpdate = true;
        }
        _setTransitionParameters(t2) {
          return { now: e.exported.now(), transition: e.extend(t2, this.stylesheet.transition) };
        }
        _updateDrapeFirstLayers() {
          if (!this.map._optimizeForTerrain || !this.terrain)
            return;
          const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
        }
        _createTerrain(e2, t2) {
          const i2 = this.terrain = new M(e2, t2);
          this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
          const o2 = this._setTransitionParameters({ duration: 0 });
          i2.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e2 in this._layers) {
            const t2 = this._layers[e2];
            t2.type === "fill-extrusion" && this._updateLayer(t2);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e2 in this._layers) {
            const t2 = this._layers[e2];
            t2.type === "symbol" && this._updateLayer(t2);
          }
        }
        _validate(t2, i2, o2, r, n2 = {}) {
          return (!n2 || n2.validate !== false) && $t(this, t2.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e2 in this._layers)
            this._layers[e2].setEventedParent(null);
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.clearTiles();
        }
        _reloadSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.resume(), e3.reload();
        }
        _reloadSources() {
          for (const e2 of this._getSources())
            e2.reload && e2.reload();
        }
        _updateSources(e2) {
          for (const t2 in this._sourceCaches)
            this._sourceCaches[t2].update(e2);
        }
        _generateCollisionBoxes() {
          for (const e2 in this._sourceCaches) {
            const t2 = this._sourceCaches[e2];
            t2.resume(), t2.reload();
          }
        }
        _updatePlacement(t2, i2, o2, r, n2 = false) {
          let s2 = false, a2 = false;
          const l2 = {};
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if (i3.type !== "symbol")
              continue;
            if (!l2[i3.source]) {
              const e3 = this._getLayerSourceCache(i3);
              if (!e3)
                continue;
              l2[i3.source] = e3.getRenderableIds(true).map((t3) => e3.getTileByID(t3)).sort((e4, t3) => t3.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t3.tileID) ? -1 : 1));
            }
            const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng, t2.projection);
            s2 = s2 || o3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || o2 === 0, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t2.zoom)) && (this.pauseablePlacement = new jt(t2, this._order, n2, i2, o2, r, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a2 = true), s2 && this.pauseablePlacement.placement.setStale()), a2 || s2)
            for (const e2 of this._order) {
              const t3 = this._layers[e2];
              t3.type === "symbol" && this.placement.updateLayerOpacities(t3, l2[t3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].releaseSymbolFadeTiles();
        }
        getImages(e2, t2, i2) {
          this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
          const o2 = (e3) => {
            e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
          };
          o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
        }
        getGlyphs(e2, t2, i2) {
          this.glyphManager.getGlyphs(t2.stacks, i2);
        }
        getResource(t2, i2, o2) {
          return e.makeRequest(i2, o2);
        }
        _getSourceCache(e2) {
          return this._otherSourceCaches[e2];
        }
        _getLayerSourceCache(e2) {
          return e2.type === "symbol" ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
        }
        _getSourceCaches(e2) {
          const t2 = [];
          return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
        }
        _isSourceCacheLoaded(t2) {
          const i2 = this._getSourceCaches(t2);
          return i2.length === 0 ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
        }
        has3DLayers() {
          return this._num3DLayers > 0;
        }
        hasSymbolLayers() {
          return this._numSymbolLayers > 0;
        }
        hasCircleLayers() {
          return this._numCircleLayers > 0;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      Qt.getSourceType = function(e2) {
        return ze[e2];
      }, Qt.setSourceType = function(e2, t2) {
        ze[e2] = t2;
      }, Qt.registerForPluginStateChange = e.registerForPluginStateChange;
      var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
      let ni = {}, si = {};
      const ai = [];
      _i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);
      const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ci = ei, hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
      var ui = { background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti), skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
      function _i(e2, t2) {
        const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i2)
          if (e3 = e3.trim(), e3[0] === "#" && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3)
              t2.includes(e4) || t2.push(e4);
          }
      }
      function di(e2, t2) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r = {}, n2 = [...ai];
        return _i(e2, n2), _i(t2, n2), { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, o3, n3) => (r[n3] = true, t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${n3}
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, o3, n3) => {
          const s2 = o3 === "float" ? "vec2" : "vec4", a2 = n3.match(/color/) ? "color" : s2;
          return r[n3] ? t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
varying ${i3} ${o3} ${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : a2 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : t3 === "define" ? `
#ifndef HAS_UNIFORM_u_${n3}
uniform lowp float u_${n3}_t;
attribute ${i3} ${s2} a_${n3};
#else
uniform ${i3} ${o3} u_${n3};
#endif
` : a2 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = a_${n3};
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n3}
    ${i3} ${o3} ${n3} = unpack_mix_${a2}(a_${n3}, u_${n3}_t);
#else
    ${i3} ${o3} ${n3} = u_${n3};
#endif
`;
        }), staticAttributes: o2, usedDefines: n2 };
      }
      class pi {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e2, t2, i2, o2, r, n2, s2) {
          this.context = e2;
          let a2 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !a2 && e3 < o2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== o2[e3] && (a2 = true);
          let l2 = this.boundDynamicVertexBuffers.length !== s2.length;
          for (let e3 = 0; !l2 && e3 < s2.length; e3++)
            this.boundDynamicVertexBuffers[e3] !== s2[e3] && (l2 = true);
          if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || a2 || l2 || this.boundIndexBuffer !== r || this.boundVertexOffset !== n2)
            this.freshBind(t2, i2, o2, r, n2, s2);
          else {
            e2.bindVertexArrayOES.set(this.vao);
            for (const e3 of s2)
              e3 && e3.bind();
            r && r.dynamicDraw && r.bind();
          }
        }
        freshBind(e2, t2, i2, o2, r, n2) {
          let s2;
          const a2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
          if (l2.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = l2.extVertexArrayObject.createVertexArrayOES(), l2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n2;
          else {
            s2 = l2.currentNumAttributes || 0;
            for (let e3 = a2; e3 < s2; e3++)
              c2.disableVertexAttribArray(e3);
          }
          t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, r);
          for (const t3 of i2)
            t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r);
          for (const t3 of n2)
            t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r));
          o2 && o2.bind(), l2.currentNumAttributes = a2;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function mi(t2, i2) {
        const o2 = Math.pow(2, i2.canonical.z), r = i2.canonical.y;
        return [new e.MercatorCoordinate(0, r / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o2).toLngLat().lat];
      }
      function fi(t2, i2, o2, r, n2, s2, a2) {
        const l2 = t2.context, c2 = l2.gl, h4 = o2.fbo;
        if (!h4)
          return;
        t2.prepareDrawTile();
        const u2 = t2.useProgram("hillshade");
        l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h4.colorAttachment.get());
        const _2 = ((e2, t3, i3, o3) => {
          const r2 = i3.paint.get("hillshade-shadow-color"), n3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
          let a3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          i3.paint.get("hillshade-illumination-anchor") === "viewport" && (a3 -= e2.transform.angle);
          const l3 = !e2.options.moving;
          return { u_matrix: o3 || e2.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: mi(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), a3], u_shadow: r2, u_highlight: n3, u_accent: s3 };
        })(t2, o2, r, t2.terrain ? i2.projMatrix : null);
        t2.prepareDrawProgram(l2, u2, i2.toUnwrapped());
        const { tileBoundsBuffer: d2, tileBoundsIndexBuffer: p2, tileBoundsSegments: m2 } = t2.getTileBoundsBuffers(o2);
        u2.draw(l2, c2.TRIANGLES, n2, s2, a2, e.CullFaceMode.disabled, _2, r.id, d2, p2, m2);
      }
      function gi(t2, i2, o2) {
        if (!i2.needsDEMTextureUpload)
          return;
        const r = t2.context, n2 = r.gl;
        r.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
        const s2 = o2.getPixels();
        i2.demTexture ? i2.demTexture.update(s2, { premultiply: false }) : i2.demTexture = new e.Texture(r, s2, n2.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
      }
      function vi(t2, i2, o2, r, n2, s2) {
        const a2 = t2.context, l2 = a2.gl;
        if (!i2.dem)
          return;
        const c2 = i2.dem;
        if (a2.activeTexture.set(l2.TEXTURE1), gi(t2, i2, c2), !i2.demTexture)
          return;
        i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
        const h4 = c2.dim;
        a2.activeTexture.set(l2.TEXTURE0);
        let u2 = i2.fbo;
        if (!u2) {
          const t3 = new e.Texture(a2, { width: h4, height: h4, data: null }, l2.RGBA);
          t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u2 = i2.fbo = a2.createFramebuffer(h4, h4, true), u2.colorAttachment.set(t3.texture);
        }
        a2.bindFramebuffer.set(u2.framebuffer), a2.viewport.set([0, 0, h4, h4]);
        const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d2, tileBoundsSegments: p2 } = t2.getMercatorTileBoundsBuffers();
        t2.useProgram("hillshadePrepare").draw(a2, l2.TRIANGLES, r, n2, s2, e.CullFaceMode.disabled, ((t3, i3) => {
          const o3 = i3.stride, r2 = e.create();
          return e.ortho(r2, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r2, r2, [0, -e.EXTENT, 0]), { u_matrix: r2, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ, u_unpack: i3.unpackVector };
        })(i2.tileID, c2), o2.id, _2, d2, p2), i2.needsHillshadePrepare = false;
      }
      const xi = (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image0: new e.Uniform1i(t2), u_skirt_height: new e.Uniform1f(t2) }), yi = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), bi = (e2, t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r, u_merc_center: n2, u_image0: 0, u_frustum_tl: s2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h4, u_globe_radius: u2, u_viewport: _2, u_grid_matrix: p2 ? Float32Array.from(p2) : new Float32Array(9), u_skirt_height: d2 });
      function wi(e2, t2) {
        return e2 != null && t2 != null && !(!e2.hasData() || !t2.hasData()) && e2.demTexture != null && t2.demTexture != null && e2.tileID.key !== t2.tileID.key;
      }
      const Ti = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e2, t2, i2, o2, r) {
          if (e2 in this.operations) {
            const t3 = this.operations[e2];
            t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
          } else
            this.operations[e2] = { startTime: o2, phase: 0, duration: r, from: t2, to: i2, queued: null };
        }
        getMorphValuesForProxy(e2) {
          if (!(e2 in this.operations))
            return null;
          const t2 = this.operations[e2];
          return { from: t2.from, to: t2.to, phase: t2.phase };
        }
        update(e2) {
          for (const t2 in this.operations) {
            const i2 = this.operations[t2];
            for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e2)) {
                delete this.operations[t2];
                break;
              }
          }
        }
        _nextOp(e2, t2) {
          return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
        }
        _validOp(e2) {
          return e2.from.hasData() && e2.to.hasData();
        }
      }(), Ei = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
      function Ci(e2) {
        return 6 * Math.pow(1.5, 22 - e2);
      }
      function Mi(e2, t2) {
        const i2 = 1 << e2.z;
        return !t2 && (e2.x === 0 || e2.x === i2 - 1) || e2.y === 0 || e2.y === i2 - 1;
      }
      const Ii = (e2) => ({ u_matrix: e2 });
      function Si(t2, i2, o2, r, n2) {
        if (n2 > 0) {
          const s2 = e.exported.now(), a2 = (s2 - t2.timeAdded) / n2, l2 = i2 ? (s2 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h4 = r.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h4) > Math.abs(t2.tileID.overscaledZ - h4), _2 = u2 && t2.refreshedUponExpiration ? 1 : e.clamp(u2 ? a2 : 1 - l2, 0, 1);
          return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class Di extends e.SourceCache {
        constructor(e2) {
          const t2 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new z(je(), null), o2 = Pe("mock-dem", t2, i2, e2.style);
          super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e2, t2) {
          e2.state = "loaded", t2(null);
        }
      }
      class Li extends e.SourceCache {
        constructor(e2) {
          const t2 = Pe("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new z(je(), null), e2.style);
          super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t2, i2, o2) {
          if (t2.freezeTileCoverage)
            return;
          this.transform = t2;
          const r = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
            if (i3[o3.key] = "", !this._tiles[o3.key]) {
              const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
              i4.state = "loaded", this._tiles[o3.key] = i4;
            }
            return i3;
          }, {});
          for (const e2 in this._tiles)
            e2 in r || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
        }
        freeFBO(e2) {
          const t2 = this.proxyCachedFBO[e2];
          if (t2 !== void 0) {
            const i2 = Object.values(t2);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Ai extends e.OverscaledTileID {
        constructor(e2, t2, i2) {
          super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
        }
      }
      class zi extends e.Elevation {
        constructor(t2, i2) {
          super(), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, r, n2] = function(t3) {
            const i3 = new e.StructArrayLayout2i4(), o3 = new e.StructArrayLayout3ui6(), r2 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const n3 = e.EXTENT / 128, s3 = e.EXTENT + n3 / 2, a3 = s3 + n3;
            for (let t4 = -n3; t4 < a3; t4 += n3)
              for (let o4 = -n3; o4 < a3; o4 += n3) {
                const r3 = o4 < 0 || o4 > s3 || t4 < 0 || t4 > s3 ? 24575 : 0, n4 = e.clamp(Math.round(o4), 0, e.EXTENT), a4 = e.clamp(Math.round(t4), 0, e.EXTENT);
                i3.emplaceBack(n4 + r3, a4);
              }
            const l2 = (e2, t4) => {
              const i4 = t4 * r2 + e2;
              o3.emplaceBack(i4 + 1, i4, i4 + r2), o3.emplaceBack(i4 + r2, i4 + r2 + 1, i4 + 1);
            };
            for (let e2 = 1; e2 < 129; e2++)
              for (let t4 = 1; t4 < 129; t4++)
                l2(t4, e2);
            return [0, 129].forEach((e2) => {
              for (let t4 = 0; t4 < 130; t4++)
                l2(t4, e2), l2(e2, t4);
            }), [i3, o3, 32768];
          }(), s2 = t2.context;
          this.gridBuffer = s2.createVertexBuffer(o2, e.posAttributes.members), this.gridIndexBuffer = s2.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i2.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);
          const a2 = s2.gl;
          this._overlapStencilMode = new e.StencilMode({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Di(i2.map);
        }
        set style(e2) {
          e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t2, i2, o2) {
          if (t2 && t2.terrain) {
            this._style !== t2 && (this.style = t2), this.enabled = true;
            const r = t2.terrain.properties;
            this.sourceCache = t2.terrain.drapeRenderMode === 0 ? this._mockSourceCache : t2._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");
            const n2 = () => {
              this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const t3 = this.getScaledDemTileSize();
              this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
          } else
            this._disable();
        }
        resetTileLookupCache(e2) {
          this._findCoveringTileCache[e2] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _checkRenderCacheEfficiency() {
          const t2 = this.renderCacheEfficiency(this._style);
          this._style.map._optimizeForTerrain || t2.efficiency !== 100 && e.warnOnce(`Terrain render cache efficiency is not optimal (${t2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
        }
        _onStyleDataEvent(e2) {
          e2.coord && e2.dataType === "source" ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : e2.dataType === "style" && (this._invalidateRenderCache = true);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e2 in this._style._sourceCaches)
              this._style._sourceCaches[e2].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e2 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e2, e2];
        }
        set useVertexMorphing(e2) {
          this._useVertexMorphing = e2;
        }
        updateTileBinding(t2) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i2 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = o2._centerAltitude === 0 && this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
          const r = this.proxyCoords = i2.getIds().map((e2) => {
            const t3 = i2.getTileByID(e2).tileID;
            return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
          });
          !function(t3, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r2 = new e.pointGeometry(o3.x, o3.y);
            t3.sort((t4, i4) => {
              if (i4.overscaledZ - t4.overscaledZ)
                return i4.overscaledZ - t4.overscaledZ;
              const o4 = new e.pointGeometry(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), n3 = new e.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), s3 = r2.mult(1 << t4.canonical.z);
              return s3.x -= 0.5, s3.y -= 0.5, s3.distSqr(o4) - s3.distSqr(n3);
            });
          }(r, this.painter), this._previousZoom = o2.zoom;
          const n2 = this.proxyToSource || {};
          this.proxyToSource = {}, r.forEach((e2) => {
            this.proxyToSource[e2.key] = {};
          }), this.terrainTileForTile = {};
          const s2 = this._style._sourceCaches;
          for (const e2 in s2) {
            const i3 = s2[e2];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], n2), i3.usedForTerrain)
              continue;
            const o3 = t2[e2];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i2.id] = r.map((e2) => new Ai(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
          const a2 = {};
          this._visibleDemTiles = [];
          for (const e2 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e2.key];
            if (!t3)
              continue;
            const i3 = t3.tileID.key;
            i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
          }
        }
        _assignTerrainTiles(e2) {
          this._initializing || e2.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
            t2 && (this.terrainTileForTile[e3.key] = t2);
          });
        }
        _prepareDEMTextures() {
          const e2 = this.painter.context, t2 = e2.gl;
          for (const i2 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i2], r = o2.dem;
            !r || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), gi(this.painter, o2, r));
          }
        }
        _prepareDemTileUniforms(e2, t2, i2, o2) {
          if (!t2 || t2.demTexture == null)
            return false;
          const r = e2.tileID.canonical, n2 = Math.pow(2, t2.tileID.canonical.z - r.z), s2 = o2 || "";
          return i2[`u_dem_tl${s2}`] = [r.x * n2 % 1, r.y * n2 % 1], i2[`u_dem_scale${s2}`] = n2, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const t2 = this.painter.context, i2 = t2.gl;
          if (!this._emptyDepthBufferTexture) {
            const o2 = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new e.Texture(t2, o2, i2.RGBA, { premultiply: false });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let e2 = 0;
          const t2 = this._visibleDemTiles.reduce((t3, i2) => {
            if (!i2.dem)
              return t3;
            const o2 = i2.dem.tree.minimums[0];
            return o2 > 0 && e2++, t3 + o2;
          }, 0);
          return e2 ? t2 / e2 : 0;
        }
        _updateEmptyDEMTexture() {
          const t2 = this.painter.context, i2 = t2.gl;
          t2.activeTexture.set(i2.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), r = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)));
          this._emptyDEMTextureDirty = false;
          let n2 = this._emptyDEMTexture;
          return n2 ? n2.update(r, { premultiply: false }) : n2 = this._emptyDEMTexture = new e.Texture(t2, r, i2.RGBA, { premultiply: false }), n2;
        }
        setupElevationDraw(t2, i2, o2) {
          const r = this.painter.context, n2 = r.gl, s2 = (a2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
          var a2;
          s2.u_dem_size = this.sourceCache.getSource().tileSize, s2.u_exaggeration = this.exaggeration();
          let l2 = null, c2 = null, h4 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            h4 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, s2, "_prev") && (c2 = e2), this._prepareDemTileUniforms(t2, i3, s2) && (l2 = i3));
          }
          if (c2 && l2 ? (r.activeTexture.set(n2.TEXTURE2), l2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r.activeTexture.set(n2.TEXTURE4), c2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), s2.u_dem_lerp = h4) : (l2 = this.terrainTileForTile[t2.tileID.key], r.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(t2, l2, s2) ? l2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE)), r.activeTexture.set(n2.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), this._depthFBO && (s2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), s2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && l2) {
            const t3 = (1 << l2.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            s2.u_meter_to_dem = t3;
          }
          if (o2 && o2.labelPlaneMatrixInv && (s2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r, s2), this.painter.transform.projection.name === "globe") {
            const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
            i2.setGlobeUniformValues(r, e2);
          }
        }
        globeUniformValues(t2, i2, o2) {
          const r = t2.projection;
          return { u_tile_tl_up: r.upVector(i2, 0, 0), u_tile_tr_up: r.upVector(i2, e.EXTENT, 0), u_tile_br_up: r.upVector(i2, e.EXTENT, e.EXTENT), u_tile_bl_up: r.upVector(i2, 0, e.EXTENT), u_tile_up_scale: o2 ? e.globeMetersToEcef(1) : r.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
        }
        renderToBackBuffer(t2) {
          const i2 = this.painter, o2 = this.painter.context;
          t2.length !== 0 && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r, n2) {
            if (t3.transform.projection.name === "globe")
              !function(t4, i4, o4, r2, n3) {
                const s2 = t4.context, a2 = s2.gl;
                let l2, c2;
                const h4 = t4.options.showTerrainWireframe ? 2 : 0, u2 = t4.transform, _2 = e.globeUseCustomAntiAliasing(t4, s2, u2), d2 = (e2, i5) => {
                  if (c2 === e2)
                    return;
                  const o5 = [Ei[e2], "PROJECTION_GLOBE_VIEW"];
                  _2 && o5.push("CUSTOM_ANTIALIASING"), i5 && o5.push(Ei[h4]), l2 = t4.useProgram("globeRaster", null, o5), c2 = e2;
                }, p2 = t4.colorModeForRenderPass(), m2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
                Ti.update(n3);
                const f2 = e.calculateGlobeMercatorMatrix(u2), g2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], v3 = h4 ? [false, true] : [false], x2 = t4.globeSharedBuffers, y2 = [u2.width * e.exported.devicePixelRatio, u2.height * e.exported.devicePixelRatio], b2 = Float32Array.from(u2.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                if (v3.forEach((h5) => {
                  const u3 = t4.transform, _3 = Ci(u3.zoom) * i4.exaggeration();
                  c2 = -1;
                  const v4 = h5 ? a2.LINES : a2.TRIANGLES;
                  for (const c3 of r2) {
                    const r3 = o4.getTile(c3), T2 = e.StencilMode.disabled, E2 = i4.prevTerrainTileForTile[c3.key], C2 = i4.terrainTileForTile[c3.key];
                    wi(E2, C2) && Ti.newMorphing(c3.key, E2, C2, n3, 250), s2.activeTexture.set(a2.TEXTURE0), r3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                    const M2 = Ti.getMorphValuesForProxy(c3.key), I2 = M2 ? 1 : 0;
                    M2 && e.extend$1(w2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e.easeCubicInOut(M2.phase) } });
                    const S2 = e.tileCornersToBounds(c3.canonical), D2 = e.getLatitudinalLod(S2.getCenter().lat), L2 = e.getGridMatrix(c3.canonical, S2, D2, u3.worldSize / u3._pixelsPerMercatorPixel), A2 = e.globeNormalizeECEF(e.globeTileBounds(c3.canonical)), z2 = bi(u3.projMatrix, b2, f2, A2, e.globeToMercatorTransition(u3.zoom), g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y2, _3, L2);
                    if (d2(I2, h5), i4.setupElevationDraw(r3, l2, w2), t4.prepareDrawProgram(s2, l2, c3.toUnwrapped()), x2) {
                      const [i5, o5, r4] = h5 ? x2.getWirefameBuffers(t4.context, D2) : x2.getGridBuffers(D2, _3 !== 0);
                      l2.draw(s2, v4, m2, T2, p2, e.CullFaceMode.backCCW, z2, "globe_raster", i5, o5, r4);
                    }
                  }
                }), x2) {
                  const n4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _2 && n4.push("CUSTOM_ANTIALIASING"), l2 = t4.useProgram("globeRaster", null, n4);
                  for (const n5 of r2) {
                    const { x: r3, y: c3, z: h5 } = n5.canonical, _3 = c3 === 0, d3 = c3 === (1 << h5) - 1, [f3, v4, b3, T2] = x2.getPoleBuffers(h5);
                    if (T2 && (_3 || d3)) {
                      const c4 = o4.getTile(n5);
                      s2.activeTexture.set(a2.TEXTURE0), c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      let x3 = e.globePoleMatrixForTile(h5, r3, u2);
                      const E2 = e.globeNormalizeECEF(e.globeTileBounds(n5.canonical)), C2 = (t5, i5) => t5.draw(s2, a2.TRIANGLES, m2, e.StencilMode.disabled, p2, e.CullFaceMode.disabled, bi(u2.projMatrix, x3, x3, E2, 0, g2, u2.frustumCorners.TL, u2.frustumCorners.TR, u2.frustumCorners.BR, u2.frustumCorners.BL, u2.globeCenterInViewSpace, u2.globeRadius, y2, 0), "globe_pole_raster", i5, b3, T2);
                      i4.setupElevationDraw(c4, l2, w2), t4.prepareDrawProgram(s2, l2, n5.toUnwrapped()), _3 && C2(l2, f3), d3 && (x3 = e.scale(e.create(), x3, [1, -1, 1]), C2(l2, v4));
                    }
                  }
                }
              }(t3, i3, o3, r, n2);
            else {
              const s2 = t3.context, a2 = s2.gl;
              let l2, c2;
              const h4 = t3.options.showTerrainWireframe ? 2 : 0, u2 = (e2, i4) => {
                if (c2 === e2)
                  return;
                const o4 = [Ei[e2]];
                i4 && o4.push(Ei[h4]), l2 = t3.useProgram("terrainRaster", null, o4), c2 = e2;
              }, _2 = t3.colorModeForRenderPass(), d2 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
              Ti.update(n2);
              const p2 = t3.transform, m2 = Ci(p2.zoom) * i3.exaggeration();
              (h4 ? [false, true] : [false]).forEach((h5) => {
                c2 = -1;
                const f2 = h5 ? a2.LINES : a2.TRIANGLES, [g2, v3] = h5 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                for (const c3 of r) {
                  const r2 = o3.getTile(c3), x2 = e.StencilMode.disabled, y2 = i3.prevTerrainTileForTile[c3.key], b2 = i3.terrainTileForTile[c3.key];
                  wi(y2, b2) && Ti.newMorphing(c3.key, y2, b2, n2, 250), s2.activeTexture.set(a2.TEXTURE0), r2.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
                  const w2 = Ti.getMorphValuesForProxy(c3.key), T2 = w2 ? 1 : 0;
                  let E2;
                  w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e.easeCubicInOut(w2.phase) } });
                  const C2 = yi(c3.projMatrix, Mi(c3.canonical, p2.renderWorldCopies) ? m2 / 10 : m2);
                  u2(T2, h5), i3.setupElevationDraw(r2, l2, E2), t3.prepareDrawProgram(s2, l2, c3.toUnwrapped()), l2.draw(s2, f2, d2, x2, _2, e.CullFaceMode.backCCW, C2, "terrain_raster", i3.gridBuffer, g2, v3);
                }
              });
            }
          }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
        }
        renderBatch(t2) {
          if (this._drapedRenderBatches.length === 0)
            return t2 + 1;
          this.renderingToTexture = true;
          const i2 = this.painter, o2 = this.painter.context, r = this.proxySourceCache, n2 = this.proxiedCoords[r.id], s2 = this._drapedRenderBatches.shift(), a2 = [], l2 = i2.style.order;
          let c2 = 0;
          for (const h4 of n2) {
            const n3 = r.getTileByID(h4.proxyTileKey), u2 = r.proxyCachedFBO[h4.key] ? r.proxyCachedFBO[h4.key][t2] : void 0, _2 = u2 !== void 0 ? r.renderCache[u2] : this.pool[c2++], d2 = u2 !== void 0;
            if (n3.texture = _2.tex, d2 && !_2.dirty) {
              a2.push(n3.tileID);
              continue;
            }
            let p2;
            o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e.Color.transparent, stencil: 0 }), _2.dirty = false);
            for (let e2 = s2.start; e2 <= s2.end; ++e2) {
              const t3 = i2.style._layers[l2[e2]];
              if (t3.isHidden(i2.transform.zoom))
                continue;
              const r2 = i2.style._getLayerSourceCache(t3), n4 = r2 ? this.proxyToSource[h4.key][r2.id] : [h4];
              if (!n4)
                continue;
              const s3 = n4;
              o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p2 !== (r2 ? r2.id : null) && (this._setupStencil(_2, n4, t3, r2), p2 = r2 ? r2.id : null), i2.renderLayer(i2, r2, t3, s3);
            }
            this.renderedToTile ? (_2.dirty = true, a2.push(n3.tileID)) : d2 || --c2, c2 === 5 && (c2 = 0, this.renderToBackBuffer(a2));
          }
          return this.renderToBackBuffer(a2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), s2.end + 1;
        }
        postRender() {
        }
        renderCacheEfficiency(e2) {
          const t2 = e2.order.length;
          if (t2 === 0)
            return { efficiency: 100 };
          let i2, o2 = 0, r = 0, n2 = false;
          for (let s2 = 0; s2 < t2; ++s2) {
            const t3 = e2._layers[e2.order[s2]];
            this._style.isLayerDraped(t3) ? (n2 && ++o2, ++r) : n2 || (n2 = true, i2 = t3.id);
          }
          return r === 0 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r), firstUndrapedLayer: i2 };
        }
        getMinElevationBelowMSL() {
          let e2 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
            e2 = Math.min(e2, t2.dem.tree.minimums[0]);
          }), e2 === 0 ? e2 : (e2 - 30) * this._exaggeration;
        }
        raycast(e2, t2, i2) {
          if (!this._visibleDemTiles)
            return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const r = o3.tileID, n2 = 1 << r.overscaledZ, { x: s2, y: a2 } = r.canonical, l2 = s2 / n2, c2 = (s2 + 1) / n2, h4 = a2 / n2, u2 = (a2 + 1) / n2;
            return { minx: l2, miny: h4, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h4, c2, u2, e2, t2, i2), tile: o3 };
          });
          o2.sort((e3, t3) => (e3.t !== null ? e3.t : Number.MAX_VALUE) - (t3.t !== null ? t3.t : Number.MAX_VALUE));
          for (const r of o2) {
            if (r.t == null)
              return null;
            const o3 = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e2, t2, i2);
            if (o3 != null)
              return o3;
          }
          return null;
        }
        _createFBO() {
          const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
          t2.activeTexture.set(i2.TEXTURE0);
          const r = new e.Texture(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
          r.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          const n2 = t2.createFramebuffer(o2[0], o2[1], false);
          return n2.colorAttachment.set(r.texture), n2.depthAttachment = new Ee(t2, n2.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && !t2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: n2, tex: r, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.light && this._style.light.hasTransition())
            return true;
          for (const e2 in this._style._sourceCaches)
            if (this._style._sourceCaches[e2].hasTransition())
              return true;
          return this._style.order.some((e2) => {
            const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
            return t2.type === "custom" ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t2 = false;
          for (const e2 of this._style._getSources())
            if (e2 instanceof Ie) {
              t2 = true;
              break;
            }
          if (!t2)
            return;
          const i2 = {};
          for (let t3 = 0; t3 < this._style.order.length; ++t3) {
            const o2 = this._style._layers[this._style.order[t3]], r = this._style._getLayerSourceCache(o2);
            if (r && !i2[r.id] && !o2.isHidden(this.painter.transform.zoom) && o2.type === "line" && o2.widthExpression() instanceof e.ZoomDependentExpression) {
              i2[r.id] = true;
              for (const e2 of this.proxyCoords) {
                const t4 = this.proxyToSource[e2.key][r.id];
                if (t4)
                  for (const e3 of t4)
                    this._clearRenderCacheForTile(r.id, e3);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let e2 = false;
          for (const t3 in this._style._sourceCaches)
            if (this._style._sourceCaches[t3]._source instanceof Se) {
              e2 = true;
              break;
            }
          if (!e2)
            return;
          const t2 = {};
          for (let e3 = 0; e3 < this._style.order.length; ++e3) {
            const i2 = this._style._layers[this._style.order[e3]], o2 = this._style._getLayerSourceCache(i2);
            if (!o2 || t2[o2.id])
              continue;
            if (i2.isHidden(this.painter.transform.zoom) || i2.type !== "raster")
              continue;
            const r = i2.paint.get("raster-fade-duration");
            for (const e4 of this.proxyCoords) {
              const t3 = this.proxyToSource[e4.key][o2.id];
              if (t3)
                for (const e5 of t3) {
                  const t4 = Si(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r);
                  (t4.opacity !== 1 || t4.mix !== 0) && this._clearRenderCacheForTile(o2.id, e5);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const e2 = this._style.order, t2 = e2.length;
          if (t2 === 0)
            return;
          const i2 = [];
          let o2, r = 0, n2 = this._style._layers[e2[r]];
          for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r < t2; )
            n2 = this._style._layers[e2[r]];
          for (; r < t2; ++r) {
            const t3 = this._style._layers[e2[r]];
            t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? o2 === void 0 && (o2 = r) : o2 !== void 0 && (i2.push({ start: o2, end: r - 1 }), o2 = void 0));
          }
          o2 !== void 0 && i2.push({ start: o2, end: r - 1 }), this._drapedRenderBatches = i2;
        }
        _setupRenderCache(e2) {
          const t2 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
            if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
              const e3 = Object.values(t2.proxyCachedFBO);
              t2.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t2.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const i2 = this.proxyCoords, o2 = this._tilesDirty;
          for (let r2 = i2.length - 1; r2 >= 0; r2--) {
            const n2 = i2[r2];
            if (t2.getTileByID(n2.key), t2.proxyCachedFBO[n2.key] !== void 0) {
              const i3 = e2[n2.key], r3 = this.proxyToSource[n2.key];
              let s2 = 0;
              for (const e3 in r3) {
                const t3 = r3[e3], n3 = i3[e3];
                if (!n3 || n3.length !== t3.length || t3.some((t4, i4) => t4 !== n3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                  s2 = -1;
                  break;
                }
                ++s2;
              }
              for (const e3 in t2.proxyCachedFBO[n2.key])
                t2.renderCache[t2.proxyCachedFBO[n2.key][e3]].dirty = s2 < 0 || s2 !== Object.values(i3).length;
            }
          }
          const r = [...this._drapedRenderBatches];
          r.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of r)
            for (const o3 of i2) {
              if (t2.proxyCachedFBO[o3.key])
                continue;
              let i3 = t2.renderCachePool.pop();
              i3 === void 0 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), i3 !== void 0 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e2, t2, i2, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const r = this.painter.context, n2 = r.gl;
          if (t2.length <= 1)
            return void (this._overlapStencilType = false);
          let s2;
          if (i2.isTileClipped())
            s2 = t2.length, this._overlapStencilMode.test = { func: n2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            s2 = 1, this._overlapStencilMode.test = { func: n2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + s2 > 255 && (r.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
        }
        stencilModeForRTTOverlap(t2) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.StencilMode.disabled;
        }
        _renderTileClippingMasks(t2, i2) {
          const o2 = this.painter, r = this.painter.context, n2 = r.gl;
          o2._tileClippingMaskIDs = {}, r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
          const s2 = o2.useProgram("clippingMask");
          for (const a2 of t2) {
            const t3 = o2._tileClippingMaskIDs[a2.key] = --i2;
            s2.draw(r, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, t3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(a2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
          }
        }
        pointCoordinate(t2) {
          const i2 = this.painter.transform;
          if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
            return null;
          const o2 = [t2.x, t2.y, 1, 1];
          e.transformMat4$1(o2, o2, i2.pixelMatrixInverse), e.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
          const r = i2._camera.position, n2 = e.mercatorZfromAltitude(1, i2.center.lat), s2 = [r[0], r[1], r[2] / n2, 0], a2 = e.subtract([], o2.slice(0, 3), s2);
          e.normalize(a2, a2);
          const l2 = this.raycast(s2, a2, this._exaggeration);
          return l2 !== null && l2 ? (e.scaleAndAdd(s2, s2, a2, l2), s2[3] = s2[2], s2[2] *= n2, s2) : null;
        }
        drawDepth() {
          const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r = Math.ceil(t2.width), n2 = Math.ceil(t2.height);
          if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n2 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const t3 = i2.gl, o3 = i2.createFramebuffer(r, n2, true);
            i2.activeTexture.set(t3.TEXTURE0);
            const s2 = new e.Texture(i2, { width: r, height: n2, data: null }, t3.RGBA);
            s2.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(s2.texture);
            const a2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r, n2);
            o3.depthAttachment.set(a2), this._depthFBO = o3, this._depthTexture = s2;
          }
          i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r, n2]), function(t3, i3, o3, r2) {
            if (t3.transform.projection.name === "globe")
              return;
            const n3 = t3.context, s2 = n3.gl;
            n3.clear({ depth: 1 });
            const a2 = t3.useProgram("terrainDepth"), l2 = new e.DepthMode(s2.LESS, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
            for (const t4 of r2) {
              const r3 = o3.getTile(t4), c2 = yi(t4.projMatrix, 0);
              i3.setupElevationDraw(r3, a2), a2.draw(n3, s2.TRIANGLES, l2, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
            }
          }(t2, this, o2, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(e2, t2, i2) {
          if (e2.getSource() instanceof Ae)
            return this._setupProxiedCoordsForImageSource(e2, t2, i2);
          this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
          const o2 = this.proxiedCoords[e2.id] = [], r = this.proxyCoords;
          for (let t3 = 0; t3 < r.length; t3++) {
            const n3 = r[t3], s2 = this._findTileCoveringTileID(n3, e2);
            if (s2) {
              const t4 = this._createProxiedId(n3, s2, i2[n3.key] && i2[n3.key][e2.id]);
              o2.push(t4), this.proxyToSource[n3.key][e2.id] = [t4];
            }
          }
          let n2 = false;
          for (let r2 = 0; r2 < t2.length; r2++) {
            const s2 = e2.getTile(t2[r2]);
            if (!s2 || !s2.hasData())
              continue;
            const a2 = this._findTileCoveringTileID(s2.tileID, this.proxySourceCache);
            if (a2 && a2.tileID.canonical.z !== s2.tileID.canonical.z) {
              const t3 = this.proxyToSource[a2.tileID.key][e2.id], r3 = this._createProxiedId(a2.tileID, s2, i2[a2.tileID.key] && i2[a2.tileID.key][e2.id]);
              t3 ? t3.splice(t3.length - 1, 0, r3) : this.proxyToSource[a2.tileID.key][e2.id] = [r3], o2.push(r3), n2 = true;
            }
          }
          this._sourceTilesOverlap[e2.id] = n2;
        }
        _setupProxiedCoordsForImageSource(t2, i2, o2) {
          if (!t2.getSource().loaded())
            return;
          const r = this.proxiedCoords[t2.id] = [], n2 = this.proxyCoords, s2 = t2.getSource(), a2 = new e.pointGeometry(s2.tileID.x, s2.tileID.y)._div(1 << s2.tileID.z), l2 = s2.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - a2.x), e2.min.y = Math.min(e2.min.y, t3.y - a2.y), e2.max.x = Math.max(e2.max.x, t3.x - a2.x), e2.max.y = Math.max(e2.max.y, t3.y - a2.y), e2), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t3, i3) => {
            const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r2 = t3.canonical.y / (1 << t3.canonical.z), n3 = e.EXTENT / (1 << t3.canonical.z), s3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + n3 < s3 + l2.min.x || o3 > s3 + l2.max.x || r2 + n3 < a3 + l2.min.y || r2 > a3 + l2.max.y;
          };
          for (let e2 = 0; e2 < n2.length; e2++) {
            const s3 = n2[e2];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const n3 = t2.getTile(i2[e3]);
              if (!n3 || !n3.hasData())
                continue;
              if (c2(s3, n3.tileID))
                continue;
              const a3 = this._createProxiedId(s3, n3, o2[s3.key] && o2[s3.key][t2.id]), l3 = this.proxyToSource[s3.key][t2.id];
              l3 ? l3.push(a3) : this.proxyToSource[s3.key][t2.id] = [a3], r.push(a3);
            }
          }
        }
        _createProxiedId(t2, i2, o2) {
          let r = this.orthoMatrix;
          if (o2) {
            const e2 = o2.find((e3) => e3.key === i2.tileID.key);
            if (e2)
              return e2;
          }
          if (i2.tileID.key !== t2.key) {
            const o3 = t2.canonical.z - i2.tileID.canonical.z;
            let n2, s2, a2;
            r = e.create();
            const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
            o3 > 0 ? (n2 = e.EXTENT >> o3, s2 = n2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = n2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (n2 = e.EXTENT << -o3, s2 = e.EXTENT * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.EXTENT * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ortho(r, 0, n2, 0, n2, 0, 1), e.translate(r, r, [s2, a2, 0]);
          }
          return new Ai(i2.tileID, t2.key, r);
        }
        _findTileCoveringTileID(t2, i2) {
          let o2 = i2.getTile(t2);
          if (o2 && o2.hasData())
            return o2;
          const r = this._findCoveringTileCache[i2.id], n2 = r[t2.key];
          if (o2 = n2 ? i2.getTileByID(n2) : null, o2 && o2.hasData() || n2 === null)
            return o2;
          let s2 = o2 ? o2.tileID : t2, a2 = s2.overscaledZ;
          const l2 = i2.getSource().minzoom, c2 = [];
          if (!n2) {
            const r2 = i2.getSource().maxzoom;
            if (t2.canonical.z >= r2) {
              const o3 = t2.canonical.z - r2;
              i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), s2 = new e.OverscaledTileID(a2, t2.wrap, r2, t2.canonical.x >> o3, t2.canonical.y >> o3)) : o3 !== 0 && (a2 = r2, s2 = new e.OverscaledTileID(a2, t2.wrap, r2, t2.canonical.x >> o3, t2.canonical.y >> o3));
            }
            s2.key !== t2.key && (c2.push(s2.key), o2 = i2.getTile(s2));
          }
          const h4 = (e2) => {
            c2.forEach((t3) => {
              r[t3] = e2;
            }), c2.length = 0;
          };
          for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
            o2 && h4(o2.tileID.key);
            const e2 = s2.calculateScaledKey(a2);
            if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
              break;
            const t3 = r[e2];
            if (t3 === null)
              break;
            t3 === void 0 ? c2.push(e2) : o2 = i2.getTileByID(t3);
          }
          return h4(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e2) {
          return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e2, t2) {
          let i2 = this._tilesDirty[e2];
          i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
        }
        getWirefameBuffer() {
          if (!this.wireframeSegments) {
            const t2 = function(t3) {
              let i2 = 0;
              const o2 = new e.StructArrayLayout2ui4(), r = 131;
              for (let e2 = 1; e2 < 129; e2++) {
                for (let t4 = 1; t4 < 129; t4++)
                  i2 = e2 * r + t4, o2.emplaceBack(i2, i2 + 1), o2.emplaceBack(i2, i2 + r), o2.emplaceBack(i2 + 1, i2 + r), e2 === 128 && o2.emplaceBack(i2 + r, i2 + r + 1);
                o2.emplaceBack(i2 + 1, i2 + 1 + r);
              }
              return o2;
            }();
            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t2), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t2.length);
          }
          return [this.wireframeIndexBuffer, this.wireframeSegments];
        }
      }
      class Pi {
        static cacheKey(e2, t2, i2, o2) {
          let r = `${t2}${o2 ? o2.cacheKey : ""}`;
          for (const t3 of i2)
            e2.usedDefines.includes(t3) && (r += `/${t3}`);
          return r;
        }
        constructor(t2, i2, o2, r, n2, s2) {
          const a2 = t2.gl;
          this.program = a2.createProgram();
          const l2 = function(e2) {
            const t3 = [];
            for (let i3 = 0; i3 < e2.length; i3++) {
              if (e2[i3] === null)
                continue;
              const o3 = e2[i3].split(" ");
              t3.push(o3.pop());
            }
            return t3;
          }(o2.staticAttributes), c2 = r ? r.getBinderAttributes() : [], h4 = l2.concat(c2);
          let u2 = r ? r.defines() : [];
          u2 = u2.concat(s2.map((e2) => `#define ${e2}`));
          const _2 = t2.isWebGL2 ? "#version 300 es\n" : "", d2 = _2 + u2.concat(t2.extStandardDerivatives && _2.length === 0 ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o2.fragmentSource).join("\n"), p2 = _2 + u2.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o2.vertexSource).join("\n"), m2 = a2.createShader(a2.FRAGMENT_SHADER);
          if (a2.isContextLost())
            return void (this.failedToCreate = true);
          a2.shaderSource(m2, d2), a2.compileShader(m2), a2.attachShader(this.program, m2);
          const f2 = a2.createShader(a2.VERTEX_SHADER);
          if (a2.isContextLost())
            this.failedToCreate = true;
          else {
            a2.shaderSource(f2, p2), a2.compileShader(f2), a2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = h4.length;
            for (let e2 = 0; e2 < this.numAttributes; e2++)
              h4[e2] && (a2.bindAttribLocation(this.program, e2, h4[e2]), this.attributes[h4[e2]] = e2);
            a2.linkProgram(this.program), a2.deleteShader(f2), a2.deleteShader(m2), this.fixedUniforms = n2(t2), this.binderUniforms = r ? r.getUniforms(t2) : [], s2.includes("TERRAIN") && (this.terrainUniforms = ((t3) => ({ u_dem: new e.Uniform1i(t3), u_dem_prev: new e.Uniform1i(t3), u_dem_unpack: new e.Uniform4f(t3), u_dem_tl: new e.Uniform2f(t3), u_dem_scale: new e.Uniform1f(t3), u_dem_tl_prev: new e.Uniform2f(t3), u_dem_scale_prev: new e.Uniform1f(t3), u_dem_size: new e.Uniform1f(t3), u_dem_lerp: new e.Uniform1f(t3), u_exaggeration: new e.Uniform1f(t3), u_depth: new e.Uniform1i(t3), u_depth_size_inv: new e.Uniform2f(t3), u_meter_to_dem: new e.Uniform1f(t3), u_label_plane_matrix_inv: new e.UniformMatrix4f(t3) }))(t2)), s2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.Uniform3f(t3), u_tile_tr_up: new e.Uniform3f(t3), u_tile_br_up: new e.Uniform3f(t3), u_tile_bl_up: new e.Uniform3f(t3), u_tile_up_scale: new e.Uniform1f(t3) }))(t2)), s2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.UniformMatrix4f(t3), u_fog_range: new e.Uniform2f(t3), u_fog_color: new e.Uniform4f(t3), u_fog_horizon_blend: new e.Uniform1f(t3), u_fog_temporal_offset: new e.Uniform1f(t3), u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_globe_pos: new e.Uniform3f(t3), u_globe_radius: new e.Uniform1f(t3), u_globe_transition: new e.Uniform1f(t3), u_is_globe: new e.Uniform1i(t3), u_viewport: new e.Uniform2f(t3) }))(t2));
          }
        }
        setTerrainUniformValues(e2, t2) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setGlobeUniformValues(e2, t2) {
          if (!this.globeUniforms)
            return;
          const i2 = this.globeUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setFogUniformValues(e2, t2) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        draw(e2, t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2) {
          const m2 = e2.gl;
          if (this.failedToCreate)
            return;
          e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r), e2.setCullFace(n2);
          for (const e3 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e3].set(this.program, e3, s2[e3]);
          d2 && d2.setUniforms(this.program, e2, this.binderUniforms, u2, { zoom: _2 });
          const f2 = { [m2.LINES]: 2, [m2.TRIANGLES]: 3, [m2.LINE_STRIP]: 1 }[t2];
          for (const i3 of h4.get()) {
            const o3 = i3.vaos || (i3.vaos = {});
            (o3[a2] || (o3[a2] = new pi())).bind(e2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p2 || []), m2.drawElements(t2, i3.primitiveLength * f2, m2.UNSIGNED_SHORT, i3.primitiveOffset * f2 * 2);
          }
        }
      }
      function Ri(e2, t2) {
        const i2 = Math.pow(2, t2.tileID.overscaledZ), o2 = t2.tileSize * Math.pow(2, e2.transform.tileZoom) / i2, r = o2 * (t2.tileID.canonical.x + t2.tileID.wrap * i2), n2 = o2 * t2.tileID.canonical.y;
        return { u_image: 0, u_texsize: t2.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / P(t2, 1, e2.transform.tileZoom), u_pixel_coord_upper: [r >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r, 65535 & n2] };
      }
      const Oi = e.create(), Bi = (t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2) => {
        const _2 = i2.style.light, d2 = _2.properties.get("position"), p2 = [d2.x, d2.y, d2.z], m2 = e.create$1();
        _2.properties.get("anchor") === "viewport" && (e.fromRotation(m2, -i2.transform.angle), e.transformMat3(p2, p2, m2));
        const f2 = _2.properties.get("color"), g2 = i2.transform, v3 = { u_matrix: t2, u_lightpos: p2, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f2.r, f2.g, f2.b], u_vertical_gradient: +o2, u_opacity: r, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Oi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n2, u_edge_radius: s2 };
        return g2.projection.name === "globe" && (v3.u_tile_id = [a2.canonical.x, a2.canonical.y, 1 << a2.canonical.z], v3.u_zoom_transition = c2, v3.u_inv_rot_matrix = u2, v3.u_merc_center = h4, v3.u_up_dir = g2.projection.upVector(new e.CanonicalTileID(0, 0, 0), h4[0] * e.EXTENT, h4[1] * e.EXTENT), v3.u_height_lift = l2), v3;
      }, ki = (t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2) => {
        const d2 = Bi(t2, i2, o2, r, n2, s2, a2, c2, h4, u2, _2), p2 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l2.tileSize / 8 };
        return e.extend(d2, Ri(i2, l2), p2);
      }, Fi = (e2) => ({ u_matrix: e2 }), Ui = (t2, i2, o2) => e.extend(Fi(t2), Ri(i2, o2)), Ni = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), Gi = (t2, i2, o2, r) => e.extend(Ui(t2, i2, o2), { u_world: r }), ji = e.create(), Zi = (t2, i2, o2, r, n2, s2) => {
        const a2 = t2.transform, l2 = a2.projection.name === "globe";
        let c2;
        if (s2.paint.get("circle-pitch-alignment") === "map")
          if (l2) {
            const t3 = e.globePixelsToTileUnits(a2.zoom, i2.canonical) * a2._pixelsPerMercatorPixel;
            c2 = Float32Array.from([t3, 0, 0, t3]);
          } else
            c2 = a2.calculatePixelsToTileUnitsMatrix(o2);
        else
          c2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
        const h4 = { u_camera_to_center_distance: a2.cameraToCenterDistance, u_matrix: t2.translatePosMatrix(i2.projMatrix, o2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c2, u_inv_rot_matrix: ji, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (l2) {
          h4.u_inv_rot_matrix = r, h4.u_merc_center = n2, h4.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], h4.u_zoom_transition = e.globeToMercatorTransition(a2.zoom);
          const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
          h4.u_up_dir = a2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
        }
        return h4;
      }, Vi = (e2) => {
        const t2 = [];
        return e2.paint.get("circle-pitch-alignment") === "map" && t2.push("PITCH_WITH_MAP"), e2.paint.get("circle-pitch-scale") === "map" && t2.push("SCALE_WITH_MAP"), t2;
      }, Wi = (t2, i2, o2, r) => {
        const n2 = e.EXTENT / o2.tileSize;
        return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r), u_extrude_scale: [i2.pixelsToGLUnits[0] / n2, i2.pixelsToGLUnits[1] / n2] };
      }, Xi = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), qi = e.create(), $i = (t2, i2, o2, r, n2, s2, a2) => {
        const l2 = t2.transform, c2 = l2.projection.name === "globe", h4 = c2 ? e.globePixelsToTileUnits(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : P(o2, 1, s2), u2 = { u_matrix: i2.projMatrix, u_extrude_scale: h4, u_intensity: a2, u_inv_rot_matrix: qi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (c2) {
          u2.u_inv_rot_matrix = r, u2.u_merc_center = n2, u2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u2.u_zoom_transition = e.globeToMercatorTransition(l2.zoom);
          const t3 = n2[0] * e.EXTENT, o3 = n2[1] * e.EXTENT;
          u2.u_up_dir = l2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
        }
        return u2;
      }, Hi = (e2, t2, i2, o2, r, n2, s2) => {
        const a2 = e2.transform, l2 = a2.calculatePixelsToTileUnitsMatrix(t2);
        return { u_matrix: Ji(e2, t2, i2, o2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: n2, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r, u_texsize: Qi(i2) ? t2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ki(t2, e2.transform), u_alpha_discard_threshold: 0, u_trim_offset: s2 };
      }, Yi = (e2, t2, i2, o2, r) => {
        const n2 = e2.transform;
        return { u_matrix: Ji(e2, t2, i2, o2), u_texsize: t2.imageAtlasTexture.size, u_pixels_to_tile_units: n2.calculatePixelsToTileUnitsMatrix(t2), u_device_pixel_ratio: r, u_image: 0, u_tile_units_to_pixels: Ki(t2, n2), u_units_to_pixels: [1 / n2.pixelsToGLUnits[0], 1 / n2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      };
      function Ki(e2, t2) {
        return 1 / P(e2, 1, t2.tileZoom);
      }
      function Ji(e2, t2, i2, o2) {
        return e2.translatePosMatrix(o2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      function Qi(e2) {
        const t2 = e2.paint.get("line-dasharray").value;
        return t2.value || t2.kind !== "constant";
      }
      const eo = (e2, t2, i2, o2, r, n2) => {
        return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_fade_t: o2.mix, u_opacity: o2.opacity * r.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r.paint.get("raster-brightness-min"), u_brightness_high: r.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = r.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (s2 = r.paint.get("raster-contrast"), s2 > 0 ? 1 / (1 - s2) : 1 + s2), u_spin_weights: to2(r.paint.get("raster-hue-rotate")), u_perspective_transform: n2 };
        var s2, a2;
      };
      function to2(e2) {
        e2 *= Math.PI / 180;
        const t2 = Math.sin(e2), i2 = Math.cos(e2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
      }
      const io = e.create(), oo = (t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2) => {
        const g2 = n2.transform, v3 = { u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"), u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: g2.cameraToCenterDistance, u_rotate_symbol: +o2, u_aspect_ratio: g2.width / g2.height, u_fade_change: n2.options.fadeDuration ? n2.symbolFadeChange : 1, u_matrix: s2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +c2, u_pitch_with_map: +r, u_texsize: h4, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: io, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: io, u_up_vector: [0, -1, 0] };
        return f2.name === "globe" && (v3.u_tile_id = [u2.canonical.x, u2.canonical.y, 1 << u2.canonical.z], v3.u_zoom_transition = _2, v3.u_inv_rot_matrix = p2, v3.u_merc_center = d2, v3.u_camera_forward = g2._camera.forward(), v3.u_ecef_origin = e.globeECEFOrigin(g2.globeMatrix, u2.toUnwrapped()), v3.u_tile_matrix = Float32Array.from(g2.globeMatrix), v3.u_up_vector = m2), v3;
      }, ro = (t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2, g2) => e.extend(oo(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, _2, d2, p2, m2, f2, g2), { u_gamma_scale: r ? n2.transform.cameraToCenterDistance * Math.cos(n2.terrain ? 0 : n2.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u2 }), no = (t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2, d2, p2, m2, f2) => e.extend(ro(t2, i2, o2, r, n2, s2, a2, l2, true, c2, true, u2, _2, d2, p2, m2, f2), { u_texsize_icon: h4, u_texture_icon: 1 }), so = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), ao = (t2, i2, o2, r, n2) => e.extend(function(e2, t3, i3) {
        const o3 = t3.imageManager.getPattern(e2.toString()), { width: r2, height: n3 } = t3.imageManager.getPixelSize(), s2 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / s2, l2 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * s2), c2 = a2 * i3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [r2, n3], u_pattern_size: o3.displaySize, u_tile_units_to_pixels: 1 / P(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [l2 >> 16, c2 >> 16], u_pixel_coord_lower: [65535 & l2, 65535 & c2] };
      }(r, o2, n2), { u_matrix: t2, u_opacity: i2 }), lo = { fillExtrusion: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_height_factor: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2) }), fill: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), fillPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), fillOutline: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), circle: (t2) => ({ u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), collisionBox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.Uniform2f(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_inv_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_viewport_size: new e.Uniform2f(t2) }), debug: (t2) => ({ u_color: new e.UniformColor(t2), u_matrix: new e.UniformMatrix4f(t2), u_overlay: new e.Uniform1i(t2), u_overlay_scale: new e.Uniform1f(t2) }), clippingMask: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.Uniform1f(t2), u_intensity: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), heatmapTexture: (t2) => ({ u_image: new e.Uniform1i(t2), u_color_ramp: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2) }), hillshade: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_latrange: new e.Uniform2f(t2), u_light: new e.Uniform2f(t2), u_shadow: new e.UniformColor(t2), u_highlight: new e.UniformColor(t2), u_accent: new e.UniformColor(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_dimension: new e.Uniform2f(t2), u_zoom: new e.Uniform1f(t2), u_unpack: new e.Uniform4f(t2) }), line: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_units_to_pixels: new e.Uniform2f(t2), u_dash_image: new e.Uniform1i(t2), u_gradient_image: new e.Uniform1i(t2), u_image_height: new e.Uniform1f(t2), u_texsize: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2), u_trim_offset: new e.Uniform2f(t2) }), linePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_texsize: new e.Uniform2f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_units_to_pixels: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2) }), raster: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_tl_parent: new e.Uniform2f(t2), u_scale_parent: new e.Uniform1f(t2), u_fade_t: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_image0: new e.Uniform1i(t2), u_image1: new e.Uniform1i(t2), u_brightness_low: new e.Uniform1f(t2), u_brightness_high: new e.Uniform1f(t2), u_saturation_factor: new e.Uniform1f(t2), u_contrast_factor: new e.Uniform1f(t2), u_spin_weights: new e.Uniform3f(t2), u_perspective_transform: new e.Uniform2f(t2) }), symbolIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_texture: new e.Uniform1i(t2) }), symbolSDF: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_is_halo: new e.Uniform1i(t2) }), symbolTextAndIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texsize_icon: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_texture_icon: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_is_halo: new e.Uniform1i(t2) }), background: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_color: new e.UniformColor(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_pattern_tl: new e.Uniform2f(t2), u_pattern_br: new e.Uniform2f(t2), u_texsize: new e.Uniform2f(t2), u_pattern_size: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), terrainRaster: xi, terrainDepth: xi, skybox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_sun_direction: new e.Uniform3f(t2), u_cubemap: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_color_ramp: new e.Uniform1i(t2), u_center_direction: new e.Uniform3f(t2), u_radius: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.UniformMatrix3f(t2), u_sun_direction: new e.Uniform3f(t2), u_sun_intensity: new e.Uniform1f(t2), u_color_tint_r: new e.Uniform4f(t2), u_color_tint_m: new e.Uniform4f(t2), u_luminance: new e.Uniform1f(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.UniformMatrix4f(t2), u_globe_matrix: new e.UniformMatrix4f(t2), u_normalize_matrix: new e.UniformMatrix4f(t2), u_merc_matrix: new e.UniformMatrix4f(t2), u_zoom_transition: new e.Uniform1f(t2), u_merc_center: new e.Uniform2f(t2), u_image0: new e.Uniform1i(t2), u_grid_matrix: new e.UniformMatrix3f(t2), u_skirt_height: new e.Uniform1f(t2), u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_globe_pos: new e.Uniform3f(t2), u_globe_radius: new e.Uniform1f(t2), u_viewport: new e.Uniform2f(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_horizon: new e.Uniform1f(t2), u_transition: new e.Uniform1f(t2), u_fadeout_range: new e.Uniform1f(t2), u_color: new e.Uniform4f(t2), u_high_color: new e.Uniform4f(t2), u_space_color: new e.Uniform4f(t2), u_star_intensity: new e.Uniform1f(t2), u_star_density: new e.Uniform1f(t2), u_star_size: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2), u_horizon_angle: new e.Uniform1f(t2), u_rotation_matrix: new e.UniformMatrix4f(t2) }) };
      let co;
      function ho(t2, i2, o2, r, n2, s2, a2) {
        const l2 = t2.context, c2 = l2.gl, h4 = t2.transform, u2 = t2.useProgram("collisionBox"), _2 = [];
        let d2 = 0, p2 = 0;
        for (let m3 = 0; m3 < r.length; m3++) {
          const f3 = r[m3], g3 = i2.getTile(f3), v4 = g3.getBucket(o2);
          if (!v4)
            continue;
          const x3 = yt(f3, v4, h4);
          let y3 = x3;
          n2[0] === 0 && n2[1] === 0 || (y3 = t2.translatePosMatrix(x3, g3, n2, s2));
          const b2 = a2 ? v4.textCollisionBox : v4.iconCollisionBox, w2 = v4.collisionCircleArray;
          if (w2.length > 0) {
            const t3 = e.create(), i3 = y3;
            e.mul(t3, v4.placementInvProjMatrix, h4.glCoordMatrix), e.mul(t3, t3, v4.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p2, transform: i3, invTransform: t3, projection: v4.getProjection() }), d2 += w2.length / 4, p2 = d2;
          }
          b2 && (t2.terrain && t2.terrain.setupElevationDraw(g3, u2), u2.draw(l2, c2.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi(y3, h4, g3, v4.getProjection()), o2.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, null, h4.zoom, null, [b2.collisionVertexBuffer, b2.collisionVertexBufferExt]));
        }
        if (!a2 || !_2.length)
          return;
        const m2 = t2.useProgram("collisionCircle"), f2 = new e.StructArrayLayout2f1f2i16();
        f2.resize(4 * d2), f2._trim();
        let g2 = 0;
        for (const e2 of _2)
          for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r2 = e2.circleArray[i3 + 1], n3 = e2.circleArray[i3 + 2], s3 = e2.circleArray[i3 + 3];
            f2.emplace(g2++, o3, r2, n3, s3, 0), f2.emplace(g2++, o3, r2, n3, s3, 1), f2.emplace(g2++, o3, r2, n3, s3, 2), f2.emplace(g2++, o3, r2, n3, s3, 3);
          }
        (!co || co.length < 2 * d2) && (co = function(t3) {
          const i3 = 2 * t3, o3 = new e.StructArrayLayout3ui6();
          o3.resize(i3), o3._trim();
          for (let e2 = 0; e2 < i3; e2++) {
            const t4 = 6 * e2;
            o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
          }
          return o3;
        }(d2));
        const v3 = l2.createIndexBuffer(co, true), x2 = l2.createVertexBuffer(f2, e.collisionCircleLayout.members, true);
        for (const i3 of _2) {
          const r2 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h4).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
          m2.draw(l2, c2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, r2, o2.id, x2, v3, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h4.zoom);
        }
        var y2;
        x2.destroy(), v3.destroy();
      }
      const uo = e.create();
      function _o({ width: t2, height: i2, anchor: o2, textOffset: r, textScale: n2 }, s2) {
        const { horizontalAlign: a2, verticalAlign: l2 } = e.getAnchorAlignment(o2), c2 = -(a2 - 0.5) * t2, h4 = -(l2 - 0.5) * i2, u2 = e.evaluateVariableOffset(o2, r);
        return new e.pointGeometry((c2 / n2 + u2[0]) * s2, (h4 / n2 + u2[1]) * s2);
      }
      function po(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2) {
        const _2 = t2.text.placedSymbolArray, d2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {}, f2 = t2.getProjection(), g2 = bt(l2, f2, s2), v3 = s2.elevation, x2 = f2.upVectorScale(l2.canonical, s2.center.lat, s2.worldSize).metersToTile;
        d2.clear();
        for (let p3 = 0; p3 < _2.length; p3++) {
          const y2 = _2.get(p3), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y2, E2 = t2.allowVerticalPlacement && !y2.placedOrientation, C2 = y2.hidden || !y2.crossTileID || E2 ? null : r[y2.crossTileID];
          if (C2) {
            let r2 = 0, _3 = 0, p4 = 0;
            if (v3) {
              const e2 = v3 ? v3.getAtTileOffset(l2, b2, w2) : 0, [t3, i3, o3] = f2.upVector(l2.canonical, b2, w2);
              r2 = e2 * t3 * x2, _3 = e2 * i3 * x2, p4 = e2 * o3 * x2;
            }
            let [E3, M2, I2, S2] = nt(y2.projectedAnchorX + r2, y2.projectedAnchorY + _3, y2.projectedAnchorZ + p4, o2 ? g2 : a2);
            const D2 = st(s2.getCameraToCenterDistance(f2), S2);
            let L2 = n2.evaluateSizeForFeature(t2.textSizeData, h4, y2) * D2 / e.ONE_EM;
            o2 && (L2 *= t2.tilePixelRatio / c2);
            const A2 = _o(C2, L2);
            o2 ? ({ x: E3, y: M2, z: I2 } = f2.projectTilePoint(b2 + A2.x, w2 + A2.y, l2.canonical), [E3, M2, I2] = nt(E3 + r2, M2 + _3, I2 + p4, a2)) : (i2 && A2._rotate(-s2.angle), E3 += A2.x, M2 += A2.y, I2 = 0);
            const z2 = t2.allowVerticalPlacement && y2.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0; t3 < T2; t3++)
              e.addDynamicAttributes(d2, E3, M2, I2, z2);
            u2 && y2.associatedIconIndex >= 0 && (m2[y2.associatedIconIndex] = { x: E3, y: M2, z: I2, angle: z2 });
          } else
            mt(T2, d2);
        }
        if (u2) {
          p2.clear();
          const i3 = t2.icon.placedSymbolArray;
          for (let t3 = 0; t3 < i3.length; t3++) {
            const o3 = i3.get(t3), { numGlyphs: r2 } = o3, n3 = m2[t3];
            if (o3.hidden || !n3)
              mt(r2, p2);
            else {
              const { x: t4, y: i4, z: o4, angle: s3 } = n3;
              for (let n4 = 0; n4 < r2; n4++)
                e.addDynamicAttributes(p2, t4, i4, o4, s3);
            }
          }
          t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        t2.text.dynamicLayoutVertexBuffer.updateData(d2);
      }
      function mo(e2, t2, i2) {
        return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
      }
      function fo(t2, i2, o2, r, n2, s2, a2, l2, c2, h4, u2, _2) {
        const d2 = t2.context, p2 = d2.gl, m2 = t2.transform, f2 = l2 === "map", g2 = c2 === "map", v3 = f2 && o2.layout.get("symbol-placement") !== "point", x2 = f2 && !g2 && !v3, y2 = o2.layout.get("symbol-sort-key").constantOr(1) !== void 0;
        let b2 = false;
        const w2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), T2 = [e.mercatorXfromLng(m2.center.lng), e.mercatorYfromLat(m2.center.lat)], E2 = o2.layout.get("text-variable-anchor"), C2 = m2.projection.name === "globe", M2 = [], I2 = [0, -1, 0];
        let S2 = I2;
        !C2 && !m2.mercatorFromTransition || f2 || (S2 = function(t3) {
          const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e.multiply([], i3, t3.globeMatrix);
          e.invert(o3, o3);
          const r2 = [0, 0, 0], n3 = [0, 1, 0, 0];
          return e.transformMat4$1(n3, n3, o3), r2[0] = n3[0], r2[1] = n3[1], r2[2] = n3[2], e.normalize(r2, r2), r2;
        }(m2));
        for (const l3 of r) {
          const r2 = i2.getTile(l3), c3 = r2.getBucket(o2);
          if (!c3)
            continue;
          if (c3.projection.name === "mercator" && C2)
            continue;
          const u3 = n2 ? c3.text : c3.icon;
          if (!u3 || c3.fullyClipped || !u3.segments.get().length)
            continue;
          const _3 = u3.programConfigurations.get(o2.id), d3 = n2 || c3.sdfIcons, w3 = n2 ? c3.textSizeData : c3.iconSizeData, D2 = g2 || m2.pitch !== 0, L2 = e.evaluateSizeForZoom(w3, m2.zoom);
          let A2, z2, P2, R3, O2 = [0, 0], B2 = null;
          if (n2) {
            if (z2 = r2.glyphAtlasTexture, P2 = p2.LINEAR, A2 = r2.glyphAtlasTexture.size, c3.iconsInText) {
              O2 = r2.imageAtlasTexture.size, B2 = r2.imageAtlasTexture;
              const e2 = w3.kind === "composite" || w3.kind === "camera";
              R3 = D2 || t2.options.rotating || t2.options.zooming || e2 ? p2.LINEAR : p2.NEAREST;
            }
          } else {
            const e2 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
            z2 = r2.imageAtlasTexture, P2 = d3 || t2.options.rotating || t2.options.zooming || e2 || D2 ? p2.LINEAR : p2.NEAREST, A2 = r2.imageAtlasTexture.size;
          }
          const k2 = c3.projection.name === "globe", F2 = k2 ? S2 : I2, U2 = k2 ? e.globeToMercatorTransition(m2.zoom) : 0, N2 = bt(l3, c3.getProjection(), m2), G2 = m2.calculatePixelsToTileUnitsMatrix(r2), j2 = it(N2, r2.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), Z2 = t2.terrain && g2 && v3 ? e.invert(e.create(), j2) : uo, V2 = rt(N2, r2.tileID.canonical, g2, f2, m2, c3.getProjection(), G2), W2 = E2 && c3.hasTextData(), X2 = o2.layout.get("icon-text-fit") !== "none" && W2 && c3.hasIconData();
          if (v3) {
            const e2 = m2.elevation, i3 = e2 ? e2.getAtTileOffsetFunc(l3, m2.center.lat, m2.worldSize, c3.getProjection()) : null, o3 = ot(N2, r2.tileID.canonical, g2, f2, m2, c3.getProjection(), G2);
            lt(c3, N2, t2, n2, o3, V2, g2, h4, i3, l3);
          }
          const q2 = v3 || n2 && E2 || X2, $2 = t2.translatePosMatrix(N2, r2, s2, a2), H2 = q2 ? uo : j2, Y2 = t2.translatePosMatrix(V2, r2, s2, a2, true), K2 = c3.getProjection().createInversionMatrix(m2, l3.canonical), J2 = [];
          t2.terrainRenderModeElevated() && g2 && J2.push("PITCH_WITH_MAP_TERRAIN"), k2 && J2.push("PROJECTION_GLOBE_VIEW"), q2 && J2.push("PROJECTED_POS_ON_VIEWPORT");
          const Q2 = d3 && o2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let ee2;
          ee2 = d3 ? c3.iconsInText ? no(w3.kind, L2, x2, g2, t2, $2, H2, Y2, A2, O2, l3, U2, T2, K2, F2, c3.getProjection()) : ro(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, true, l3, U2, T2, K2, F2, c3.getProjection()) : oo(w3.kind, L2, x2, g2, t2, $2, H2, Y2, n2, A2, l3, U2, T2, K2, F2, c3.getProjection());
          const te2 = { program: t2.useProgram(mo(d3, n2, c3), _3, J2), buffers: u3, uniformValues: ee2, atlasTexture: z2, atlasTextureIcon: B2, atlasInterpolation: P2, atlasInterpolationIcon: R3, isSDF: d3, hasHalo: Q2, tile: r2, labelPlaneMatrixInv: Z2 };
          if (y2 && c3.canOverlap) {
            b2 = true;
            const t3 = u3.segments.get();
            for (const i3 of t3)
              M2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: te2 });
          } else
            M2.push({ segments: u3.segments, sortKey: 0, state: te2 });
        }
        b2 && M2.sort((e2, t3) => e2.sortKey - t3.sortKey);
        for (const e2 of M2) {
          const i3 = e2.state;
          if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: !C2, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), d2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (d2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
            const r2 = i3.uniformValues;
            i3.hasHalo && (r2.u_is_halo = 1, go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, r2)), r2.u_is_halo = 0;
          }
          go(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, _2, i3.uniformValues);
        }
      }
      function go(t2, i2, o2, r, n2, s2, a2, l2, c2) {
        const h4 = r.context, u2 = [t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer, t2.globeExtVertexBuffer];
        n2.draw(h4, h4.gl.TRIANGLES, s2, a2, l2, e.CullFaceMode.disabled, c2, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r.transform.zoom, t2.programConfigurations.get(o2.id), u2);
      }
      function vo(t2, i2, o2, r, n2, s2, a2) {
        const l2 = t2.context.gl, c2 = o2.paint.get("fill-pattern"), h4 = c2 && c2.constantOr(1);
        let u2, _2, d2, p2, m2;
        a2 ? (_2 = h4 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = l2.LINES) : (_2 = h4 ? "fillPattern" : "fill", u2 = l2.TRIANGLES);
        for (const f2 of r) {
          const r2 = i2.getTile(f2);
          if (h4 && !r2.patternsLoaded())
            continue;
          const g2 = r2.getBucket(o2);
          if (!g2)
            continue;
          t2.prepareDrawTile();
          const v3 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram(_2, v3);
          h4 && (t2.context.activeTexture.set(l2.TEXTURE0), r2.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v3.updatePaintBuffers());
          const y2 = c2.constantOr(null);
          if (y2 && r2.imageAtlas) {
            const e2 = r2.imageAtlas.patternPositions[y2.toString()];
            e2 && v3.setConstantPatternPositions(e2);
          }
          const b2 = t2.translatePosMatrix(f2.projMatrix, r2, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
          if (a2) {
            p2 = g2.indexBuffer2, m2 = g2.segments2;
            const e2 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
            d2 = _2 === "fillOutlinePattern" && h4 ? Gi(b2, t2, r2, e2) : Ni(b2, e2);
          } else
            p2 = g2.indexBuffer, m2 = g2.segments, d2 = h4 ? Ui(b2, t2, r2) : Fi(b2);
          t2.prepareDrawProgram(t2.context, x2, f2.toUnwrapped()), x2.draw(t2.context, u2, n2, t2.stencilModeForClipping(f2), s2, e.CullFaceMode.disabled, d2, o2.id, g2.layoutVertexBuffer, p2, m2, o2.paint, t2.transform.zoom, v3);
        }
      }
      function xo(t2, i2, o2, r, n2, s2, a2) {
        const l2 = t2.context, c2 = l2.gl, h4 = t2.transform, u2 = o2.paint.get("fill-extrusion-pattern"), _2 = u2.constantOr(1), d2 = o2.paint.get("fill-extrusion-opacity"), p2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), o2.paint.get("fill-extrusion-ambient-occlusion-radius")], m2 = o2.layout.get("fill-extrusion-edge-radius"), f2 = h4.projection.name === "globe" ? e.fillExtrusionHeightLift() : 0, g2 = h4.projection.name === "globe", v3 = g2 ? e.globeToMercatorTransition(h4.zoom) : 0, x2 = [e.mercatorXfromLng(h4.center.lng), e.mercatorYfromLat(h4.center.lat)], y2 = [];
        g2 && y2.push("PROJECTION_GLOBE_VIEW"), p2[0] > 0 && y2.push("FAUX_AO");
        for (const b2 of r) {
          const r2 = i2.getTile(b2), w2 = r2.getBucket(o2);
          if (!w2 || w2.projection.name !== h4.projection.name)
            continue;
          const T2 = w2.programConfigurations.get(o2.id), E2 = t2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", T2, y2);
          if (t2.terrain) {
            const e2 = t2.terrain;
            if (t2.style.terrainSetForDrapingOnly())
              e2.setupElevationDraw(r2, E2, { useMeterToDem: true });
            else {
              if (!w2.enableTerrain)
                continue;
              if (e2.setupElevationDraw(r2, E2, { useMeterToDem: true }), yo(l2, i2, b2, w2, o2, e2), !w2.centroidVertexBuffer) {
                const e3 = E2.attributes.a_centroid_pos;
                e3 !== void 0 && c2.vertexAttrib2f(e3, 0, 0);
              }
            }
          }
          _2 && (t2.context.activeTexture.set(c2.TEXTURE0), r2.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), T2.updatePaintBuffers());
          const C2 = u2.constantOr(null);
          if (C2 && r2.imageAtlas) {
            const e2 = r2.imageAtlas.patternPositions[C2.toString()];
            e2 && T2.setConstantPatternPositions(e2);
          }
          const M2 = t2.translatePosMatrix(b2.projMatrix, r2, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), I2 = h4.projection.createInversionMatrix(h4, b2.canonical), S2 = o2.paint.get("fill-extrusion-vertical-gradient"), D2 = _2 ? ki(M2, t2, S2, d2, p2, m2, b2, r2, f2, v3, x2, I2) : Bi(M2, t2, S2, d2, p2, m2, b2, f2, v3, x2, I2);
          t2.prepareDrawProgram(l2, E2, b2.toUnwrapped());
          const L2 = [];
          t2.terrain && L2.push(w2.centroidVertexBuffer), g2 && L2.push(w2.layoutVertexExtBuffer), E2.draw(l2, l2.gl.TRIANGLES, n2, s2, a2, e.CullFaceMode.backCCW, D2, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, t2.transform.zoom, T2, L2);
        }
      }
      function yo(t2, i2, o2, r, n2, s2) {
        const a2 = [(t3) => {
          let i3 = t3.canonical.x - 1, o3 = t3.wrap;
          return i3 < 0 && (i3 = (1 << t3.canonical.z) - 1, o3--), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
        }, (t3) => {
          let i3 = t3.canonical.x + 1, o3 = t3.wrap;
          return i3 === 1 << t3.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
        }, (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (t3.canonical.y === 0 ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)], l2 = (e2) => {
          const t3 = i2.getSource().minzoom, o3 = (e3) => {
            const t4 = i2.getTileByID(e3);
            if (t4 && t4.hasData())
              return t4.getBucket(n2);
          }, r2 = [0, -1, 1];
          for (const i3 of r2) {
            if (e2.overscaledZ + i3 < t3)
              continue;
            const r3 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
            if (r3)
              return r3;
          }
        }, c2 = [0, 0, 0], h4 = (t3, i3) => (c2[0] = Math.min(t3.min.y, i3.min.y), c2[1] = Math.max(t3.max.y, i3.max.y), c2[2] = e.EXTENT - i3.min.x > t3.max.x ? i3.min.x - e.EXTENT : t3.max.x, c2), u2 = (t3, i3) => (c2[0] = Math.min(t3.min.x, i3.min.x), c2[1] = Math.max(t3.max.x, i3.max.x), c2[2] = e.EXTENT - i3.min.y > t3.max.y ? i3.min.y - e.EXTENT : t3.max.y, c2), _2 = [(e2, t3) => h4(e2, t3), (e2, t3) => h4(t3, e2), (e2, t3) => u2(e2, t3), (e2, t3) => u2(t3, e2)], d2 = new e.pointGeometry(0, 0);
        let p2, m2, f2;
        const g2 = (t3, i3, r2, n3, a3) => {
          const l3 = [[n3 ? r2 : t3, n3 ? t3 : r2, 0], [n3 ? r2 : i3, n3 ? i3 : r2, 0]], c3 = a3 < 0 ? e.EXTENT + a3 : a3, h5 = [n3 ? c3 : (t3 + i3) / 2, n3 ? (t3 + i3) / 2 : c3, 0];
          return r2 === 0 && a3 < 0 || r2 !== 0 && a3 > 0 ? s2.getForTilePoints(f2, [h5], true, m2) : l3.push(h5), s2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h5[2]) / s2.exaggeration();
        };
        for (let t3 = 0; t3 < 4; t3++) {
          const i3 = (t3 < 2 ? 1 : 5) - t3, n3 = r.borders[t3];
          if (n3.length === 0)
            continue;
          const c3 = f2 = a2[t3](o2), h5 = l2(c3);
          if (!(h5 && h5 instanceof e.FillExtrusionBucket && h5.enableTerrain))
            continue;
          if (r.borderDoneWithNeighborZ[t3] === h5.canonical.z && h5.borderDoneWithNeighborZ[i3] === r.canonical.z)
            continue;
          if (m2 = s2.findDEMTileFor(c3), !m2 || !m2.dem)
            continue;
          if (!p2) {
            const e2 = s2.findDEMTileFor(o2);
            if (!e2 || !e2.dem)
              return;
            p2 = e2;
          }
          const u3 = h5.borders[i3];
          let v3 = 0;
          const x2 = h5.borderDoneWithNeighborZ[i3] !== r.canonical.z;
          if (r.canonical.z === h5.canonical.z) {
            for (let o3 = 0; o3 < n3.length; o3++) {
              const s3 = r.featuresOnBorder[n3[o3]], a3 = s3.borders[t3];
              let l3;
              for (; v3 < u3.length && (l3 = h5.featuresOnBorder[u3[v3]], !(l3.borders[i3][1] > a3[0] + 3)); )
                x2 && h5.encodeCentroid(void 0, l3, false), v3++;
              if (l3 && v3 < u3.length) {
                const o4 = v3;
                let n4 = 0;
                for (; !(l3.borders[i3][0] > a3[1] - 3) && (n4++, ++v3 !== u3.length); )
                  l3 = h5.featuresOnBorder[u3[v3]];
                if (l3 = h5.featuresOnBorder[u3[o4]], s3.intersectsCount() > 1 || l3.intersectsCount() > 1 || n4 !== 1) {
                  n4 !== 1 && (v3 = o4), r.encodeCentroid(void 0, s3, false), x2 && h5.encodeCentroid(void 0, l3, false);
                  continue;
                }
                const c4 = _2[t3](s3, l3), p3 = t3 % 2 ? e.EXTENT - 1 : 0;
                d2.x = g2(c4[0], Math.min(e.EXTENT - 1, c4[1]), p3, t3 < 2, c4[2]), d2.y = 0, r.encodeCentroid(d2, s3, false), x2 && h5.encodeCentroid(d2, l3, false);
              } else
                r.encodeCentroid(void 0, s3, false);
            }
            r.borderDoneWithNeighborZ[t3] = h5.canonical.z, r.needsCentroidUpdate = true, x2 && (h5.borderDoneWithNeighborZ[i3] = r.canonical.z, h5.needsCentroidUpdate = true);
          } else {
            for (const e2 of n3)
              r.encodeCentroid(void 0, r.featuresOnBorder[e2], false);
            if (x2) {
              for (const e2 of u3)
                h5.encodeCentroid(void 0, h5.featuresOnBorder[e2], false);
              h5.borderDoneWithNeighborZ[i3] = r.canonical.z, h5.needsCentroidUpdate = true;
            }
            r.borderDoneWithNeighborZ[t3] = h5.canonical.z, r.needsCentroidUpdate = true;
          }
        }
        (r.needsCentroidUpdate || !r.centroidVertexBuffer && r.centroidVertexArray.length !== 0) && r.uploadCentroid(t2);
      }
      const bo = new e.Color(1, 0, 0, 1), wo = new e.Color(0, 1, 0, 1), To = new e.Color(0, 0, 1, 1), Eo = new e.Color(1, 0, 1, 1), Co = new e.Color(0, 1, 1, 1);
      function Mo(t2, i2, o2) {
        const r = t2.context, n2 = t2.transform, s2 = r.gl, a2 = n2.projection.name === "globe", l2 = a2 ? ["PROJECTION_GLOBE_VIEW"] : null;
        let c2 = o2.projMatrix;
        if (a2 && e.globeToMercatorTransition(n2.zoom) > 0) {
          const t3 = e.transitionTileAABBinECEF(o2.canonical, n2), i3 = e.globeDenormalizeECEF(t3);
          c2 = e.multiply(new Float32Array(16), n2.globeMatrix, i3), e.multiply(c2, n2.projMatrix, c2);
        }
        const h4 = t2.useProgram("debug", null, l2), u2 = i2.getTileByID(o2.key);
        t2.terrain && t2.terrain.setupElevationDraw(u2, h4);
        const _2 = e.DepthMode.disabled, d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = "$debug";
        r.activeTexture.set(s2.TEXTURE0), t2.emptyTexture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), a2 ? u2._makeGlobeTileDebugBuffers(t2.context, n2) : u2._makeDebugTileBoundsBuffers(t2.context, n2.projection);
        const f2 = u2._tileDebugBuffer || t2.debugBuffer, g2 = u2._tileDebugIndexBuffer || t2.debugIndexBuffer, v3 = u2._tileDebugSegments || t2.debugSegments;
        h4.draw(r, s2.LINE_STRIP, _2, d2, p2, e.CullFaceMode.disabled, Xi(c2, e.Color.red), m2, f2, g2, v3, null, null, null, [u2._globeTileDebugBorderBuffer]);
        const x2 = u2.latestRawTileData, y2 = Math.floor((x2 && x2.byteLength || 0) / 1024), b2 = i2.getTile(o2).tileSize, w2 = 512 / Math.min(b2, 512) * (o2.overscaledZ / n2.zoom) * 0.5;
        let T2 = o2.canonical.toString();
        o2.overscaledZ !== o2.canonical.z && (T2 += ` => ${o2.overscaledZ}`), T2 += ` ${y2}kb`, function(e2, t3) {
          e2.initDebugOverlayCanvas();
          const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r2 = e2.debugOverlayCanvas.getContext("2d");
          r2.clearRect(0, 0, i3.width, i3.height), r2.shadowColor = "white", r2.shadowBlur = 2, r2.lineWidth = 1.5, r2.strokeStyle = "white", r2.textBaseline = "top", r2.font = "bold 36px Open Sans, sans-serif", r2.fillText(t3, 5, 5), r2.strokeText(t3, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        }(t2, T2);
        const E2 = u2._tileDebugTextBuffer || t2.debugBuffer, C2 = u2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, M2 = u2._tileDebugTextSegments || t2.debugSegments;
        h4.draw(r, s2.TRIANGLES, _2, d2, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi(c2, e.Color.transparent, w2), m2, E2, C2, M2, null, null, null, [u2._globeTileDebugTextBuffer]);
      }
      function Io(e2, t2, i2, o2) {
        Do(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
      }
      function So(e2, t2, i2, o2) {
        Do(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
      }
      function Do(t2, i2, o2, r, n2, s2) {
        const a2 = t2.context, l2 = a2.gl;
        l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n2 * e.exported.devicePixelRatio), a2.clear({ color: s2 }), l2.disable(l2.SCISSOR_TEST);
      }
      const Lo = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Ao } = Lo;
      function zo(e2, t2, i2, o2) {
        e2.emplaceBack(t2, i2, o2);
      }
      class Po {
        constructor(t2) {
          this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
        }
      }
      function Ro(t2, i2, o2, r, n2, s2) {
        const a2 = t2.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h4 = i2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e2, t3, i3, o3, r2) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r2.r, r2.g, r2.b, r2.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r), n2, h4, l2, c2);
        a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + s2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
      }
      const Oo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class Bo {
        constructor(t2) {
          const i2 = new e.StructArrayLayout5f20();
          i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
          const o2 = new e.StructArrayLayout3ui6();
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, Oo.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const ko = { symbol: function(t2, i2, o2, r, n2) {
        if (t2.renderPass !== "translucent")
          return;
        const s2 = e.StencilMode.disabled, a2 = t2.colorModeForRenderPass();
        o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r2, n3, s3, a3) {
          const l2 = i3.transform, c2 = n3 === "map", h4 = s3 === "map";
          for (const i4 of t3) {
            const t4 = r2.getTile(i4), n4 = t4.getBucket(o3);
            if (!n4 || !n4.text || !n4.text.segments.get().length)
              continue;
            const s4 = e.evaluateSizeForZoom(n4.textSizeData, l2.zoom), u2 = bt(i4, n4.getProjection(), l2), _2 = l2.calculatePixelsToTileUnitsMatrix(t4), d2 = it(u2, t4.tileID.canonical, h4, c2, l2, n4.getProjection(), _2), p2 = o3.layout.get("icon-text-fit") !== "none" && n4.hasIconData();
            if (s4) {
              const o4 = Math.pow(2, l2.zoom - t4.tileID.overscaledZ);
              po(n4, c2, h4, a3, e.symbolSize, l2, d2, i4, o4, s4, p2);
            }
          }
        }(r, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n2), o2.paint.get("icon-opacity").constantOr(1) !== 0 && fo(t2, i2, o2, r, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s2, a2), o2.paint.get("text-opacity").constantOr(1) !== 0 && fo(t2, i2, o2, r, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s2, a2), i2.map.showCollisionBoxes && (ho(t2, i2, o2, r, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), ho(t2, i2, o2, r, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t2, i2, o2, r) {
        if (t2.renderPass !== "translucent")
          return;
        const n2 = o2.paint.get("circle-opacity"), s2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = o2.layout.get("circle-sort-key").constantOr(1) !== void 0;
        if (n2.constantOr(1) === 0 && (s2.constantOr(1) === 0 || a2.constantOr(1) === 0))
          return;
        const c2 = t2.context, h4 = c2.gl, u2 = t2.transform, _2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), d2 = e.StencilMode.disabled, p2 = t2.colorModeForRenderPass(), m2 = u2.projection.name === "globe", f2 = [e.mercatorXfromLng(u2.center.lng), e.mercatorYfromLat(u2.center.lat)], g2 = [];
        for (let n3 = 0; n3 < r.length; n3++) {
          const s3 = r[n3], a3 = i2.getTile(s3), c3 = a3.getBucket(o2);
          if (!c3 || c3.projection.name !== u2.projection.name)
            continue;
          const h5 = c3.programConfigurations.get(o2.id), _3 = Vi(o2);
          m2 && _3.push("PROJECTION_GLOBE_VIEW");
          const d3 = t2.useProgram("circle", h5, _3), p3 = c3.layoutVertexBuffer, v4 = c3.globeExtVertexBuffer, x2 = c3.indexBuffer, y2 = u2.projection.createInversionMatrix(u2, s3.canonical), b2 = { programConfiguration: h5, program: d3, layoutVertexBuffer: p3, globeExtVertexBuffer: v4, indexBuffer: x2, uniformValues: Zi(t2, s3, a3, y2, f2, o2), tile: a3 };
          if (l2) {
            const t3 = c3.segments.get();
            for (const i3 of t3)
              g2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: b2 });
          } else
            g2.push({ segments: c3.segments, sortKey: 0, state: b2 });
        }
        l2 && g2.sort((e2, t3) => e2.sortKey - t3.sortKey);
        const v3 = { useDepthForOcclusion: !m2 };
        for (const i3 of g2) {
          const { programConfiguration: r2, program: n3, layoutVertexBuffer: s3, globeExtVertexBuffer: a3, indexBuffer: l3, uniformValues: m3, tile: f3 } = i3.state, g3 = i3.segments;
          t2.terrain && t2.terrain.setupElevationDraw(f3, n3, v3), t2.prepareDrawProgram(c2, n3, f3.tileID.toUnwrapped()), n3.draw(c2, h4.TRIANGLES, _2, d2, p2, e.CullFaceMode.disabled, m3, o2.id, s3, l3, g3, o2.paint, u2.zoom, r2, [a3]);
        }
      }, heatmap: function(t2, i2, o2, r) {
        if (o2.paint.get("heatmap-opacity") !== 0)
          if (t2.renderPass === "offscreen") {
            const n2 = t2.context, s2 = n2.gl, a2 = e.StencilMode.disabled, l2 = new e.ColorMode([s2.ONE, s2.ONE], e.Color.transparent, [true, true, true, true]);
            !function(e2, t3, i3, o3) {
              const r2 = e2.gl, n3 = t3.width * o3, s3 = t3.height * o3;
              e2.activeTexture.set(r2.TEXTURE1), e2.viewport.set([0, 0, n3, s3]);
              let a3 = i3.heatmapFbo;
              if (!a3 || a3 && (a3.width !== n3 || a3.height !== s3)) {
                a3 && a3.destroy();
                const t4 = r2.createTexture();
                r2.bindTexture(r2.TEXTURE_2D, t4), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.LINEAR), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(n3, s3, false), function(e3, t5, i4, o4, r3, n4) {
                  const s4 = e3.gl;
                  s4.texImage2D(s4.TEXTURE_2D, 0, e3.isWebGL2 && e3.extRenderToTextureHalfFloat ? s4.RGBA16F : s4.RGBA, r3, n4, 0, s4.RGBA, e3.extRenderToTextureHalfFloat ? e3.isWebGL2 ? s4.HALF_FLOAT : e3.extTextureHalfFloat.HALF_FLOAT_OES : s4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e2, 0, t4, a3, n3, s3);
              } else
                r2.bindTexture(r2.TEXTURE_2D, a3.colorAttachment.get()), e2.bindFramebuffer.set(a3.framebuffer);
            }(n2, t2, o2, t2.transform.projection.name === "globe" ? 0.5 : 0.25), n2.clear({ color: e.Color.transparent });
            const c2 = t2.transform, h4 = c2.projection.name === "globe", u2 = h4 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h4 ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, d2 = [e.mercatorXfromLng(c2.center.lng), e.mercatorYfromLat(c2.center.lat)];
            for (let p2 = 0; p2 < r.length; p2++) {
              const m2 = r[p2];
              if (i2.hasRenderableParent(m2))
                continue;
              const f2 = i2.getTile(m2), g2 = f2.getBucket(o2);
              if (!g2 || g2.projection.name !== c2.projection.name)
                continue;
              const v3 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram("heatmap", v3, u2), { zoom: y2 } = t2.transform;
              t2.terrain && t2.terrain.setupElevationDraw(f2, x2), t2.prepareDrawProgram(n2, x2, m2.toUnwrapped());
              const b2 = c2.projection.createInversionMatrix(c2, m2.canonical);
              x2.draw(n2, s2.TRIANGLES, e.DepthMode.disabled, a2, l2, _2, $i(t2, m2, f2, b2, d2, y2, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t2.transform.zoom, v3, h4 ? [g2.globeExtVertexBuffer] : null);
            }
            n2.viewport.set([0, 0, t2.width, t2.height]);
          } else
            t2.renderPass === "translucent" && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
              const o3 = t3.context, r2 = o3.gl, n2 = i3.heatmapFbo;
              if (!n2)
                return;
              o3.activeTexture.set(r2.TEXTURE0), r2.bindTexture(r2.TEXTURE_2D, n2.colorAttachment.get()), o3.activeTexture.set(r2.TEXTURE1);
              let s2 = i3.colorRampTexture;
              s2 || (s2 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r2.RGBA)), s2.bind(r2.LINEAR, r2.CLAMP_TO_EDGE), t3.useProgram("heatmapTexture").draw(o3, r2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
            }(t2, o2));
      }, line: function(t2, i2, o2, r) {
        if (t2.renderPass !== "translucent")
          return;
        const n2 = o2.paint.get("line-opacity"), s2 = o2.paint.get("line-width");
        if (n2.constantOr(1) === 0 || s2.constantOr(1) === 0)
          return;
        const a2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), l2 = t2.colorModeForRenderPass(), c2 = t2.terrain && t2.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, h4 = o2.paint.get("line-dasharray"), u2 = h4.constantOr(1), _2 = o2.layout.get("line-cap"), d2 = o2.paint.get("line-pattern"), p2 = d2.constantOr(1), m2 = o2.paint.get("line-gradient"), f2 = p2 ? "linePattern" : "line", g2 = t2.context, v3 = g2.gl, x2 = ((e2) => {
          const t3 = [];
          Qi(e2) && t3.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
          const i3 = e2.paint.get("line-trim-offset");
          i3[0] === 0 && i3[1] === 0 || t3.push("RENDER_LINE_TRIM_OFFSET");
          const o3 = e2.paint.get("line-pattern").constantOr(1), r2 = e2.paint.get("line-opacity").constantOr(1) !== 1;
          return !o3 && r2 && t3.push("RENDER_LINE_ALPHA_DISCARD"), t3;
        })(o2);
        let y2 = x2.includes("RENDER_LINE_ALPHA_DISCARD");
        t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (y2 = false);
        for (const n3 of r) {
          const r2 = i2.getTile(n3);
          if (p2 && !r2.patternsLoaded())
            continue;
          const s3 = r2.getBucket(o2);
          if (!s3)
            continue;
          t2.prepareDrawTile();
          const b2 = s3.programConfigurations.get(o2.id), w2 = t2.useProgram(f2, b2, x2), T2 = d2.constantOr(null);
          if (T2 && r2.imageAtlas) {
            const e2 = r2.imageAtlas.patternPositions[T2.toString()];
            e2 && b2.setConstantPatternPositions(e2);
          }
          const E2 = h4.constantOr(null), C2 = _2.constantOr(null);
          if (!p2 && E2 && C2 && r2.lineAtlas) {
            const e2 = r2.lineAtlas.getDash(E2, C2);
            e2 && b2.setConstantPatternPositions(e2);
          }
          let [M2, I2] = o2.paint.get("line-trim-offset");
          if (C2 === "round" || C2 === "square") {
            const e2 = 1;
            M2 !== I2 && (M2 === 0 && (M2 -= e2), I2 === 1 && (I2 += e2));
          }
          const S2 = t2.terrain ? n3.projMatrix : null, D2 = p2 ? Yi(t2, r2, o2, S2, c2) : Hi(t2, r2, o2, S2, s3.lineClipsArray.length, c2, [M2, I2]);
          if (m2) {
            const r3 = s3.gradients[o2.id];
            let a3 = r3.texture;
            if (o2.gradientVersion !== r3.version) {
              let l3 = 256;
              if (o2.stepInterpolant) {
                const o3 = i2.getSource().maxzoom, r4 = n3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - n3.canonical.z) : 1;
                l3 = e.clamp(e.nextPowerOfTwo(s3.maxLineLength / e.EXTENT * 1024 * r4), 256, g2.maxTextureSize);
              }
              r3.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r3.gradient || void 0, clips: s3.lineClipsArray }), r3.texture ? r3.texture.update(r3.gradient) : r3.texture = new e.Texture(g2, r3.gradient, v3.RGBA), r3.version = o2.gradientVersion, a3 = r3.texture;
            }
            g2.activeTexture.set(v3.TEXTURE1), a3.bind(o2.stepInterpolant ? v3.NEAREST : v3.LINEAR, v3.CLAMP_TO_EDGE);
          }
          u2 && (g2.activeTexture.set(v3.TEXTURE0), r2.lineAtlasTexture.bind(v3.LINEAR, v3.REPEAT), b2.updatePaintBuffers()), p2 && (g2.activeTexture.set(v3.TEXTURE0), r2.imageAtlasTexture.bind(v3.LINEAR, v3.CLAMP_TO_EDGE), b2.updatePaintBuffers()), t2.prepareDrawProgram(g2, w2, n3.toUnwrapped());
          const L2 = (i3) => {
            w2.draw(g2, v3.TRIANGLES, a2, i3, l2, e.CullFaceMode.disabled, D2, o2.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, o2.paint, t2.transform.zoom, b2, [s3.layoutVertexBuffer2]);
          };
          if (y2) {
            const i3 = t2.stencilModeForClipping(n3).ref;
            i3 === 0 && t2.terrain && g2.clear({ stencil: 0 });
            const o3 = { func: v3.EQUAL, mask: 255 };
            D2.u_alpha_discard_threshold = 0.8, L2(new e.StencilMode(o3, i3, 255, v3.KEEP, v3.KEEP, v3.INVERT)), D2.u_alpha_discard_threshold = 0, L2(new e.StencilMode(o3, i3, 255, v3.KEEP, v3.KEEP, v3.KEEP));
          } else
            L2(t2.stencilModeForClipping(n3));
        }
        y2 && (t2.resetStencilClippingMasks(), t2.terrain && g2.clear({ stencil: 0 }));
      }, fill: function(t2, i2, o2, r) {
        const n2 = o2.paint.get("fill-color"), s2 = o2.paint.get("fill-opacity");
        if (s2.constantOr(1) === 0)
          return;
        const a2 = t2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = t2.opaquePassEnabledForLayer() && !l2.constantOr(1) && n2.constantOr(e.Color.transparent).a === 1 && s2.constantOr(0) === 1 ? "opaque" : "translucent";
        if (t2.renderPass === c2) {
          const n3 = t2.depthModeForSublayer(1, t2.renderPass === "opaque" ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
          vo(t2, i2, o2, r, n3, a2, false);
        }
        if (t2.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
          const n3 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
          vo(t2, i2, o2, r, n3, a2, true);
        }
      }, "fill-extrusion": function(t2, i2, o2, r) {
        const n2 = o2.paint.get("fill-extrusion-opacity");
        if (n2 !== 0 && t2.renderPass === "translucent") {
          const s2 = new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D);
          if (n2 !== 1 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
            xo(t2, i2, o2, r, s2, e.StencilMode.disabled, e.ColorMode.disabled), xo(t2, i2, o2, r, s2, t2.stencilModeFor3D(), t2.colorModeForRenderPass()), t2.resetStencilClippingMasks();
          else {
            const n3 = t2.colorModeForRenderPass();
            xo(t2, i2, o2, r, s2, e.StencilMode.disabled, n3);
          }
        }
      }, hillshade: function(t2, i2, o2, r) {
        if (t2.renderPass !== "offscreen" && t2.renderPass !== "translucent")
          return;
        const n2 = t2.context, s2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), a2 = t2.colorModeForRenderPass(), l2 = t2.terrain && t2.terrain.renderingToTexture, [c2, h4] = t2.renderPass !== "translucent" || l2 ? [{}, r] : t2.stencilConfigForOverlap(r);
        for (const r2 of h4) {
          const n3 = i2.getTile(r2);
          if (n3.needsHillshadePrepare && t2.renderPass === "offscreen")
            vi(t2, n3, o2, s2, e.StencilMode.disabled, a2);
          else if (t2.renderPass === "translucent") {
            const e2 = l2 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r2) : c2[r2.overscaledZ];
            fi(t2, r2, n3, o2, s2, e2, a2);
          }
        }
        n2.viewport.set([0, 0, t2.width, t2.height]), t2.resetStencilClippingMasks();
      }, raster: function(t2, i2, o2, r, n2, s2) {
        if (t2.renderPass !== "translucent")
          return;
        if (o2.paint.get("raster-opacity") === 0)
          return;
        if (!r.length)
          return;
        const a2 = t2.context, l2 = a2.gl, c2 = i2.getSource(), h4 = t2.useProgram("raster"), u2 = t2.colorModeForRenderPass(), _2 = t2.terrain && t2.terrain.renderingToTexture, [d2, p2] = c2 instanceof Ae || _2 ? [{}, r] : t2.stencilConfigForOverlap(r), m2 = p2[p2.length - 1].overscaledZ, f2 = !t2.options.moving;
        for (const r2 of p2) {
          const n3 = _2 ? e.DepthMode.disabled : t2.depthModeForSublayer(r2.overscaledZ - m2, o2.paint.get("raster-opacity") === 1 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l2.LESS), p3 = r2.toUnwrapped(), g2 = i2.getTile(r2);
          if (_2 && (!g2 || !g2.hasData()))
            continue;
          const v3 = _2 ? r2.projMatrix : t2.transform.calculateProjMatrix(p3, f2), x2 = t2.terrain && _2 ? t2.terrain.stencilModeForRTTOverlap(r2) : d2[r2.overscaledZ], y2 = s2 ? 0 : o2.paint.get("raster-fade-duration");
          g2.registerFadeDuration(y2);
          const b2 = i2.findLoadedParent(r2, 0), w2 = Si(g2, b2, i2, t2.transform, y2);
          let T2, E2;
          t2.terrain && t2.terrain.prepareDrawTile();
          const C2 = o2.paint.get("raster-resampling") === "nearest" ? l2.NEAREST : l2.LINEAR;
          a2.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE), a2.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE);
          const M2 = eo(v3, E2 || [0, 0], T2 || 1, w2, o2, c2 instanceof Ae ? c2.perspectiveTransform : [0, 0]);
          if (t2.prepareDrawProgram(a2, h4, p3), c2 instanceof Ae)
            c2.boundsBuffer && c2.boundsSegments && h4.draw(a2, l2.TRIANGLES, n3, e.StencilMode.disabled, u2, e.CullFaceMode.disabled, M2, o2.id, c2.boundsBuffer, t2.quadTriangleIndexBuffer, c2.boundsSegments);
          else {
            const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r3, tileBoundsSegments: s3 } = t2.getTileBoundsBuffers(g2);
            h4.draw(a2, l2.TRIANGLES, n3, x2, u2, e.CullFaceMode.disabled, M2, o2.id, i3, r3, s3);
          }
        }
        t2.resetStencilClippingMasks();
      }, background: function(t2, i2, o2, r) {
        const n2 = o2.paint.get("background-color"), s2 = o2.paint.get("background-opacity");
        if (s2 === 0)
          return;
        const a2 = t2.context, l2 = a2.gl, c2 = t2.transform, h4 = c2.tileSize, u2 = o2.paint.get("background-pattern");
        if (t2.isPatternMissing(u2))
          return;
        const _2 = !u2 && n2.a === 1 && s2 === 1 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t2.renderPass !== _2)
          return;
        const d2 = e.StencilMode.disabled, p2 = t2.depthModeForSublayer(0, _2 === "opaque" ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m2 = t2.colorModeForRenderPass(), f2 = t2.useProgram(u2 ? "backgroundPattern" : "background");
        let g2, v3 = r;
        v3 || (g2 = t2.getBackgroundTiles(), v3 = Object.values(g2).map((e2) => e2.tileID)), u2 && (a2.activeTexture.set(l2.TEXTURE0), t2.imageManager.bind(t2.context));
        for (const _3 of v3) {
          const v4 = _3.toUnwrapped(), x2 = r ? _3.projMatrix : t2.transform.calculateProjMatrix(v4);
          t2.prepareDrawTile();
          const y2 = i2 ? i2.getTile(_3) : g2 ? g2[_3.key] : new e.Tile(_3, h4, c2.zoom, t2), b2 = u2 ? ao(x2, s2, t2, u2, { tileID: _3, tileSize: h4 }) : so(x2, s2, n2);
          t2.prepareDrawProgram(a2, f2, v4);
          const { tileBoundsBuffer: w2, tileBoundsIndexBuffer: T2, tileBoundsSegments: E2 } = t2.getTileBoundsBuffers(y2);
          f2.draw(a2, l2.TRIANGLES, p2, d2, m2, e.CullFaceMode.disabled, b2, o2.id, w2, T2, E2);
        }
      }, sky: function(t2, i2, o2) {
        const r = t2.transform, n2 = r.projection.name === "mercator" || r.projection.name === "globe" ? 1 : e.smoothstep(7, 8, r.zoom), s2 = o2.paint.get("sky-opacity") * n2;
        if (s2 === 0)
          return;
        const a2 = t2.context, l2 = o2.paint.get("sky-type"), c2 = new e.DepthMode(a2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), h4 = t2.frameCounter / 1e3 % 1;
        l2 === "atmosphere" ? t2.renderPass === "offscreen" ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r2) {
          const n3 = t3.context, s3 = n3.gl;
          let a3 = i3.skyboxFbo;
          if (!a3) {
            a3 = i3.skyboxFbo = n3.createFramebuffer(32, 32, false), i3.skyboxGeometry = new Po(n3), i3.skyboxTexture = n3.gl.createTexture(), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MAG_FILTER, s3.LINEAR);
            for (let e2 = 0; e2 < 6; ++e2)
              s3.texImage2D(s3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, s3.RGBA, 32, 32, 0, s3.RGBA, s3.UNSIGNED_BYTE, null);
          }
          n3.bindFramebuffer.set(a3.framebuffer), n3.viewport.set([0, 0, 32, 32]);
          const l3 = i3.getCenter(t3, true), c3 = t3.useProgram("skyboxCapture"), h5 = new Float64Array(16);
          e.identity(h5), e.rotateY(h5, h5, 0.5 * -Math.PI), Ro(n3, i3, c3, h5, l3, 0), e.identity(h5), e.rotateY(h5, h5, 0.5 * Math.PI), Ro(n3, i3, c3, h5, l3, 1), e.identity(h5), e.rotateX(h5, h5, 0.5 * -Math.PI), Ro(n3, i3, c3, h5, l3, 2), e.identity(h5), e.rotateX(h5, h5, 0.5 * Math.PI), Ro(n3, i3, c3, h5, l3, 3), e.identity(h5), Ro(n3, i3, c3, h5, l3, 4), e.identity(h5), e.rotateY(h5, h5, Math.PI), Ro(n3, i3, c3, h5, l3, 5), n3.viewport.set([0, 0, t3.width, t3.height]);
        }(t2, o2), o2.markSkyboxValid(t2)) : t2.renderPass === "sky" && function(t3, i3, o3, r2, n3) {
          const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skybox");
          s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
          const h5 = ((e2, t4, i4, o4, r3) => ({ u_matrix: e2, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r3 }))(l3.skyboxMatrix, i3.getCenter(t3, false), 0, r2, n3);
          t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, h5, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, c2, s2, h4) : l2 === "gradient" && t2.renderPass === "sky" && function(t3, i3, o3, r2, n3) {
          const s3 = t3.context, a3 = s3.gl, l3 = t3.transform, c3 = t3.useProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new Po(s3)), s3.activeTexture.set(a3.TEXTURE0);
          let h5 = i3.colorRampTexture;
          h5 || (h5 = i3.colorRampTexture = new e.Texture(s3, i3.colorRamp, a3.RGBA)), h5.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          const u2 = ((t4, i4, o4, r3, n4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r3, u_temporal_offset: n4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r2, n3);
          t3.prepareDrawProgram(s3, c3), c3.draw(s3, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, u2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, c2, s2, h4);
      }, debug: function(e2, t2, i2) {
        for (let o2 = 0; o2 < i2.length; o2++)
          Mo(e2, t2, i2[o2]);
      }, custom: function(t2, i2, o2, r) {
        const n2 = t2.context, s2 = o2.implementation;
        if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || t2.renderPass === "offscreen") && o2.isLayerDraped()) {
          if (t2.renderPass === "offscreen") {
            const i3 = s2.prerender;
            if (i3) {
              if (t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), t2.transform.projection.name === "globe") {
                const o3 = t2.transform.pointMerc;
                i3.call(s2, n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
              } else
                i3.call(s2, n2.gl, t2.transform.customLayerMatrix());
              n2.setDirty(), t2.setBaseState();
            }
          } else if (t2.renderPass === "translucent") {
            if (t2.terrain && t2.terrain.renderingToTexture) {
              const i4 = s2.renderToTile;
              if (i4) {
                const o3 = r[0].canonical, a2 = new e.MercatorCoordinate(o3.x + r[0].wrap * (1 << o3.z), o3.y, o3.z);
                n2.setDepthMode(e.DepthMode.disabled), n2.setStencilMode(e.StencilMode.disabled), n2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(s2, n2.gl, a2), n2.setDirty(), t2.setBaseState();
              }
              return;
            }
            t2.setCustomLayerDefaults(), n2.setColorMode(t2.colorModeForRenderPass()), n2.setStencilMode(e.StencilMode.disabled);
            const i3 = s2.renderingMode === "3d" ? new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.DepthMode.ReadOnly);
            if (n2.setDepthMode(i3), t2.transform.projection.name === "globe") {
              const i4 = t2.transform.pointMerc;
              s2.render(n2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
            } else
              s2.render(n2.gl, t2.transform.customLayerMatrix());
            n2.setDirty(), t2.setBaseState(), n2.bindFramebuffer.set(null);
          }
        } else
          e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      } };
      class Fo {
        constructor(t2, i2, o2 = false) {
          this.context = new Me(t2, o2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
        }
        updateTerrain(e2, t2) {
          const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new zi(this, e2));
          const o2 = this._terrain;
          this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2);
        }
        _updateFog(e2) {
          const t2 = e2.fog;
          if (!t2 || this.transform.projection.name === "globe" || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
          if (i2 > o2)
            return void (this.transform.fogCullDistSq = null);
          const r = i2 + 0.78 * (o2 - i2);
          this.transform.fogCullDistSq = r * r;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        resize(t2, i2) {
          if (this.width = t2 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e2 of this.style.order)
              this.style._layers[e2].resize();
        }
        setup() {
          const t2 = this.context, i2 = new e.StructArrayLayout2i4();
          i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const o2 = new e.StructArrayLayout2i4();
          o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t2.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
          const r = new e.StructArrayLayout2i4();
          r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const n2 = new e.StructArrayLayout4i8();
          n2.emplaceBack(0, 0, 0, 0), n2.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n2.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n2.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t2.createVertexBuffer(n2, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const s2 = new e.StructArrayLayout3ui6();
          s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s2);
          const a2 = new e.StructArrayLayout1ui2();
          for (const e2 of [0, 1, 3, 2, 0])
            a2.emplaceBack(e2);
          this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.Texture(t2, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = e.create();
          const l2 = this.context.gl;
          this.stencilClearMode = new e.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e2) {
          return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t2 = this.context, i2 = t2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(t2, i2, o2) {
          if (!i2 || this.currentStencilSource === i2.id || !t2.isTileClipped() || !o2 || o2.length === 0)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e2 = false;
            for (const t3 of o2)
              if (this._tileClippingMaskIDs[t3.key] === void 0) {
                e2 = true;
                break;
              }
            if (!e2)
              return;
          }
          this.currentStencilSource = i2.id;
          const r = this.context, n2 = r.gl;
          this.nextStencilID + o2.length > 256 && this.clearStencil(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
          const s2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t3 of o2) {
            const o3 = i2.getTile(t3), a2 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, { tileBoundsBuffer: l2, tileBoundsIndexBuffer: c2, tileBoundsSegments: h4 } = this.getTileBoundsBuffers(o3);
            s2.draw(r, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, a2, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(t3.projMatrix), "$clipping", l2, c2, h4);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t2 = this.nextStencilID++, i2 = this.context.gl;
          return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilModeForClipping(t2) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t2);
          const i2 = this.context.gl;
          return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilConfigForOverlap(t2) {
          const i2 = this.context.gl, o2 = t2.sort((e2, t3) => t3.overscaledZ - e2.overscaledZ), r = o2[o2.length - 1].overscaledZ, n2 = o2[0].overscaledZ - r + 1;
          if (n2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
            const t3 = {};
            for (let o3 = 0; o3 < n2; o3++)
              t3[o3 + r] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            return this.nextStencilID += n2, [t3, o2];
          }
          return [{ [r]: e.StencilMode.disabled }, o2];
        }
        colorModeForRenderPass() {
          const t2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new e.ColorMode([t2.CONSTANT_COLOR, t2.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
          }
          return this.renderPass === "opaque" ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
        }
        depthModeForSublayer(t2, i2, o2) {
          if (!this.opaquePassEnabledForLayer())
            return e.DepthMode.disabled;
          const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r, r]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this.style = t2, this.options = i2, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
          const o2 = this.style.order, r = this.style._sourceCaches;
          for (const e2 in r) {
            const t3 = r[e2];
            t3.used && t3.prepare(this.context);
          }
          const n2 = {}, s2 = {}, a2 = {};
          for (const e2 in r) {
            const t3 = r[e2];
            n2[e2] = t3.getVisibleCoordinates(), s2[e2] = n2[e2].slice().reverse(), a2[e2] = t3.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e2 = 0; e2 < o2.length; e2++)
            if (this.style._layers[o2[e2]].is3D()) {
              this.opaquePassCutoff = e2;
              break;
            }
          if (this.terrain && (this.terrain.updateTileBinding(a2), this.opaquePassCutoff = 0), this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), e.isMapAuthenticated(this.context.gl)) {
            this.renderPass = "offscreen";
            for (const e2 of o2) {
              const i3 = this.style._layers[e2], o3 = t2._getLayerSourceCache(i3);
              if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                continue;
              const r2 = o3 ? s2[o3.id] : void 0;
              (i3.type === "custom" || i3.isSky() || r2 && r2.length) && this.renderLayer(this, o3, i3, r2);
            }
            if (this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                if (e2.isSky())
                  continue;
                const r2 = i3 ? s2[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, r2), this.renderLayer(this, i3, e2, r2);
              }
            if (this.style.fog && this.transform.projection.supportsFog && function(t3, i3) {
              const o3 = t3.context, r2 = o3.gl, n3 = t3.transform, s3 = new e.DepthMode(r2.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), a3 = t3.useProgram("globeAtmosphere", null, n3.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l2 = e.globeToMercatorTransition(n3.zoom), c2 = i3.properties.get("color").toArray01(), h4 = i3.properties.get("high-color").toArray01(), u2 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e.identity$1([]);
              e.rotateY$1(_2, _2, -e.degToRad(n3._center.lng)), e.rotateX$1(_2, _2, e.degToRad(n3._center.lat)), e.rotateZ$1(_2, _2, n3.angle), e.rotateX$1(_2, _2, -n3._pitch);
              const d2 = e.fromQuat(new Float32Array(16), _2), p2 = e.mapValue(i3.properties.get("star-intensity"), 0, 1, 0, 0.25), m2 = 5e-4, f2 = e.mapValue(i3.properties.get("horizon-blend"), 0, 1, m2, 0.25), g2 = e.globeUseCustomAntiAliasing(t3, o3, n3) && f2 === m2 ? n3.worldSize / (2 * Math.PI * 1.025) - 1 : n3.globeRadius, v3 = t3.frameCounter / 1e3 % 1, x2 = e.length(n3.globeCenterInViewSpace), y2 = Math.sqrt(Math.pow(x2, 2) - Math.pow(g2, 2)), b2 = Math.acos(y2 / x2), w2 = ((t4, i4, o4, r3, n4, s4, a4, l3, c3, h5, u3, _3, d3, p3) => ({ u_frustum_tl: t4, u_frustum_tr: i4, u_frustum_br: o4, u_frustum_bl: r3, u_horizon: n4, u_transition: s4, u_fadeout_range: a4, u_color: l3, u_high_color: c3, u_space_color: h5, u_star_intensity: u3, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d3, u_rotation_matrix: p3 }))(n3.frustumCorners.TL, n3.frustumCorners.TR, n3.frustumCorners.BR, n3.frustumCorners.BL, n3.frustumCorners.horizon, l2, f2, c2, h4, u2, p2, v3, b2, d2);
              t3.prepareDrawProgram(o3, a3);
              const T2 = t3.atmosphereBuffer;
              T2 && a3.draw(o3, r2.TRIANGLES, s3, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w2, "skybox", T2.vertexBuffer, T2.indexBuffer, T2.segments);
            }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || this.transform.projection.name !== "globe") && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                e2.isSky() && this.renderLayer(this, i3, e2, i3 ? s2[i3.id] : void 0);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r2 = i3 ? (e2.type === "symbol" ? a2 : s2)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, i3 ? n2[i3.id] : void 0), this.renderLayer(this, i3, e2, r2), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i3 = null;
              e.values(this.style._layers).forEach((e2) => {
                const o3 = t2._getLayerSourceCache(e2);
                o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
              }), i3 && this.options.showTileBoundaries && ko.debug(this, i3, i3.getVisibleCoordinates());
            }
            this.options.showPadding && function(e2) {
              const t3 = e2.transform.padding;
              Io(e2, e2.transform.height - (t3.top || 0), 3, bo), Io(e2, t3.bottom || 0, 3, wo), So(e2, t3.left || 0, 3, To), So(e2, e2.transform.width - (t3.right || 0), 3, Eo);
              const i3 = e2.transform.centerPoint;
              !function(e3, t4, i4, o3) {
                Do(e3, t4 - 1, i4 - 10, 2, 20, o3), Do(e3, t4 - 10, i4 - 1, 20, 2, o3);
              }(e2, i3.x, e2.transform.height - i3.y, Co);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
          }
        }
        renderLayer(e2, t2, i2, o2) {
          i2.isHidden(this.transform.zoom) || (i2.type === "background" || i2.type === "sky" || i2.type === "custom" || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), (!e2.transform.projection.unsupportedLayers || !e2.transform.projection.unsupportedLayers.includes(i2.type) || e2.terrain && i2.type === "custom") && ko[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e2) {
          if (!this.options.gpuTiming)
            return;
          const t2 = this.context.extTimerQuery;
          let i2 = this.gpuTimers[e2.id];
          i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e2 = this.context.extTimerQuery, t2 = e2.createQueryEXT();
            this.deferredRenderGpuTimeQueries.push(t2), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t2);
          }
        }
        gpuTimingDeferredRenderEnd() {
          if (!this.options.gpuTimingDeferredRender)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e2 = this.gpuTimers;
          return this.gpuTimers = {}, e2;
        }
        collectDeferredRenderGpuQueries() {
          const e2 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e2;
        }
        queryGpuTimers(e2) {
          const t2 = {};
          for (const i2 in e2) {
            const o2 = e2[i2], r = this.context.extTimerQuery, n2 = r.getQueryObjectEXT(o2.query, r.QUERY_RESULT_EXT) / 1e6;
            r.deleteQueryEXT(o2.query), t2[i2] = n2;
          }
          return t2;
        }
        queryGpuTimeDeferredRender(e2) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t2 = this.context.extTimerQuery;
          let i2 = 0;
          for (const o2 of e2)
            i2 += t2.getQueryObjectEXT(o2, t2.QUERY_RESULT_EXT) / 1e6, t2.deleteQueryEXT(o2);
          return i2;
        }
        translatePosMatrix(t2, i2, o2, r, n2) {
          if (!o2[0] && !o2[1])
            return t2;
          const s2 = n2 ? r === "map" ? this.transform.angle : 0 : r === "viewport" ? -this.transform.angle : 0;
          if (s2) {
            const e2 = Math.sin(s2), t3 = Math.cos(s2);
            o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
          }
          const a2 = [n2 ? o2[0] : P(i2, o2[0], this.transform.zoom), n2 ? o2[1] : P(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
          return e.translate(l2, t2, a2), l2;
        }
        saveTileTexture(e2) {
          const t2 = this._tileTextures[e2.size[0]];
          t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
        }
        getTileTexture(e2) {
          const t2 = this._tileTextures[e2];
          return t2 && t2.length > 0 ? t2.pop() : null;
        }
        isPatternMissing(e2) {
          return e2 === null || e2 !== void 0 && !this.imageManager.getPattern(e2.toString());
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        currentGlobalDefines() {
          const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.terrain && this.terrain.exaggeration() === 0, i2 = this.style && this.style.fog, o2 = [];
          return this.terrainRenderModeElevated() && o2.push("TERRAIN"), this.transform.projection.name === "globe" && o2.push("GLOBE"), t2 && o2.push("ZERO_EXAGGERATION"), i2 && !e2 && i2.getOpacity(this.transform.pitch) !== 0 && o2.push("FOG"), e2 && o2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o2.push("OVERDRAW_INSPECTOR"), o2;
        }
        useProgram(e2, t2, i2) {
          this.cache = this.cache || {};
          const o2 = i2 || [], r = this.currentGlobalDefines().concat(o2), n2 = Pi.cacheKey(ui[e2], e2, r, t2);
          return this.cache[n2] || (this.cache[n2] = new Pi(this.context, e2, ui[e2], t2, lo[e2], r)), this.cache[n2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        prepareDrawProgram(t2, i2, o2) {
          if (this.terrain && this.terrain.renderingToTexture)
            return;
          const r = this.style.fog;
          if (r) {
            const n2 = r.getOpacity(this.transform.pitch), s2 = ((t3, i3, o3, r2, n3, s3, a2, l2, c2, h4, u2) => {
              const _2 = t3.transform, d2 = i3.properties.get("color").toArray01();
              d2[3] = r2;
              const p2 = t3.frameCounter / 1e3 % 1;
              return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: d2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_temporal_offset: p2, u_frustum_tl: n3, u_frustum_tr: s3, u_frustum_br: a2, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h4, u_viewport: u2, u_globe_transition: e.globeToMercatorTransition(_2.zoom), u_is_globe: +(_2.projection.name === "globe") };
            })(this, r, o2, n2, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
            i2.setFogUniformValues(t2, s2);
          }
        }
        setTileLoadedFlag(e2) {
          this.tileLoaded = e2;
        }
        saveCanvasCopy() {
          const e2 = this.canvasCopy();
          e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
        }
        canvasCopy() {
          const e2 = this.context.gl, t2 = e2.createTexture();
          return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e2 = this.style && this.style.fog;
          return !!e2 && e2.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const t2 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
          for (const r of o2)
            i2[r.key] = t2[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);
          return i2;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
      }
      class Uo {
        constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
          if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
        }
        interpolate(t2, i2, o2) {
          return i2.top != null && t2.top != null && (this.top = e.number(t2.top, i2.top, o2)), i2.bottom != null && t2.bottom != null && (this.bottom = e.number(t2.bottom, i2.bottom, o2)), i2.left != null && t2.left != null && (this.left = e.number(t2.left, i2.left, o2)), i2.right != null && t2.right != null && (this.right = e.number(t2.right, i2.right, o2)), this;
        }
        getCenter(t2, i2) {
          const o2 = e.clamp((this.left + t2 - this.right) / 2, 0, t2), r = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.pointGeometry(o2, r);
        }
        equals(e2) {
          return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
        }
        clone() {
          return new Uo(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function No(t2, i2) {
        const o2 = e.getColumn(t2, 3);
        e.fromQuat(t2, i2), e.setColumn(t2, 3, o2);
      }
      function Go(t2, i2) {
        const o2 = e.identity$1([]);
        return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t2), o2;
      }
      function jo(t2, i2) {
        const o2 = [t2[0], t2[1], 0], r = [i2[0], i2[1], 0];
        if (e.length(o2) >= 1e-15) {
          const t3 = e.normalize([], o2);
          e.scale$2(r, t3, e.dot(r, t3)), i2[0] = r[0], i2[1] = r[1];
        }
        const n2 = e.cross([], i2, t2);
        if (e.len(n2) < 1e-15)
          return null;
        const s2 = Math.atan2(-n2[1], n2[0]);
        return Go(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), s2);
      }
      class Zo {
        constructor(e2, t2) {
          this.position = e2, this.orientation = t2;
        }
        get position() {
          return this._position;
        }
        set position(t2) {
          if (t2) {
            const i2 = t2 instanceof e.MercatorCoordinate ? t2 : new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
            this._renderWorldCopies && (i2.x = e.wrap(i2.x, 0, 1)), this._position = i2;
          } else
            this._position = null;
        }
        lookAtPoint(t2, i2) {
          if (this.orientation = null, !this.position)
            return;
          const o2 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t2)) : 0, r = this.position, n2 = e.MercatorCoordinate.fromLngLat(t2, o2), s2 = [n2.x - r.x, n2.y - r.y, n2.z - r.z];
          i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = jo(s2, i2);
        }
        setPitchBearing(t2, i2) {
          this.orientation = Go(e.degToRad(t2), e.degToRad(-i2));
        }
      }
      class Vo {
        constructor(t2, i2) {
          this._transform = e.identity([]), this.orientation = i2, this.position = t2;
        }
        get mercatorPosition() {
          const t2 = this.position;
          return new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
        }
        get position() {
          const t2 = e.getColumn(this._transform, 3);
          return [t2[0], t2[1], t2[2]];
        }
        set position(t2) {
          var i2;
          t2 && e.setColumn(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t2) {
          this._orientation = t2 || e.identity$1([]), t2 && No(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e2 = this.forward(), t2 = this.right();
          return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
        }
        setPitchBearing(e2, t2) {
          this._orientation = Go(e2, t2), No(this._transform, this._orientation);
        }
        forward() {
          const t2 = e.getColumn(this._transform, 2);
          return [-t2[0], -t2[1], -t2[2]];
        }
        up() {
          const t2 = e.getColumn(this._transform, 1);
          return [-t2[0], -t2[1], -t2[2]];
        }
        right() {
          const t2 = e.getColumn(this._transform, 0);
          return [t2[0], t2[1], t2[2]];
        }
        getCameraToWorld(t2, i2) {
          const o2 = new Float64Array(16);
          return e.invert(o2, this.getWorldToCamera(t2, i2)), o2;
        }
        getWorldToCameraPosition(t2, i2, o2) {
          const r = this.position;
          e.scale$2(r, r, -t2);
          const n2 = new Float64Array(16);
          return e.fromScaling(n2, [o2, o2, o2]), e.translate(n2, n2, r), n2[10] *= i2, n2;
        }
        getWorldToCamera(t2, i2) {
          const o2 = new Float64Array(16), r = new Float64Array(4), n2 = this.position;
          return e.conjugate(r, this._orientation), e.scale$2(n2, n2, -t2), e.fromQuat(o2, r), e.translate(o2, o2, n2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
        }
        getCameraToClipPerspective(t2, i2, o2, r) {
          const n2 = new Float64Array(16);
          return e.perspective(n2, t2, i2, o2, r), n2;
        }
        getDistanceToElevation(t2, i2 = false) {
          const o2 = t2 === 0 ? 0 : e.mercatorZfromAltitude(t2, i2 ? e.latFromMercatorY(this.position[1]) : this.position[1]), r = this.forward();
          return (o2 - this.position[2]) / r[2];
        }
        clone() {
          return new Vo([...this.position], [...this.orientation]);
        }
      }
      function Wo(t2, i2) {
        const o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r = function(t3, i3, o3, r2, n3) {
          const s2 = new e.LngLat(o3.lng - 180 * $o, o3.lat), a2 = new e.LngLat(o3.lng + 180 * $o, o3.lat), l2 = t3.project(s2.lng, s2.lat), c2 = t3.project(a2.lng, a2.lat), h4 = -Math.atan2(c2.y - l2.y, c2.x - l2.x), u2 = e.MercatorCoordinate.fromLngLat(o3);
          u2.y = e.clamp(u2.y, -0.999975, 0.999975);
          const _2 = u2.toLngLat(), d2 = t3.project(_2.lng, _2.lat), p2 = e.MercatorCoordinate.fromLngLat(_2);
          p2.x += $o;
          const m2 = p2.toLngLat(), f2 = t3.project(m2.lng, m2.lat), g2 = Yo(f2.x - d2.x, f2.y - d2.y, h4), v3 = e.MercatorCoordinate.fromLngLat(_2);
          v3.y += $o;
          const x2 = v3.toLngLat(), y2 = t3.project(x2.lng, x2.lat), b2 = Yo(y2.x - d2.x, y2.y - d2.y, h4), w2 = Math.abs(g2.x) / Math.abs(b2.y), T2 = e.identity([]);
          e.rotateZ(T2, T2, -h4 * (1 - (n3 ? 0 : r2)));
          const E2 = e.identity([]);
          return e.scale(E2, E2, [1, 1 - (1 - w2) * r2, 1]), E2[4] = -b2.x / b2.y * r2, e.rotateZ(E2, E2, h4), e.multiply(E2, T2, E2), E2;
        }(t2.projection, 0, t2.center, o2, i2), n2 = Xo(t2);
        return e.scale(r, r, [n2, n2, 1]), r;
      }
      function Xo(t2) {
        const i2 = t2.projection, o2 = qo(t2.projection, t2.zoom, t2.width, t2.height), r = Ho(i2, t2.center), n2 = Ho(i2, e.LngLat.convert(i2.center));
        return Math.pow(2, r * o2 + (1 - o2) * n2);
      }
      function qo(t2, i2, o2, r, n2 = 1 / 0) {
        const s2 = t2.range;
        if (!s2)
          return 0;
        const a2 = Math.min(n2, Math.max(o2, r)), l2 = Math.log(a2 / 1024) / Math.LN2;
        return e.smoothstep(s2[0] + l2, s2[1] + l2, i2);
      }
      const $o = 1 / 4e4;
      function Ho(t2, i2) {
        const o2 = e.clamp(i2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), r = new e.LngLat(i2.lng - 180 * $o, o2), n2 = new e.LngLat(i2.lng + 180 * $o, o2), s2 = t2.project(r.lng, o2), a2 = t2.project(n2.lng, o2), l2 = e.MercatorCoordinate.fromLngLat(r), c2 = e.MercatorCoordinate.fromLngLat(n2), h4 = a2.x - s2.x, u2 = a2.y - s2.y, _2 = c2.x - l2.x, d2 = c2.y - l2.y, p2 = Math.sqrt((_2 * _2 + d2 * d2) / (h4 * h4 + u2 * u2));
        return Math.log(p2) / Math.LN2;
      }
      function Yo(e2, t2, i2) {
        const o2 = Math.cos(i2), r = Math.sin(i2);
        return { x: e2 * o2 - t2 * r, y: e2 * r + t2 * o2 };
      }
      class Ko {
        constructor(t2, i2, o2, r, n2, s2, a2) {
          this.tileSize = 512, this._renderWorldCopies = n2 === void 0 || n2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = r == null ? 60 : r, this.setProjection(s2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
        }
        clone() {
          const e2 = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e2) {
          this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        updateElevation(e2, t2 = false) {
          const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
        }
        getProjection() {
          return e.pick(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(i2) {
          this.projectionOptions = i2 || { name: "mercator" };
          const o2 = this.projection ? this.getProjection() : void 0;
          this.projection = e.getProjection(this.projectionOptions);
          const r = !t(o2, this.getProjection());
          return r && this._calcMatrices(), this.mercatorFromTransition = false, r;
        }
        setMercatorFromTransition() {
          const t2 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });
          const i2 = t2 !== this.projection.name;
          return i2 && this._calcMatrices(), i2;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e2) {
          this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e2) {
          this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e2) {
          this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e2) {
          this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === true;
        }
        set renderWorldCopies(e2) {
          e2 === void 0 ? e2 = true : e2 === null && (e2 = false), this._renderWorldCopies = e2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get cameraWorldSize() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.pointGeometry(this.width, this.height);
        }
        get bearing() {
          return e.wrap(this.rotation, -180, 180);
        }
        set bearing(e2) {
          this.rotation = e2;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t2) {
          const i2 = -t2 * Math.PI / 180;
          var o2;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t3, i3) {
            var o3 = t3[0], r = t3[1], n2 = t3[2], s2 = t3[3], a2 = Math.sin(i3), l2 = Math.cos(i3);
            e2[0] = o3 * l2 + n2 * a2, e2[1] = r * l2 + s2 * a2, e2[2] = o3 * -a2 + n2 * l2, e2[3] = r * -a2 + s2 * l2;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t2) {
          const i2 = e.clamp(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e2 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e2);
        }
        set fov(t2) {
          t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.degToRad(t2), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e2) {
          this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e2) {
          const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
          this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e2) {
          this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const e2 = this._elevation;
          this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let r = 0, n2 = 0;
          for (let s2 = 0; s2 < i2.length; s2++) {
            const a2 = new e.pointGeometry(i2[s2][0] * this.width, o2 + i2[s2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
            if (!l2)
              continue;
            const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
            r += l2[3] * c2, n2 += c2;
          }
          return n2 === 0 ? NaN : r / n2;
        }
        get center() {
          return this._center;
        }
        set center(e2) {
          e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation)
            return;
          const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), r = this._mercatorZfromZoom(this._maxZoom), n2 = Math.max(o2 - i2, r);
          this._setZoom(this._zoomFromMercatorZ(n2));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e2) {
          this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t2) {
          const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
          let o2;
          o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
          const r = e.length(e.sub([], this._camera.position, o2));
          return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t2) {
          if (!this.height)
            return;
          if (!t2.position && !t2.orientation)
            return;
          this._updateCameraState();
          let i2 = false;
          if (t2.orientation && !e.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
            const o2 = [t2.position.x, t2.position.y, t2.position.z];
            e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
          }
          i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t2 = this._camera.position, i2 = new Zo();
          return i2.position = new e.MercatorCoordinate(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
        }
        _setCameraOrientation(t2) {
          if (!e.length$1(t2))
            return false;
          e.normalize$1(t2, t2);
          const i2 = e.transformQuat([], [0, 0, -1], t2), o2 = e.transformQuat([], [0, -1, 0], t2);
          if (o2[2] < 0)
            return false;
          const r = jo(i2, o2);
          return !!r && (this._camera.orientation = r, true);
        }
        _setCameraPosition(t2) {
          const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
          t2[2] = e.clamp(t2[2], r / o2, r / i2), this._camera.position = t2;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e2) {
          return this._edgeInsets.equals(e2);
        }
        interpolatePadding(e2, t2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e2) {
          const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
          return Math.max(0, t2);
        }
        getVisibleUnwrappedCoordinates(t2) {
          const i2 = [new e.UnwrappedTileID(0, t2)];
          if (this.renderWorldCopies) {
            const o2 = this.pointCoordinate(new e.pointGeometry(0, 0)), r = this.pointCoordinate(new e.pointGeometry(this.width, 0)), n2 = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), s2 = this.pointCoordinate(new e.pointGeometry(0, this.height)), a2 = Math.floor(Math.min(o2.x, r.x, n2.x, s2.x)), l2 = Math.floor(Math.max(o2.x, r.x, n2.x, s2.x)), c2 = 1;
            for (let o3 = a2 - c2; o3 <= l2 + c2; o3++)
              o3 !== 0 && i2.push(new e.UnwrappedTileID(o3, t2));
          }
          return i2;
        }
        coveringTiles(t2) {
          let i2 = this.coveringZoomLevel(t2);
          const o2 = i2, r = this.elevation && !t2.isTerrainDEM, n2 = this.projection.name === "mercator";
          if (t2.minzoom !== void 0 && i2 < t2.minzoom)
            return [];
          t2.maxzoom !== void 0 && i2 > t2.maxzoom && (i2 = t2.maxzoom);
          const s2 = this.locationCoordinate(this.center), a2 = this.center.lat, l2 = 1 << i2, c2 = [l2 * s2.x, l2 * s2.y, 0], h4 = this.projection.name === "globe", u2 = !h4, _2 = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u2), d2 = h4 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p2 = l2 * e.mercatorZfromAltitude(1, this.center.lat), m2 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), f2 = [l2 * d2.x, l2 * d2.y, m2 * (u2 ? 1 : p2)], g2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), v3 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i2 : 0, x2 = t2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y2 = t2.isTerrainDEM ? -x2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? Xo(this) : 1, w2 = (t3) => {
            const i3 = 1 / 4e4, o3 = new e.MercatorCoordinate(t3.x + i3, t3.y, t3.z), r2 = new e.MercatorCoordinate(t3.x, t3.y + i3, t3.z), n3 = t3.toLngLat(), s3 = o3.toLngLat(), a3 = r2.toLngLat(), l3 = this.locationCoordinate(n3), c3 = this.locationCoordinate(s3), h5 = this.locationCoordinate(a3), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), _3 = Math.hypot(h5.x - l3.x, h5.y - l3.y);
            return Math.sqrt(u3 * _3) * b2 / i3;
          }, T2 = (t3) => {
            const i3 = x2, o3 = y2;
            return { aabb: e.tileAABB(this, l2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
          }, E2 = [];
          let C2 = [];
          const M2 = i2, I2 = t2.reparseOverscaled ? o2 : i2, S2 = (e2) => e2 * e2, D2 = S2((m2 - this._centerAltitude) * p2), L2 = (e2) => {
            if (!this._elevation || !e2.tileID || !n2)
              return;
            const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = A2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, A2 = (t3) => {
            if (t3.zoom < v3)
              return true;
            if (t3.zoom === M2)
              return false;
            if (t3.shouldSplit != null)
              return t3.shouldSplit;
            const i3 = t3.aabb.distanceX(f2), n3 = t3.aabb.distanceY(f2);
            let s3 = D2, l3 = 1;
            if (h4) {
              s3 = S2(t3.aabb.distanceZ(f2));
              const i4 = Math.pow(2, t3.zoom), o3 = e.latFromMercatorY((t3.y + 1) / i4), r2 = e.latFromMercatorY(t3.y / i4), n4 = Math.min(Math.max(a2, o3), r2), c4 = e.circumferenceAtLatitude(n4) / e.circumferenceAtLatitude(a2);
              if (l3 = n4 === a2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c4 / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t3.zoom === M2 - 1 && c4 >= 0.9)
                return true;
            } else if (r && (s3 = S2(t3.aabb.distanceZ(f2) * p2)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
              const i4 = Math.pow(2, t3.zoom), o3 = w2(new e.MercatorCoordinate((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
              l3 = o3 > 0.85 ? 1 : o3;
            }
            const c3 = i3 * i3 + n3 * n3 + s3, u3 = S2((1 << M2 - t3.zoom) * g2 * l3 * ((e2, t4) => {
              if (t4 * S2(0.707) < e2)
                return 1;
              const i4 = Math.sqrt(t4 / e2);
              return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(s3, D2), c3));
            return c3 < u3;
          };
          if (this.renderWorldCopies)
            for (let e2 = 1; e2 <= 3; e2++)
              E2.push(T2(-e2)), E2.push(T2(e2));
          for (E2.push(T2(0)); E2.length > 0; ) {
            const o3 = E2.pop(), s3 = o3.x, a3 = o3.y;
            let u3 = o3.fullyVisible;
            if (!u3) {
              const e2 = o3.aabb.intersects(_2);
              if (e2 === 0)
                continue;
              u3 = e2 === 2;
            }
            if (o3.zoom !== M2 && A2(o3))
              for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (s3 << 1) + t3 % 2, c3 = (a3 << 1) + (t3 >> 1), _3 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.tileAABB(this, l2, o3.zoom + 1, i3, c3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: c3, wrap: o3.wrap, fullyVisible: u3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                r && !h4 && (_3.tileID = new e.OverscaledTileID(o3.zoom + 1 === M2 ? I2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, c3), L2(_3)), E2.push(_3);
              }
            else {
              const r2 = o3.zoom === M2 ? I2 : o3.zoom;
              if (t2.minzoom && t2.minzoom > r2)
                continue;
              const n3 = c2[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), l3 = c2[1] - 0.5 - a3, h5 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r2, o3.wrap, o3.zoom, s3, a3);
              C2.push({ tileID: h5, distanceSq: n3 * n3 + l3 * l3 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            C2 = C2.filter((r2) => {
              const n3 = [0, 0, 0, 1], s3 = [e.EXTENT, e.EXTENT, 0, 1], a3 = this.calculateFogTileMatrix(r2.tileID.toUnwrapped());
              e.transformMat4$1(n3, n3, a3), e.transformMat4$1(s3, s3, a3);
              const l3 = e.getAABBPointSquareDist(n3, s3);
              if (l3 === 0)
                return true;
              let c3 = false;
              const h5 = this._elevation;
              if (h5 && l3 > i3 && o3 !== 0) {
                const i4 = this.calculateProjMatrix(r2.tileID.toUnwrapped());
                let n4;
                t2.isTerrainDEM || (n4 = h5.getMinMaxForTile(r2.tileID)), n4 || (n4 = { min: y2, max: x2 });
                const s4 = e.furthestTileCorner(this.rotation), a4 = [s4[0] * e.EXTENT, s4[1] * e.EXTENT, n4.max];
                e.transformMat4(a4, a4, i4), c3 = (1 - a4[1]) * this.height * 0.5 < o3;
              }
              return l3 < i3 || c3;
            });
          }
          return C2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
        }
        resize(e2, t2) {
          this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e2) {
          return Math.pow(2, e2);
        }
        scaleZoom(e2) {
          return Math.log(e2) / Math.LN2;
        }
        project(t2) {
          const i2 = e.clamp(t2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t2.lng, i2);
          return new e.pointGeometry(o2.x * this.worldSize, o2.y * this.worldSize);
        }
        unproject(e2) {
          return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t2, i2) {
          let o2, r;
          const n2 = this.centerPoint;
          if (this.projection.name === "globe") {
            const e2 = this.worldSize;
            o2 = (i2.x - n2.x) / e2, r = (i2.y - n2.y) / e2;
          } else {
            const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(n2);
            o2 = e2.x - t3.x, r = e2.y - t3.y;
          }
          const s2 = this.locationCoordinate(t2);
          this.setLocation(new e.MercatorCoordinate(s2.x - o2, s2.y - r));
        }
        setLocation(e2) {
          this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e2) {
          return this.projection.locationPoint(this, e2);
        }
        locationPoint3D(e2) {
          return this.projection.locationPoint(this, e2, true);
        }
        pointLocation(e2) {
          return this.coordinateLocation(this.pointCoordinate(e2));
        }
        pointLocation3D(e2) {
          return this.coordinateLocation(this.pointCoordinate3D(e2));
        }
        locationCoordinate(t2, i2) {
          const o2 = i2 ? e.mercatorZfromAltitude(i2, t2.lat) : void 0, r = this.projection.project(t2.lng, t2.lat);
          return new e.MercatorCoordinate(r.x, r.y, o2);
        }
        coordinateLocation(e2) {
          return this.projection.unproject(e2.x, e2.y);
        }
        pointRayIntersection(t2, i2) {
          const o2 = i2 != null ? i2 : this._centerAltitude, r = [t2.x, t2.y, 0, 1], n2 = [t2.x, t2.y, 1, 1];
          e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n2, n2, this.pixelMatrixInverse);
          const s2 = n2[3];
          e.scale$1(r, r, 1 / r[3]), e.scale$1(n2, n2, 1 / s2);
          const a2 = r[2], l2 = n2[2];
          return { p0: r, p1: n2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
        }
        screenPointToMercatorRay(t2) {
          const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
          return e.transformMat4$1(i2, i2, this.pixelMatrixInverse), e.transformMat4$1(o2, o2, this.pixelMatrixInverse), e.scale$1(i2, i2, 1 / i2[3]), e.scale$1(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$1(i2, i2, 1 / this.worldSize), e.scale$1(o2, o2, 1 / this.worldSize), new e.Ray([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
        }
        rayIntersectionCoordinate(t2) {
          const { p0: i2, p1: o2, t: r } = t2, n2 = e.mercatorZfromAltitude(i2[2], this._center.lat), s2 = e.mercatorZfromAltitude(o2[2], this._center.lat);
          return new e.MercatorCoordinate(e.number(i2[0], o2[0], r) / this.worldSize, e.number(i2[1], o2[1], r) / this.worldSize, e.number(n2, s2, r));
        }
        pointCoordinate(e2, t2 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
        }
        pointCoordinate3D(t2) {
          if (!this.elevation)
            return this.pointCoordinate(t2);
          let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
          if (i2)
            return new e.MercatorCoordinate(i2[0], i2[1], i2[2]);
          let o2 = 0, r = this.horizonLineFromTop();
          if (t2.y > r)
            return this.pointCoordinate(t2);
          const n2 = 0.02 * r, s2 = t2.clone();
          for (let t3 = 0; t3 < 10 && r - o2 > n2; t3++) {
            s2.y = e.number(o2, r, 0.66);
            const t4 = this.projection.pointCoordinate3D(this, s2.x, s2.y);
            t4 ? (r = s2.y, i2 = t4) : o2 = s2.y;
          }
          return i2 ? new e.MercatorCoordinate(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
        }
        isPointAboveHorizon(e2) {
          return this.projection.isPointAboveHorizon(this, e2);
        }
        _coordinatePoint(t2, i2) {
          const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
          return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r = this.width - this._edgeInsets.right, n2 = this.pointLocation3D(new e.pointGeometry(i2, t2)), s2 = this.pointLocation3D(new e.pointGeometry(r, t2)), a2 = this.pointLocation3D(new e.pointGeometry(r, o2)), l2 = this.pointLocation3D(new e.pointGeometry(i2, o2));
          let c2 = Math.min(n2.lng, s2.lng, a2.lng, l2.lng), h4 = Math.max(n2.lng, s2.lng, a2.lng, l2.lng), u2 = Math.min(n2.lat, s2.lat, a2.lat, l2.lat), _2 = Math.max(n2.lat, s2.lat, a2.lat, l2.lat);
          const d2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = this.projection.name === "globe" ? 1 : 4, m2 = (t3, i3, o3, r2, n3) => {
            const s3 = (t3 + o3) / 2, a3 = (i3 + r2) / 2, l3 = new e.pointGeometry(s3, a3), { lng: f2, lat: g2 } = this.pointLocation3D(l3), v3 = Math.max(0, c2 - f2, u2 - g2, f2 - h4, g2 - _2);
            c2 = Math.min(c2, f2), h4 = Math.max(h4, f2), u2 = Math.min(u2, g2), _2 = Math.max(_2, g2), (n3 < p2 || v3 > d2) && (m2(t3, i3, s3, a3, n3 + 1), m2(s3, a3, o3, r2, n3 + 1));
          };
          if (m2(i2, t2, r, t2, 1), m2(r, t2, r, o2, 1), m2(r, o2, i2, o2, 1), m2(i2, o2, i2, t2, 1), this.projection.name === "globe") {
            const [t3, i3] = e.polesInViewport(this);
            t3 ? (_2 = 90, h4 = 180, c2 = -180) : i3 && (u2 = -90, h4 = 180, c2 = -180);
          }
          return new e.LngLatBounds(new e.LngLat(c2, u2), new e.LngLat(h4, _2));
        }
        _getBoundsRectangular(t2, i2) {
          const { top: o2, left: r } = this._edgeInsets, n2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, a2 = new e.pointGeometry(r, o2), l2 = new e.pointGeometry(s2, o2), c2 = new e.pointGeometry(s2, n2), h4 = new e.pointGeometry(r, n2);
          let u2 = this.pointCoordinate(a2, t2), _2 = this.pointCoordinate(l2, t2);
          const d2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h4, i2), m2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
          return u2.y > 1 && _2.y >= 0 ? u2 = new e.MercatorCoordinate((1 - p2.y) / m2(p2, u2) + p2.x, 1) : u2.y < 0 && _2.y <= 1 && (u2 = new e.MercatorCoordinate(-p2.y / m2(p2, u2) + p2.x, 0)), _2.y > 1 && u2.y >= 0 ? _2 = new e.MercatorCoordinate((1 - d2.y) / m2(d2, _2) + d2.x, 1) : _2.y < 0 && u2.y <= 1 && (_2 = new e.MercatorCoordinate(-d2.y / m2(d2, _2) + d2.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u2)).extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(d2));
        }
        _getBoundsRectangularTerrain() {
          const e2 = this.elevation;
          if (!e2.visibleDemTiles.length || e2.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i2 = t3.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
        }
        getBounds() {
          return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(e2 = true) {
          const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
          return e2 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t2) {
          this.maxBounds = t2, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e2, t2) {
          return this.projection.createTileMatrix(this, t2, e2);
        }
        calculateDistanceTileData(t2) {
          const i2 = t2.key, o2 = this._distanceTileDataCache;
          if (o2[i2])
            return o2[i2];
          const r = t2.canonical, n2 = 1 / this.height, s2 = this.cameraWorldSize, a2 = s2 / this.zoomScale(r.z), l2 = (r.x + Math.pow(2, r.z) * t2.wrap) * a2, c2 = r.y * a2, h4 = this.point;
          h4.x *= s2 / this.worldSize, h4.y *= s2 / this.worldSize;
          const u2 = this.angle, _2 = Math.sin(-u2), d2 = -Math.cos(-u2);
          return o2[i2] = { bearing: [_2, d2], center: [(h4.x - l2) * n2, (h4.y - c2) * n2], scale: a2 / e.EXTENT * n2 }, o2[i2];
        }
        calculateFogTileMatrix(t2) {
          const i2 = t2.key, o2 = this._fogTileMatrixCache;
          if (o2[i2])
            return o2[i2];
          const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
          return e.multiply(r, this.worldToFogMatrix, r), o2[i2] = new Float32Array(r), o2[i2];
        }
        calculateProjMatrix(t2, i2 = false) {
          const o2 = t2.key, r = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
          if (r[o2])
            return r[o2];
          const n2 = this.calculatePosMatrix(t2, this.worldSize);
          return e.multiply(n2, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, n2), r[o2] = new Float32Array(n2), r[o2];
        }
        calculatePixelsToTileUnitsMatrix(t2) {
          const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
          if (o2[i2])
            return o2[i2];
          const r = function(t3, i3) {
            const { scale: o3 } = t3.tileTransform, r2 = o3 * e.EXTENT / (t3.tileSize * Math.pow(2, i3.zoom - t3.tileID.overscaledZ + t3.tileID.canonical.z));
            return n2 = new Float32Array(4), l2 = (s2 = i3.inverseAdjustmentMatrix)[1], c2 = s2[2], h4 = s2[3], _2 = (a2 = [r2, r2])[1], n2[0] = s2[0] * (u2 = a2[0]), n2[1] = l2 * u2, n2[2] = c2 * _2, n2[3] = h4 * _2, n2;
            var n2, s2, a2, l2, c2, h4, u2, _2;
          }(t2, this);
          return o2[i2] = r, o2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if (this.projection.name === "globe") {
            const t2 = 1 / this.worldSize, i2 = e.fromScaling([], [t2, t2, t2]);
            return e.multiply(i2, i2, this.globeMatrix), i2;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === "globe")
            return;
          const t2 = this._elevation;
          this._updateCameraState();
          const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r = this._camera.forward(), n2 = e.mercatorZfromAltitude(1, this._center.lat);
          o2[2] /= n2, r[2] /= n2, e.normalize(r, r);
          const s2 = t2.raycast(o2, r, t2.exaggeration());
          if (s2) {
            const t3 = e.scaleAndAdd([], o2, r, s2), i3 = new e.MercatorCoordinate(t3[0], t3[1], e.mercatorZfromAltitude(t3[2], e.latFromMercatorY(t3[1]))), a2 = (i3.z + e.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * n2])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t2 = false) {
          if (!this._elevation)
            return;
          const i2 = this._elevation, o2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r = this._computeCameraPosition(o2), n2 = i2.getAtPointOrZero(new e.MercatorCoordinate(...r)), s2 = this.pixelsPerMeter / this.worldSize * n2, a2 = this._minimumHeightOverTerrain(), l2 = r[2] - s2;
          if (l2 <= a2)
            if (l2 < 0 || t2) {
              const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r[0], r[1], t3.z - r[2]], o3 = e.length(i3);
              i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
              const n3 = e.length(i3);
              if (n3 === 0)
                return;
              e.scale$2(i3, i3, o3 / n3 * this._pixelsPerMercatorPixel), this._camera.position = [r[0], r[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t2 = this.projection.name === "globe" || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t2) {
            const i3 = this.center;
            return i3.lat = e.clamp(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.clamp(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
          }
          const i2 = this._unmodified, { x: o2, y: r } = this.point;
          let n2 = 0, s2 = o2, a2 = r;
          const l2 = this.width / 2, c2 = this.height / 2, h4 = this.worldMinY * this.scale, u2 = this.worldMaxY * this.scale;
          if (r - c2 < h4 && (a2 = h4 + c2), r + c2 > u2 && (a2 = u2 - c2), u2 - h4 < this.height && (n2 = Math.max(n2, this.height / (u2 - h4)), a2 = (u2 + h4) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
            s2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, s2 - l2 < e2 && (s2 = e2 + l2), s2 + l2 > t3 && (s2 = t3 - l2), t3 - e2 < this.width && (n2 = Math.max(n2, this.width / (t3 - e2)), s2 = (t3 + e2) / 2);
          }
          s2 === o2 && a2 === r || (this.center = this.unproject(new e.pointGeometry(s2, a2))), n2 && (this.zoom += this.scaleZoom(n2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
        }
        _minZoomForBounds() {
          let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t2 = this.centerOffset, i2 = this.pixelsPerMeter;
          this.projection.name === "globe" && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
          const o2 = qo(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const r = this.projection.zAxisUnit === "meters" ? i2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, r), s2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height;
          let a2 = e.mul([], s2, n2);
          if (this.projection.isReprojectedInTileSpace) {
            const t3 = this.locationCoordinate(this.center), i3 = e.identity([]);
            e.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.multiply(i3, i3, Wo(this)), e.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.multiply(a2, a2, i3), this.inverseAdjustmentMatrix = function(e2) {
              const t4 = Wo(e2, true);
              return v2([], [t4[0], t4[1], t4[4], t4[5]]);
            }(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          this.mercatorMatrix = e.scale([], a2, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = a2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
          const l2 = e.invert([], s2);
          this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l2, this.horizonLineFromTop(), this.height);
          const c2 = new Float32Array(16);
          e.identity(c2), e.scale(c2, c2, [1, -1, 1]), e.rotateX(c2, c2, this._pitch), e.rotateZ(c2, c2, this.angle);
          const h4 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          h4[8] = 2 * -t2.x / this.width, h4[9] = 2 * (t2.y + u2) / this.height, this.skyboxMatrix = e.multiply(c2, h4, c2);
          const _2 = this.point, d2 = _2.x, p2 = _2.y, m2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = d2 - Math.round(d2) + g2 * m2 + x2 * f2, b2 = p2 - Math.round(p2) + g2 * f2 + x2 * m2, w2 = new Float64Array(a2);
          if (e.translate(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedProjMatrix = w2, a2 = e.create(), e.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), e.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.create(), e.scale(a2, a2, [1, -1, 1]), e.translate(a2, a2, [-1, -1, 0]), e.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a2 = e.invert(new Float64Array(16), this.pixelMatrix), !a2)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = a2, this.projection.name === "globe" || this.mercatorFromTransition) {
            this.globeMatrix = e.calculateGlobeMatrix(this);
            const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = e.transformMat4(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = a2;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r = 1 / this.height / this._pixelsPerMercatorPixel, n2 = [t2, t2, i2];
          e.scale$2(n2, n2, r), e.scale$2(o2, o2, -1), e.multiply$2(o2, o2, n2);
          const s2 = e.create();
          e.translate(s2, s2, o2), e.scale(s2, s2, n2), this.mercatorFogMatrix = s2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r);
        }
        _computeCameraPosition(e2) {
          const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
          return [o2.x / this.worldSize - i2[0] * r, o2.y / this.worldSize - i2[1] * r, e2 / this.worldSize * this._centerAltitude - i2[2] * r];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t2) {
          const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r = t2[2];
          let n2 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n2 = Math.min((i2 - o2) / r, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t2, n2), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r } = this._camera.getPitchBearing(), n2 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), a2 = Math.max((t2[2] - n2) / Math.cos(o2), s2), l2 = this._zoomFromMercatorZ(a2);
          e.scaleAndAdd(t2, t2, i2, a2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e2) {
          return Math.pow(2, e2) * this.tileSize;
        }
        _mercatorZfromZoom(e2) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
        }
        _minimumHeightOverTerrain() {
          const e2 = Math.min((this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(e2);
        }
        _zoomFromMercatorZ(e2) {
          return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t2) {
          let i2 = 0, o2 = e.GLOBE_ZOOM_THRESHOLD_MAX, r = 0, n2 = 1 / 0;
          for (; o2 - i2 > 1e-6 && o2 > i2; ) {
            const e2 = i2 + 0.5 * (o2 - i2), s2 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, s2), l2 = this.scaleZoom(a2 / (t2 * this.tileSize)), c2 = Math.abs(e2 - l2);
            c2 < n2 && (n2 = c2, r = e2), e2 < l2 ? i2 = e2 : o2 = e2;
          }
          return r;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t2, i2) {
          const o2 = Math.min(t2.x, i2.x), r = Math.max(t2.x, i2.x), n2 = Math.min(t2.y, i2.y), s2 = Math.max(t2.y, i2.y);
          if (n2 < this.horizonLineFromTop(false))
            return true;
          if (this.projection.name !== "mercator")
            return false;
          const a2 = [new e.pointGeometry(o2, n2), new e.pointGeometry(r, s2), new e.pointGeometry(o2, s2), new e.pointGeometry(r, n2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
          for (const e2 of a2) {
            const t3 = this.pointRayIntersection(e2);
            if (t3.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
        }
        zoomDeltaToMovement(t2, i2) {
          const o2 = e.length(e.sub([], this._camera.position, t2)), r = this._zoomFromMercatorZ(o2) + i2;
          return o2 - this._mercatorZfromZoom(r);
        }
        getCameraPoint() {
          if (this.projection.name === "globe") {
            const t2 = function([t3, i2, o2], r) {
              const n2 = [t3, i2, o2, 1];
              e.transformMat4$1(n2, n2, r);
              const s2 = n2[3] = Math.max(n2[3], 1e-6);
              return n2[0] /= s2, n2[1] /= s2, n2[2] /= s2, n2;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new e.pointGeometry(t2[0], t2[1]);
          }
          {
            const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e.pointGeometry(0, t2));
          }
        }
        getCameraToCenterDistance(e2, t2 = this.zoom, i2 = this.worldSize) {
          const o2 = qo(e2, t2, this.width, this.height, 1024), r = e2.pixelSpaceConversion(this.center.lat, i2, o2);
          return 0.5 / Math.tan(0.5 * this._fov) * this.height * r;
        }
        getWorldToCameraMatrix() {
          const t2 = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
          return this.projection.name === "globe" && e.multiply(t2, t2, this.globeMatrix), t2;
        }
      }
      function Jo(e2, t2) {
        let i2 = false, o2 = null;
        const r = () => {
          o2 = null, i2 && (e2(), o2 = setTimeout(r, t2), i2 = false);
        };
        return () => (i2 = true, o2 || r(), o2);
      }
      class Qo {
        constructor(t2) {
          this._hashName = t2 && encodeURIComponent(t2), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t2) {
          return this._map = t2, e.window.addEventListener("hashchange", this._onHashChange, false), t2.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const t2 = this._map;
          if (!t2)
            return "";
          const i2 = er(t2);
          if (this._hashName) {
            const t3 = this._hashName;
            let o2 = false;
            const r = e.window.location.hash.slice(1).split("&").map((e2) => {
              const r2 = e2.split("=")[0];
              return r2 === t3 ? (o2 = true, `${r2}=${i2}`) : e2;
            }).filter((e2) => e2);
            return o2 || r.push(`${t3}=${i2}`), `#${r.join("&")}`;
          }
          return `#${i2}`;
        }
        _getCurrentHash() {
          const t2 = e.window.location.hash.replace("#", "");
          if (this._hashName) {
            let e2;
            return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
              t3[0] === this._hashName && (e2 = t3);
            }), (e2 && e2[1] || "").split("/");
          }
          return t2.split("/");
        }
        _onHashChange() {
          const e2 = this._map;
          if (!e2)
            return false;
          const t2 = this._getCurrentHash();
          if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
            const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
            return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          const t2 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
          e.window.history.replaceState(e.window.history.state, null, t2);
        }
      }
      function er(e2, t2) {
        const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n2 = Math.pow(10, r), s2 = Math.round(i2.lng * n2) / n2, a2 = Math.round(i2.lat * n2) / n2, l2 = e2.getBearing(), c2 = e2.getPitch();
        let h4 = t2 ? `/${s2}/${a2}/${o2}` : `${o2}/${a2}/${s2}`;
        return (l2 || c2) && (h4 += "/" + Math.round(10 * l2) / 10), c2 && (h4 += `/${Math.round(c2)}`), h4;
      }
      const tr = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, ir = e.extend({ deceleration: 2500, maxSpeed: 1400 }, tr), or = e.extend({ deceleration: 20, maxSpeed: 1400 }, tr), rr = e.extend({ deceleration: 1e3, maxSpeed: 360 }, tr), nr = e.extend({ deceleration: 1e3, maxSpeed: 90 }, tr);
      class sr {
        constructor(e2) {
          this._map = e2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t2 });
        }
        _drainInertiaBuffer() {
          const t2 = this._inertiaBuffer, i2 = e.exported.now();
          for (; t2.length > 0 && i2 - t2[0].time > 160; )
            t2.shift();
        }
        _onMoveEnd(t2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e2 } of this._inertiaBuffer)
            i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
          if (i2.pan.mag()) {
            const n2 = lr(i2.pan.mag(), o2, e.extend({}, ir, t2 || {}));
            r.offset = i2.pan.mult(n2.amount / i2.pan.mag()), r.center = this._map.transform.center, ar(r, n2);
          }
          if (i2.zoom) {
            const e2 = lr(i2.zoom, o2, or);
            r.zoom = this._map.transform.zoom + e2.amount, ar(r, e2);
          }
          if (i2.bearing) {
            const t3 = lr(i2.bearing, o2, rr);
            r.bearing = this._map.transform.bearing + e.clamp(t3.amount, -179, 179), ar(r, t3);
          }
          if (i2.pitch) {
            const e2 = lr(i2.pitch, o2, nr);
            r.pitch = this._map.transform.pitch + e2.amount, ar(r, e2);
          }
          if (r.zoom || r.bearing) {
            const e2 = i2.pinchAround === void 0 ? i2.around : i2.pinchAround;
            r.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
          }
          return this.clear(), r.noMoveStart = true, r;
        }
      }
      function ar(e2, t2) {
        (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
      }
      function lr(t2, i2, o2) {
        const { maxSpeed: r, linearity: n2, deceleration: s2 } = o2, a2 = e.clamp(t2 * n2 / (i2 / 1e3), -r, r), l2 = Math.abs(a2) / (s2 * n2);
        return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
      }
      class cr extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2, r = {}) {
          const n2 = p(i2.getCanvasContainer(), o2), s2 = i2.unproject(n2);
          super(t2, e.extend({ point: n2, lngLat: s2, originalEvent: o2 }, r)), this._defaultPrevented = false, this.target = i2;
        }
      }
      class hr extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2) {
          const r = t2 === "touchend" ? o2.changedTouches : o2.touches, n2 = m(i2.getCanvasContainer(), r), s2 = n2.map((e2) => i2.unproject(e2)), a2 = n2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.pointGeometry(0, 0));
          super(t2, { points: n2, point: a2, lngLats: s2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class ur extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2) {
          super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class _r {
        constructor(e2, t2) {
          this._map = e2, this._clickTolerance = t2.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e2) {
          return this._firePreventable(new ur(e2.type, this._map, e2));
        }
        mousedown(e2, t2) {
          return this._mousedownPos = t2, this._firePreventable(new cr(e2.type, this._map, e2));
        }
        mouseup(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        preclick(t2) {
          const i2 = e.extend({}, t2);
          i2.type = "preclick", this._map.fire(new cr(i2.type, this._map, i2));
        }
        click(e2, t2) {
          this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new cr(e2.type, this._map, e2)));
        }
        dblclick(e2) {
          return this._firePreventable(new cr(e2.type, this._map, e2));
        }
        mouseover(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        mouseout(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        touchstart(e2) {
          return this._firePreventable(new hr(e2.type, this._map, e2));
        }
        touchmove(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        touchend(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        touchcancel(e2) {
          this._map.fire(new hr(e2.type, this._map, e2));
        }
        _firePreventable(e2) {
          if (this._map.fire(e2), e2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class dr {
        constructor(e2) {
          this._map = e2;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e2) {
          this._map.fire(new cr(e2.type, this._map, e2));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e2) {
          this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new cr(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class pr {
        constructor(e2, t2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e2, t2) {
          this.isEnabled() && e2.shiftKey && e2.button === 0 && (h3(), this._startPos = this._lastPos = t2, this._active = true);
        }
        mousemoveWindow(e2, t2) {
          if (!this._active)
            return;
          const i2 = t2, o2 = this._startPos, r = this._lastPos;
          if (!o2 || !r || r.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
            return;
          this._lastPos = i2, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
          const s2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), l2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${s2}px,${l2}px)`, this._box.style.width = a2 - s2 + "px", this._box.style.height = c2 - l2 + "px");
          });
        }
        mouseupWindow(t2, i2) {
          if (!this._active)
            return;
          const o2 = this._startPos, r = i2;
          if (o2 && t2.button === 0) {
            if (this.reset(), d(), o2.x !== r.x || o2.y !== r.y)
              return this._map.fire(new e.Event("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", t2);
          }
        }
        keydown(e2) {
          this._active && e2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e2));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t2, i2) {
          return this._map.fire(new e.Event(t2, { originalEvent: i2 }));
        }
      }
      function mr(e2, t2) {
        const i2 = {};
        for (let o2 = 0; o2 < e2.length; o2++)
          i2[e2[o2].identifier] = t2[o2];
        return i2;
      }
      class fr {
        constructor(e2) {
          this.reset(), this.numTouches = e2.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(t2, i2, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === 0 && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e.pointGeometry(0, 0);
            for (const e2 of t3)
              i3._add(e2);
            return i3.div(t3.length);
          }(i2), this.touches = mr(o2, i2)));
        }
        touchmove(e2, t2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const o2 = mr(i2, t2);
          for (const e3 in this.touches) {
            const t3 = this.touches[e3], i3 = o2[e3];
            (!i3 || i3.dist(t3) > 30) && (this.aborted = true);
          }
        }
        touchend(e2, t2, i2) {
          if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class gr {
        constructor(e2) {
          this.singleTap = new fr(e2), this.numTaps = e2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e2, t2, i2) {
          this.singleTap.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this.singleTap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const o2 = this.singleTap.touchend(e2, t2, i2);
          if (o2) {
            const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        }
      }
      class vr {
        constructor() {
          this._zoomIn = new gr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new gr({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e2, t2, i2) {
          this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const o2 = this._zoomIn.touchend(e2, t2, i2), r = this._zoomOut.touchend(e2, t2, i2);
          return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r) }, { originalEvent: e2 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const xr = { 0: 1, 2: 2 };
      class yr {
        constructor(e2) {
          this.reset(), this._clickTolerance = e2.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e2, t2) {
          return false;
        }
        _move(e2, t2) {
          return {};
        }
        mousedown(e2, t2) {
          if (this._lastPoint)
            return;
          const i2 = f(e2);
          this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
        }
        mousemoveWindow(e2, t2) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e2.preventDefault(), this._eventButton != null && function(e3, t3) {
              const i3 = xr[t3];
              return e3.buttons === void 0 || (e3.buttons & i3) !== i3;
            }(e2, this._eventButton))
              this.reset();
            else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
          }
        }
        mouseupWindow(e2) {
          this._lastPoint && f(e2) === this._eventButton && (this._moved && d(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class br extends yr {
        mousedown(e2, t2) {
          super.mousedown(e2, t2), this._lastPoint && (this._active = true);
        }
        _correctButton(e2, t2) {
          return t2 === 0 && !e2.ctrlKey;
        }
        _move(e2, t2) {
          return { around: t2, panDelta: t2.sub(e2) };
        }
      }
      class wr extends yr {
        _correctButton(e2, t2) {
          return t2 === 0 && e2.ctrlKey || t2 === 2;
        }
        _move(e2, t2) {
          const i2 = 0.8 * (t2.x - e2.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Tr extends yr {
        _correctButton(e2, t2) {
          return t2 === 0 && e2.ctrlKey || t2 === 2;
        }
        _move(e2, t2) {
          const i2 = -0.5 * (t2.y - e2.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Er {
        constructor(t2, i2) {
          this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
        }
        touchstart(e2, t2, i2) {
          return this._calculateTransform(e2, t2, i2);
        }
        touchmove(t2, i2, o2) {
          if (this._active && !(o2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (o2.length === 1 && !e.isFullscreen())
                return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
          }
        }
        touchend(e2, t2, i2) {
          this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t2, i2, o2) {
          o2.length > 0 && (this._active = true);
          const r = mr(o2, i2), n2 = new e.pointGeometry(0, 0), s2 = new e.pointGeometry(0, 0);
          let a2 = 0;
          for (const e2 in r) {
            const t3 = r[e2], i3 = this._touches[e2];
            i3 && (n2._add(t3), s2._add(t3.sub(i3)), a2++, r[e2] = t3);
          }
          if (this._touches = r, a2 < this._minTouches || !s2.mag())
            return;
          const l2 = s2.div(a2);
          return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(a2), panDelta: l2 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 500);
        }
      }
      class Cr {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e2) {
        }
        _move(e2, t2, i2) {
          return {};
        }
        touchstart(e2, t2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
        }
        touchmove(e2, t2, i2) {
          const o2 = this._firstTwoTouches;
          if (!o2)
            return;
          e2.preventDefault();
          const [r, n2] = o2, s2 = Mr(i2, t2, r), a2 = Mr(i2, t2, n2);
          if (!s2 || !a2)
            return;
          const l2 = this._aroundCenter ? null : s2.add(a2).div(2);
          return this._move([s2, a2], l2, e2);
        }
        touchend(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [o2, r] = this._firstTwoTouches, n2 = Mr(i2, t2, o2), s2 = Mr(i2, t2, r);
          n2 && s2 || (this._active && d(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e2) {
          this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center";
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Mr(e2, t2, i2) {
        for (let o2 = 0; o2 < e2.length; o2++)
          if (e2[o2].identifier === i2)
            return t2[o2];
      }
      function Ir(e2, t2) {
        return Math.log(e2 / t2) / Math.LN2;
      }
      class Sr extends Cr {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e2) {
          this._startDistance = this._distance = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._distance;
          if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: Ir(this._distance, i2), pinchAround: t2 };
        }
      }
      function Dr(e2, t2) {
        return 180 * e2.angleWith(t2) / Math.PI;
      }
      class Lr extends Cr {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e2) {
          this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._vector;
          if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = true, { bearingDelta: Dr(this._vector, i2), pinchAround: t2 };
        }
        _isBelowThreshold(e2) {
          this._minDiameter = Math.min(this._minDiameter, e2.mag());
          const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
          if (!i2)
            return false;
          const o2 = Dr(e2, i2);
          return Math.abs(o2) < t2;
        }
      }
      function Ar(e2) {
        return Math.abs(e2.y) > Math.abs(e2.x);
      }
      class zr extends Cr {
        constructor(e2) {
          super(), this._map = e2;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e2) {
          this._lastPoints = e2, Ar(e2[0].sub(e2[1])) && (this._valid = false);
        }
        _move(t2, i2, o2) {
          const r = this._lastPoints;
          if (!r)
            return;
          const n2 = t2[0].sub(r[0]), s2 = t2[1].sub(r[1]);
          return this._map._cooperativeGestures && !e.isFullscreen() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n2, s2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (n2.y + s2.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e2, t2, i2) {
          if (this._valid !== void 0)
            return this._valid;
          const o2 = e2.mag() >= 2, r = t2.mag() >= 2;
          if (!o2 && !r)
            return;
          if (!o2 || !r)
            return this._firstMove == null && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const n2 = e2.y > 0 == t2.y > 0;
          return Ar(e2) && Ar(t2) && n2;
        }
      }
      const Pr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Rr {
        constructor() {
          const e2 = Pr;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e2) {
          if (e2.altKey || e2.ctrlKey || e2.metaKey)
            return;
          let t2 = 0, i2 = 0, o2 = 0, r = 0, n2 = 0;
          switch (e2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t2 = -1;
              break;
            case 37:
              e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r = -1);
              break;
            case 39:
              e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r = 1);
              break;
            case 38:
              e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n2 = -1);
              break;
            case 40:
              e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s2) => {
            const a2 = s2.getZoom();
            s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Or, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + o2 * this._pitchStep, offset: [-r * this._panStep, -n2 * this._panStep], center: s2.getCenter() }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function Or(e2) {
        return e2 * (2 - e2);
      }
      const Br = 4.000244140625;
      class kr {
        constructor(t2, i2) {
          this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e2) {
          this._defaultZoomRate = e2;
        }
        setWheelZoomRate(e2) {
          this._wheelZoomRate = e2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && e2.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.isFullscreen()))
              return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i2 = t2.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const o2 = e.exported.now(), r = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, i2 !== 0 && i2 % Br == 0 ? this._type = "wheel" : i2 !== 0 && Math.abs(i2) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
        }
        _onTimeout(e2) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
        }
        _start(e2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t2 = p(this._el, e2);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t2 = this._map.transform;
          this._type === "wheel" && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
          if (this._delta !== 0) {
            const e2 = this._type === "wheel" && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
            this._delta < 0 && o3 !== 0 && (o3 = 1 / o3);
            const r2 = i2(), n3 = Math.pow(2, r2), s3 = typeof this._targetZoom == "number" ? t2.zoomScale(this._targetZoom) : n3;
            this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(s3 * o3))), this._type === "wheel" && (this._startZoom = r2, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const o2 = typeof this._targetZoom == "number" ? this._targetZoom : i2(), r = this._startZoom, n2 = this._easing;
          let s2, a2 = false;
          if (this._type === "wheel" && r && n2) {
            const t3 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n2(t3);
            s2 = e.number(r, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
          } else
            s2 = o2, a2 = true;
          return this._active = true, a2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !a2, zoomDelta: s2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t2) {
          let i2 = e.ease;
          if (this._prevEase) {
            const t3 = this._prevEase, o2 = (e.exported.now() - t3.start) / t3.duration, r = t3.easing(o2 + 0.01) - t3.easing(o2), n2 = 0.27 / Math.sqrt(r * r + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
            i2 = e.bezier(n2, s2, 0.25, 1);
          }
          return this._prevEase = { start: e.exported.now(), duration: t2, easing: i2 }, i2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 200);
        }
      }
      class Fr {
        constructor(e2, t2) {
          this._clickZoom = e2, this._tapZoom = t2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ur {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e2, t2) {
          return e2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Nr {
        constructor() {
          this._tap = new gr({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e2, t2, i2) {
          this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
        }
        touchmove(e2, t2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const o2 = t2[0], r = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r / 128 };
            }
          } else
            this._tap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          this._tapTime ? this._swipePoint && i2.length === 0 && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Gr {
        constructor(e2, t2, i2) {
          this._el = e2, this._mousePan = t2, this._touchPan = i2;
        }
        enable(e2) {
          this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class jr {
        constructor(e2, t2, i2) {
          this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Zr {
        constructor(e2, t2, i2, o2) {
          this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e2) {
          this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Vr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
      class Wr extends e.Event {
      }
      class Xr {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t2, i2) {
          const o2 = e.sub([], i2, t2);
          this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t2) {
          e.div(t2, t2, this.constants), e.normalize(t2, t2), e.mul$1(t2, t2, this.constants);
          const i2 = e.scale$2([], t2, this.radius);
          if (i2[2] > 0) {
            const t3 = e.scale$2([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale$2([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r = e.add([], i2, e.scale$2([], e.sub([], e.add([], o2, t3), i2), 2));
            i2[0] = r[0], i2[1] = r[1];
          }
          return i2;
        }
      }
      function qr(e2) {
        return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
      }
      class $r {
        constructor(t2, i2) {
          this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
          for (const [t3, i3, o3] of this._listeners)
            t3.addEventListener(i3, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
        }
        destroy() {
          for (const [t2, i2, o2] of this._listeners)
            t2.removeEventListener(i2, t2 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
        }
        _addDefaultHandlers(e2) {
          const t2 = this._map, i2 = t2.getCanvasContainer();
          this._add("mapEvent", new _r(t2, e2));
          const o2 = t2.boxZoom = new pr(t2, e2);
          this._add("boxZoom", o2);
          const r = new vr(), n2 = new Ur();
          t2.doubleClickZoom = new Fr(n2, r), this._add("tapZoom", r), this._add("clickZoom", n2);
          const s2 = new Nr();
          this._add("tapDragZoom", s2);
          const a2 = t2.touchPitch = new zr(t2);
          this._add("touchPitch", a2);
          const l2 = new wr(e2), c2 = new Tr(e2);
          t2.dragRotate = new jr(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          const h4 = new br(e2), u2 = new Er(t2, e2);
          t2.dragPan = new Gr(i2, h4, u2), this._add("mousePan", h4), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
          const _2 = new Lr(), d2 = new Sr();
          t2.touchZoomRotate = new Zr(i2, d2, _2, s2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t2));
          const p2 = t2.scrollZoom = new kr(t2, this);
          this._add("scrollZoom", p2, ["mousePan"]);
          const m2 = t2.keyboard = new Rr();
          this._add("keyboard", m2);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
        }
        _add(e2, t2, i2) {
          this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
        }
        stop(e2) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e2 } of this._handlers)
            if (e2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Vr(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e2, t2, i2) {
          for (const o2 in e2)
            if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e2) {
          this.handleEvent(e2, `${e2.type}Window`);
        }
        _getMapTouches(e2) {
          const t2 = [];
          for (const i2 of e2)
            this._el.contains(i2.target) && t2.push(i2);
          return t2;
        }
        handleEvent(e2, t2) {
          this._updatingCamera = true;
          const i2 = e2.type === "renderFrame", o2 = i2 ? void 0 : e2, r = { needsRenderFrame: false }, n2 = {}, s2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? m(this._el, a2) : i2 ? void 0 : p(this._el, e2);
          for (const { handlerName: i3, handler: c3, allowed: h5 } of this._handlers) {
            if (!c3.isEnabled())
              continue;
            let u2;
            this._blockedByActive(s2, h5, i3) ? c3.reset() : c3[t2 || e2.type] && (u2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(r, n2, u2, i3, o2), u2 && u2.needsRenderFrame && this._triggerRenderFrame()), (u2 || c3.isActive()) && (s2[i3] = c3);
          }
          const c2 = {};
          for (const e3 in this._previousActiveHandlers)
            s2[e3] || (c2[e3] = o2);
          this._previousActiveHandlers = s2, (Object.keys(c2).length || qr(r)) && (this._changes.push([r, n2, c2]), this._triggerRenderFrame()), (Object.keys(s2).length || qr(r)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h4 } = r;
          h4 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h4(this._map));
        }
        mergeHandlerResult(t2, i2, o2, r, n2) {
          if (!o2)
            return;
          e.extend(t2, o2);
          const s2 = { handlerName: r, originalEvent: o2.originalEvent || n2 };
          o2.zoomDelta !== void 0 && (i2.zoom = s2), o2.panDelta !== void 0 && (i2.drag = s2), o2.pitchDelta !== void 0 && (i2.pitch = s2), o2.bearingDelta !== void 0 && (i2.rotate = s2);
        }
        _applyChanges() {
          const t2 = {}, i2 = {}, o2 = {};
          for (const [r, n2, s2] of this._changes)
            r.panDelta && (t2.panDelta = (t2.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r.pitchDelta), r.around !== void 0 && (t2.around = r.around), r.aroundCoord !== void 0 && (t2.aroundCoord = r.aroundCoord), r.pinchAround !== void 0 && (t2.pinchAround = r.pinchAround), r.noInertia && (t2.noInertia = r.noInertia), e.extend(i2, n2), e.extend(o2, s2);
          this._updateMapTransform(t2, i2, o2), this._changes = [];
        }
        _updateMapTransform(t2, i2, o2) {
          const r = this._map, n2 = r.transform, s2 = (e2) => [e2.x, e2.y, e2.z];
          if (((e2) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !qr(t2)) {
            const e2 = n2.zoom;
            n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e2 !== n2.zoom && this._map._update(true);
          }
          if (n2._isCameraConstrained && r._stop(true), !qr(t2))
            return void this._fireEvents(i2, o2, true);
          let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h4, around: u2, aroundCoord: _2, pinchAround: d2 } = t2;
          n2._isCameraConstrained && (l2 > 0 && (l2 = 0), n2._isCameraConstrained = false), d2 !== void 0 && (u2 = d2), (l2 || ((e2) => i2.drag && !this._eventsInProgress.drag)()) && u2 && (this._dragOrigin = s2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r._stop(true), u2 = u2 || r.transform.centerPoint, c2 && (n2.bearing += c2), h4 && (n2.pitch += h4), n2._updateCameraState();
          const p2 = [0, 0, 0];
          if (a2)
            if (n2.projection.name === "mercator") {
              const e2 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2).dir), t3 = this._trackingEllipsoid.projectRay(n2.screenPointToMercatorRay(u2.sub(a2)).dir);
              p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
            } else {
              const t3 = n2.pointCoordinate(u2);
              if (n2.projection.name === "globe") {
                a2 = a2.rotate(-n2.angle);
                const i3 = n2._pixelsPerMercatorPixel / n2.worldSize;
                p2[0] = -a2.x * e.mercatorScale(e.latFromMercatorY(t3.y)) * i3, p2[1] = -a2.y * e.mercatorScale(n2.center.lat) * i3;
              } else {
                const e2 = n2.pointCoordinate(u2.sub(a2));
                t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
              }
            }
          const m2 = n2.zoom, f2 = [0, 0, 0];
          if (l2) {
            const t3 = s2(_2 || n2.pointCoordinate3D(u2)), i3 = { dir: e.normalize([], e.sub([], t3, n2._camera.position)) };
            if (i3.dir[2] < 0) {
              const o3 = n2.zoomDeltaToMovement(t3, l2);
              e.scale$2(f2, i3.dir, o3);
            }
          }
          const g2 = e.add(p2, p2, f2);
          n2._translateCameraConstrained(g2), l2 && Math.abs(n2.zoom - m2) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
        }
        _fireEvents(t2, i2, o2) {
          const r = Vr(this._eventsInProgress), n2 = Vr(t2), s2 = {};
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._eventsInProgress[e2] || (s2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
          }
          !r && n2 && this._fireEvent("movestart", n2.originalEvent);
          for (const e2 in s2)
            this._fireEvent(e2, s2[e2]);
          n2 && this._fireEvent("move", n2.originalEvent);
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._fireEvent(e2, i3);
          }
          const a2 = {};
          let l2;
          for (const e2 in this._eventsInProgress) {
            const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
            this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, a2[`${e2}end`] = l2);
          }
          for (const e2 in a2)
            this._fireEvent(e2, a2[e2]);
          const c2 = Vr(this._eventsInProgress);
          if (o2 && (r || n2) && !c2) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => e2 !== 0 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
            t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t2, i2) {
          this._map.fire(new e.Event(t2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
            this._frameId = void 0, this.handleEvent(new Wr("renderFrame", { timeStamp: e2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Yr extends e.Evented {
        constructor(t2, i2) {
          super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e2, t2) {
          return this.jumpTo({ center: e2 }, t2);
        }
        panBy(t2, i2, o2) {
          return t2 = e.pointGeometry.convert(t2).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t2 }, i2), o2);
        }
        panTo(t2, i2, o2) {
          return this.easeTo(e.extend({ center: t2 }, i2), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e2, t2) {
          return this.jumpTo({ zoom: e2 }, t2), this;
        }
        zoomTo(t2, i2, o2) {
          return this.easeTo(e.extend({ zoom: t2 }, i2), o2);
        }
        zoomIn(e2, t2) {
          return this.zoomTo(this.getZoom() + 1, e2, t2), this;
        }
        zoomOut(e2, t2) {
          return this.zoomTo(this.getZoom() - 1, e2, t2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e2, t2) {
          return this.jumpTo({ bearing: e2 }, t2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e2, t2) {
          return this.jumpTo({ padding: e2 }, t2), this;
        }
        rotateTo(t2, i2, o2) {
          return this.easeTo(e.extend({ bearing: t2 }, i2), o2);
        }
        resetNorth(t2, i2) {
          return this.rotateTo(0, e.extend({ duration: 1e3 }, t2), i2), this;
        }
        resetNorthPitch(t2, i2) {
          return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
        }
        snapToNorth(e2, t2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e2, t2) {
          return this.jumpTo({ pitch: e2 }, t2), this;
        }
        cameraForBounds(t2, i2) {
          t2 = e.LngLatBounds.convert(t2);
          const o2 = i2 && i2.bearing || 0, r = i2 && i2.pitch || 0, n2 = t2.getNorthWest(), s2 = t2.getSouthEast();
          return this._cameraForBounds(this.transform, n2, s2, o2, r, i2);
        }
        _extendCameraOptions(t2) {
          const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (t2 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding == "number") {
            const e2 = t2.padding;
            t2.padding = { top: e2, bottom: e2, right: e2, left: e2 };
          }
          return t2.padding = e.extend(i2, t2.padding), t2;
        }
        _minimumAABBFrustumDistance(e2, t2) {
          const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
          return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
        }
        _cameraForBoundsOnGlobe(t2, i2, o2, r, n2, s2) {
          const a2 = t2.clone(), l2 = this._extendCameraOptions(s2);
          a2.bearing = r, a2.pitch = n2;
          const c2 = e.LngLat.convert(i2), h4 = e.LngLat.convert(o2), u2 = 0.5 * (c2.lat + h4.lat), _2 = 0.5 * (c2.lng + h4.lng), d2 = e.latLngToECEF(u2, _2), p2 = e.normalize([], d2), m2 = e.normalize([], e.cross([], p2, [0, 1, 0])), f2 = e.cross([], m2, p2), g2 = [m2[0], m2[1], m2[2], 0, f2[0], f2[1], f2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v3 = [d2, e.latLngToECEF(c2.lat, c2.lng), e.latLngToECEF(h4.lat, c2.lng), e.latLngToECEF(h4.lat, h4.lng), e.latLngToECEF(c2.lat, h4.lng), e.latLngToECEF(u2, c2.lng), e.latLngToECEF(u2, h4.lng), e.latLngToECEF(c2.lat, _2), e.latLngToECEF(h4.lat, _2)];
          let x2 = e.Aabb.fromPoints(v3.map((t3) => [e.dot(m2, t3), e.dot(f2, t3), e.dot(p2, t3)]));
          const y2 = e.transformMat4([], x2.center, g2);
          e.squaredLength(y2) === 0 && e.set(y2, 0, 0, 1), e.normalize(y2, y2), e.scale$2(y2, y2, e.GLOBE_RADIUS), a2.center = e.ecefToLatLng(y2);
          const b2 = a2.getWorldToCameraMatrix(), w2 = e.invert(new Float64Array(16), b2);
          x2 = e.Aabb.applyTransform(x2, e.multiply([], b2, g2)), e.transformMat4(y2, y2, b2);
          const T2 = 0.5 * (x2.max[2] - x2.min[2]), E2 = this._minimumAABBFrustumDistance(a2, x2), C2 = e.scale$2([], [0, 0, 1], T2), M2 = e.add(C2, y2, C2), I2 = E2 + (a2.pitch === 0 ? 0 : e.distance(y2, M2)), S2 = a2.globeCenterInViewSpace, D2 = e.sub([], y2, [S2[0], S2[1], S2[2]]);
          e.normalize(D2, D2), e.scale$2(D2, D2, I2);
          const L2 = e.add([], y2, D2);
          e.transformMat4(L2, L2, w2);
          const A2 = e.earthRadius / e.GLOBE_RADIUS, z2 = e.length(L2), P2 = e.mercatorZfromAltitude(Math.max(z2 * A2 - e.earthRadius, Number.EPSILON), 0), R3 = Math.min(a2.zoomFromMercatorZAdjusted(P2), l2.maxZoom);
          return R3 > 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "mercator" }), a2.zoom = R3, this._cameraForBounds(a2, i2, o2, r, n2, s2)) : { center: a2.center, zoom: R3, bearing: r, pitch: n2 };
        }
        queryTerrainElevation(t2, i2) {
          const o2 = this.transform.elevation;
          return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t2), null, i2.exaggerated)) : null;
        }
        _cameraForBounds(t2, i2, o2, r, n2, s2) {
          if (t2.projection.name === "globe")
            return this._cameraForBoundsOnGlobe(t2, i2, o2, r, n2, s2);
          const a2 = t2.clone(), l2 = this._extendCameraOptions(s2), c2 = a2.padding;
          a2.bearing = r, a2.pitch = n2;
          const h4 = e.LngLat.convert(i2), u2 = e.LngLat.convert(o2), _2 = new e.LngLat(h4.lng, u2.lat), d2 = new e.LngLat(u2.lng, h4.lat), p2 = a2.project(h4), m2 = a2.project(u2), f2 = this.queryTerrainElevation(h4), g2 = this.queryTerrainElevation(u2), v3 = this.queryTerrainElevation(_2), x2 = this.queryTerrainElevation(d2), y2 = [[p2.x, p2.y, Math.min(f2 || 0, g2 || 0, v3 || 0, x2 || 0)], [m2.x, m2.y, Math.max(f2 || 0, g2 || 0, v3 || 0, x2 || 0)]];
          let b2 = e.Aabb.fromPoints(y2);
          const w2 = a2.getWorldToCameraMatrix(), T2 = e.invert(new Float64Array(16), w2);
          b2 = e.Aabb.applyTransform(b2, w2);
          const E2 = e.sub([], b2.max, b2.min), C2 = c2.left || 0, M2 = c2.right || 0, I2 = c2.bottom || 0, S2 = c2.top || 0, { left: D2, right: L2, top: A2, bottom: z2 } = l2.padding, P2 = 0.5 * (C2 + M2), R3 = 0.5 * (S2 + I2), O2 = Math.min(a2.scaleZoom(a2.scale * Math.min((a2.width - (C2 + M2 + D2 + L2)) / E2[0], (a2.height - (I2 + S2 + z2 + A2)) / E2[1])), l2.maxZoom), B2 = a2.scale / a2.zoomScale(O2);
          b2 = new e.Aabb([b2.min[0] - (D2 + P2) * B2, b2.min[1] - (z2 + R3) * B2, b2.min[2]], [b2.max[0] + (L2 + P2) * B2, b2.max[1] + (A2 + R3) * B2, b2.max[2]]);
          const k2 = 0.5 * E2[2], F2 = this._minimumAABBFrustumDistance(a2, b2), U2 = [0, 0, 1, 0];
          e.transformMat4$1(U2, U2, w2), e.normalize$2(U2, U2);
          const N2 = e.scale$2([], U2, F2 + k2), G2 = e.add([], b2.center, N2), j2 = (typeof l2.offset.x == "number" && typeof l2.offset.y == "number" ? new e.pointGeometry(l2.offset.x, l2.offset.y) : e.pointGeometry.convert(l2.offset)).rotate(-e.degToRad(r));
          b2.center[0] -= j2.x * B2, b2.center[1] += j2.y * B2, e.transformMat4(b2.center, b2.center, T2), e.transformMat4(G2, G2, T2);
          const Z2 = [b2.center[0], b2.center[1], G2[2] * a2.pixelsPerMeter];
          e.scale$2(Z2, Z2, 1 / a2.worldSize);
          const V2 = e.lngFromMercatorX(Z2[0]), W2 = e.latFromMercatorY(Z2[1]), X2 = Math.min(a2._zoomFromMercatorZ(Z2[2]), l2.maxZoom), q2 = new e.LngLat(V2, W2);
          return a2.mercatorFromTransition && X2 < 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "globe" }), a2.zoom = X2, this._cameraForBounds(a2, i2, o2, r, n2, s2)) : { center: q2, zoom: X2, bearing: r, pitch: n2 };
        }
        fitBounds(e2, t2, i2) {
          const o2 = this.cameraForBounds(e2, t2);
          return this._fitInternal(o2, t2, i2);
        }
        fitScreenCoordinates(t2, i2, o2, r, n2) {
          const s2 = e.pointGeometry.convert(t2), a2 = e.pointGeometry.convert(i2), l2 = new e.pointGeometry(Math.min(s2.x, a2.x), Math.min(s2.y, a2.y)), c2 = new e.pointGeometry(Math.max(s2.x, a2.x), Math.max(s2.y, a2.y));
          if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(s2, a2))
            return this;
          const h4 = this.transform.pointLocation3D(l2), u2 = this.transform.pointLocation3D(c2), _2 = this.transform.pointLocation3D(new e.pointGeometry(l2.x, c2.y)), d2 = this.transform.pointLocation3D(new e.pointGeometry(c2.x, l2.y)), p2 = [Math.min(h4.lng, u2.lng, _2.lng, d2.lng), Math.min(h4.lat, u2.lat, _2.lat, d2.lat)], m2 = [Math.max(h4.lng, u2.lng, _2.lng, d2.lng), Math.max(h4.lat, u2.lat, _2.lat, d2.lat)], f2 = r && r.pitch ? r.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, m2, o2, f2, r);
          return this._fitInternal(g2, r, n2);
        }
        _fitInternal(t2, i2, o2) {
          return t2 ? (delete (i2 = e.extend(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
        }
        jumpTo(t2, i2) {
          this.stop();
          const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
          let r = false, n2 = false, s2 = false;
          return "zoom" in t2 && o2.zoom !== +t2.zoom && (r = true, o2.zoom = +t2.zoom), t2.center !== void 0 && (o2.center = e.LngLat.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (n2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (s2 = true, o2.pitch = +t2.pitch), t2.padding == null || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), s2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t2, i2) {
          const o2 = this.transform;
          if (!o2.projection.supportsFreeCamera)
            return e.warnOnce(Hr), this;
          this.stop();
          const r = o2.zoom, n2 = o2.pitch, s2 = o2.bearing;
          o2.setFreeCameraOptions(t2);
          const a2 = r !== o2.zoom, l2 = n2 !== o2.pitch, c2 = s2 !== o2.bearing;
          return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), a2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
        }
        easeTo(t2, i2) {
          this._stop(false, t2.easeId), ((t2 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t2)).animate === false || !t2.essential && e.exported.prefersReducedMotion) && (t2.duration = 0);
          const o2 = this.transform, r = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h4 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = e.pointGeometry.convert(t2.offset);
          let d2, p2, m2;
          if (o2.projection.name === "globe") {
            const i3 = e.MercatorCoordinate.fromLngLat(o2.center), r2 = _2.rotate(-o2.angle);
            i3.x += r2.x / o2.worldSize, i3.y += r2.y / o2.worldSize;
            const n3 = i3.toLngLat(), s3 = e.LngLat.convert(t2.center || n3);
            this._normalizeCenter(s3), d2 = o2.centerPoint.add(r2), p2 = new e.pointGeometry(i3.x, i3.y).mult(o2.worldSize), m2 = new e.pointGeometry(e.mercatorXfromLng(s3.lng), e.mercatorYfromLat(s3.lat)).mult(o2.worldSize).sub(p2);
          } else {
            d2 = o2.centerPoint.add(_2);
            const i3 = o2.pointLocation(d2), r2 = e.LngLat.convert(t2.center || i3);
            this._normalizeCenter(r2), p2 = o2.project(i3), m2 = o2.project(r2).sub(p2);
          }
          const f2 = o2.zoomScale(l2 - r);
          let g2, v3;
          t2.around && (g2 = e.LngLat.convert(t2.around), v3 = o2.locationPoint(g2));
          const x2 = this._zooming || l2 !== r, y2 = this._rotating || n2 !== c2, b2 = this._pitching || h4 !== s2, w2 = !o2.isPaddingEqual(u2), T2 = (o3) => (T3) => {
            if (x2 && (o3.zoom = e.number(r, l2, T3)), y2 && (o3.bearing = e.number(n2, c2, T3)), b2 && (o3.pitch = e.number(s2, h4, T3)), w2 && (o3.interpolatePadding(a2, u2, T3), d2 = o3.centerPoint.add(_2)), g2)
              o3.setLocationAtPoint(g2, v3);
            else {
              const e2 = o3.zoomScale(o3.zoom - r), t3 = l2 > r ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - T3), n3 = o3.unproject(p2.add(m2.mult(T3 * i3)).mult(e2));
              o3.setLocationAtPoint(o3.renderWorldCopies ? n3.wrap() : n3, d2);
            }
            return t2.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t2.preloadOnly) {
            const e2 = this._emulate(T2, t2.duration, o2);
            return this._preloadTiles(e2), this;
          }
          const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x2, this._rotating = y2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, E2), this._ease(T2(o2), (e2) => {
            o2.recenterOnTerrain(), this._afterEase(i2, e2);
          }, t2), this;
        }
        _prepareEase(t2, i2, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t2));
        }
        _fireMoveEvents(t2) {
          this.fire(new e.Event("move", t2)), this._zooming && this.fire(new e.Event("zoom", t2)), this._rotating && this.fire(new e.Event("rotate", t2)), this._pitching && this.fire(new e.Event("pitch", t2));
        }
        _afterEase(t2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, r = this._rotating, n2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t2)), r && this.fire(new e.Event("rotateend", t2)), n2 && this.fire(new e.Event("pitchend", t2)), this.fire(new e.Event("moveend", t2));
        }
        flyTo(t2, i2) {
          if (!t2.essential && e.exported.prefersReducedMotion) {
            const o3 = e.pick(t2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(o3, i2);
          }
          this.stop(), t2 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t2);
          const o2 = this.transform, r = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? e.clamp(+t2.zoom, o2.minZoom, o2.maxZoom) : r, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h4 = "pitch" in t2 ? +t2.pitch : s2, u2 = "padding" in t2 ? t2.padding : o2.padding, _2 = o2.zoomScale(l2 - r), d2 = e.pointGeometry.convert(t2.offset);
          let p2 = o2.centerPoint.add(d2);
          const m2 = o2.pointLocation(p2), f2 = e.LngLat.convert(t2.center || m2);
          this._normalizeCenter(f2);
          const g2 = o2.project(m2), v3 = o2.project(f2).sub(g2);
          let x2 = t2.curve;
          const y2 = Math.max(o2.width, o2.height), b2 = y2 / _2, w2 = v3.mag();
          if ("minZoom" in t2) {
            const i3 = e.clamp(Math.min(t2.minZoom, r, l2), o2.minZoom, o2.maxZoom), n3 = y2 / o2.zoomScale(i3 - r);
            x2 = Math.sqrt(n3 / w2 * 2);
          }
          const T2 = x2 * x2;
          function E2(e2) {
            const t3 = (b2 * b2 - y2 * y2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : y2) * T2 * w2);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function C2(e2) {
            return (Math.exp(e2) - Math.exp(-e2)) / 2;
          }
          function M2(e2) {
            return (Math.exp(e2) + Math.exp(-e2)) / 2;
          }
          const I2 = E2(0);
          let S2 = function(e2) {
            return M2(I2) / M2(I2 + x2 * e2);
          }, D2 = function(e2) {
            return y2 * ((M2(I2) * (C2(t3 = I2 + x2 * e2) / M2(t3)) - C2(I2)) / T2) / w2;
            var t3;
          }, L2 = (E2(1) - I2) / x2;
          if (Math.abs(w2) < 1e-6 || !isFinite(L2)) {
            if (Math.abs(y2 - b2) < 1e-6)
              return this.easeTo(t2, i2);
            const e2 = b2 < y2 ? -1 : 1;
            L2 = Math.abs(Math.log(b2 / y2)) / x2, D2 = function() {
              return 0;
            }, S2 = function(t3) {
              return Math.exp(e2 * x2 * t3);
            };
          }
          t2.duration = "duration" in t2 ? +t2.duration : 1e3 * L2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
          const A2 = n2 !== c2, z2 = h4 !== s2, P2 = !o2.isPaddingEqual(u2), R3 = (o3) => (_3) => {
            const m3 = _3 * L2, x3 = 1 / S2(m3);
            o3.zoom = _3 === 1 ? l2 : r + o3.scaleZoom(x3), A2 && (o3.bearing = e.number(n2, c2, _3)), z2 && (o3.pitch = e.number(s2, h4, _3)), P2 && (o3.interpolatePadding(a2, u2, _3), p2 = o3.centerPoint.add(d2));
            const y3 = _3 === 1 ? f2 : o3.unproject(g2.add(v3.mult(D2(m3))).mult(x3));
            return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t2.preloadOnly) {
            const e2 = this._emulate(R3, t2.duration, o2);
            return this._preloadTiles(e2), this;
          }
          return this._zooming = true, this._rotating = A2, this._pitching = z2, this._padding = P2, this._prepareEase(i2, false), this._ease(R3(o2), () => this._afterEase(i2), t2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e2, t2) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t2);
          }
          if (!e2) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t2, i2, o2) {
          o2.animate === false || o2.duration === 0 ? (t2(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t2 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
          i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t2, i2) {
          t2 = e.wrap(t2, -180, 180);
          const o2 = Math.abs(t2 - i2);
          return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
        }
        _normalizeCenter(e2) {
          const t2 = this.transform;
          if (!t2.renderWorldCopies || t2.maxBounds)
            return;
          const i2 = e2.lng - t2.center.lng;
          e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        _emulate(e2, t2, i2) {
          const o2 = Math.ceil(15 * t2 / 1e3), r = [], n2 = e2(i2.clone());
          for (let e3 = 0; e3 <= o2; e3++) {
            const t3 = n2(e3 / o2);
            r.push(t3.clone());
          }
          return r;
        }
      }
      class Kr {
        constructor(t2 = {}) {
          this.options = t2, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e2) {
          const t2 = this.options && this.options.compact;
          return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), t2 === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e2, t2) {
          const i2 = this._map._getUIString(`AttributionControl.${t2}`);
          e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t2 = this._editLink;
          t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
          if (t2) {
            const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
            t2.href = `${e.config.FEEDBACK_URL}/${o2}#${er(this._map, true)}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
          }
        }
        _updateData(e2) {
          !e2 || e2.sourceDataType !== "metadata" && e2.sourceDataType !== "visibility" && e2.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e2 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t2 = this._map.style._sourceCaches;
          for (const i3 in t2) {
            const o2 = t2[i3];
            if (o2.used) {
              const t3 = o2.getSource();
              t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
            }
          }
          e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
            for (let o2 = i3 + 1; o2 < e2.length; o2++)
              if (e2[o2].indexOf(t3) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
          const i2 = e2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Jr {
        constructor() {
          e.bindAll(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e2) {
          this._map = e2, this._container = n("div", "mapboxgl-ctrl");
          const t2 = n("a", "mapboxgl-ctrl-logo");
          return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e2) {
          e2 && e2.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e2 = this._map.style._sourceCaches;
          if (Object.entries(e2).length === 0)
            return true;
          for (const t2 in e2) {
            const i2 = e2[t2].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e2 = this._container.children;
          if (e2.length) {
            const t2 = e2[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Qr {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e2) {
          const t2 = ++this._id;
          return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
        }
        remove(e2) {
          const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
          for (const t3 of i2)
            if (t3.id === e2)
              return void (t3.cancelled = true);
        }
        run(e2 = 0) {
          const t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t2)
            if (!i2.cancelled && (i2.callback(e2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function en(t2, i2, o2) {
        if (t2 = new e.LngLat(t2.lng, t2.lat), i2) {
          const r = new e.LngLat(t2.lng - 360, t2.lat), n2 = new e.LngLat(t2.lng + 360, t2.lat), s2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
          o2.locationPoint(r).distSqr(i2) < a2 && (l2 || Math.abs(r.lng - o2.center.lng) < s2) ? t2 = r : o2.locationPoint(n2).distSqr(i2) < a2 && (l2 || Math.abs(n2.lng - o2.center.lng) < s2) && (t2 = n2);
        }
        for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
          const e2 = o2.locationPoint(t2);
          if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
            break;
          t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
        }
        return t2;
      }
      const tn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class on extends e.Evented {
        constructor(t2, i2) {
          if (super(), (t2 instanceof e.window.HTMLElement || i2) && (t2 = e.extend({ element: t2 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
            this._element = t2.element, this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = n("div");
            const i3 = 41, o3 = 27, r = s("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), a2 = s("radialGradient", { id: "shadowGradient" }, s("defs", {}, r));
            s("stop", { offset: "10%", "stop-opacity": 0.4 }, a2), s("stop", { offset: "100%", "stop-opacity": 0.05 }, a2), s("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r), s("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r), s("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r), s("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r), this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
            e2.preventDefault();
          }), this._element.addEventListener("mousedown", (e2) => {
            e2.preventDefault();
          });
          const o2 = this._element.classList;
          for (const e2 in tn)
            o2.remove(`mapboxgl-marker-anchor-${e2}`);
          o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
        }
        addTo(e2) {
          return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
        }
        remove() {
          const e2 = this._map;
          return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
            if (!("offset" in e2.options)) {
              const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
            }
            this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e2) {
          const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
          t2 !== "Space" && t2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
        }
        _onMapClick(e2) {
          const t2 = e2.originalEvent.target, i2 = this._element;
          this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e2 = this._popup;
          return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e2 = this._map, t2 = this._pos;
          if (!e2 || !t2)
            return false;
          const i2 = e2.unproject(t2), o2 = e2.getFreeCameraOptions();
          if (!o2.position)
            return false;
          const r = o2.position.toLngLat();
          return r.distanceTo(i2) < 0.9 * r.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t2 = this._map;
          if (!t2)
            return;
          const i2 = this._pos;
          if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height)
            return void this._clearFadeTimer();
          const o2 = t2.unproject(i2);
          let r;
          t2._showingGlobe() && e.isLngLatBehindGlobe(t2.transform, this._lngLat) ? r = 0 : (r = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e2 = this._pos;
          if (!e2 || !this._map)
            return;
          const t2 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${tn[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
        }
        _calculateXYTransform() {
          const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
          if (!i2 || !t2 || o2 !== "map")
            return "";
          if (!i2._showingGlobe()) {
            const e2 = i2.getPitch();
            return e2 ? `rotateX(${e2}deg)` : "";
          }
          const r = e.radToDeg(e.globeTiltAtLngLat(i2.transform, this._lngLat)), n2 = t2.sub(e.globeCenterToScreenPoint(i2.transform)), s2 = Math.abs(n2.x) + Math.abs(n2.y);
          if (s2 === 0)
            return "";
          const a2 = r / s2;
          return `rotateX(${-n2.y * a2}deg) rotateY(${n2.x * a2}deg)`;
        }
        _calculateZTransform() {
          const t2 = this._pos, i2 = this._map;
          if (!i2 || !t2)
            return "";
          let o2 = 0;
          const r = this.getRotationAlignment();
          if (r === "map")
            if (i2._showingGlobe()) {
              const t3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r2 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
              o2 = e.radToDeg(Math.atan2(r2.y, r2.x)) - 90;
            } else
              o2 = -i2.getBearing();
          else if (r === "horizon") {
            const r2 = e.smoothstep(4, 6, i2.getZoom()), n2 = e.globeCenterToScreenPoint(i2.transform);
            n2.y += r2 * i2.transform.height;
            const s2 = t2.sub(n2), a2 = e.radToDeg(Math.atan2(s2.y, s2.x));
            o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - r2);
          }
          return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
        }
        _update(t2) {
          e.window.cancelAnimationFrame(this._updateFrameId);
          const i2 = this._map;
          i2 && (i2.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), t2 === true ? this._updateFrameId = e.window.requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t2) {
          return this._offset = e.pointGeometry.convert(t2), this._update(), this;
        }
        _onMove(t2) {
          const i2 = this._map;
          if (!i2)
            return;
          const o2 = this._pointerdownPos, r = this._positionDelta;
          if (o2 && r) {
            if (!this._isDragging) {
              const e2 = this._clickTolerance || i2._clickTolerance;
              if (t2.point.dist(o2) < e2)
                return;
              this._isDragging = true;
            }
            this._pos = t2.point.sub(r), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const t2 = this._map;
          t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), this._state === "active" && this.fire(new e.Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(e2) {
          const t2 = this._map, i2 = this._pos;
          t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
        }
        setDraggable(e2) {
          this._draggable = !!e2;
          const t2 = this._map;
          return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e2) {
          return this._rotation = e2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e2) {
          return this._rotationAlignment = e2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e2) {
          return this._pitchAlignment = e2 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e2) {
          return this._occludedOpacity = e2 || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const rn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, nn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function sn(t2 = new e.pointGeometry(0, 0), i2 = "bottom") {
        if (typeof t2 == "number") {
          const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
          switch (i2) {
            case "top":
              return new e.pointGeometry(0, t2);
            case "top-left":
              return new e.pointGeometry(o2, o2);
            case "top-right":
              return new e.pointGeometry(-o2, o2);
            case "bottom":
              return new e.pointGeometry(0, -t2);
            case "bottom-left":
              return new e.pointGeometry(o2, -o2);
            case "bottom-right":
              return new e.pointGeometry(-o2, -o2);
            case "left":
              return new e.pointGeometry(t2, 0);
            case "right":
              return new e.pointGeometry(-t2, 0);
          }
          return new e.pointGeometry(0, 0);
        }
        return t2 instanceof e.pointGeometry || Array.isArray(t2) ? e.pointGeometry.convert(t2) : e.pointGeometry.convert(t2[i2] || [0, 0]);
      }
      class an {
        constructor(e2) {
          this.jumpTo(e2);
        }
        getValue(t2) {
          if (t2 <= this._startTime)
            return this._start;
          if (t2 >= this._endTime)
            return this._end;
          const i2 = e.easeCubicInOut((t2 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i2) + this._end * i2;
        }
        isEasing(e2) {
          return e2 >= this._startTime && e2 <= this._endTime;
        }
        jumpTo(e2) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
        }
        easeTo(e2, t2, i2) {
          this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
        }
      }
      const ln = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, cn = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, hn = { showCompass: true, showZoom: true, visualizePitch: false };
      class un {
        constructor(t2, i2, o2 = false) {
          this._clickTolerance = 10, this.element = i2, this.mouseRotate = new wr({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new Tr({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
        }
        down(e2, t2) {
          this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), h3();
        }
        move(e2, t2) {
          const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), r = o2 && o2.bearingDelta;
          if (r && i2.setBearing(i2.getBearing() + r), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e2, t2), r2 = o3 && o3.pitchDelta;
            r2 && i2.setPitch(i2.getPitch() + r2);
          }
        }
        off() {
          const e2 = this.element;
          e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          u(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t2) {
          this.down(e.extend({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), p(this.element, t2)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e2) {
          this.move(e2, p(this.element, e2));
        }
        mouseup(e2) {
          this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
        }
        touchstart(e2) {
          e2.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = m(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
        }
        touchmove(e2) {
          e2.targetTouches.length !== 1 ? this.reset() : (this._lastPos = m(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
        }
        touchend(e2) {
          e2.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const _n = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, dn = { maxWidth: 100, unit: "metric" };
      function pn(e2, t2, i2) {
        const o2 = mn(t2), r = o2 / t2, n2 = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[i2];
        this._map._requestDomTask(() => {
          this._container.style.width = e2 * r + "px", this._container.innerHTML = `${o2}&nbsp;${n2}`;
        });
      }
      function mn(e2) {
        const t2 = Math.pow(10, `${Math.floor(e2)}`.length - 1);
        let i2 = e2 / t2;
        return i2 = i2 >= 10 ? 10 : i2 >= 5 ? 5 : i2 >= 3 ? 3 : i2 >= 2 ? 2 : i2 >= 1 ? 1 : function(e3) {
          const t3 = Math.pow(10, Math.ceil(-Math.log(e3) / Math.LN10));
          return Math.round(e3 * t3) / t3;
        }(i2), t2 * i2;
      }
      const fn = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends Yr {
        constructor(t2) {
          if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), (t2 = e.extend({}, cn, t2)).minZoom != null && t2.maxZoom != null && t2.minZoom > t2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (t2.minPitch != null && t2.maxPitch != null && t2.minPitch > t2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (t2.minPitch != null && t2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2.maxPitch != null && t2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2.antialias && e.isSafariWithAntialiasingBug(e.window) && (t2.antialias = false, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._useWebGL2 = t2.useWebGL2, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, ln, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e.RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, typeof t2.container == "string") {
            if (this._container = e.window.document.getElementById(t2.container), !this._container)
              throw new Error(`Container '${t2.container}' not found.`);
          } else {
            if (!(t2.container instanceof e.window.HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t2.container;
          }
          if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), e.window !== void 0 && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new $r(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this._hash = t2.hash && new Qo(typeof t2.hash == "string" && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.extend({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), t2.attributionControl && this.addControl(new Kr({ customAttribution: t2.customAttribution })), this._logoControl = new Jr(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t3) => {
            this._update(t3.dataType === "style"), this.fire(new e.Event(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e.Event(`${t3.dataType}dataloading`, t3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t2, i2) {
          if (i2 === void 0 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t2.onAdd(this);
          this._controls.push(t2);
          const r = this._controlPositions[i2];
          return i2.indexOf("bottom") !== -1 ? r.insertBefore(o2, r.firstChild) : r.appendChild(o2), this;
        }
        removeControl(t2) {
          if (!t2 || !t2.onRemove)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t2);
          return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
        }
        hasControl(e2) {
          return this._controls.indexOf(e2) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t2) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i2 = !this._moving;
          return i2 && this.fire(new e.Event("movestart", t2)).fire(new e.Event("move", t2)), this.fire(new e.Event("resize", t2)), i2 && this.fire(new e.Event("moveend", t2)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t2) {
          return this.transform.setMaxBounds(e.LngLatBounds.convert(t2)), this._update();
        }
        setMinZoom(t2) {
          if ((t2 = t2 == null ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
            return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t2) {
          if ((t2 = t2 == null ? 22 : t2) >= this.transform.minZoom)
            return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t2) {
          if ((t2 = t2 == null ? 0 : t2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2 >= 0 && t2 <= this.transform.maxPitch)
            return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t2) {
          if ((t2 = t2 == null ? 85 : t2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2 >= this.transform.minPitch)
            return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(t2) {
          return t2 === "auto" ? e.window.navigator.language : Array.isArray(t2) ? t2.length === 0 ? void 0 : t2.map((t3) => t3 === "auto" ? e.window.navigator.language : t3) : t2;
        }
        setLanguage(e2) {
          const t2 = this._parseLanguage(e2);
          if (!this.style || t2 === this._language)
            return this;
          this._language = t2, this.style._reloadSources();
          for (const e3 of this._controls)
            e3._setLanguage && e3._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e2) {
          return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style._reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return this.transform.projection.name === "globe";
        }
        setProjection(e2) {
          return this._lazyInitEmptyStyle(), e2 ? typeof e2 == "string" && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
        }
        _updateProjectionTransition() {
          if (this.getProjection().name !== "globe")
            return;
          const t2 = this.transform, i2 = t2.projection.name;
          let o2;
          i2 === "globe" && t2.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t2.setMercatorFromTransition(), o2 = true) : i2 === "mercator" && t2.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e2, t2) {
          return this._updateProjection(e2 || t2 || { name: "mercator" });
        }
        _updateProjection(t2) {
          let i2;
          if (i2 = t2.name === "globe" && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2) {
            this.painter.clearBackgroundTiles();
            for (const e2 in this.style._sourceCaches)
              this.style._sourceCaches[e2].clearTiles();
            this._update(true), this._forceMarkerAndPopupUpdate(true);
          }
          return this;
        }
        project(t2) {
          return this.transform.locationPoint3D(e.LngLat.convert(t2));
        }
        unproject(t2) {
          return this.transform.pointLocation3D(e.pointGeometry.convert(t2));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e2, t2, i2) {
          if (e2 === "mouseenter" || e2 === "mouseover") {
            let o2 = false;
            const r = (r2) => {
              const n3 = t2.filter((e3) => this.getLayer(e3)), s2 = n3.length ? this.queryRenderedFeatures(r2.point, { layers: n3 }) : [];
              s2.length ? o2 || (o2 = true, i2.call(this, new cr(e2, this, r2.originalEvent, { features: s2 }))) : o2 = false;
            }, n2 = () => {
              o2 = false;
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: r, mouseout: n2 } };
          }
          if (e2 === "mouseleave" || e2 === "mouseout") {
            let o2 = false;
            const r = (r2) => {
              const n3 = t2.filter((e3) => this.getLayer(e3));
              (n3.length ? this.queryRenderedFeatures(r2.point, { layers: n3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new cr(e2, this, r2.originalEvent)));
            }, n2 = (t3) => {
              o2 && (o2 = false, i2.call(this, new cr(e2, this, t3.originalEvent)));
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: r, mouseout: n2 } };
          }
          {
            const o2 = (e3) => {
              const o3 = t2.filter((e4) => this.getLayer(e4)), r = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
              r.length && (e3.features = r, i2.call(this, e3), delete e3.features);
            };
            return { layers: new Set(t2), listener: i2, delegates: { [e2]: o2 } };
          }
        }
        on(e2, t2, i2) {
          if (i2 === void 0)
            return super.on(e2, t2);
          Array.isArray(t2) || (t2 = [t2]);
          const o2 = this._createDelegatedListener(e2, t2, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e2, t2, i2) {
          if (i2 === void 0)
            return super.once(e2, t2);
          Array.isArray(t2) || (t2 = [t2]);
          const o2 = this._createDelegatedListener(e2, t2, i2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e2, t2, i2) {
          if (i2 === void 0)
            return super.off(e2, t2);
          t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
          const o2 = (e3, t3) => {
            if (e3.size !== t3.size)
              return false;
            for (const i3 of e3)
              if (!t3.has(i3))
                return false;
            return true;
          }, r = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
          return r && ((e3) => {
            for (let r2 = 0; r2 < e3.length; r2++) {
              const n2 = e3[r2];
              if (n2.listener === i2 && o2(n2.layers, t2)) {
                for (const e4 in n2.delegates)
                  this.off(e4, n2.delegates[e4]);
                return e3.splice(r2, 1), this;
              }
            }
          })(r), this;
        }
        queryRenderedFeatures(t2, i2) {
          return this.style ? (i2 !== void 0 || t2 === void 0 || t2 instanceof e.pointGeometry || Array.isArray(t2) || (i2 = t2, t2 = void 0), this.style.queryRenderedFeatures(t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
        }
        querySourceFeatures(e2, t2) {
          return this.style.querySourceFeatures(e2, t2);
        }
        setStyle(t2, i2) {
          return (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
        }
        _getUIString(e2) {
          const t2 = this._locale[e2];
          if (t2 == null)
            throw new Error(`Missing UI string '${e2}'`);
          return t2;
        }
        _updateStyle(e2, t2) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new Qt(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof e2 == "string" ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t2, i2) {
          if (typeof t2 == "string") {
            const o2 = this._requestManager.normalizeStyleURL(t2), r = this._requestManager.transformRequest(o2, e.ResourceType.Style);
            e.getJSON(r, (t3, o3) => {
              t3 ? this.fire(new e.ErrorEvent(t3)) : o3 && this._updateDiff(o3, i2);
            });
          } else
            typeof t2 == "object" && this._updateDiff(t2, i2);
        }
        _updateDiff(t2, i2) {
          try {
            this.style.setState(t2) && this._update(true);
          } catch (o2) {
            e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), false);
        }
        addSource(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
        }
        isSourceLoaded(e2) {
          return !!this.style && this.style._isSourceCacheLoaded(e2);
        }
        areTilesLoaded() {
          const e2 = this.style && this.style._sourceCaches;
          for (const t2 in e2) {
            const i2 = e2[t2]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if (t3.state !== "loaded" && t3.state !== "errored")
                return false;
            }
          }
          return true;
        }
        addSourceType(e2, t2, i2) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
        }
        removeSource(e2) {
          return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
        }
        getSource(e2) {
          return this.style.getSource(e2);
        }
        addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r = false, stretchX: n2, stretchY: s2, content: a2 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap) {
            const { width: l2, height: c2, data: h4 } = e.exported.getImageData(i2);
            this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, h4), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r, version: 0 });
          } else if (i2.width === void 0 || i2.height === void 0)
            this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: l2, height: c2 } = i2, h4 = i2;
            this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h4.data)), pixelRatio: o2, stretchX: n2, stretchY: s2, content: a2, sdf: r, version: 0, userImage: h4 }), h4.onAdd && h4.onAdd(this, t2);
          }
        }
        updateImage(t2, i2) {
          const o2 = this.style.getImage(t2);
          if (!o2)
            return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r = i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? e.exported.getImageData(i2) : i2, { width: n2, height: s2 } = r;
          n2 !== void 0 && s2 !== void 0 ? n2 === o2.data.width && s2 === o2.data.height ? (o2.data.replace(r.data, !(i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap)), this.style.updateImage(t2, o2)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n2}, ${s2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(t2) {
          return t2 ? !!this.style.getImage(t2) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
        }
        removeImage(e2) {
          this.style.removeImage(e2);
        }
        loadImage(t2, i2) {
          e.getImage(this._requestManager.transformRequest(t2, e.ResourceType.Image), (t3, o2) => {
            i2(t3, o2 instanceof e.window.HTMLImageElement ? e.exported.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
        }
        moveLayer(e2, t2) {
          return this.style.moveLayer(e2, t2), this._update(true);
        }
        removeLayer(e2) {
          return this.style.removeLayer(e2), this._update(true);
        }
        getLayer(e2) {
          return this.style.getLayer(e2);
        }
        setLayerZoomRange(e2, t2, i2) {
          return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
        }
        setFilter(e2, t2, i2 = {}) {
          return this.style.setFilter(e2, t2, i2), this._update(true);
        }
        getFilter(e2) {
          return this.style.getFilter(e2);
        }
        setPaintProperty(e2, t2, i2, o2 = {}) {
          return this.style.setPaintProperty(e2, t2, i2, o2), this._update(true);
        }
        getPaintProperty(e2, t2) {
          return this.style.getPaintProperty(e2, t2);
        }
        setLayoutProperty(e2, t2, i2, o2 = {}) {
          return this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true);
        }
        getLayoutProperty(e2, t2) {
          return this.style.getLayoutProperty(e2, t2);
        }
        setLight(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(e2) {
          return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e2) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(t2) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t2), this.transform) : 0;
        }
        setFeatureState(e2, t2) {
          return this.style.setFeatureState(e2, t2), this._update();
        }
        removeFeatureState(e2, t2) {
          return this.style.removeFeatureState(e2, t2), this._update();
        }
        getFeatureState(e2) {
          return this.style.getFeatureState(e2);
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const t2 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
          let o2, r, n2, s2 = this._container;
          for (; s2 && (!r || !n2); ) {
            const t3 = e.window.getComputedStyle(s2).transform;
            t3 && t3 !== "none" && (o2 = t3.match(/matrix.*\((.+)\)/)[1].split(", "), o2[0] && o2[0] !== "0" && o2[0] !== "1" && (r = o2[0]), o2[3] && o2[3] !== "0" && o2[3] !== "1" && (n2 = o2[3])), s2 = s2.parentElement;
          }
          this._containerWidth = r ? Math.abs(t2 / r) : t2, this._containerHeight = n2 ? Math.abs(i2 / n2) : i2;
        }
        _detectMissingCSS() {
          e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e2 = this._container;
          e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
          const t2 = this._canvasContainer = n("div", "mapboxgl-canvas-container", e2);
          this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i2 = this._controlContainer = n("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            o2[e3] = n("div", `mapboxgl-ctrl-${e3}`, i2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t2, i2) {
          const o2 = e.exported.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
        }
        _addMarker(e2) {
          this._markers.push(e2);
        }
        _removeMarker(e2) {
          const t2 = this._markers.indexOf(e2);
          t2 !== -1 && this._markers.splice(t2, 1);
        }
        _addPopup(e2) {
          this._popups.push(e2);
        }
        _removePopup(e2) {
          const t2 = this._popups.indexOf(e2);
          t2 !== -1 && this._popups.splice(t2, 1);
        }
        _setupPainter() {
          const t2 = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._useWebGL2 && this._canvas.getContext("webgl2", t2), r = o2 || this._canvas.getContext("webgl", t2) || this._canvas.getContext("experimental-webgl", t2);
          r ? (this._useWebGL2 && !o2 && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r, true), this.painter = new Fo(r, this.transform, !!o2), this.on("data", (e2) => {
            e2.dataType === "source" && this.painter.setTileLoadedFlag(true);
          }), e.exported$1.testSupport(r)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t2) {
          t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t2 }));
        }
        _contextRestored(t2) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t2 }));
        }
        _onMapScroll(e2) {
          if (e2.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e2) {
          return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e2) {
          return this._update(), this._renderTaskQueue.add(e2);
        }
        _cancelRenderFrame(e2) {
          this._renderTaskQueue.remove(e2);
        }
        _requestDomTask(e2) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
        }
        _render(t2) {
          let i2;
          const o2 = this.painter.context.extTimerQuery, r = e.exported.now();
          if (this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
            return;
          this._updateProjectionTransition();
          const n2 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.exported.now(), r2 = new e.EvaluationParameters(t3, { now: o3, fadeDuration: n2, pitch: i3, transition: this.style.getTransition() });
            this.style.update(r2);
          }
          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let s2 = false;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s2 = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s2 = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
            const t3 = e.exported.now() - r;
            o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
              const n3 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
              o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t3, gpuTime: n3 })), e.window.performance.mark("frame-gpu", { startTime: r, detail: { gpuTime: n3 } });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t3 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimers(t3);
              this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t3 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimeDeferredRender(t3);
              this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i3 }));
            }, 50);
          }
          const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty || s2;
          if (a2 || this._repaint)
            this.triggerRepaint();
          else {
            const t3 = !this.isMoving() && this.loaded();
            if (t3 && (s2 = this._updateAverageElevation(r, true)), s2)
              this.triggerRepaint();
            else if (this._triggerFrame(false), t3 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t4 = this._calculateSpeedIndex();
              this.fire(new e.Event("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e2) {
          for (const t2 of this._markers)
            e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
          for (const t2 of this._popups)
            !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
        }
        _updateAverageElevation(e2, t2 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return this.transform.averageElevation !== 0 && i2(0);
          if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
            const t3 = this.transform.averageElevation;
            let o2 = this.transform.sampleAverageElevation(), r = false;
            this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
            const n2 = Math.abs(t3 - o2);
            if (n2 > 1) {
              if (this._isInitialLoad || r)
                return this._averageElevation.jumpTo(o2), i2(o2);
              this._averageElevation.easeTo(o2, e2, 300);
            } else if (n2 > 1e-4)
              return this._averageElevation.jumpTo(o2), i2(o2);
          }
          return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
        }
        _authenticate() {
          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
            if (t2 && (t2.message === e.AUTH_ERR_MSG || t2.status === 401)) {
              const t3 = this.painter.context.gl;
              e.storeAuthState(t3, false), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          const e2 = this._isDragging();
          this.painter.updateTerrain(this.style, e2);
        }
        _calculateSpeedIndex() {
          const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
          t2.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
          function r(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r(e2), t2.canvasCopies.map(r), t2.timeStamps);
        }
        _canvasPixelComparison(e2, t2, i2) {
          let o2 = i2[1] - i2[0];
          const r = e2.length / 4;
          for (let n2 = 0; n2 < t2.length; n2++) {
            const s2 = t2[n2];
            let a2 = 0;
            for (let t3 = 0; t3 < s2.length; t3 += 4)
              s2[t3] === e2[t3] && s2[t3 + 1] === e2[t3 + 1] && s2[t3 + 2] === e2[t3 + 2] && s2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
            o2 += (i2[n2 + 2] - i2[n2 + 1]) * (1 - a2 / r);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e2 of this._controls)
            e2.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), e.window !== void 0 && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, false));
          const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t2) {
          this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
          }));
        }
        _preloadTiles(t2) {
          const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
          return e.asyncAll(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e2) {
          this._trackResize && this.resize({ originalEvent: e2 })._update();
        }
        _onVisibilityChange() {
          e.window.document.visibilityState === "hidden" && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e2) {
          this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e2) {
          this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e2) {
          this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e2) {
          this._showPadding !== e2 && (this._showPadding = e2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e2) {
          this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e2) {
          this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e2) {
          this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e2) {
          this._vertices = e2, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e2) {
          this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
        }
        _setCacheLimits(t2, i2) {
          e.setCacheLimits(t2, i2);
        }
        get version() {
          return e.version;
        }
      }, NavigationControl: class {
        constructor(t2) {
          this.options = e.extend({}, hn, t2), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
            this._map && this._map.zoomIn({}, { originalEvent: e2 });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
            this._map && this._map.zoomOut({}, { originalEvent: e2 });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
            const t3 = this._map;
            t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
          }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e2 = this._map;
          if (!e2)
            return;
          const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
          this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
        }
        _rotateCompassArrow() {
          const e2 = this._map;
          if (!e2)
            return;
          const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
          e2._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t2);
          });
        }
        onAdd(e2) {
          return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e2, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e2 = this._map;
          e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e2, t2) {
          const i2 = n("button", e2, this._container);
          return i2.type = "button", i2.addEventListener("click", t2), i2;
        }
        _setButtonTitle(e2, t2) {
          if (!this._map)
            return;
          const i2 = this._map._getUIString(`NavigationControl.${t2}`);
          e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
        }
      }, GeolocateControl: class extends e.Evented {
        constructor(t2) {
          super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, _n, t2), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e2) {
          return this._map = e2, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(t2) {
          const i2 = (e2 = !!this.options.geolocation) => {
            this._supportsGeolocation = e2, t2(e2);
          };
          this._supportsGeolocation !== void 0 ? t2(this._supportsGeolocation) : e.window.navigator.permissions !== void 0 ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => i2(e2.state !== "denied")).catch(() => i2()) : i2();
        }
        _isOutOfMapMaxBounds(e2) {
          const t2 = this._map.getMaxBounds(), i2 = e2.coords;
          return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t2) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t2))
              return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = t2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t2), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t2)), this._finish();
          }
        }
        _updateCamera(t2) {
          const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r = this._map.getBearing(), n2 = e.extend({ bearing: r }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o2), n2, { geolocateSource: true });
        }
        _updateMarker(t2) {
          if (t2) {
            const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t2 = this._map.transform, i2 = e.mercatorZfromAltitude(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
          this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t2) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (t2.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (t2.code === 3 && this._noTimeout)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t2)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t2) {
          if (this._map !== void 0) {
            if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t2 === false) {
              e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
            } else {
              const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
              t3.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t3.originalEvent && t3.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e2) {
          this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : e2.absolute === true && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return e.warnOnce("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let e2;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const t2 = () => {
            e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          e.window.DeviceMotionEvent !== void 0 && typeof e.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((e2) => {
            e2 === "granted" && t2();
          }).catch(console.error) : t2();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: Kr, ScaleControl: class {
        constructor(t2) {
          this.options = e.extend({}, dn, t2), function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), true;
            } catch (e2) {
              return false;
            }
          }() || (this._setScale = pn.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, r = t2.unproject([o2, i2]), n2 = t2.unproject([o2 + e2, i2]), s2 = r.distanceTo(n2);
          if (this.options.unit === "imperial") {
            const t3 = 3.2808 * s2;
            t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
          } else
            this.options.unit === "nautical" ? this._setScale(e2, s2 / 1852, "nautical-mile") : s2 >= 1e3 ? this._setScale(e2, s2 / 1e3, "kilometer") : this._setScale(e2, s2, "meter");
        }
        _setScale(e2, t2, i2) {
          const o2 = mn(t2), r = o2 / t2;
          this._map._requestDomTask(() => {
            this._container.style.width = e2 * r + "px", this._container.innerHTML = i2 !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: i2 }).format(o2) : `${o2}&nbsp;nm`;
          });
        }
        onAdd(e2) {
          return this._map = e2, this._language = e2.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e2) {
          this._language = e2, this._update();
        }
        setUnit(e2) {
          this.options.unit = e2, this._update();
        }
      }, FullscreenControl: class {
        constructor(t2) {
          this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.window.HTMLElement ? this._container = t2.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t2) {
          return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const t2 = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          n("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e.Evented {
        constructor(t2) {
          super(), this.options = e.extend(Object.create(rn), t2), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
        }
        addTo(t2) {
          return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t2 = this._map;
          return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          this._lngLat = e.LngLat.convert(t2), this._pos = null, this._trackPointer = false, this._update();
          const i2 = this._map;
          return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e2 = this._map;
          return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t2) {
          return this.setDOMContent(e.window.document.createTextNode(t2));
        }
        setHTML(t2) {
          const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
          let r;
          for (o2.innerHTML = t2; r = o2.firstChild, r; )
            i2.appendChild(r);
          return this.setDOMContent(i2);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e2) {
          return this.options.maxWidth = e2, this._update(), this;
        }
        setDOMContent(e2) {
          let t2 = this._content;
          if (t2)
            for (; t2.hasChildNodes(); )
              t2.firstChild && t2.removeChild(t2.firstChild);
          else
            t2 = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
          if (t2.appendChild(e2), this.options.closeButton) {
            const e3 = this._closeButton = n("button", "mapboxgl-popup-close-button", t2);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e2) {
          return this._classList.add(e2), this._updateClassList(), this;
        }
        removeClassName(e2) {
          return this._classList.delete(e2), this._updateClassList(), this;
        }
        setOffset(e2) {
          return this.options.offset = e2, this._update(), this;
        }
        toggleClassName(e2) {
          let t2;
          return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
        }
        _onMouseEvent(e2) {
          this._update(e2.point);
        }
        _getAnchor(e2) {
          if (this.options.anchor)
            return this.options.anchor;
          const t2 = this._map, i2 = this._container, o2 = this._pos;
          if (!t2 || !i2 || !o2)
            return "bottom";
          const r = i2.offsetWidth, n2 = i2.offsetHeight, s2 = o2.x < r / 2, a2 = o2.x > t2.transform.width - r / 2;
          if (o2.y + e2 < n2)
            return s2 ? "top-left" : a2 ? "top-right" : "top";
          if (o2.y > t2.transform.height - n2) {
            if (s2)
              return "bottom-left";
            if (a2)
              return "bottom-right";
          }
          return s2 ? "left" : a2 ? "right" : "bottom";
        }
        _updateClassList() {
          const e2 = this._container;
          if (!e2)
            return;
          const t2 = [...this._classList];
          t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
        }
        _update(t2) {
          const i2 = this._map, o2 = this._content;
          if (!i2 || !this._lngLat && !this._trackPointer || !o2)
            return;
          let r = this._container;
          if (r || (r = this._container = n("div", "mapboxgl-popup", i2.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r), r.appendChild(o2)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
            const e2 = this._pos = this._trackPointer && t2 ? t2 : i2.project(this._lngLat), o3 = sn(this.options.offset), r2 = this._anchor = this._getAnchor(o3.y), n2 = sn(this.options.offset, r2), s2 = e2.add(n2).round();
            i2._requestDomTask(() => {
              this._container && r2 && (this._container.style.transform = `${tn[r2]} translate(${s2.x}px,${s2.y}px)`);
            });
          }
          if (!this._marker && i2._showingGlobe()) {
            const t3 = e.isLngLatBehindGlobe(i2.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t3);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e2 = this._container.querySelector(nn);
          e2 && e2.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e2) {
          this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
        }
      }, Marker: on, Style: Qt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: Zo, Evented: e.Evented, config: e.config, prewarm: function() {
        je().acquire(Ue);
      }, clearPrewarmedResources: function() {
        const e2 = Ge;
        e2 && (e2.isPreloaded() && e2.numActive() === 1 ? (e2.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return e.config.ACCESS_TOKEN;
      }, set accessToken(t2) {
        e.config.ACCESS_TOKEN = t2;
      }, get baseApiUrl() {
        return e.config.API_URL;
      }, set baseApiUrl(t2) {
        e.config.API_URL = t2;
      }, get workerCount() {
        return Ne.workerCount;
      }, set workerCount(e2) {
        Ne.workerCount = e2;
      }, get maxParallelImageRequests() {
        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t2) {
        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t2;
      }, clearStorage(t2) {
        e.clearTileCache(t2);
      }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
      return fn;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl$1);
const mapboxgl = mapboxGl$1.exports;
var immutable = extend$2;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend$2() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source2 = arguments[i];
    for (var key in source2) {
      if (hasOwnProperty.call(source2, key)) {
        target[key] = source2[key];
      }
    }
  }
  return target;
}
var fuzzy$1 = { exports: {} };
(function(module, exports) {
  (function() {
    var fuzzy2 = {};
    {
      module.exports = fuzzy2;
    }
    fuzzy2.simpleFilter = function(pattern, array) {
      return array.filter(function(str) {
        return fuzzy2.test(pattern, str);
      });
    };
    fuzzy2.test = function(pattern, str) {
      return fuzzy2.match(pattern, str) !== null;
    };
    fuzzy2.match = function(pattern, str, opts) {
      opts = opts || {};
      var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch;
      pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
      for (var idx = 0; idx < len; idx++) {
        ch = str[idx];
        if (compareString[idx] === pattern[patternIdx]) {
          ch = pre + ch + post;
          patternIdx += 1;
          currScore += 1 + currScore;
        } else {
          currScore = 0;
        }
        totalScore += currScore;
        result[result.length] = ch;
      }
      if (patternIdx === pattern.length) {
        totalScore = compareString === pattern ? Infinity : totalScore;
        return { rendered: result.join(""), score: totalScore };
      }
      return null;
    };
    fuzzy2.filter = function(pattern, arr, opts) {
      if (!arr || arr.length === 0) {
        return [];
      }
      if (typeof pattern !== "string") {
        return arr;
      }
      opts = opts || {};
      return arr.reduce(function(prev, element, idx, arr2) {
        var str = element;
        if (opts.extract) {
          str = opts.extract(element);
        }
        var rendered = fuzzy2.match(pattern, str, opts);
        if (rendered != null) {
          prev[prev.length] = {
            string: rendered.rendered,
            score: rendered.score,
            index: idx,
            original: element
          };
        }
        return prev;
      }, []).sort(function(a, b) {
        var compare = b.score - a.score;
        if (compare)
          return compare;
        return a.index - b.index;
      });
    };
  })();
})(fuzzy$1);
var List$1 = function(component) {
  this.component = component;
  this.items = [];
  this.active = 0;
  this.wrapper = document.createElement("div");
  this.wrapper.className = "suggestions-wrapper";
  this.element = document.createElement("ul");
  this.element.className = "suggestions";
  this.wrapper.appendChild(this.element);
  this.selectingListItem = false;
  component.el.parentNode.insertBefore(this.wrapper, component.el.nextSibling);
  return this;
};
List$1.prototype.show = function() {
  this.element.style.display = "block";
};
List$1.prototype.hide = function() {
  this.element.style.display = "none";
};
List$1.prototype.add = function(item) {
  this.items.push(item);
};
List$1.prototype.clear = function() {
  this.items = [];
  this.active = 0;
};
List$1.prototype.isEmpty = function() {
  return !this.items.length;
};
List$1.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
List$1.prototype.draw = function() {
  this.element.innerHTML = "";
  if (this.items.length === 0) {
    this.hide();
    return;
  }
  for (var i = 0; i < this.items.length; i++) {
    this.drawItem(this.items[i], this.active === i);
  }
  this.show();
};
List$1.prototype.drawItem = function(item, active) {
  var li = document.createElement("li"), a = document.createElement("a");
  if (active)
    li.className += " active";
  a.innerHTML = item.string;
  li.appendChild(a);
  this.element.appendChild(li);
  li.addEventListener("mousedown", function() {
    this.selectingListItem = true;
  }.bind(this));
  li.addEventListener("mouseup", function() {
    this.handleMouseUp.call(this, item);
  }.bind(this));
};
List$1.prototype.handleMouseUp = function(item) {
  this.selectingListItem = false;
  this.component.value(item.original);
  this.clear();
  this.draw();
};
List$1.prototype.move = function(index2) {
  this.active = index2;
  this.draw();
};
List$1.prototype.previous = function() {
  this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
};
List$1.prototype.next = function() {
  this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
};
List$1.prototype.drawError = function(msg) {
  var li = document.createElement("li");
  li.innerHTML = msg;
  this.element.appendChild(li);
  this.show();
};
var list = List$1;
var extend$1 = immutable;
var fuzzy = fuzzy$1.exports;
var List = list;
var Suggestions$1 = function(el, data, options) {
  options = options || {};
  this.options = extend$1({
    minLength: 2,
    limit: 5,
    filter: true,
    hideOnBlur: true
  }, options);
  this.el = el;
  this.data = data || [];
  this.list = new List(this);
  this.query = "";
  this.selected = null;
  this.list.draw();
  this.el.addEventListener("keyup", function(e) {
    this.handleKeyUp(e.keyCode);
  }.bind(this), false);
  this.el.addEventListener("keydown", function(e) {
    this.handleKeyDown(e);
  }.bind(this));
  this.el.addEventListener("focus", function() {
    this.handleFocus();
  }.bind(this));
  this.el.addEventListener("blur", function() {
    this.handleBlur();
  }.bind(this));
  this.el.addEventListener("paste", function(e) {
    this.handlePaste(e);
  }.bind(this));
  this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this);
  this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this);
  return this;
};
Suggestions$1.prototype.handleKeyUp = function(keyCode) {
  if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 13 || keyCode === 9)
    return;
  this.handleInputChange(this.el.value);
};
Suggestions$1.prototype.handleKeyDown = function(e) {
  switch (e.keyCode) {
    case 13:
    case 9:
      if (!this.list.isEmpty()) {
        if (this.list.isVisible()) {
          e.preventDefault();
        }
        this.value(this.list.items[this.list.active].original);
        this.list.hide();
      }
      break;
    case 27:
      if (!this.list.isEmpty())
        this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
Suggestions$1.prototype.handleBlur = function() {
  if (!this.list.selectingListItem && this.options.hideOnBlur) {
    this.list.hide();
  }
};
Suggestions$1.prototype.handlePaste = function(e) {
  if (e.clipboardData) {
    this.handleInputChange(e.clipboardData.getData("Text"));
  } else {
    var self2 = this;
    setTimeout(function() {
      self2.handleInputChange(e.target.value);
    }, 100);
  }
};
Suggestions$1.prototype.handleInputChange = function(query) {
  this.query = this.normalize(query);
  this.list.clear();
  if (this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates(function(data) {
    for (var i = 0; i < data.length; i++) {
      this.list.add(data[i]);
      if (i === this.options.limit - 1)
        break;
    }
    this.list.draw();
  }.bind(this));
};
Suggestions$1.prototype.handleFocus = function() {
  if (!this.list.isEmpty())
    this.list.show();
  this.list.selectingListItem = false;
};
Suggestions$1.prototype.update = function(revisedData) {
  this.data = revisedData;
  this.handleKeyUp();
};
Suggestions$1.prototype.clear = function() {
  this.data = [];
  this.list.clear();
};
Suggestions$1.prototype.normalize = function(value) {
  value = value.toLowerCase();
  return value;
};
Suggestions$1.prototype.match = function(candidate, query) {
  return candidate.indexOf(query) > -1;
};
Suggestions$1.prototype.value = function(value) {
  this.selected = value;
  this.el.value = this.getItemValue(value);
  if (document.createEvent) {
    var e = document.createEvent("HTMLEvents");
    e.initEvent("change", true, false);
    this.el.dispatchEvent(e);
  } else {
    this.el.fireEvent("onchange");
  }
};
Suggestions$1.prototype.getCandidates = function(callback2) {
  var options = {
    pre: "<strong>",
    post: "</strong>",
    extract: function(d) {
      return this.getItemValue(d);
    }.bind(this)
  };
  var results;
  if (this.options.filter) {
    results = fuzzy.filter(this.query, this.data, options);
    results = results.map(function(item) {
      return {
        original: item.original,
        string: this.render(item.original, item.string)
      };
    }.bind(this));
  } else {
    results = this.data.map(function(d) {
      var renderedString = this.render(d);
      return {
        original: d,
        string: renderedString
      };
    }.bind(this));
  }
  callback2(results);
};
Suggestions$1.prototype.getItemValue = function(item) {
  return item;
};
Suggestions$1.prototype.render = function(item, sourceFormatting) {
  if (sourceFormatting) {
    return sourceFormatting;
  }
  var boldString = item.original ? this.getItemValue(item.original) : this.getItemValue(item);
  var indexString = this.normalize(boldString);
  var indexOfQuery = indexString.lastIndexOf(this.query);
  while (indexOfQuery > -1) {
    var endIndexOfQuery = indexOfQuery + this.query.length;
    boldString = boldString.slice(0, indexOfQuery) + "<strong>" + boldString.slice(indexOfQuery, endIndexOfQuery) + "</strong>" + boldString.slice(endIndexOfQuery);
    indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
  }
  return boldString;
};
Suggestions$1.prototype.renderError = function(msg) {
  this.list.drawError(msg);
};
var suggestions$1 = Suggestions$1;
var Suggestions = suggestions$1;
var suggestions = Suggestions;
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now = function() {
  return root.Date.now();
};
function debounce$1(func2, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func2.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_debounce = debounce$1;
var events$1 = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$5() {
  EventEmitter$5.init.call(this);
}
events$1.exports = EventEmitter$5;
events$1.exports.once = once$4;
EventEmitter$5.EventEmitter = EventEmitter$5;
EventEmitter$5.prototype._events = void 0;
EventEmitter$5.prototype._eventsCount = 0;
EventEmitter$5.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$5, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$5.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$5.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$5.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$5.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$5.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter$5.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$5.prototype.on = EventEmitter$5.prototype.addListener;
EventEmitter$5.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$5.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$5.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$5.prototype.removeListener = function removeListener(type, listener) {
  var list2, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list2 = events2[type];
  if (list2 === void 0)
    return this;
  if (list2 === listener || list2.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list2.listener || listener);
    }
  } else if (typeof list2 !== "function") {
    position = -1;
    for (i = list2.length - 1; i >= 0; i--) {
      if (list2[i] === listener || list2[i].listener === listener) {
        originalListener = list2[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list2.shift();
    else {
      spliceOne(list2, position);
    }
    if (list2.length === 1)
      events2[type] = list2[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$5.prototype.off = EventEmitter$5.prototype.removeListener;
EventEmitter$5.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i = 0; i < keys2.length; ++i) {
      key = keys2[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$5.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$5.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$5.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$5.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$5.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list2, index2) {
  for (; index2 + 1 < list2.length; index2++)
    list2[index2] = list2[index2 + 1];
  list2.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once$4(emitter, name) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var exceptions$1 = {
  "fr": {
    "name": "France",
    "bbox": [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  "us": {
    "name": "United States",
    "bbox": [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  "ru": {
    "name": "Russia",
    "bbox": [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  "ca": {
    "name": "Canada",
    "bbox": [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
};
var source$4 = { exports: {} };
var create = {};
var dist$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const typedArrayTypeNames = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
  }
  const objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    ...typedArrayTypeNames
  ];
  function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
  }
  const primitiveTypeNames = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
  }
  function isOfType(type) {
    return (value) => typeof value === type;
  }
  const { toString: toString2 } = Object.prototype;
  const getObjectType = (value) => {
    const objectTypeName = toString2.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
      return "HTMLElement";
    }
    if (isObjectTypeName(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  };
  const isObjectOfType = (type) => (value) => getObjectType(value) === type;
  function is(value) {
    if (value === null) {
      return "null";
    }
    switch (typeof value) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
    }
    if (is.observable(value)) {
      return "Observable";
    }
    if (is.array(value)) {
      return "Array";
    }
    if (is.buffer(value)) {
      return "Buffer";
    }
    const tagType = getObjectType(value);
    if (tagType) {
      return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
      throw new TypeError("Please don't use object wrappers for primitive types");
    }
    return "Object";
  }
  is.undefined = isOfType("undefined");
  is.string = isOfType("string");
  const isNumberType = isOfType("number");
  is.number = (value) => isNumberType(value) && !is.nan(value);
  is.bigint = isOfType("bigint");
  is.function_ = isOfType("function");
  is.null_ = (value) => value === null;
  is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
  is.boolean = (value) => value === true || value === false;
  is.symbol = isOfType("symbol");
  is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
  is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
      return false;
    }
    if (!is.function_(assertion)) {
      return true;
    }
    return value.every(assertion);
  };
  is.buffer = (value) => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
  };
  is.blob = (value) => isObjectOfType("Blob")(value);
  is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
  is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
  is.iterable = (value) => {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
  };
  is.asyncIterable = (value) => {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
  };
  is.generator = (value) => {
    var _a, _b;
    return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw);
  };
  is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
  is.nativePromise = (value) => isObjectOfType("Promise")(value);
  const hasPromiseAPI = (value) => {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
  };
  is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
  is.generatorFunction = isObjectOfType("GeneratorFunction");
  is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
  is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
  is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
  is.regExp = isObjectOfType("RegExp");
  is.date = isObjectOfType("Date");
  is.error = isObjectOfType("Error");
  is.map = (value) => isObjectOfType("Map")(value);
  is.set = (value) => isObjectOfType("Set")(value);
  is.weakMap = (value) => isObjectOfType("WeakMap")(value);
  is.weakSet = (value) => isObjectOfType("WeakSet")(value);
  is.int8Array = isObjectOfType("Int8Array");
  is.uint8Array = isObjectOfType("Uint8Array");
  is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
  is.int16Array = isObjectOfType("Int16Array");
  is.uint16Array = isObjectOfType("Uint16Array");
  is.int32Array = isObjectOfType("Int32Array");
  is.uint32Array = isObjectOfType("Uint32Array");
  is.float32Array = isObjectOfType("Float32Array");
  is.float64Array = isObjectOfType("Float64Array");
  is.bigInt64Array = isObjectOfType("BigInt64Array");
  is.bigUint64Array = isObjectOfType("BigUint64Array");
  is.arrayBuffer = isObjectOfType("ArrayBuffer");
  is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
  is.dataView = isObjectOfType("DataView");
  is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
  is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
  is.urlInstance = (value) => isObjectOfType("URL")(value);
  is.urlString = (value) => {
    if (!is.string(value)) {
      return false;
    }
    try {
      new URL(value);
      return true;
    } catch (_a) {
      return false;
    }
  };
  is.truthy = (value) => Boolean(value);
  is.falsy = (value) => !value;
  is.nan = (value) => Number.isNaN(value);
  is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
  is.integer = (value) => Number.isInteger(value);
  is.safeInteger = (value) => Number.isSafeInteger(value);
  is.plainObject = (value) => {
    if (toString2.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
  };
  is.typedArray = (value) => isTypedArrayName(getObjectType(value));
  const isValidLength = (value) => is.safeInteger(value) && value >= 0;
  is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
  is.inRange = (value, range3) => {
    if (is.number(range3)) {
      return value >= Math.min(0, range3) && value <= Math.max(range3, 0);
    }
    if (is.array(range3) && range3.length === 2) {
      return value >= Math.min(...range3) && value <= Math.max(...range3);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range3)}`);
  };
  const NODE_TYPE_ELEMENT = 1;
  const DOM_PROPERTIES_TO_CHECK = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  is.domElement = (value) => {
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
  };
  is.observable = (value) => {
    var _a, _b, _c, _d;
    if (!value) {
      return false;
    }
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
      return true;
    }
    if (value === ((_d = (_c = value)["@@observable"]) === null || _d === void 0 ? void 0 : _d.call(_c))) {
      return true;
    }
    return false;
  };
  is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
  is.infinite = (value) => value === Infinity || value === -Infinity;
  const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
  is.evenInteger = isAbsoluteMod2(0);
  is.oddInteger = isAbsoluteMod2(1);
  is.emptyArray = (value) => is.array(value) && value.length === 0;
  is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
  is.emptyString = (value) => is.string(value) && value.length === 0;
  const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
  is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
  is.nonEmptyString = (value) => is.string(value) && value.length > 0;
  is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
  is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
  is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
  is.emptySet = (value) => is.set(value) && value.size === 0;
  is.nonEmptySet = (value) => is.set(value) && value.size > 0;
  is.emptyMap = (value) => is.map(value) && value.size === 0;
  is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
  is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
  is.formData = (value) => isObjectOfType("FormData")(value);
  is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
  const predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
      throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
      throw new TypeError("Invalid number of values");
    }
    return method.call(values, predicate);
  };
  is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
  };
  is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
  const assertType = (condition, description, value, options = {}) => {
    if (!condition) {
      const { multipleValues } = options;
      const valuesMessage = multipleValues ? `received values of types ${[
        ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
      ].join(", ")}` : `received value of type \`${is(value)}\``;
      throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
  };
  exports.assert = {
    undefined: (value) => assertType(is.undefined(value), "undefined", value),
    string: (value) => assertType(is.string(value), "string", value),
    number: (value) => assertType(is.number(value), "number", value),
    bigint: (value) => assertType(is.bigint(value), "bigint", value),
    function_: (value) => assertType(is.function_(value), "Function", value),
    null_: (value) => assertType(is.null_(value), "null", value),
    class_: (value) => assertType(is.class_(value), "Class", value),
    boolean: (value) => assertType(is.boolean(value), "boolean", value),
    symbol: (value) => assertType(is.symbol(value), "symbol", value),
    numericString: (value) => assertType(is.numericString(value), "string with a number", value),
    array: (value, assertion) => {
      const assert = assertType;
      assert(is.array(value), "Array", value);
      if (assertion) {
        value.forEach(assertion);
      }
    },
    buffer: (value) => assertType(is.buffer(value), "Buffer", value),
    blob: (value) => assertType(is.blob(value), "Blob", value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
    object: (value) => assertType(is.object(value), "Object", value),
    iterable: (value) => assertType(is.iterable(value), "Iterable", value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
    generator: (value) => assertType(is.generator(value), "Generator", value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
    promise: (value) => assertType(is.promise(value), "Promise", value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
    asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
    boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
    regExp: (value) => assertType(is.regExp(value), "RegExp", value),
    date: (value) => assertType(is.date(value), "Date", value),
    error: (value) => assertType(is.error(value), "Error", value),
    map: (value) => assertType(is.map(value), "Map", value),
    set: (value) => assertType(is.set(value), "Set", value),
    weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
    weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
    int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
    uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
    int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
    uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
    int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
    uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
    float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
    float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
    dataView: (value) => assertType(is.dataView(value), "DataView", value),
    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
    urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
    truthy: (value) => assertType(is.truthy(value), "truthy", value),
    falsy: (value) => assertType(is.falsy(value), "falsy", value),
    nan: (value) => assertType(is.nan(value), "NaN", value),
    primitive: (value) => assertType(is.primitive(value), "primitive", value),
    integer: (value) => assertType(is.integer(value), "integer", value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
    observable: (value) => assertType(is.observable(value), "Observable", value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
    infinite: (value) => assertType(is.infinite(value), "infinite number", value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
    propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
    formData: (value) => assertType(is.formData(value), "FormData", value),
    urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
    inRange: (value, range3) => assertType(is.inRange(value, range3), "in range", value),
    any: (predicate, ...values) => {
      return assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true });
    },
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
  };
  Object.defineProperties(is, {
    class: {
      value: is.class_
    },
    function: {
      value: is.function_
    },
    null: {
      value: is.null_
    }
  });
  Object.defineProperties(exports.assert, {
    class: {
      value: exports.assert.class_
    },
    function: {
      value: exports.assert.function_
    },
    null: {
      value: exports.assert.null_
    }
  });
  exports.default = is;
  module.exports = is;
  module.exports.default = is;
  module.exports.assert = exports.assert;
})(dist$1, dist$1.exports);
var asPromise = {};
var pCancelable = { exports: {} };
class CancelError extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
}
class PCancelable {
  static fn(userFn) {
    return (...arguments_) => {
      return new PCancelable((resolve2, reject, onCancel) => {
        arguments_.push(onCancel);
        userFn(...arguments_).then(resolve2, reject);
      });
    };
  }
  constructor(executor) {
    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise((resolve2, reject) => {
      this._reject = reject;
      const onResolve = (value) => {
        if (!this._isCanceled || !onCancel.shouldReject) {
          this._isPending = false;
          resolve2(value);
        }
      };
      const onReject = (error) => {
        this._isPending = false;
        reject(error);
      };
      const onCancel = (handler) => {
        if (!this._isPending) {
          throw new Error("The `onCancel` handler was attached after the promise settled.");
        }
        this._cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this._rejectOnCancel,
          set: (boolean2) => {
            this._rejectOnCancel = boolean2;
          }
        }
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel(reason) {
    if (!this._isPending || this._isCanceled) {
      return;
    }
    this._isCanceled = true;
    if (this._cancelHandlers.length > 0) {
      try {
        for (const handler of this._cancelHandlers) {
          handler();
        }
      } catch (error) {
        this._reject(error);
        return;
      }
    }
    if (this._rejectOnCancel) {
      this._reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this._isCanceled;
  }
}
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
pCancelable.exports = PCancelable;
pCancelable.exports.CancelError = CancelError;
var types$1 = {};
var core = {};
var source$3 = { exports: {} };
var source$2 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function isTLSSocket(socket) {
    return socket.encrypted;
  }
  const deferToConnect = (socket, fn) => {
    let listeners2;
    if (typeof fn === "function") {
      const connect = fn;
      listeners2 = { connect };
    } else {
      listeners2 = fn;
    }
    const hasConnectListener = typeof listeners2.connect === "function";
    const hasSecureConnectListener = typeof listeners2.secureConnect === "function";
    const hasCloseListener = typeof listeners2.close === "function";
    const onConnect = () => {
      if (hasConnectListener) {
        listeners2.connect();
      }
      if (isTLSSocket(socket) && hasSecureConnectListener) {
        if (socket.authorized) {
          listeners2.secureConnect();
        } else if (!socket.authorizationError) {
          socket.once("secureConnect", listeners2.secureConnect);
        }
      }
      if (hasCloseListener) {
        socket.once("close", listeners2.close);
      }
    };
    if (socket.writable && !socket.connecting) {
      onConnect();
    } else if (socket.connecting) {
      socket.once("connect", onConnect);
    } else if (socket.destroyed && hasCloseListener) {
      listeners2.close(socket._hadError);
    }
  };
  exports.default = deferToConnect;
  module.exports = deferToConnect;
  module.exports.default = deferToConnect;
})(source$2, source$2.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const defer_to_connect_1 = source$2.exports;
  const util_12 = require$$1;
  const nodejsMajorVersion = Number(process.versions.node.split(".")[0]);
  const timer = (request2) => {
    if (request2.timings) {
      return request2.timings;
    }
    const timings = {
      start: Date.now(),
      socket: void 0,
      lookup: void 0,
      connect: void 0,
      secureConnect: void 0,
      upload: void 0,
      response: void 0,
      end: void 0,
      error: void 0,
      abort: void 0,
      phases: {
        wait: void 0,
        dns: void 0,
        tcp: void 0,
        tls: void 0,
        request: void 0,
        firstByte: void 0,
        download: void 0,
        total: void 0
      }
    };
    request2.timings = timings;
    const handleError = (origin) => {
      const emit2 = origin.emit.bind(origin);
      origin.emit = (event, ...args) => {
        if (event === "error") {
          timings.error = Date.now();
          timings.phases.total = timings.error - timings.start;
          origin.emit = emit2;
        }
        return emit2(event, ...args);
      };
    };
    handleError(request2);
    const onAbort = () => {
      timings.abort = Date.now();
      if (!timings.response || nodejsMajorVersion >= 13) {
        timings.phases.total = Date.now() - timings.start;
      }
    };
    request2.prependOnceListener("abort", onAbort);
    const onSocket = (socket) => {
      timings.socket = Date.now();
      timings.phases.wait = timings.socket - timings.start;
      if (util_12.types.isProxy(socket)) {
        return;
      }
      const lookupListener = () => {
        timings.lookup = Date.now();
        timings.phases.dns = timings.lookup - timings.socket;
      };
      socket.prependOnceListener("lookup", lookupListener);
      defer_to_connect_1.default(socket, {
        connect: () => {
          timings.connect = Date.now();
          if (timings.lookup === void 0) {
            socket.removeListener("lookup", lookupListener);
            timings.lookup = timings.connect;
            timings.phases.dns = timings.lookup - timings.socket;
          }
          timings.phases.tcp = timings.connect - timings.lookup;
        },
        secureConnect: () => {
          timings.secureConnect = Date.now();
          timings.phases.tls = timings.secureConnect - timings.connect;
        }
      });
    };
    if (request2.socket) {
      onSocket(request2.socket);
    } else {
      request2.prependOnceListener("socket", onSocket);
    }
    const onUpload = () => {
      var _a;
      timings.upload = Date.now();
      timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);
    };
    const writableFinished = () => {
      if (typeof request2.writableFinished === "boolean") {
        return request2.writableFinished;
      }
      return request2.finished && request2.outputSize === 0 && (!request2.socket || request2.socket.writableLength === 0);
    };
    if (writableFinished()) {
      onUpload();
    } else {
      request2.prependOnceListener("finish", onUpload);
    }
    request2.prependOnceListener("response", (response) => {
      timings.response = Date.now();
      timings.phases.firstByte = timings.response - timings.upload;
      response.timings = timings;
      handleError(response);
      response.prependOnceListener("end", () => {
        timings.end = Date.now();
        timings.phases.download = timings.end - timings.response;
        timings.phases.total = timings.end - timings.start;
      });
      response.prependOnceListener("aborted", onAbort);
    });
    return timings;
  };
  exports.default = timer;
  module.exports = timer;
  module.exports.default = timer;
})(source$3, source$3.exports);
var source$1 = { exports: {} };
const {
  V4MAPPED,
  ADDRCONFIG,
  ALL,
  promises: {
    Resolver: AsyncResolver
  },
  lookup: dnsLookup
} = require$$0$1;
const { promisify } = require$$1;
const os = require$$2;
const kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
const kCacheableLookupInstance = Symbol("cacheableLookupInstance");
const kExpires = Symbol("expires");
const supportsALL = typeof ALL === "number";
const verifyAgent = (agent2) => {
  if (!(agent2 && typeof agent2.createConnection === "function")) {
    throw new Error("Expected an Agent instance as the first argument");
  }
};
const map4to6 = (entries) => {
  for (const entry2 of entries) {
    if (entry2.family === 6) {
      continue;
    }
    entry2.address = `::ffff:${entry2.address}`;
    entry2.family = 6;
  }
};
const getIfaceInfo = () => {
  let has4 = false;
  let has6 = false;
  for (const device of Object.values(os.networkInterfaces())) {
    for (const iface of device) {
      if (iface.internal) {
        continue;
      }
      if (iface.family === "IPv6") {
        has6 = true;
      } else {
        has4 = true;
      }
      if (has4 && has6) {
        return { has4, has6 };
      }
    }
  }
  return { has4, has6 };
};
const isIterable = (map2) => {
  return Symbol.iterator in map2;
};
const ttl = { ttl: true };
const all = { all: true };
class CacheableLookup {
  constructor({
    cache: cache2 = /* @__PURE__ */ new Map(),
    maxTtl = Infinity,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver(),
    lookup: lookup2 = dnsLookup
  } = {}) {
    this.maxTtl = maxTtl;
    this.errorTtl = errorTtl;
    this._cache = cache2;
    this._resolver = resolver;
    this._dnsLookup = promisify(lookup2);
    if (this._resolver instanceof AsyncResolver) {
      this._resolve4 = this._resolver.resolve4.bind(this._resolver);
      this._resolve6 = this._resolver.resolve6.bind(this._resolver);
    } else {
      this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
      this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
    }
    this._iface = getIfaceInfo();
    this._pending = {};
    this._nextRemovalTime = false;
    this._hostnamesToFallback = /* @__PURE__ */ new Set();
    if (fallbackDuration < 1) {
      this._fallback = false;
    } else {
      this._fallback = true;
      const interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1e3);
      if (interval.unref) {
        interval.unref();
      }
    }
    this.lookup = this.lookup.bind(this);
    this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear();
    this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname, options, callback2) {
    if (typeof options === "function") {
      callback2 = options;
      options = {};
    } else if (typeof options === "number") {
      options = {
        family: options
      };
    }
    if (!callback2) {
      throw new Error("Callback must be a function.");
    }
    this.lookupAsync(hostname, options).then((result) => {
      if (options.all) {
        callback2(null, result);
      } else {
        callback2(null, result.address, result.family, result.expires, result.ttl);
      }
    }, callback2);
  }
  async lookupAsync(hostname, options = {}) {
    if (typeof options === "number") {
      options = {
        family: options
      };
    }
    let cached = await this.query(hostname);
    if (options.family === 6) {
      const filtered = cached.filter((entry2) => entry2.family === 6);
      if (options.hints & V4MAPPED) {
        if (supportsALL && options.hints & ALL || filtered.length === 0) {
          map4to6(cached);
        } else {
          cached = filtered;
        }
      } else {
        cached = filtered;
      }
    } else if (options.family === 4) {
      cached = cached.filter((entry2) => entry2.family === 4);
    }
    if (options.hints & ADDRCONFIG) {
      const { _iface } = this;
      cached = cached.filter((entry2) => entry2.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
      error.code = "ENOTFOUND";
      error.hostname = hostname;
      throw error;
    }
    if (options.all) {
      return cached;
    }
    return cached[0];
  }
  async query(hostname) {
    let cached = await this._cache.get(hostname);
    if (!cached) {
      const pending = this._pending[hostname];
      if (pending) {
        cached = await pending;
      } else {
        const newPromise = this.queryAndCache(hostname);
        this._pending[hostname] = newPromise;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname];
        }
      }
    }
    cached = cached.map((entry2) => {
      return { ...entry2 };
    });
    return cached;
  }
  async _resolve(hostname) {
    const wrap = async (promise) => {
      try {
        return await promise;
      } catch (error) {
        if (error.code === "ENODATA" || error.code === "ENOTFOUND") {
          return [];
        }
        throw error;
      }
    };
    const [A, AAAA] = await Promise.all([
      this._resolve4(hostname, ttl),
      this._resolve6(hostname, ttl)
    ].map((promise) => wrap(promise)));
    let aTtl = 0;
    let aaaaTtl = 0;
    let cacheTtl = 0;
    const now2 = Date.now();
    for (const entry2 of A) {
      entry2.family = 4;
      entry2.expires = now2 + entry2.ttl * 1e3;
      aTtl = Math.max(aTtl, entry2.ttl);
    }
    for (const entry2 of AAAA) {
      entry2.family = 6;
      entry2.expires = now2 + entry2.ttl * 1e3;
      aaaaTtl = Math.max(aaaaTtl, entry2.ttl);
    }
    if (A.length > 0) {
      if (AAAA.length > 0) {
        cacheTtl = Math.min(aTtl, aaaaTtl);
      } else {
        cacheTtl = aTtl;
      }
    } else {
      cacheTtl = aaaaTtl;
    }
    return {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname) {
    try {
      const entries = await this._dnsLookup(hostname, {
        all: true
      });
      return {
        entries,
        cacheTtl: 0
      };
    } catch (_) {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
      data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname, data, cacheTtl);
      } catch (error) {
        this.lookupAsync = async () => {
          const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          cacheError.cause = error;
          throw cacheError;
        };
      }
      if (isIterable(this._cache)) {
        this._tick(cacheTtl);
      }
    }
  }
  async queryAndCache(hostname) {
    if (this._hostnamesToFallback.has(hostname)) {
      return this._dnsLookup(hostname, all);
    }
    let query = await this._resolve(hostname);
    if (query.entries.length === 0 && this._fallback) {
      query = await this._lookup(hostname);
      if (query.entries.length !== 0) {
        this._hostnamesToFallback.add(hostname);
      }
    }
    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
    await this._set(hostname, query.entries, cacheTtl);
    return query.entries;
  }
  _tick(ms) {
    const nextRemovalTime = this._nextRemovalTime;
    if (!nextRemovalTime || ms < nextRemovalTime) {
      clearTimeout(this._removalTimeout);
      this._nextRemovalTime = ms;
      this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = false;
        let nextExpiry = Infinity;
        const now2 = Date.now();
        for (const [hostname, entries] of this._cache) {
          const expires = entries[kExpires];
          if (now2 >= expires) {
            this._cache.delete(hostname);
          } else if (expires < nextExpiry) {
            nextExpiry = expires;
          }
        }
        if (nextExpiry !== Infinity) {
          this._tick(nextExpiry - now2);
        }
      }, ms);
      if (this._removalTimeout.unref) {
        this._removalTimeout.unref();
      }
    }
  }
  install(agent2) {
    verifyAgent(agent2);
    if (kCacheableLookupCreateConnection in agent2) {
      throw new Error("CacheableLookup has been already installed");
    }
    agent2[kCacheableLookupCreateConnection] = agent2.createConnection;
    agent2[kCacheableLookupInstance] = this;
    agent2.createConnection = (options, callback2) => {
      if (!("lookup" in options)) {
        options.lookup = this.lookup;
      }
      return agent2[kCacheableLookupCreateConnection](options, callback2);
    };
  }
  uninstall(agent2) {
    verifyAgent(agent2);
    if (agent2[kCacheableLookupCreateConnection]) {
      if (agent2[kCacheableLookupInstance] !== this) {
        throw new Error("The agent is not owned by this CacheableLookup instance");
      }
      agent2.createConnection = agent2[kCacheableLookupCreateConnection];
      delete agent2[kCacheableLookupCreateConnection];
      delete agent2[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    const { _iface } = this;
    this._iface = getIfaceInfo();
    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
      this._cache.clear();
    }
  }
  clear(hostname) {
    if (hostname) {
      this._cache.delete(hostname);
      return;
    }
    this._cache.clear();
  }
}
source$1.exports = CacheableLookup;
source$1.exports.default = CacheableLookup;
const DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
const DATA_URL_DEFAULT_CHARSET = "us-ascii";
const testParameter = (name, filters) => {
  return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
};
const normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let { type, data, hash: hash2 } = match.groups;
  const mediaType = type.split(";");
  hash2 = stripHash ? "" : hash2;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = (mediaType.shift() || "").toLowerCase();
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string2) => string2.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [
    ...attributes
  ];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash2 ? `#${hash2}` : ""}`;
};
const normalizeUrl$1 = (urlString, options) => {
  options = {
    defaultProtocol: "http:",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true,
    ...options
  };
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (/^view-source:/i.test(urlString)) {
    throw new Error("`view-source:` is not supported as it is a non-standard protocol");
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObj = new URL(urlString);
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObj.protocol === "https:") {
    urlObj.protocol = "http:";
  }
  if (options.forceHttps && urlObj.protocol === "http:") {
    urlObj.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObj.username = "";
    urlObj.password = "";
  }
  if (options.stripHash) {
    urlObj.hash = "";
  } else if (options.stripTextFragment) {
    urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObj.pathname) {
    urlObj.pathname = urlObj.pathname.replace(new RegExp("(?<!\\b(?:[a-z][a-z\\d+\\-.]{1,50}:))\\/{2,}", "g"), "/");
  }
  if (urlObj.pathname) {
    try {
      urlObj.pathname = decodeURI(urlObj.pathname);
    } catch (_) {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObj.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (urlObj.hostname) {
    urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
      urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObj.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObj.searchParams.delete(key);
      }
    }
  }
  if (options.removeQueryParameters === true) {
    urlObj.search = "";
  }
  if (options.sortQueryParameters) {
    urlObj.searchParams.sort();
  }
  if (options.removeTrailingSlash) {
    urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
  }
  const oldUrlString = urlString;
  urlString = urlObj.toString();
  if (!options.removeSingleSlash && urlObj.pathname === "/" && !oldUrlString.endsWith("/") && urlObj.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
};
var normalizeUrl_1 = normalizeUrl$1;
var getStream$2 = { exports: {} };
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base642 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject2(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from2(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer2(size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size).fill(fill2, encoding) : createBuffer2(size).fill(fill2);
    }
    return createBuffer2(size);
  }
  Buffer2.alloc = function(size, fill2, encoding) {
    return alloc(size, fill2, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer2(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string2, encoding) | 0;
    var buf = createBuffer2(length);
    var actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer2(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject2(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer2(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list2, length) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list2.length; ++i) {
        length += list2[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list2.length; ++i) {
      var buf = list2[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
    }
    var len = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap2(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap2(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap2(this, i, i + 3);
      swap2(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap2(this, i, i + 7);
      swap2(this, i + 1, i + 6);
      swap2(this, i + 2, i + 5);
      swap2(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string2.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string2.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src2.length)
        break;
      dst[i + offset] = src2[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
})(buffer);
var once$3 = { exports: {} };
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb)
    return wrappy$1(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);
once$2.proto = once$2(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$2(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once$2(fn) {
  var f = function() {
    if (f.called)
      return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
var once$1 = once$3.exports;
var noop$2 = function() {
};
var isRequest$1 = function(stream) {
  return stream.setHeader && typeof stream.abort === "function";
};
var isChildProcess = function(stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};
var eos$1 = function(stream, opts, callback2) {
  if (typeof opts === "function")
    return eos$1(stream, null, opts);
  if (!opts)
    opts = {};
  callback2 = once$1(callback2 || noop$2);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;
  var onlegacyfinish = function() {
    if (!stream.writable)
      onfinish();
  };
  var onfinish = function() {
    writable = false;
    if (!readable)
      callback2.call(stream);
  };
  var onend = function() {
    readable = false;
    if (!writable)
      callback2.call(stream);
  };
  var onexit = function(exitCode) {
    callback2.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
  };
  var onerror = function(err) {
    callback2.call(stream, err);
  };
  var onclose = function() {
    process.nextTick(onclosenexttick);
  };
  var onclosenexttick = function() {
    if (cancelled)
      return;
    if (readable && !(rs && (rs.ended && !rs.destroyed)))
      return callback2.call(stream, new Error("premature close"));
    if (writable && !(ws && (ws.ended && !ws.destroyed)))
      return callback2.call(stream, new Error("premature close"));
  };
  var onrequest = function() {
    stream.req.on("finish", onfinish);
  };
  if (isRequest$1(stream)) {
    stream.on("complete", onfinish);
    stream.on("abort", onclose);
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !ws) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (isChildProcess(stream))
    stream.on("exit", onexit);
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (opts.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  return function() {
    cancelled = true;
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("exit", onexit);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
};
var endOfStream = eos$1;
var once2 = once$3.exports;
var eos = endOfStream;
var fs$2 = require$$2$1;
var noop$1 = function() {
};
var ancient = /^v?\.0/.test(process.version);
var isFn = function(fn) {
  return typeof fn === "function";
};
var isFS = function(stream) {
  if (!ancient)
    return false;
  if (!fs$2)
    return false;
  return (stream instanceof (fs$2.ReadStream || noop$1) || stream instanceof (fs$2.WriteStream || noop$1)) && isFn(stream.close);
};
var isRequest = function(stream) {
  return stream.setHeader && isFn(stream.abort);
};
var destroyer = function(stream, reading, writing, callback2) {
  callback2 = once2(callback2);
  var closed = false;
  stream.on("close", function() {
    closed = true;
  });
  eos(stream, { readable: reading, writable: writing }, function(err) {
    if (err)
      return callback2(err);
    closed = true;
    callback2();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isFS(stream))
      return stream.close(noop$1);
    if (isRequest(stream))
      return stream.abort();
    if (isFn(stream.destroy))
      return stream.destroy();
    callback2(err || new Error("stream was destroyed"));
  };
};
var call = function(fn) {
  fn();
};
var pipe = function(from2, to2) {
  return from2.pipe(to2);
};
var pump$1 = function() {
  var streams = Array.prototype.slice.call(arguments);
  var callback2 = isFn(streams[streams.length - 1] || noop$1) && streams.pop() || noop$1;
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2)
    throw new Error("pump requires two streams per minimum");
  var error;
  var destroys = streams.map(function(stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function(err) {
      if (!error)
        error = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback2(error);
    });
  });
  return streams.reduce(pipe);
};
var pump_1 = pump$1;
const { PassThrough: PassThroughStream } = require$$0$2__default;
var bufferStream$1 = (options) => {
  options = { ...options };
  const { array } = options;
  let { encoding } = options;
  const isBuffer = encoding === "buffer";
  let objectMode = false;
  if (array) {
    objectMode = !(encoding || isBuffer);
  } else {
    encoding = encoding || "utf8";
  }
  if (isBuffer) {
    encoding = null;
  }
  const stream = new PassThroughStream({ objectMode });
  if (encoding) {
    stream.setEncoding(encoding);
  }
  let length = 0;
  const chunks = [];
  stream.on("data", (chunk) => {
    chunks.push(chunk);
    if (objectMode) {
      length = chunks.length;
    } else {
      length += chunk.length;
    }
  });
  stream.getBufferedValue = () => {
    if (array) {
      return chunks;
    }
    return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
  };
  stream.getBufferedLength = () => length;
  return stream;
};
const { constants: BufferConstants } = buffer;
const pump = pump_1;
const bufferStream = bufferStream$1;
class MaxBufferError extends Error {
  constructor() {
    super("maxBuffer exceeded");
    this.name = "MaxBufferError";
  }
}
async function getStream$1(inputStream, options) {
  if (!inputStream) {
    return Promise.reject(new Error("Expected a stream"));
  }
  options = {
    maxBuffer: Infinity,
    ...options
  };
  const { maxBuffer } = options;
  let stream;
  await new Promise((resolve2, reject) => {
    const rejectPromise = (error) => {
      if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
        error.bufferedData = stream.getBufferedValue();
      }
      reject(error);
    };
    stream = pump(inputStream, bufferStream(options), (error) => {
      if (error) {
        rejectPromise(error);
        return;
      }
      resolve2();
    });
    stream.on("data", () => {
      if (stream.getBufferedLength() > maxBuffer) {
        rejectPromise(new MaxBufferError());
      }
    });
  });
  return stream.getBufferedValue();
}
getStream$2.exports = getStream$1;
getStream$2.exports.default = getStream$1;
getStream$2.exports.buffer = (stream, options) => getStream$1(stream, { ...options, encoding: "buffer" });
getStream$2.exports.array = (stream, options) => getStream$1(stream, { ...options, array: true });
getStream$2.exports.MaxBufferError = MaxBufferError;
const statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
  200,
  203,
  204,
  206,
  300,
  301,
  308,
  404,
  405,
  410,
  414,
  501
]);
const understoodStatuses = /* @__PURE__ */ new Set([
  200,
  203,
  204,
  300,
  301,
  302,
  303,
  307,
  308,
  404,
  405,
  410,
  414,
  501
]);
const errorStatusCodes = /* @__PURE__ */ new Set([
  500,
  502,
  503,
  504
]);
const hopByHopHeaders = {
  date: true,
  connection: true,
  "keep-alive": true,
  "proxy-authenticate": true,
  "proxy-authorization": true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true
};
const excludedFromRevalidationUpdate = {
  "content-length": true,
  "content-encoding": true,
  "transfer-encoding": true,
  "content-range": true
};
function toNumberOrZero(s) {
  const n = parseInt(s, 10);
  return isFinite(n) ? n : 0;
}
function isErrorResponse(response) {
  if (!response) {
    return true;
  }
  return errorStatusCodes.has(response.status);
}
function parseCacheControl(header) {
  const cc = {};
  if (!header)
    return cc;
  const parts = header.trim().split(/,/);
  for (const part of parts) {
    const [k, v2] = part.split(/=/, 2);
    cc[k.trim()] = v2 === void 0 ? true : v2.trim().replace(/^"|"$/g, "");
  }
  return cc;
}
function formatCacheControl(cc) {
  let parts = [];
  for (const k in cc) {
    const v2 = cc[k];
    parts.push(v2 === true ? k : k + "=" + v2);
  }
  if (!parts.length) {
    return void 0;
  }
  return parts.join(", ");
}
var httpCacheSemantics = class CachePolicy {
  constructor(req, res, {
    shared,
    cacheHeuristic,
    immutableMinTimeToLive,
    ignoreCargoCult,
    _fromObject
  } = {}) {
    if (_fromObject) {
      this._fromObject(_fromObject);
      return;
    }
    if (!res || !res.headers) {
      throw Error("Response headers missing");
    }
    this._assertRequestHasHeaders(req);
    this._responseTime = this.now();
    this._isShared = shared !== false;
    this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1;
    this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3;
    this._status = "status" in res ? res.status : 200;
    this._resHeaders = res.headers;
    this._rescc = parseCacheControl(res.headers["cache-control"]);
    this._method = "method" in req ? req.method : "GET";
    this._url = req.url;
    this._host = req.headers.host;
    this._noAuthorization = !req.headers.authorization;
    this._reqHeaders = res.headers.vary ? req.headers : null;
    this._reqcc = parseCacheControl(req.headers["cache-control"]);
    if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
      delete this._rescc["pre-check"];
      delete this._rescc["post-check"];
      delete this._rescc["no-cache"];
      delete this._rescc["no-store"];
      delete this._rescc["must-revalidate"];
      this._resHeaders = Object.assign({}, this._resHeaders, {
        "cache-control": formatCacheControl(this._rescc)
      });
      delete this._resHeaders.expires;
      delete this._resHeaders.pragma;
    }
    if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
      this._rescc["no-cache"] = true;
    }
  }
  now() {
    return Date.now();
  }
  storable() {
    return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
  }
  _hasExplicitExpiration() {
    return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
  }
  _assertRequestHasHeaders(req) {
    if (!req || !req.headers) {
      throw Error("Request headers missing");
    }
  }
  satisfiesWithoutRevalidation(req) {
    this._assertRequestHasHeaders(req);
    const requestCC = parseCacheControl(req.headers["cache-control"]);
    if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
      return false;
    }
    if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
      return false;
    }
    if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
      return false;
    }
    if (this.stale()) {
      const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
      if (!allowsStale) {
        return false;
      }
    }
    return this._requestMatches(req, false);
  }
  _requestMatches(req, allowHeadMethod) {
    return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
  }
  _allowsStoringAuthenticated() {
    return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
  }
  _varyMatches(req) {
    if (!this._resHeaders.vary) {
      return true;
    }
    if (this._resHeaders.vary === "*") {
      return false;
    }
    const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
    for (const name of fields) {
      if (req.headers[name] !== this._reqHeaders[name])
        return false;
    }
    return true;
  }
  _copyWithoutHopByHopHeaders(inHeaders) {
    const headers = {};
    for (const name in inHeaders) {
      if (hopByHopHeaders[name])
        continue;
      headers[name] = inHeaders[name];
    }
    if (inHeaders.connection) {
      const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
      for (const name of tokens) {
        delete headers[name];
      }
    }
    if (headers.warning) {
      const warnings = headers.warning.split(/,/).filter((warning) => {
        return !/^\s*1[0-9][0-9]/.test(warning);
      });
      if (!warnings.length) {
        delete headers.warning;
      } else {
        headers.warning = warnings.join(",").trim();
      }
    }
    return headers;
  }
  responseHeaders() {
    const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
    const age = this.age();
    if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
      headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
    }
    headers.age = `${Math.round(age)}`;
    headers.date = new Date(this.now()).toUTCString();
    return headers;
  }
  date() {
    const serverDate = Date.parse(this._resHeaders.date);
    if (isFinite(serverDate)) {
      return serverDate;
    }
    return this._responseTime;
  }
  age() {
    let age = this._ageValue();
    const residentTime = (this.now() - this._responseTime) / 1e3;
    return age + residentTime;
  }
  _ageValue() {
    return toNumberOrZero(this._resHeaders.age);
  }
  maxAge() {
    if (!this.storable() || this._rescc["no-cache"]) {
      return 0;
    }
    if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
      return 0;
    }
    if (this._resHeaders.vary === "*") {
      return 0;
    }
    if (this._isShared) {
      if (this._rescc["proxy-revalidate"]) {
        return 0;
      }
      if (this._rescc["s-maxage"]) {
        return toNumberOrZero(this._rescc["s-maxage"]);
      }
    }
    if (this._rescc["max-age"]) {
      return toNumberOrZero(this._rescc["max-age"]);
    }
    const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
    const serverDate = this.date();
    if (this._resHeaders.expires) {
      const expires = Date.parse(this._resHeaders.expires);
      if (Number.isNaN(expires) || expires < serverDate) {
        return 0;
      }
      return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
    }
    if (this._resHeaders["last-modified"]) {
      const lastModified = Date.parse(this._resHeaders["last-modified"]);
      if (isFinite(lastModified) && serverDate > lastModified) {
        return Math.max(defaultMinTtl, (serverDate - lastModified) / 1e3 * this._cacheHeuristic);
      }
    }
    return defaultMinTtl;
  }
  timeToLive() {
    const age = this.maxAge() - this.age();
    const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
    const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
    return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
  }
  stale() {
    return this.maxAge() <= this.age();
  }
  _useStaleIfError() {
    return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
  }
  useStaleWhileRevalidate() {
    return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
  }
  static fromObject(obj) {
    return new this(void 0, void 0, { _fromObject: obj });
  }
  _fromObject(obj) {
    if (this._responseTime)
      throw Error("Reinitialized");
    if (!obj || obj.v !== 1)
      throw Error("Invalid serialization");
    this._responseTime = obj.t;
    this._isShared = obj.sh;
    this._cacheHeuristic = obj.ch;
    this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
    this._status = obj.st;
    this._resHeaders = obj.resh;
    this._rescc = obj.rescc;
    this._method = obj.m;
    this._url = obj.u;
    this._host = obj.h;
    this._noAuthorization = obj.a;
    this._reqHeaders = obj.reqh;
    this._reqcc = obj.reqcc;
  }
  toObject() {
    return {
      v: 1,
      t: this._responseTime,
      sh: this._isShared,
      ch: this._cacheHeuristic,
      imm: this._immutableMinTtl,
      st: this._status,
      resh: this._resHeaders,
      rescc: this._rescc,
      m: this._method,
      u: this._url,
      h: this._host,
      a: this._noAuthorization,
      reqh: this._reqHeaders,
      reqcc: this._reqcc
    };
  }
  revalidationHeaders(incomingReq) {
    this._assertRequestHasHeaders(incomingReq);
    const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
    delete headers["if-range"];
    if (!this._requestMatches(incomingReq, true) || !this.storable()) {
      delete headers["if-none-match"];
      delete headers["if-modified-since"];
      return headers;
    }
    if (this._resHeaders.etag) {
      headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
    }
    const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
    if (forbidsWeakValidators) {
      delete headers["if-modified-since"];
      if (headers["if-none-match"]) {
        const etags = headers["if-none-match"].split(/,/).filter((etag) => {
          return !/^\s*W\//.test(etag);
        });
        if (!etags.length) {
          delete headers["if-none-match"];
        } else {
          headers["if-none-match"] = etags.join(",").trim();
        }
      }
    } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
      headers["if-modified-since"] = this._resHeaders["last-modified"];
    }
    return headers;
  }
  revalidatedPolicy(request2, response) {
    this._assertRequestHasHeaders(request2);
    if (this._useStaleIfError() && isErrorResponse(response)) {
      return {
        modified: false,
        matches: false,
        policy: this
      };
    }
    if (!response || !response.headers) {
      throw Error("Response headers missing");
    }
    let matches = false;
    if (response.status !== void 0 && response.status != 304) {
      matches = false;
    } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
      matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
    } else if (this._resHeaders.etag && response.headers.etag) {
      matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
    } else if (this._resHeaders["last-modified"]) {
      matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
    } else {
      if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
        matches = true;
      }
    }
    if (!matches) {
      return {
        policy: new this.constructor(request2, response),
        modified: response.status != 304,
        matches: false
      };
    }
    const headers = {};
    for (const k in this._resHeaders) {
      headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
    }
    const newResponse = Object.assign({}, response, {
      status: this._status,
      method: this._method,
      headers
    });
    return {
      policy: new this.constructor(request2, newResponse, {
        shared: this._isShared,
        cacheHeuristic: this._cacheHeuristic,
        immutableMinTimeToLive: this._immutableMinTtl
      }),
      modified: false,
      matches: true
    };
  }
};
var lowercaseKeys$2 = (object) => {
  const result = {};
  for (const [key, value] of Object.entries(object)) {
    result[key.toLowerCase()] = value;
  }
  return result;
};
const Readable$1 = require$$0$2__default.Readable;
const lowercaseKeys$1 = lowercaseKeys$2;
class Response$2 extends Readable$1 {
  constructor(statusCode, headers, body, url2) {
    if (typeof statusCode !== "number") {
      throw new TypeError("Argument `statusCode` should be a number");
    }
    if (typeof headers !== "object") {
      throw new TypeError("Argument `headers` should be an object");
    }
    if (!(body instanceof Buffer)) {
      throw new TypeError("Argument `body` should be a buffer");
    }
    if (typeof url2 !== "string") {
      throw new TypeError("Argument `url` should be a string");
    }
    super();
    this.statusCode = statusCode;
    this.headers = lowercaseKeys$1(headers);
    this.body = body;
    this.url = url2;
  }
  _read() {
    this.push(this.body);
    this.push(null);
  }
}
var src$3 = Response$2;
const knownProps = [
  "destroy",
  "setTimeout",
  "socket",
  "headers",
  "trailers",
  "rawHeaders",
  "statusCode",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "rawTrailers",
  "statusMessage"
];
var mimicResponse$3 = (fromStream, toStream) => {
  const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
  for (const prop of fromProps) {
    if (prop in toStream) {
      continue;
    }
    toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
  }
};
const PassThrough$1 = require$$0$2__default.PassThrough;
const mimicResponse$2 = mimicResponse$3;
const cloneResponse$1 = (response) => {
  if (!(response && response.pipe)) {
    throw new TypeError("Parameter `response` must be a response stream.");
  }
  const clone3 = new PassThrough$1();
  mimicResponse$2(response, clone3);
  return response.pipe(clone3);
};
var src$2 = cloneResponse$1;
var jsonBuffer = {};
jsonBuffer.stringify = function stringify(o) {
  if (typeof o == "undefined")
    return o;
  if (o && Buffer.isBuffer(o))
    return JSON.stringify(":base64:" + o.toString("base64"));
  if (o && o.toJSON)
    o = o.toJSON();
  if (o && typeof o === "object") {
    var s = "";
    var array = Array.isArray(o);
    s = array ? "[" : "{";
    var first = true;
    for (var k in o) {
      var ignore = typeof o[k] == "function" || !array && typeof o[k] === "undefined";
      if (Object.hasOwnProperty.call(o, k) && !ignore) {
        if (!first)
          s += ",";
        first = false;
        if (array) {
          if (o[k] == void 0)
            s += "null";
          else
            s += stringify(o[k]);
        } else if (o[k] !== void 0) {
          s += stringify(k) + ":" + stringify(o[k]);
        }
      }
    }
    s += array ? "]" : "}";
    return s;
  } else if (typeof o === "string") {
    return JSON.stringify(/^:/.test(o) ? ":" + o : o);
  } else if (typeof o === "undefined") {
    return "null";
  } else
    return JSON.stringify(o);
};
jsonBuffer.parse = function(s) {
  return JSON.parse(s, function(key, value) {
    if (typeof value === "string") {
      if (/^:base64:/.test(value))
        return Buffer.from(value.substring(8), "base64");
      else
        return /^:/.test(value) ? value.substring(1) : value;
    }
    return value;
  });
};
const EventEmitter$4 = events$1.exports;
const JSONB = jsonBuffer;
const loadStore = (options) => {
  const adapters2 = {
    redis: "@keyv/redis",
    rediss: "@keyv/redis",
    mongodb: "@keyv/mongo",
    mongo: "@keyv/mongo",
    sqlite: "@keyv/sqlite",
    postgresql: "@keyv/postgres",
    postgres: "@keyv/postgres",
    mysql: "@keyv/mysql",
    etcd: "@keyv/etcd",
    offline: "@keyv/offline",
    tiered: "@keyv/tiered"
  };
  if (options.adapter || options.uri) {
    const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
    return new (commonjsRequire(adapters2[adapter]))(options);
  }
  return /* @__PURE__ */ new Map();
};
const iterableAdapters = [
  "sqlite",
  "postgres",
  "mysql",
  "mongo",
  "redis",
  "tiered"
];
class Keyv$1 extends EventEmitter$4 {
  constructor(uri, { emitErrors = true, ...options } = {}) {
    super();
    this.opts = {
      namespace: "keyv",
      serialize: JSONB.stringify,
      deserialize: JSONB.parse,
      ...typeof uri === "string" ? { uri } : uri,
      ...options
    };
    if (!this.opts.store) {
      const adapterOptions = { ...this.opts };
      this.opts.store = loadStore(adapterOptions);
    }
    if (this.opts.compression) {
      const compression = this.opts.compression;
      this.opts.serialize = compression.serialize.bind(compression);
      this.opts.deserialize = compression.deserialize.bind(compression);
    }
    if (typeof this.opts.store.on === "function" && emitErrors) {
      this.opts.store.on("error", (error) => this.emit("error", error));
    }
    this.opts.store.namespace = this.opts.namespace;
    const generateIterator = (iterator) => async function* () {
      for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
        const data = this.opts.deserialize(raw);
        if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
          continue;
        }
        if (typeof data.expires === "number" && Date.now() > data.expires) {
          this.delete(key);
          continue;
        }
        yield [this._getKeyUnprefix(key), data.value];
      }
    };
    if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
      this.iterator = generateIterator(this.opts.store);
    } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
      this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
    }
  }
  _checkIterableAdaptar() {
    return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
  }
  _getKeyPrefix(key) {
    return `${this.opts.namespace}:${key}`;
  }
  _getKeyPrefixArray(keys2) {
    return keys2.map((key) => `${this.opts.namespace}:${key}`);
  }
  _getKeyUnprefix(key) {
    return key.split(":").splice(1).join(":");
  }
  get(key, options) {
    const { store } = this.opts;
    const isArray2 = Array.isArray(key);
    const keyPrefixed = isArray2 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
    if (isArray2 && store.getMany === void 0) {
      const promises = [];
      for (const key2 of keyPrefixed) {
        promises.push(Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0 || data === null) {
            return void 0;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            return this.delete(key2).then(() => void 0);
          }
          return options && options.raw ? data : data.value;
        }));
      }
      return Promise.allSettled(promises).then((values) => {
        const data = [];
        for (const value of values) {
          data.push(value.value);
        }
        return data;
      });
    }
    return Promise.resolve().then(() => isArray2 ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
      if (data === void 0 || data === null) {
        return void 0;
      }
      if (isArray2) {
        const result = [];
        for (let row of data) {
          if (typeof row === "string") {
            row = this.opts.deserialize(row);
          }
          if (row === void 0 || row === null) {
            result.push(void 0);
            continue;
          }
          if (typeof row.expires === "number" && Date.now() > row.expires) {
            this.delete(key).then(() => void 0);
            result.push(void 0);
          } else {
            result.push(options && options.raw ? row : row.value);
          }
        }
        return result;
      }
      if (typeof data.expires === "number" && Date.now() > data.expires) {
        return this.delete(key).then(() => void 0);
      }
      return options && options.raw ? data : data.value;
    });
  }
  set(key, value, ttl2) {
    const keyPrefixed = this._getKeyPrefix(key);
    if (typeof ttl2 === "undefined") {
      ttl2 = this.opts.ttl;
    }
    if (ttl2 === 0) {
      ttl2 = void 0;
    }
    const { store } = this.opts;
    return Promise.resolve().then(() => {
      const expires = typeof ttl2 === "number" ? Date.now() + ttl2 : null;
      if (typeof value === "symbol") {
        this.emit("error", "symbol cannot be serialized");
      }
      value = { value, expires };
      return this.opts.serialize(value);
    }).then((value2) => store.set(keyPrefixed, value2, ttl2)).then(() => true);
  }
  delete(key) {
    const { store } = this.opts;
    if (Array.isArray(key)) {
      const keyPrefixed2 = this._getKeyPrefixArray(key);
      if (store.deleteMany === void 0) {
        const promises = [];
        for (const key2 of keyPrefixed2) {
          promises.push(store.delete(key2));
        }
        return Promise.allSettled(promises).then((values) => values.every((x) => x.value === true));
      }
      return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
    }
    const keyPrefixed = this._getKeyPrefix(key);
    return Promise.resolve().then(() => store.delete(keyPrefixed));
  }
  clear() {
    const { store } = this.opts;
    return Promise.resolve().then(() => store.clear());
  }
  has(key) {
    const keyPrefixed = this._getKeyPrefix(key);
    const { store } = this.opts;
    return Promise.resolve().then(async () => {
      if (typeof store.has === "function") {
        return store.has(keyPrefixed);
      }
      const value = await store.get(keyPrefixed);
      return value !== void 0;
    });
  }
  disconnect() {
    const { store } = this.opts;
    if (typeof store.disconnect === "function") {
      return store.disconnect();
    }
  }
}
var src$1 = Keyv$1;
const EventEmitter$3 = events$1.exports;
const urlLib = require$$0$3;
const normalizeUrl = normalizeUrl_1;
const getStream = getStream$2.exports;
const CachePolicy2 = httpCacheSemantics;
const Response$1 = src$3;
const lowercaseKeys = lowercaseKeys$2;
const cloneResponse = src$2;
const Keyv = src$1;
class CacheableRequest {
  constructor(request2, cacheAdapter) {
    if (typeof request2 !== "function") {
      throw new TypeError("Parameter `request` must be a function");
    }
    this.cache = new Keyv({
      uri: typeof cacheAdapter === "string" && cacheAdapter,
      store: typeof cacheAdapter !== "string" && cacheAdapter,
      namespace: "cacheable-request"
    });
    return this.createCacheableRequest(request2);
  }
  createCacheableRequest(request2) {
    return (opts, cb) => {
      let url2;
      if (typeof opts === "string") {
        url2 = normalizeUrlObject(urlLib.parse(opts));
        opts = {};
      } else if (opts instanceof urlLib.URL) {
        url2 = normalizeUrlObject(urlLib.parse(opts.toString()));
        opts = {};
      } else {
        const [pathname, ...searchParts] = (opts.path || "").split("?");
        const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url2 = normalizeUrlObject({ ...opts, pathname, search });
      }
      opts = {
        headers: {},
        method: "GET",
        cache: true,
        strictTtl: false,
        automaticFailover: false,
        ...opts,
        ...urlObjectToRequestOptions(url2)
      };
      opts.headers = lowercaseKeys(opts.headers);
      const ee = new EventEmitter$3();
      const normalizedUrlString = normalizeUrl(urlLib.format(url2), {
        stripWWW: false,
        removeTrailingSlash: false,
        stripAuthentication: false
      });
      const key = `${opts.method}:${normalizedUrlString}`;
      let revalidate = false;
      let madeRequest = false;
      const makeRequest = (opts2) => {
        madeRequest = true;
        let requestErrored = false;
        let requestErrorCallback;
        const requestErrorPromise = new Promise((resolve2) => {
          requestErrorCallback = () => {
            if (!requestErrored) {
              requestErrored = true;
              resolve2();
            }
          };
        });
        const handler = (response) => {
          if (revalidate && !opts2.forceRefresh) {
            response.status = response.statusCode;
            const revalidatedPolicy = CachePolicy2.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
            if (!revalidatedPolicy.modified) {
              const headers = revalidatedPolicy.policy.responseHeaders();
              response = new Response$1(revalidate.statusCode, headers, revalidate.body, revalidate.url);
              response.cachePolicy = revalidatedPolicy.policy;
              response.fromCache = true;
            }
          }
          if (!response.fromCache) {
            response.cachePolicy = new CachePolicy2(opts2, response, opts2);
            response.fromCache = false;
          }
          let clonedResponse;
          if (opts2.cache && response.cachePolicy.storable()) {
            clonedResponse = cloneResponse(response);
            (async () => {
              try {
                const bodyPromise = getStream.buffer(response);
                await Promise.race([
                  requestErrorPromise,
                  new Promise((resolve2) => response.once("end", resolve2))
                ]);
                if (requestErrored) {
                  return;
                }
                const body = await bodyPromise;
                const value = {
                  cachePolicy: response.cachePolicy.toObject(),
                  url: response.url,
                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                  body
                };
                let ttl2 = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                if (opts2.maxTtl) {
                  ttl2 = ttl2 ? Math.min(ttl2, opts2.maxTtl) : opts2.maxTtl;
                }
                await this.cache.set(key, value, ttl2);
              } catch (error) {
                ee.emit("error", new CacheableRequest.CacheError(error));
              }
            })();
          } else if (opts2.cache && revalidate) {
            (async () => {
              try {
                await this.cache.delete(key);
              } catch (error) {
                ee.emit("error", new CacheableRequest.CacheError(error));
              }
            })();
          }
          ee.emit("response", clonedResponse || response);
          if (typeof cb === "function") {
            cb(clonedResponse || response);
          }
        };
        try {
          const req = request2(opts2, handler);
          req.once("error", requestErrorCallback);
          req.once("abort", requestErrorCallback);
          ee.emit("request", req);
        } catch (error) {
          ee.emit("error", new CacheableRequest.RequestError(error));
        }
      };
      (async () => {
        const get2 = async (opts2) => {
          await Promise.resolve();
          const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
          if (typeof cacheEntry === "undefined") {
            return makeRequest(opts2);
          }
          const policy = CachePolicy2.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
            const headers = policy.responseHeaders();
            const response = new Response$1(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
            response.cachePolicy = policy;
            response.fromCache = true;
            ee.emit("response", response);
            if (typeof cb === "function") {
              cb(response);
            }
          } else {
            revalidate = cacheEntry;
            opts2.headers = policy.revalidationHeaders(opts2);
            makeRequest(opts2);
          }
        };
        const errorHandler = (error) => ee.emit("error", new CacheableRequest.CacheError(error));
        this.cache.once("error", errorHandler);
        ee.on("response", () => this.cache.removeListener("error", errorHandler));
        try {
          await get2(opts);
        } catch (error) {
          if (opts.automaticFailover && !madeRequest) {
            makeRequest(opts);
          }
          ee.emit("error", new CacheableRequest.CacheError(error));
        }
      })();
      return ee;
    };
  }
}
function urlObjectToRequestOptions(url2) {
  const options = { ...url2 };
  options.path = `${url2.pathname || "/"}${url2.search || ""}`;
  delete options.pathname;
  delete options.search;
  return options;
}
function normalizeUrlObject(url2) {
  return {
    protocol: url2.protocol,
    auth: url2.auth,
    hostname: url2.hostname || url2.host || "localhost",
    port: url2.port,
    pathname: url2.pathname,
    search: url2.search
  };
}
CacheableRequest.RequestError = class extends Error {
  constructor(error) {
    super(error.message);
    this.name = "RequestError";
    Object.assign(this, error);
  }
};
CacheableRequest.CacheError = class extends Error {
  constructor(error) {
    super(error.message);
    this.name = "CacheError";
    Object.assign(this, error);
  }
};
var src = CacheableRequest;
const knownProperties = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
var mimicResponse$1 = (fromStream, toStream) => {
  if (toStream._readableState.autoDestroy) {
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  }
  const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
  const properties = {};
  for (const property of fromProperties) {
    if (property in toStream) {
      continue;
    }
    properties[property] = {
      get() {
        const value = fromStream[property];
        const isFunction2 = typeof value === "function";
        return isFunction2 ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: true,
      configurable: false
    };
  }
  Object.defineProperties(toStream, properties);
  fromStream.once("aborted", () => {
    toStream.destroy();
    toStream.emit("aborted");
  });
  fromStream.once("close", () => {
    if (fromStream.complete) {
      if (toStream.readable) {
        toStream.once("end", () => {
          toStream.emit("close");
        });
      } else {
        toStream.emit("close");
      }
    } else {
      toStream.emit("close");
    }
  });
  return toStream;
};
const { Transform, PassThrough } = require$$0$2__default;
const zlib = require$$1$1;
const mimicResponse = mimicResponse$1;
var decompressResponse = (response) => {
  const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
  if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
    return response;
  }
  const isBrotli = contentEncoding === "br";
  if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
    response.destroy(new Error("Brotli is not supported on Node.js < 12"));
    return response;
  }
  let isEmpty = true;
  const checker = new Transform({
    transform(data, _encoding, callback2) {
      isEmpty = false;
      callback2(null, data);
    },
    flush(callback2) {
      callback2();
    }
  });
  const finalStream = new PassThrough({
    autoDestroy: false,
    destroy(error, callback2) {
      response.destroy();
      callback2(error);
    }
  });
  const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
  decompressStream.once("error", (error) => {
    if (isEmpty && !response.readable) {
      finalStream.end();
      return;
    }
    finalStream.destroy(error);
  });
  mimicResponse(response, finalStream);
  response.pipe(checker).pipe(decompressStream).pipe(finalStream);
  return finalStream;
};
class QuickLRU$2 {
  constructor(options = {}) {
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      if (typeof this.onEviction === "function") {
        for (const [key2, value2] of this.oldCache.entries()) {
          this.onEviction(key2, value2);
        }
      }
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      const value = this.oldCache.get(key);
      this.oldCache.delete(key);
      this._set(key, value);
      return value;
    }
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.set(key, value);
    } else {
      this._set(key, value);
    }
    return this;
  }
  has(key) {
    return this.cache.has(key) || this.oldCache.has(key);
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      return this.oldCache.get(key);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      yield item;
    }
    for (const item of this.oldCache) {
      const [key] = item;
      if (!this.cache.has(key)) {
        yield item;
      }
    }
  }
  get size() {
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
}
var quickLru = QuickLRU$2;
const EventEmitter$2 = events$1.exports;
const tls$1 = require$$1$2;
const http2$2 = require$$0$4;
const QuickLRU$1 = quickLru;
const kCurrentStreamsCount = Symbol("currentStreamsCount");
const kRequest = Symbol("request");
const kOriginSet = Symbol("cachedOriginSet");
const kGracefullyClosing = Symbol("gracefullyClosing");
const nameKeys = [
  "maxDeflateDynamicTableSize",
  "maxSessionMemory",
  "maxHeaderListPairs",
  "maxOutstandingPings",
  "maxReservedRemoteStreams",
  "maxSendHeaderBlockLength",
  "paddingStrategy",
  "localAddress",
  "path",
  "rejectUnauthorized",
  "minDHSize",
  "ca",
  "cert",
  "clientCertEngine",
  "ciphers",
  "key",
  "pfx",
  "servername",
  "minVersion",
  "maxVersion",
  "secureProtocol",
  "crl",
  "honorCipherOrder",
  "ecdhCurve",
  "dhparam",
  "secureOptions",
  "sessionIdContext"
];
const getSortedIndex = (array, value, compare) => {
  let low = 0;
  let high = array.length;
  while (low < high) {
    const mid = low + high >>> 1;
    if (compare(array[mid], value)) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
};
const compareSessions = (a, b) => {
  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
};
const closeCoveredSessions = (where, session) => {
  for (const coveredSession of where) {
    if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
      gracefullyClose(coveredSession);
    }
  }
};
const closeSessionIfCovered = (where, coveredSession) => {
  for (const session of where) {
    if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
      gracefullyClose(coveredSession);
    }
  }
};
const getSessions = ({ agent: agent2, isFree }) => {
  const result = {};
  for (const normalizedOptions in agent2.sessions) {
    const sessions = agent2.sessions[normalizedOptions];
    const filtered = sessions.filter((session) => {
      const result2 = session[Agent$1.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
      return isFree ? result2 : !result2;
    });
    if (filtered.length !== 0) {
      result[normalizedOptions] = filtered;
    }
  }
  return result;
};
const gracefullyClose = (session) => {
  session[kGracefullyClosing] = true;
  if (session[kCurrentStreamsCount] === 0) {
    session.close();
  }
};
class Agent$1 extends EventEmitter$2 {
  constructor({ timeout = 6e4, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100 } = {}) {
    super();
    this.sessions = {};
    this.queue = {};
    this.timeout = timeout;
    this.maxSessions = maxSessions;
    this.maxFreeSessions = maxFreeSessions;
    this._freeSessionsCount = 0;
    this._sessionsCount = 0;
    this.settings = {
      enablePush: false
    };
    this.tlsSessionCache = new QuickLRU$1({ maxSize: maxCachedTlsSessions });
  }
  static normalizeOrigin(url2, servername) {
    if (typeof url2 === "string") {
      url2 = new URL(url2);
    }
    if (servername && url2.hostname !== servername) {
      url2.hostname = servername;
    }
    return url2.origin;
  }
  normalizeOptions(options) {
    let normalized = "";
    if (options) {
      for (const key of nameKeys) {
        if (options[key]) {
          normalized += `:${options[key]}`;
        }
      }
    }
    return normalized;
  }
  _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
    if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
      return;
    }
    const item = this.queue[normalizedOptions][normalizedOrigin];
    if (this._sessionsCount < this.maxSessions && !item.completed) {
      item.completed = true;
      item();
    }
  }
  getSession(origin, options, listeners2) {
    return new Promise((resolve2, reject) => {
      if (Array.isArray(listeners2)) {
        listeners2 = [...listeners2];
        resolve2();
      } else {
        listeners2 = [{ resolve: resolve2, reject }];
      }
      const normalizedOptions = this.normalizeOptions(options);
      const normalizedOrigin = Agent$1.normalizeOrigin(origin, options && options.servername);
      if (normalizedOrigin === void 0) {
        for (const { reject: reject2 } of listeners2) {
          reject2(new TypeError("The `origin` argument needs to be a string or an URL object"));
        }
        return;
      }
      if (normalizedOptions in this.sessions) {
        const sessions = this.sessions[normalizedOptions];
        let maxConcurrentStreams = -1;
        let currentStreamsCount = -1;
        let optimalSession;
        for (const session of sessions) {
          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
            break;
          }
          if (session[kOriginSet].includes(normalizedOrigin)) {
            const sessionCurrentStreamsCount = session[kCurrentStreamsCount];
            if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
              continue;
            }
            if (!optimalSession) {
              maxConcurrentStreams = sessionMaxConcurrentStreams;
            }
            if (sessionCurrentStreamsCount > currentStreamsCount) {
              optimalSession = session;
              currentStreamsCount = sessionCurrentStreamsCount;
            }
          }
        }
        if (optimalSession) {
          if (listeners2.length !== 1) {
            for (const { reject: reject2 } of listeners2) {
              const error = new Error(`Expected the length of listeners to be 1, got ${listeners2.length}.
Please report this to https://github.com/szmarczak/http2-wrapper/`);
              reject2(error);
            }
            return;
          }
          listeners2[0].resolve(optimalSession);
          return;
        }
      }
      if (normalizedOptions in this.queue) {
        if (normalizedOrigin in this.queue[normalizedOptions]) {
          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners2);
          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
          return;
        }
      } else {
        this.queue[normalizedOptions] = {};
      }
      const removeFromQueue = () => {
        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry2) {
          delete this.queue[normalizedOptions][normalizedOrigin];
          if (Object.keys(this.queue[normalizedOptions]).length === 0) {
            delete this.queue[normalizedOptions];
          }
        }
      };
      const entry2 = () => {
        const name = `${normalizedOrigin}:${normalizedOptions}`;
        let receivedSettings = false;
        try {
          const session = http2$2.connect(origin, {
            createConnection: this.createConnection,
            settings: this.settings,
            session: this.tlsSessionCache.get(name),
            ...options
          });
          session[kCurrentStreamsCount] = 0;
          session[kGracefullyClosing] = false;
          const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
          let wasFree = true;
          session.socket.once("session", (tlsSession) => {
            this.tlsSessionCache.set(name, tlsSession);
          });
          session.once("error", (error) => {
            for (const { reject: reject2 } of listeners2) {
              reject2(error);
            }
            this.tlsSessionCache.delete(name);
          });
          session.setTimeout(this.timeout, () => {
            session.destroy();
          });
          session.once("close", () => {
            if (receivedSettings) {
              if (wasFree) {
                this._freeSessionsCount--;
              }
              this._sessionsCount--;
              const where = this.sessions[normalizedOptions];
              where.splice(where.indexOf(session), 1);
              if (where.length === 0) {
                delete this.sessions[normalizedOptions];
              }
            } else {
              const error = new Error("Session closed without receiving a SETTINGS frame");
              error.code = "HTTP2WRAPPER_NOSETTINGS";
              for (const { reject: reject2 } of listeners2) {
                reject2(error);
              }
              removeFromQueue();
            }
            this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
          });
          const processListeners = () => {
            if (!(normalizedOptions in this.queue) || !isFree()) {
              return;
            }
            for (const origin2 of session[kOriginSet]) {
              if (origin2 in this.queue[normalizedOptions]) {
                const { listeners: listeners3 } = this.queue[normalizedOptions][origin2];
                while (listeners3.length !== 0 && isFree()) {
                  listeners3.shift().resolve(session);
                }
                const where = this.queue[normalizedOptions];
                if (where[origin2].listeners.length === 0) {
                  delete where[origin2];
                  if (Object.keys(where).length === 0) {
                    delete this.queue[normalizedOptions];
                    break;
                  }
                }
                if (!isFree()) {
                  break;
                }
              }
            }
          };
          session.on("origin", () => {
            session[kOriginSet] = session.originSet;
            if (!isFree()) {
              return;
            }
            processListeners();
            closeCoveredSessions(this.sessions[normalizedOptions], session);
          });
          session.once("remoteSettings", () => {
            session.ref();
            session.unref();
            this._sessionsCount++;
            if (entry2.destroyed) {
              const error = new Error("Agent has been destroyed");
              for (const listener of listeners2) {
                listener.reject(error);
              }
              session.destroy();
              return;
            }
            session[kOriginSet] = session.originSet;
            {
              const where = this.sessions;
              if (normalizedOptions in where) {
                const sessions = where[normalizedOptions];
                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
              } else {
                where[normalizedOptions] = [session];
              }
            }
            this._freeSessionsCount += 1;
            receivedSettings = true;
            this.emit("session", session);
            processListeners();
            removeFromQueue();
            if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
              session.close();
            }
            if (listeners2.length !== 0) {
              this.getSession(normalizedOrigin, options, listeners2);
              listeners2.length = 0;
            }
            session.on("remoteSettings", () => {
              processListeners();
              closeCoveredSessions(this.sessions[normalizedOptions], session);
            });
          });
          session[kRequest] = session.request;
          session.request = (headers, streamOptions) => {
            if (session[kGracefullyClosing]) {
              throw new Error("The session is gracefully closing. No new streams are allowed.");
            }
            const stream = session[kRequest](headers, streamOptions);
            session.ref();
            ++session[kCurrentStreamsCount];
            if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
              this._freeSessionsCount--;
            }
            stream.once("close", () => {
              wasFree = isFree();
              --session[kCurrentStreamsCount];
              if (!session.destroyed && !session.closed) {
                closeSessionIfCovered(this.sessions[normalizedOptions], session);
                if (isFree() && !session.closed) {
                  if (!wasFree) {
                    this._freeSessionsCount++;
                    wasFree = true;
                  }
                  const isEmpty = session[kCurrentStreamsCount] === 0;
                  if (isEmpty) {
                    session.unref();
                  }
                  if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {
                    session.close();
                  } else {
                    closeCoveredSessions(this.sessions[normalizedOptions], session);
                    processListeners();
                  }
                }
              }
            });
            return stream;
          };
        } catch (error) {
          for (const listener of listeners2) {
            listener.reject(error);
          }
          removeFromQueue();
        }
      };
      entry2.listeners = listeners2;
      entry2.completed = false;
      entry2.destroyed = false;
      this.queue[normalizedOptions][normalizedOrigin] = entry2;
      this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
    });
  }
  request(origin, options, headers, streamOptions) {
    return new Promise((resolve2, reject) => {
      this.getSession(origin, options, [{
        reject,
        resolve: (session) => {
          try {
            resolve2(session.request(headers, streamOptions));
          } catch (error) {
            reject(error);
          }
        }
      }]);
    });
  }
  createConnection(origin, options) {
    return Agent$1.connect(origin, options);
  }
  static connect(origin, options) {
    options.ALPNProtocols = ["h2"];
    const port = origin.port || 443;
    const host = origin.hostname || origin.host;
    if (typeof options.servername === "undefined") {
      options.servername = host;
    }
    return tls$1.connect(port, host, options);
  }
  closeFreeSessions() {
    for (const sessions of Object.values(this.sessions)) {
      for (const session of sessions) {
        if (session[kCurrentStreamsCount] === 0) {
          session.close();
        }
      }
    }
  }
  destroy(reason) {
    for (const sessions of Object.values(this.sessions)) {
      for (const session of sessions) {
        session.destroy(reason);
      }
    }
    for (const entriesOfAuthority of Object.values(this.queue)) {
      for (const entry2 of Object.values(entriesOfAuthority)) {
        entry2.destroyed = true;
      }
    }
    this.queue = {};
  }
  get freeSessions() {
    return getSessions({ agent: this, isFree: true });
  }
  get busySessions() {
    return getSessions({ agent: this, isFree: false });
  }
}
Agent$1.kCurrentStreamsCount = kCurrentStreamsCount;
Agent$1.kGracefullyClosing = kGracefullyClosing;
var agent$1 = {
  Agent: Agent$1,
  globalAgent: new Agent$1()
};
const { Readable } = require$$0$2__default;
class IncomingMessage$2 extends Readable {
  constructor(socket, highWaterMark) {
    super({
      highWaterMark,
      autoDestroy: false
    });
    this.statusCode = null;
    this.statusMessage = "";
    this.httpVersion = "2.0";
    this.httpVersionMajor = 2;
    this.httpVersionMinor = 0;
    this.headers = {};
    this.trailers = {};
    this.req = null;
    this.aborted = false;
    this.complete = false;
    this.upgrade = null;
    this.rawHeaders = [];
    this.rawTrailers = [];
    this.socket = socket;
    this.connection = socket;
    this._dumped = false;
  }
  _destroy(error) {
    this.req._request.destroy(error);
  }
  setTimeout(ms, callback2) {
    this.req.setTimeout(ms, callback2);
    return this;
  }
  _dump() {
    if (!this._dumped) {
      this._dumped = true;
      this.removeAllListeners("data");
      this.resume();
    }
  }
  _read() {
    if (this.req) {
      this.req._request.resume();
    }
  }
}
var incomingMessage = IncomingMessage$2;
var urlToOptions$3 = (url2) => {
  const options = {
    protocol: url2.protocol,
    hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
    host: url2.host,
    hash: url2.hash,
    search: url2.search,
    pathname: url2.pathname,
    href: url2.href,
    path: `${url2.pathname || ""}${url2.search || ""}`
  };
  if (typeof url2.port === "string" && url2.port.length !== 0) {
    options.port = Number(url2.port);
  }
  if (url2.username || url2.password) {
    options.auth = `${url2.username || ""}:${url2.password || ""}`;
  }
  return options;
};
var proxyEvents$2 = (from2, to2, events2) => {
  for (const event of events2) {
    from2.on(event, (...args) => to2.emit(event, ...args));
  }
};
var isRequestPseudoHeader$1 = (header) => {
  switch (header) {
    case ":method":
    case ":scheme":
    case ":authority":
    case ":path":
      return true;
    default:
      return false;
  }
};
var errors = { exports: {} };
(function(module) {
  const makeError = (Base2, key, getMessage) => {
    module.exports[key] = class NodeError extends Base2 {
      constructor(...args) {
        super(typeof getMessage === "string" ? getMessage : getMessage(args));
        this.name = `${super.name} [${key}]`;
        this.code = key;
      }
    };
  };
  makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
    const type = args[0].includes(".") ? "property" : "argument";
    let valid = args[1];
    const isManyTypes = Array.isArray(valid);
    if (isManyTypes) {
      valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
    }
    return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
  });
  makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
    return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
  });
  makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
    return `Cannot ${args[0]} headers after they are sent to the client`;
  });
  makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
    return `${args[0]} must be a valid HTTP token [${args[1]}]`;
  });
  makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
    return `Invalid value "${args[0]} for header "${args[1]}"`;
  });
  makeError(TypeError, "ERR_INVALID_CHAR", (args) => {
    return `Invalid character in ${args[0]} [${args[1]}]`;
  });
})(errors);
const http2$1 = require$$0$4;
const { Writable } = require$$0$2__default;
const { Agent, globalAgent } = agent$1;
const IncomingMessage$1 = incomingMessage;
const urlToOptions$2 = urlToOptions$3;
const proxyEvents$1 = proxyEvents$2;
const isRequestPseudoHeader = isRequestPseudoHeader$1;
const {
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_PROTOCOL,
  ERR_HTTP_HEADERS_SENT,
  ERR_INVALID_HTTP_TOKEN,
  ERR_HTTP_INVALID_HEADER_VALUE,
  ERR_INVALID_CHAR
} = errors.exports;
const {
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_METHOD_CONNECT
} = http2$1.constants;
const kHeaders = Symbol("headers");
const kOrigin = Symbol("origin");
const kSession = Symbol("session");
const kOptions = Symbol("options");
const kFlushedHeaders = Symbol("flushedHeaders");
const kJobs = Symbol("jobs");
const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
class ClientRequest$1 extends Writable {
  constructor(input, options, callback2) {
    super({
      autoDestroy: false
    });
    const hasInput = typeof input === "string" || input instanceof URL;
    if (hasInput) {
      input = urlToOptions$2(input instanceof URL ? input : new URL(input));
    }
    if (typeof options === "function" || options === void 0) {
      callback2 = options;
      options = hasInput ? input : { ...input };
    } else {
      options = { ...input, ...options };
    }
    if (options.h2session) {
      this[kSession] = options.h2session;
    } else if (options.agent === false) {
      this.agent = new Agent({ maxFreeSessions: 0 });
    } else if (typeof options.agent === "undefined" || options.agent === null) {
      if (typeof options.createConnection === "function") {
        this.agent = new Agent({ maxFreeSessions: 0 });
        this.agent.createConnection = options.createConnection;
      } else {
        this.agent = globalAgent;
      }
    } else if (typeof options.agent.request === "function") {
      this.agent = options.agent;
    } else {
      throw new ERR_INVALID_ARG_TYPE("options.agent", ["Agent-like Object", "undefined", "false"], options.agent);
    }
    if (options.protocol && options.protocol !== "https:") {
      throw new ERR_INVALID_PROTOCOL(options.protocol, "https:");
    }
    const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;
    const host = options.hostname || options.host || "localhost";
    delete options.hostname;
    delete options.host;
    delete options.port;
    const { timeout } = options;
    options.timeout = void 0;
    this[kHeaders] = /* @__PURE__ */ Object.create(null);
    this[kJobs] = [];
    this.socket = null;
    this.connection = null;
    this.method = options.method || "GET";
    this.path = options.path;
    this.res = null;
    this.aborted = false;
    this.reusedSocket = false;
    if (options.headers) {
      for (const [header, value] of Object.entries(options.headers)) {
        this.setHeader(header, value);
      }
    }
    if (options.auth && !("authorization" in this[kHeaders])) {
      this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
    }
    options.session = options.tlsSession;
    options.path = options.socketPath;
    this[kOptions] = options;
    if (port === 443) {
      this[kOrigin] = `https://${host}`;
      if (!(":authority" in this[kHeaders])) {
        this[kHeaders][":authority"] = host;
      }
    } else {
      this[kOrigin] = `https://${host}:${port}`;
      if (!(":authority" in this[kHeaders])) {
        this[kHeaders][":authority"] = `${host}:${port}`;
      }
    }
    if (timeout) {
      this.setTimeout(timeout);
    }
    if (callback2) {
      this.once("response", callback2);
    }
    this[kFlushedHeaders] = false;
  }
  get method() {
    return this[kHeaders][HTTP2_HEADER_METHOD];
  }
  set method(value) {
    if (value) {
      this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
    }
  }
  get path() {
    return this[kHeaders][HTTP2_HEADER_PATH];
  }
  set path(value) {
    if (value) {
      this[kHeaders][HTTP2_HEADER_PATH] = value;
    }
  }
  get _mustNotHaveABody() {
    return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
  }
  _write(chunk, encoding, callback2) {
    if (this._mustNotHaveABody) {
      callback2(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
      return;
    }
    this.flushHeaders();
    const callWrite = () => this._request.write(chunk, encoding, callback2);
    if (this._request) {
      callWrite();
    } else {
      this[kJobs].push(callWrite);
    }
  }
  _final(callback2) {
    if (this.destroyed) {
      return;
    }
    this.flushHeaders();
    const callEnd = () => {
      if (this._mustNotHaveABody) {
        callback2();
        return;
      }
      this._request.end(callback2);
    };
    if (this._request) {
      callEnd();
    } else {
      this[kJobs].push(callEnd);
    }
  }
  abort() {
    if (this.res && this.res.complete) {
      return;
    }
    if (!this.aborted) {
      process.nextTick(() => this.emit("abort"));
    }
    this.aborted = true;
    this.destroy();
  }
  _destroy(error, callback2) {
    if (this.res) {
      this.res._dump();
    }
    if (this._request) {
      this._request.destroy();
    }
    callback2(error);
  }
  async flushHeaders() {
    if (this[kFlushedHeaders] || this.destroyed) {
      return;
    }
    this[kFlushedHeaders] = true;
    const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
    const onStream = (stream) => {
      this._request = stream;
      if (this.destroyed) {
        stream.destroy();
        return;
      }
      if (!isConnectMethod) {
        proxyEvents$1(stream, this, ["timeout", "continue", "close", "error"]);
      }
      const waitForEnd = (fn) => {
        return (...args) => {
          if (!this.writable && !this.destroyed) {
            fn(...args);
          } else {
            this.once("finish", () => {
              fn(...args);
            });
          }
        };
      };
      stream.once("response", waitForEnd((headers, flags, rawHeaders) => {
        const response = new IncomingMessage$1(this.socket, stream.readableHighWaterMark);
        this.res = response;
        response.req = this;
        response.statusCode = headers[HTTP2_HEADER_STATUS];
        response.headers = headers;
        response.rawHeaders = rawHeaders;
        response.once("end", () => {
          if (this.aborted) {
            response.aborted = true;
            response.emit("aborted");
          } else {
            response.complete = true;
            response.socket = null;
            response.connection = null;
          }
        });
        if (isConnectMethod) {
          response.upgrade = true;
          if (this.emit("connect", response, stream, Buffer.alloc(0))) {
            this.emit("close");
          } else {
            stream.destroy();
          }
        } else {
          stream.on("data", (chunk) => {
            if (!response._dumped && !response.push(chunk)) {
              stream.pause();
            }
          });
          stream.once("end", () => {
            response.push(null);
          });
          if (!this.emit("response", response)) {
            response._dump();
          }
        }
      }));
      stream.once("headers", waitForEnd((headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] })));
      stream.once("trailers", waitForEnd((trailers, flags, rawTrailers) => {
        const { res } = this;
        res.trailers = trailers;
        res.rawTrailers = rawTrailers;
      }));
      const { socket } = stream.session;
      this.socket = socket;
      this.connection = socket;
      for (const job of this[kJobs]) {
        job();
      }
      this.emit("socket", this.socket);
    };
    if (this[kSession]) {
      try {
        onStream(this[kSession].request(this[kHeaders]));
      } catch (error) {
        this.emit("error", error);
      }
    } else {
      this.reusedSocket = true;
      try {
        onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
      } catch (error) {
        this.emit("error", error);
      }
    }
  }
  getHeader(name) {
    if (typeof name !== "string") {
      throw new ERR_INVALID_ARG_TYPE("name", "string", name);
    }
    return this[kHeaders][name.toLowerCase()];
  }
  get headersSent() {
    return this[kFlushedHeaders];
  }
  removeHeader(name) {
    if (typeof name !== "string") {
      throw new ERR_INVALID_ARG_TYPE("name", "string", name);
    }
    if (this.headersSent) {
      throw new ERR_HTTP_HEADERS_SENT("remove");
    }
    delete this[kHeaders][name.toLowerCase()];
  }
  setHeader(name, value) {
    if (this.headersSent) {
      throw new ERR_HTTP_HEADERS_SENT("set");
    }
    if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
      throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
    }
    if (typeof value === "undefined") {
      throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
    }
    if (isInvalidHeaderValue.test(value)) {
      throw new ERR_INVALID_CHAR("header content", name);
    }
    this[kHeaders][name.toLowerCase()] = value;
  }
  setNoDelay() {
  }
  setSocketKeepAlive() {
  }
  setTimeout(ms, callback2) {
    const applyTimeout = () => this._request.setTimeout(ms, callback2);
    if (this._request) {
      applyTimeout();
    } else {
      this[kJobs].push(applyTimeout);
    }
    return this;
  }
  get maxHeadersCount() {
    if (!this.destroyed && this._request) {
      return this._request.session.localSettings.maxHeaderListSize;
    }
    return void 0;
  }
  set maxHeadersCount(_value) {
  }
}
var clientRequest = ClientRequest$1;
var auto$1 = { exports: {} };
const tls = require$$1$2;
var resolveAlpn = (options = {}, connect = tls.connect) => new Promise((resolve2, reject) => {
  let timeout = false;
  let socket;
  const callback2 = async () => {
    await socketPromise;
    socket.off("timeout", onTimeout);
    socket.off("error", reject);
    if (options.resolveSocket) {
      resolve2({ alpnProtocol: socket.alpnProtocol, socket, timeout });
      if (timeout) {
        await Promise.resolve();
        socket.emit("timeout");
      }
    } else {
      socket.destroy();
      resolve2({ alpnProtocol: socket.alpnProtocol, timeout });
    }
  };
  const onTimeout = async () => {
    timeout = true;
    callback2();
  };
  const socketPromise = (async () => {
    try {
      socket = await connect(options, callback2);
      socket.on("error", reject);
      socket.once("timeout", onTimeout);
    } catch (error) {
      reject(error);
    }
  })();
});
const net$1 = require$$0$5;
var calculateServerName$1 = (options) => {
  let servername = options.host;
  const hostHeader = options.headers && options.headers.host;
  if (hostHeader) {
    if (hostHeader.startsWith("[")) {
      const index2 = hostHeader.indexOf("]");
      if (index2 === -1) {
        servername = hostHeader;
      } else {
        servername = hostHeader.slice(1, -1);
      }
    } else {
      servername = hostHeader.split(":", 1)[0];
    }
  }
  if (net$1.isIP(servername)) {
    return "";
  }
  return servername;
};
const http$1 = require$$4;
const https$1 = require$$1$3;
const resolveALPN = resolveAlpn;
const QuickLRU = quickLru;
const Http2ClientRequest = clientRequest;
const calculateServerName = calculateServerName$1;
const urlToOptions$1 = urlToOptions$3;
const cache = new QuickLRU({ maxSize: 100 });
const queue = /* @__PURE__ */ new Map();
const installSocket = (agent2, socket, options) => {
  socket._httpMessage = { shouldKeepAlive: true };
  const onFree = () => {
    agent2.emit("free", socket, options);
  };
  socket.on("free", onFree);
  const onClose = () => {
    agent2.removeSocket(socket, options);
  };
  socket.on("close", onClose);
  const onRemove = () => {
    agent2.removeSocket(socket, options);
    socket.off("close", onClose);
    socket.off("free", onFree);
    socket.off("agentRemove", onRemove);
  };
  socket.on("agentRemove", onRemove);
  agent2.emit("free", socket, options);
};
const resolveProtocol = async (options) => {
  const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
  if (!cache.has(name)) {
    if (queue.has(name)) {
      const result = await queue.get(name);
      return result.alpnProtocol;
    }
    const { path: path2, agent: agent2 } = options;
    options.path = options.socketPath;
    const resultPromise = resolveALPN(options);
    queue.set(name, resultPromise);
    try {
      const { socket, alpnProtocol } = await resultPromise;
      cache.set(name, alpnProtocol);
      options.path = path2;
      if (alpnProtocol === "h2") {
        socket.destroy();
      } else {
        const { globalAgent: globalAgent2 } = https$1;
        const defaultCreateConnection = https$1.Agent.prototype.createConnection;
        if (agent2) {
          if (agent2.createConnection === defaultCreateConnection) {
            installSocket(agent2, socket, options);
          } else {
            socket.destroy();
          }
        } else if (globalAgent2.createConnection === defaultCreateConnection) {
          installSocket(globalAgent2, socket, options);
        } else {
          socket.destroy();
        }
      }
      queue.delete(name);
      return alpnProtocol;
    } catch (error) {
      queue.delete(name);
      throw error;
    }
  }
  return cache.get(name);
};
auto$1.exports = async (input, options, callback2) => {
  if (typeof input === "string" || input instanceof URL) {
    input = urlToOptions$1(new URL(input));
  }
  if (typeof options === "function") {
    callback2 = options;
    options = void 0;
  }
  options = {
    ALPNProtocols: ["h2", "http/1.1"],
    ...input,
    ...options,
    resolveSocket: true
  };
  if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
    throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
  }
  options.protocol = options.protocol || "https:";
  const isHttps = options.protocol === "https:";
  options.host = options.hostname || options.host || "localhost";
  options.session = options.tlsSession;
  options.servername = options.servername || calculateServerName(options);
  options.port = options.port || (isHttps ? 443 : 80);
  options._defaultAgent = isHttps ? https$1.globalAgent : http$1.globalAgent;
  const agents = options.agent;
  if (agents) {
    if (agents.addRequest) {
      throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");
    }
    options.agent = agents[isHttps ? "https" : "http"];
  }
  if (isHttps) {
    const protocol = await resolveProtocol(options);
    if (protocol === "h2") {
      if (agents) {
        options.agent = agents.http2;
      }
      return new Http2ClientRequest(options, callback2);
    }
  }
  return http$1.request(options, callback2);
};
auto$1.exports.protocolCache = cache;
const http2 = require$$0$4;
const agent = agent$1;
const ClientRequest = clientRequest;
const IncomingMessage = incomingMessage;
const auto = auto$1.exports;
const request = (url2, options, callback2) => {
  return new ClientRequest(url2, options, callback2);
};
const get = (url2, options, callback2) => {
  const req = new ClientRequest(url2, options, callback2);
  req.end();
  return req;
};
var source = {
  ...http2,
  ClientRequest,
  IncomingMessage,
  ...agent,
  request,
  get,
  auto
};
var getBodySize = {};
var isFormData = {};
Object.defineProperty(isFormData, "__esModule", { value: true });
const is_1$4 = dist$1.exports;
isFormData.default = (body) => is_1$4.default.nodeStream(body) && is_1$4.default.function_(body.getBoundary);
Object.defineProperty(getBodySize, "__esModule", { value: true });
const fs_1 = require$$2$1;
const util_1 = require$$1;
const is_1$3 = dist$1.exports;
const is_form_data_1 = isFormData;
const statAsync = util_1.promisify(fs_1.stat);
getBodySize.default = async (body, headers) => {
  if (headers && "content-length" in headers) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (is_1$3.default.string(body)) {
    return Buffer.byteLength(body);
  }
  if (is_1$3.default.buffer(body)) {
    return body.length;
  }
  if (is_form_data_1.default(body)) {
    return util_1.promisify(body.getLength.bind(body))();
  }
  if (body instanceof fs_1.ReadStream) {
    const { size } = await statAsync(body.path);
    if (size === 0) {
      return void 0;
    }
    return size;
  }
  return void 0;
};
var proxyEvents = {};
Object.defineProperty(proxyEvents, "__esModule", { value: true });
function default_1(from2, to2, events2) {
  const fns = {};
  for (const event of events2) {
    fns[event] = (...args) => {
      to2.emit(event, ...args);
    };
    from2.on(event, fns[event]);
  }
  return () => {
    for (const event of events2) {
      from2.off(event, fns[event]);
    }
  };
}
proxyEvents.default = default_1;
var timedOut = {};
var unhandle = {};
Object.defineProperty(unhandle, "__esModule", { value: true });
unhandle.default = () => {
  const handlers = [];
  return {
    once(origin, event, fn) {
      origin.once(event, fn);
      handlers.push({ origin, event, fn });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
};
Object.defineProperty(timedOut, "__esModule", { value: true });
timedOut.TimeoutError = void 0;
const net = require$$0$5;
const unhandle_1 = unhandle;
const reentry = Symbol("reentry");
const noop = () => {
};
class TimeoutError extends Error {
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    this.event = event;
    this.name = "TimeoutError";
    this.code = "ETIMEDOUT";
  }
}
timedOut.TimeoutError = TimeoutError;
timedOut.default = (request2, delays, options) => {
  if (reentry in request2) {
    return noop;
  }
  request2[reentry] = true;
  const cancelers = [];
  const { once: once3, unhandleAll } = unhandle_1.default();
  const addTimeout = (delay, callback2, event) => {
    var _a;
    const timeout = setTimeout(callback2, delay, delay, event);
    (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
    const cancel = () => {
      clearTimeout(timeout);
    };
    cancelers.push(cancel);
    return cancel;
  };
  const { host, hostname } = options;
  const timeoutHandler = (delay, event) => {
    request2.destroy(new TimeoutError(delay, event));
  };
  const cancelTimeouts = () => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  };
  request2.once("error", (error) => {
    cancelTimeouts();
    if (request2.listenerCount("error") === 0) {
      throw error;
    }
  });
  request2.once("close", cancelTimeouts);
  once3(request2, "response", (response) => {
    once3(response, "end", cancelTimeouts);
  });
  if (typeof delays.request !== "undefined") {
    addTimeout(delays.request, timeoutHandler, "request");
  }
  if (typeof delays.socket !== "undefined") {
    const socketTimeoutHandler = () => {
      timeoutHandler(delays.socket, "socket");
    };
    request2.setTimeout(delays.socket, socketTimeoutHandler);
    cancelers.push(() => {
      request2.removeListener("timeout", socketTimeoutHandler);
    });
  }
  once3(request2, "socket", (socket) => {
    var _a;
    const { socketPath } = request2;
    if (socket.connecting) {
      const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : "") !== 0);
      if (typeof delays.lookup !== "undefined" && !hasPath && typeof socket.address().address === "undefined") {
        const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
        once3(socket, "lookup", cancelTimeout);
      }
      if (typeof delays.connect !== "undefined") {
        const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
        if (hasPath) {
          once3(socket, "connect", timeConnect());
        } else {
          once3(socket, "lookup", (error) => {
            if (error === null) {
              once3(socket, "connect", timeConnect());
            }
          });
        }
      }
      if (typeof delays.secureConnect !== "undefined" && options.protocol === "https:") {
        once3(socket, "connect", () => {
          const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
          once3(socket, "secureConnect", cancelTimeout);
        });
      }
    }
    if (typeof delays.send !== "undefined") {
      const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
      if (socket.connecting) {
        once3(socket, "connect", () => {
          once3(request2, "upload-complete", timeRequest());
        });
      } else {
        once3(request2, "upload-complete", timeRequest());
      }
    }
  });
  if (typeof delays.response !== "undefined") {
    once3(request2, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once3(request2, "response", cancelTimeout);
    });
  }
  return cancelTimeouts;
};
var urlToOptions = {};
Object.defineProperty(urlToOptions, "__esModule", { value: true });
const is_1$2 = dist$1.exports;
urlToOptions.default = (url2) => {
  url2 = url2;
  const options = {
    protocol: url2.protocol,
    hostname: is_1$2.default.string(url2.hostname) && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
    host: url2.host,
    hash: url2.hash,
    search: url2.search,
    pathname: url2.pathname,
    href: url2.href,
    path: `${url2.pathname || ""}${url2.search || ""}`
  };
  if (is_1$2.default.string(url2.port) && url2.port.length > 0) {
    options.port = Number(url2.port);
  }
  if (url2.username || url2.password) {
    options.auth = `${url2.username || ""}:${url2.password || ""}`;
  }
  return options;
};
var optionsToUrl = {};
Object.defineProperty(optionsToUrl, "__esModule", { value: true });
const url_1 = require$$0$3;
const keys = [
  "protocol",
  "host",
  "hostname",
  "port",
  "pathname",
  "search"
];
optionsToUrl.default = (origin, options) => {
  var _a, _b;
  if (options.path) {
    if (options.pathname) {
      throw new TypeError("Parameters `path` and `pathname` are mutually exclusive.");
    }
    if (options.search) {
      throw new TypeError("Parameters `path` and `search` are mutually exclusive.");
    }
    if (options.searchParams) {
      throw new TypeError("Parameters `path` and `searchParams` are mutually exclusive.");
    }
  }
  if (options.search && options.searchParams) {
    throw new TypeError("Parameters `search` and `searchParams` are mutually exclusive.");
  }
  if (!origin) {
    if (!options.protocol) {
      throw new TypeError("No URL protocol specified");
    }
    origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ""}`;
  }
  const url2 = new url_1.URL(origin);
  if (options.path) {
    const searchIndex = options.path.indexOf("?");
    if (searchIndex === -1) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.slice(0, searchIndex);
      options.search = options.path.slice(searchIndex + 1);
    }
    delete options.path;
  }
  for (const key of keys) {
    if (options[key]) {
      url2[key] = options[key].toString();
    }
  }
  return url2;
};
var weakableMap = {};
Object.defineProperty(weakableMap, "__esModule", { value: true });
class WeakableMap {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
    this.map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
}
weakableMap.default = WeakableMap;
var getBuffer$1 = {};
Object.defineProperty(getBuffer$1, "__esModule", { value: true });
const getBuffer = async (stream) => {
  const chunks = [];
  let length = 0;
  for await (const chunk of stream) {
    chunks.push(chunk);
    length += Buffer.byteLength(chunk);
  }
  if (Buffer.isBuffer(chunks[0])) {
    return Buffer.concat(chunks, length);
  }
  return Buffer.from(chunks.join(""));
};
getBuffer$1.default = getBuffer;
var dnsIpVersion = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
  const conversionTable = {
    auto: 0,
    ipv4: 4,
    ipv6: 6
  };
  exports.isDnsLookupIpVersion = (value) => {
    return value in conversionTable;
  };
  exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
      return conversionTable[dnsLookupIpVersion];
    }
    throw new Error("Invalid DNS lookup IP version");
  };
})(dnsIpVersion);
var isResponseOk = {};
Object.defineProperty(isResponseOk, "__esModule", { value: true });
isResponseOk.isResponseOk = void 0;
isResponseOk.isResponseOk = (response) => {
  const { statusCode } = response;
  const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
var deprecationWarning = {};
Object.defineProperty(deprecationWarning, "__esModule", { value: true });
const alreadyWarned = /* @__PURE__ */ new Set();
deprecationWarning.default = (message) => {
  if (alreadyWarned.has(message)) {
    return;
  }
  alreadyWarned.add(message);
  process.emitWarning(`Got: ${message}`, {
    type: "DeprecationWarning"
  });
};
var normalizeArguments$1 = {};
Object.defineProperty(normalizeArguments$1, "__esModule", { value: true });
const is_1$1 = dist$1.exports;
const normalizeArguments = (options, defaults2) => {
  if (is_1$1.default.null_(options.encoding)) {
    throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
  }
  is_1$1.assert.any([is_1$1.default.string, is_1$1.default.undefined], options.encoding);
  is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.resolveBodyOnly);
  is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.methodRewriting);
  is_1$1.assert.any([is_1$1.default.boolean, is_1$1.default.undefined], options.isStream);
  is_1$1.assert.any([is_1$1.default.string, is_1$1.default.undefined], options.responseType);
  if (options.responseType === void 0) {
    options.responseType = "text";
  }
  const { retry } = options;
  if (defaults2) {
    options.retry = { ...defaults2.retry };
  } else {
    options.retry = {
      calculateDelay: (retryObject) => retryObject.computedValue,
      limit: 0,
      methods: [],
      statusCodes: [],
      errorCodes: [],
      maxRetryAfter: void 0
    };
  }
  if (is_1$1.default.object(retry)) {
    options.retry = {
      ...options.retry,
      ...retry
    };
    options.retry.methods = [...new Set(options.retry.methods.map((method) => method.toUpperCase()))];
    options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
    options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
  } else if (is_1$1.default.number(retry)) {
    options.retry.limit = retry;
  }
  if (is_1$1.default.undefined(options.retry.maxRetryAfter)) {
    options.retry.maxRetryAfter = Math.min(...[options.timeout.request, options.timeout.connect].filter(is_1$1.default.number));
  }
  if (is_1$1.default.object(options.pagination)) {
    if (defaults2) {
      options.pagination = {
        ...defaults2.pagination,
        ...options.pagination
      };
    }
    const { pagination } = options;
    if (!is_1$1.default.function_(pagination.transform)) {
      throw new Error("`options.pagination.transform` must be implemented");
    }
    if (!is_1$1.default.function_(pagination.shouldContinue)) {
      throw new Error("`options.pagination.shouldContinue` must be implemented");
    }
    if (!is_1$1.default.function_(pagination.filter)) {
      throw new TypeError("`options.pagination.filter` must be implemented");
    }
    if (!is_1$1.default.function_(pagination.paginate)) {
      throw new Error("`options.pagination.paginate` must be implemented");
    }
  }
  if (options.responseType === "json" && options.headers.accept === void 0) {
    options.headers.accept = "application/json";
  }
  return options;
};
normalizeArguments$1.default = normalizeArguments;
var calculateRetryDelay$1 = {};
Object.defineProperty(calculateRetryDelay$1, "__esModule", { value: true });
calculateRetryDelay$1.retryAfterStatusCodes = void 0;
calculateRetryDelay$1.retryAfterStatusCodes = /* @__PURE__ */ new Set([413, 429, 503]);
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error.code);
  const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error.response) {
    if (retryAfter) {
      if (retryOptions.maxRetryAfter === void 0 || retryAfter > retryOptions.maxRetryAfter) {
        return 0;
      }
      return retryAfter;
    }
    if (error.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * 100;
  return 2 ** (attemptCount - 1) * 1e3 + noise;
};
calculateRetryDelay$1.default = calculateRetryDelay;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
  const util_12 = require$$1;
  const stream_1 = require$$0$2__default;
  const fs_12 = require$$2$1;
  const url_12 = require$$0$3;
  const http3 = require$$4;
  const http_1 = require$$4;
  const https2 = require$$1$3;
  const http_timer_1 = source$3.exports;
  const cacheable_lookup_1 = source$1.exports;
  const CacheableRequest2 = src;
  const decompressResponse$1 = decompressResponse;
  const http2wrapper = source;
  const lowercaseKeys2 = lowercaseKeys$2;
  const is_12 = dist$1.exports;
  const get_body_size_1 = getBodySize;
  const is_form_data_12 = isFormData;
  const proxy_events_1 = proxyEvents;
  const timed_out_1 = timedOut;
  const url_to_options_1 = urlToOptions;
  const options_to_url_1 = optionsToUrl;
  const weakable_map_1 = weakableMap;
  const get_buffer_1 = getBuffer$1;
  const dns_ip_version_1 = dnsIpVersion;
  const is_response_ok_1 = isResponseOk;
  const deprecation_warning_1 = deprecationWarning;
  const normalize_arguments_1 = normalizeArguments$1;
  const calculate_retry_delay_1 = calculateRetryDelay$1;
  let globalDnsCache;
  const kRequest2 = Symbol("request");
  const kResponse = Symbol("response");
  const kResponseSize = Symbol("responseSize");
  const kDownloadedSize = Symbol("downloadedSize");
  const kBodySize = Symbol("bodySize");
  const kUploadedSize = Symbol("uploadedSize");
  const kServerResponsesPiped = Symbol("serverResponsesPiped");
  const kUnproxyEvents = Symbol("unproxyEvents");
  const kIsFromCache = Symbol("isFromCache");
  const kCancelTimeouts = Symbol("cancelTimeouts");
  const kStartedReading = Symbol("startedReading");
  const kStopReading = Symbol("stopReading");
  const kTriggerRead = Symbol("triggerRead");
  const kBody = Symbol("body");
  const kJobs2 = Symbol("jobs");
  const kOriginalResponse = Symbol("originalResponse");
  const kRetryTimeout = Symbol("retryTimeout");
  exports.kIsNormalizedAlready = Symbol("isNormalizedAlready");
  const supportsBrotli = is_12.default.string(process.versions.brotli);
  exports.withoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
  exports.knownHookEvents = [
    "init",
    "beforeRequest",
    "beforeRedirect",
    "beforeError",
    "beforeRetry",
    "afterResponse"
  ];
  function validateSearchParameters(searchParameters) {
    for (const key in searchParameters) {
      const value = searchParameters[key];
      if (!is_12.default.string(value) && !is_12.default.number(value) && !is_12.default.boolean(value) && !is_12.default.null_(value) && !is_12.default.undefined(value)) {
        throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
      }
    }
  }
  function isClientRequest(clientRequest2) {
    return is_12.default.object(clientRequest2) && !("statusCode" in clientRequest2);
  }
  const cacheableStore = new weakable_map_1.default();
  const waitForOpenFile = async (file2) => new Promise((resolve2, reject) => {
    const onError = (error) => {
      reject(error);
    };
    if (!file2.pending) {
      resolve2();
    }
    file2.once("error", onError);
    file2.once("ready", () => {
      file2.off("error", onError);
      resolve2();
    });
  });
  const redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
  const nonEnumerableProperties = [
    "context",
    "body",
    "json",
    "form"
  ];
  exports.setNonEnumerableProperties = (sources, to2) => {
    const properties = {};
    for (const source2 of sources) {
      if (!source2) {
        continue;
      }
      for (const name of nonEnumerableProperties) {
        if (!(name in source2)) {
          continue;
        }
        properties[name] = {
          writable: true,
          configurable: true,
          enumerable: false,
          value: source2[name]
        };
      }
    }
    Object.defineProperties(to2, properties);
  };
  class RequestError extends Error {
    constructor(message, error, self2) {
      var _a, _b;
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = "RequestError";
      this.code = (_a = error.code) !== null && _a !== void 0 ? _a : "ERR_GOT_REQUEST_ERROR";
      if (self2 instanceof Request) {
        Object.defineProperty(this, "request", {
          enumerable: false,
          value: self2
        });
        Object.defineProperty(this, "response", {
          enumerable: false,
          value: self2[kResponse]
        });
        Object.defineProperty(this, "options", {
          enumerable: false,
          value: self2.options
        });
      } else {
        Object.defineProperty(this, "options", {
          enumerable: false,
          value: self2
        });
      }
      this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;
      if (is_12.default.string(error.stack) && is_12.default.string(this.stack)) {
        const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
        const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
        const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
        while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
          thisStackTrace.shift();
        }
        this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
      }
    }
  }
  exports.RequestError = RequestError;
  class MaxRedirectsError extends RequestError {
    constructor(request2) {
      super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
      this.name = "MaxRedirectsError";
      this.code = "ERR_TOO_MANY_REDIRECTS";
    }
  }
  exports.MaxRedirectsError = MaxRedirectsError;
  class HTTPError extends RequestError {
    constructor(response) {
      super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
      this.name = "HTTPError";
      this.code = "ERR_NON_2XX_3XX_RESPONSE";
    }
  }
  exports.HTTPError = HTTPError;
  class CacheError extends RequestError {
    constructor(error, request2) {
      super(error.message, error, request2);
      this.name = "CacheError";
      this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
    }
  }
  exports.CacheError = CacheError;
  class UploadError extends RequestError {
    constructor(error, request2) {
      super(error.message, error, request2);
      this.name = "UploadError";
      this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
    }
  }
  exports.UploadError = UploadError;
  class TimeoutError2 extends RequestError {
    constructor(error, timings, request2) {
      super(error.message, error, request2);
      this.name = "TimeoutError";
      this.event = error.event;
      this.timings = timings;
    }
  }
  exports.TimeoutError = TimeoutError2;
  class ReadError extends RequestError {
    constructor(error, request2) {
      super(error.message, error, request2);
      this.name = "ReadError";
      this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
    }
  }
  exports.ReadError = ReadError;
  class UnsupportedProtocolError extends RequestError {
    constructor(options) {
      super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
      this.name = "UnsupportedProtocolError";
      this.code = "ERR_UNSUPPORTED_PROTOCOL";
    }
  }
  exports.UnsupportedProtocolError = UnsupportedProtocolError;
  const proxiedRequestEvents = [
    "socket",
    "connect",
    "continue",
    "information",
    "upgrade",
    "timeout"
  ];
  class Request extends stream_1.Duplex {
    constructor(url2, options = {}, defaults2) {
      super({
        autoDestroy: false,
        highWaterMark: 0
      });
      this[kDownloadedSize] = 0;
      this[kUploadedSize] = 0;
      this.requestInitialized = false;
      this[kServerResponsesPiped] = /* @__PURE__ */ new Set();
      this.redirects = [];
      this[kStopReading] = false;
      this[kTriggerRead] = false;
      this[kJobs2] = [];
      this.retryCount = 0;
      this._progressCallbacks = [];
      const unlockWrite = () => this._unlockWrite();
      const lockWrite = () => this._lockWrite();
      this.on("pipe", (source2) => {
        source2.prependListener("data", unlockWrite);
        source2.on("data", lockWrite);
        source2.prependListener("end", unlockWrite);
        source2.on("end", lockWrite);
      });
      this.on("unpipe", (source2) => {
        source2.off("data", unlockWrite);
        source2.off("data", lockWrite);
        source2.off("end", unlockWrite);
        source2.off("end", lockWrite);
      });
      this.on("pipe", (source2) => {
        if (source2 instanceof http_1.IncomingMessage) {
          this.options.headers = {
            ...source2.headers,
            ...this.options.headers
          };
        }
      });
      const { json, body, form } = options;
      if (json || body || form) {
        this._lockWrite();
      }
      if (exports.kIsNormalizedAlready in options) {
        this.options = options;
      } else {
        try {
          this.options = this.constructor.normalizeArguments(url2, options, defaults2);
        } catch (error) {
          if (is_12.default.nodeStream(options.body)) {
            options.body.destroy();
          }
          this.destroy(error);
          return;
        }
      }
      (async () => {
        var _a;
        try {
          if (this.options.body instanceof fs_12.ReadStream) {
            await waitForOpenFile(this.options.body);
          }
          const { url: normalizedURL } = this.options;
          if (!normalizedURL) {
            throw new TypeError("Missing `url` property");
          }
          this.requestUrl = normalizedURL.toString();
          decodeURI(this.requestUrl);
          await this._finalizeBody();
          await this._makeRequest();
          if (this.destroyed) {
            (_a = this[kRequest2]) === null || _a === void 0 ? void 0 : _a.destroy();
            return;
          }
          for (const job of this[kJobs2]) {
            job();
          }
          this[kJobs2].length = 0;
          this.requestInitialized = true;
        } catch (error) {
          if (error instanceof RequestError) {
            this._beforeError(error);
            return;
          }
          if (!this.destroyed) {
            this.destroy(error);
          }
        }
      })();
    }
    static normalizeArguments(url2, options, defaults2) {
      var _a, _b, _c, _d, _e;
      const rawOptions = options;
      if (is_12.default.object(url2) && !is_12.default.urlInstance(url2)) {
        options = { ...defaults2, ...url2, ...options };
      } else {
        if (url2 && options && options.url !== void 0) {
          throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
        }
        options = { ...defaults2, ...options };
        if (url2 !== void 0) {
          options.url = url2;
        }
        if (is_12.default.urlInstance(options.url)) {
          options.url = new url_12.URL(options.url.toString());
        }
      }
      if (options.cache === false) {
        options.cache = void 0;
      }
      if (options.dnsCache === false) {
        options.dnsCache = void 0;
      }
      is_12.assert.any([is_12.default.string, is_12.default.undefined], options.method);
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.headers);
      is_12.assert.any([is_12.default.string, is_12.default.urlInstance, is_12.default.undefined], options.prefixUrl);
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.cookieJar);
      is_12.assert.any([is_12.default.object, is_12.default.string, is_12.default.undefined], options.searchParams);
      is_12.assert.any([is_12.default.object, is_12.default.string, is_12.default.undefined], options.cache);
      is_12.assert.any([is_12.default.object, is_12.default.number, is_12.default.undefined], options.timeout);
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.context);
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.hooks);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.decompress);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.ignoreInvalidCookies);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.followRedirect);
      is_12.assert.any([is_12.default.number, is_12.default.undefined], options.maxRedirects);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.throwHttpErrors);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.http2);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.allowGetBody);
      is_12.assert.any([is_12.default.string, is_12.default.undefined], options.localAddress);
      is_12.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_12.default.undefined], options.dnsLookupIpVersion);
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.https);
      is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.rejectUnauthorized);
      if (options.https) {
        is_12.assert.any([is_12.default.boolean, is_12.default.undefined], options.https.rejectUnauthorized);
        is_12.assert.any([is_12.default.function_, is_12.default.undefined], options.https.checkServerIdentity);
        is_12.assert.any([is_12.default.string, is_12.default.object, is_12.default.array, is_12.default.undefined], options.https.certificateAuthority);
        is_12.assert.any([is_12.default.string, is_12.default.object, is_12.default.array, is_12.default.undefined], options.https.key);
        is_12.assert.any([is_12.default.string, is_12.default.object, is_12.default.array, is_12.default.undefined], options.https.certificate);
        is_12.assert.any([is_12.default.string, is_12.default.undefined], options.https.passphrase);
        is_12.assert.any([is_12.default.string, is_12.default.buffer, is_12.default.array, is_12.default.undefined], options.https.pfx);
      }
      is_12.assert.any([is_12.default.object, is_12.default.undefined], options.cacheOptions);
      if (is_12.default.string(options.method)) {
        options.method = options.method.toUpperCase();
      } else {
        options.method = "GET";
      }
      if (options.headers === (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.headers)) {
        options.headers = { ...options.headers };
      } else {
        options.headers = lowercaseKeys2({ ...defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.headers, ...options.headers });
      }
      if ("slashes" in options) {
        throw new TypeError("The legacy `url.Url` has been deprecated. Use `URL` instead.");
      }
      if ("auth" in options) {
        throw new TypeError("Parameter `auth` is deprecated. Use `username` / `password` instead.");
      }
      if ("searchParams" in options) {
        if (options.searchParams && options.searchParams !== (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.searchParams)) {
          let searchParameters;
          if (is_12.default.string(options.searchParams) || options.searchParams instanceof url_12.URLSearchParams) {
            searchParameters = new url_12.URLSearchParams(options.searchParams);
          } else {
            validateSearchParameters(options.searchParams);
            searchParameters = new url_12.URLSearchParams();
            for (const key in options.searchParams) {
              const value = options.searchParams[key];
              if (value === null) {
                searchParameters.append(key, "");
              } else if (value !== void 0) {
                searchParameters.append(key, value);
              }
            }
          }
          (_a = defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
            if (!searchParameters.has(key)) {
              searchParameters.append(key, value);
            }
          });
          options.searchParams = searchParameters;
        }
      }
      options.username = (_b = options.username) !== null && _b !== void 0 ? _b : "";
      options.password = (_c = options.password) !== null && _c !== void 0 ? _c : "";
      if (is_12.default.undefined(options.prefixUrl)) {
        options.prefixUrl = (_d = defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.prefixUrl) !== null && _d !== void 0 ? _d : "";
      } else {
        options.prefixUrl = options.prefixUrl.toString();
        if (options.prefixUrl !== "" && !options.prefixUrl.endsWith("/")) {
          options.prefixUrl += "/";
        }
      }
      if (is_12.default.string(options.url)) {
        if (options.url.startsWith("/")) {
          throw new Error("`input` must not start with a slash when using `prefixUrl`");
        }
        options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
      } else if (is_12.default.undefined(options.url) && options.prefixUrl !== "" || options.protocol) {
        options.url = options_to_url_1.default(options.prefixUrl, options);
      }
      if (options.url) {
        if ("port" in options) {
          delete options.port;
        }
        let { prefixUrl } = options;
        Object.defineProperty(options, "prefixUrl", {
          set: (value) => {
            const url3 = options.url;
            if (!url3.href.startsWith(value)) {
              throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url3.href}`);
            }
            options.url = new url_12.URL(value + url3.href.slice(prefixUrl.length));
            prefixUrl = value;
          },
          get: () => prefixUrl
        });
        let { protocol } = options.url;
        if (protocol === "unix:") {
          protocol = "http:";
          options.url = new url_12.URL(`http://unix${options.url.pathname}${options.url.search}`);
        }
        if (options.searchParams) {
          options.url.search = options.searchParams.toString();
        }
        if (protocol !== "http:" && protocol !== "https:") {
          throw new UnsupportedProtocolError(options);
        }
        if (options.username === "") {
          options.username = options.url.username;
        } else {
          options.url.username = options.username;
        }
        if (options.password === "") {
          options.password = options.url.password;
        } else {
          options.url.password = options.password;
        }
      }
      const { cookieJar } = options;
      if (cookieJar) {
        let { setCookie, getCookieString } = cookieJar;
        is_12.assert.function_(setCookie);
        is_12.assert.function_(getCookieString);
        if (setCookie.length === 4 && getCookieString.length === 0) {
          setCookie = util_12.promisify(setCookie.bind(options.cookieJar));
          getCookieString = util_12.promisify(getCookieString.bind(options.cookieJar));
          options.cookieJar = {
            setCookie,
            getCookieString
          };
        }
      }
      const { cache: cache2 } = options;
      if (cache2) {
        if (!cacheableStore.has(cache2)) {
          cacheableStore.set(cache2, new CacheableRequest2((requestOptions, handler) => {
            const result = requestOptions[kRequest2](requestOptions, handler);
            if (is_12.default.promise(result)) {
              result.once = (event, handler2) => {
                if (event === "error") {
                  result.catch(handler2);
                } else if (event === "abort") {
                  (async () => {
                    try {
                      const request2 = await result;
                      request2.once("abort", handler2);
                    } catch (_a2) {
                    }
                  })();
                } else {
                  throw new Error(`Unknown HTTP2 promise event: ${event}`);
                }
                return result;
              };
            }
            return result;
          }, cache2));
        }
      }
      options.cacheOptions = { ...options.cacheOptions };
      if (options.dnsCache === true) {
        if (!globalDnsCache) {
          globalDnsCache = new cacheable_lookup_1.default();
        }
        options.dnsCache = globalDnsCache;
      } else if (!is_12.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
        throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_12.default(options.dnsCache)}`);
      }
      if (is_12.default.number(options.timeout)) {
        options.timeout = { request: options.timeout };
      } else if (defaults2 && options.timeout !== defaults2.timeout) {
        options.timeout = {
          ...defaults2.timeout,
          ...options.timeout
        };
      } else {
        options.timeout = { ...options.timeout };
      }
      if (!options.context) {
        options.context = {};
      }
      const areHooksDefault = options.hooks === (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.hooks);
      options.hooks = { ...options.hooks };
      for (const event of exports.knownHookEvents) {
        if (event in options.hooks) {
          if (is_12.default.array(options.hooks[event])) {
            options.hooks[event] = [...options.hooks[event]];
          } else {
            throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_12.default(options.hooks[event])}`);
          }
        } else {
          options.hooks[event] = [];
        }
      }
      if (defaults2 && !areHooksDefault) {
        for (const event of exports.knownHookEvents) {
          const defaultHooks = defaults2.hooks[event];
          if (defaultHooks.length > 0) {
            options.hooks[event] = [
              ...defaults2.hooks[event],
              ...options.hooks[event]
            ];
          }
        }
      }
      if ("family" in options) {
        deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
      }
      if (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.https) {
        options.https = { ...defaults2.https, ...options.https };
      }
      if ("rejectUnauthorized" in options) {
        deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
      }
      if ("checkServerIdentity" in options) {
        deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
      }
      if ("ca" in options) {
        deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
      }
      if ("key" in options) {
        deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
      }
      if ("cert" in options) {
        deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
      }
      if ("passphrase" in options) {
        deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
      }
      if ("pfx" in options) {
        deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
      }
      if ("followRedirects" in options) {
        throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
      }
      if (options.agent) {
        for (const key in options.agent) {
          if (key !== "http" && key !== "https" && key !== "http2") {
            throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
          }
        }
      }
      options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
      exports.setNonEnumerableProperties([defaults2, rawOptions], options);
      return normalize_arguments_1.default(options, defaults2);
    }
    _lockWrite() {
      const onLockedWrite = () => {
        throw new TypeError("The payload has been already provided");
      };
      this.write = onLockedWrite;
      this.end = onLockedWrite;
    }
    _unlockWrite() {
      this.write = super.write;
      this.end = super.end;
    }
    async _finalizeBody() {
      const { options } = this;
      const { headers } = options;
      const isForm = !is_12.default.undefined(options.form);
      const isJSON = !is_12.default.undefined(options.json);
      const isBody = !is_12.default.undefined(options.body);
      const hasPayload = isForm || isJSON || isBody;
      const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
      this._cannotHaveBody = cannotHaveBody;
      if (hasPayload) {
        if (cannotHaveBody) {
          throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
        }
        if ([isBody, isForm, isJSON].filter((isTrue) => isTrue).length > 1) {
          throw new TypeError("The `body`, `json` and `form` options are mutually exclusive");
        }
        if (isBody && !(options.body instanceof stream_1.Readable) && !is_12.default.string(options.body) && !is_12.default.buffer(options.body) && !is_form_data_12.default(options.body)) {
          throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
        }
        if (isForm && !is_12.default.object(options.form)) {
          throw new TypeError("The `form` option must be an Object");
        }
        {
          const noContentType = !is_12.default.string(headers["content-type"]);
          if (isBody) {
            if (is_form_data_12.default(options.body) && noContentType) {
              headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
            }
            this[kBody] = options.body;
          } else if (isForm) {
            if (noContentType) {
              headers["content-type"] = "application/x-www-form-urlencoded";
            }
            this[kBody] = new url_12.URLSearchParams(options.form).toString();
          } else {
            if (noContentType) {
              headers["content-type"] = "application/json";
            }
            this[kBody] = options.stringifyJson(options.json);
          }
          const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
          if (is_12.default.undefined(headers["content-length"]) && is_12.default.undefined(headers["transfer-encoding"])) {
            if (!cannotHaveBody && !is_12.default.undefined(uploadBodySize)) {
              headers["content-length"] = String(uploadBodySize);
            }
          }
        }
      } else if (cannotHaveBody) {
        this._lockWrite();
      } else {
        this._unlockWrite();
      }
      this[kBodySize] = Number(headers["content-length"]) || void 0;
    }
    async _onResponseBase(response) {
      const { options } = this;
      const { url: url2 } = options;
      this[kOriginalResponse] = response;
      if (options.decompress) {
        response = decompressResponse$1(response);
      }
      const statusCode = response.statusCode;
      const typedResponse = response;
      typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http3.STATUS_CODES[statusCode];
      typedResponse.url = options.url.toString();
      typedResponse.requestUrl = this.requestUrl;
      typedResponse.redirectUrls = this.redirects;
      typedResponse.request = this;
      typedResponse.isFromCache = response.fromCache || false;
      typedResponse.ip = this.ip;
      typedResponse.retryCount = this.retryCount;
      this[kIsFromCache] = typedResponse.isFromCache;
      this[kResponseSize] = Number(response.headers["content-length"]) || void 0;
      this[kResponse] = response;
      response.once("end", () => {
        this[kResponseSize] = this[kDownloadedSize];
        this.emit("downloadProgress", this.downloadProgress);
      });
      response.once("error", (error) => {
        response.destroy();
        this._beforeError(new ReadError(error, this));
      });
      response.once("aborted", () => {
        this._beforeError(new ReadError({
          name: "Error",
          message: "The server aborted pending request",
          code: "ECONNRESET"
        }, this));
      });
      this.emit("downloadProgress", this.downloadProgress);
      const rawCookies = response.headers["set-cookie"];
      if (is_12.default.object(options.cookieJar) && rawCookies) {
        let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url2.toString()));
        if (options.ignoreInvalidCookies) {
          promises = promises.map(async (p) => p.catch(() => {
          }));
        }
        try {
          await Promise.all(promises);
        } catch (error) {
          this._beforeError(error);
          return;
        }
      }
      if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
        response.resume();
        if (this[kRequest2]) {
          this[kCancelTimeouts]();
          delete this[kRequest2];
          this[kUnproxyEvents]();
        }
        const shouldBeGet = statusCode === 303 && options.method !== "GET" && options.method !== "HEAD";
        if (shouldBeGet || !options.methodRewriting) {
          options.method = "GET";
          if ("body" in options) {
            delete options.body;
          }
          if ("json" in options) {
            delete options.json;
          }
          if ("form" in options) {
            delete options.form;
          }
          this[kBody] = void 0;
          delete options.headers["content-length"];
        }
        if (this.redirects.length >= options.maxRedirects) {
          this._beforeError(new MaxRedirectsError(this));
          return;
        }
        try {
          let isUnixSocketURL = function(url3) {
            return url3.protocol === "unix:" || url3.hostname === "unix";
          };
          const redirectBuffer = Buffer.from(response.headers.location, "binary").toString();
          const redirectUrl = new url_12.URL(redirectBuffer, url2);
          const redirectString = redirectUrl.toString();
          decodeURI(redirectString);
          if (!isUnixSocketURL(url2) && isUnixSocketURL(redirectUrl)) {
            this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
            return;
          }
          if (redirectUrl.hostname !== url2.hostname || redirectUrl.port !== url2.port) {
            if ("host" in options.headers) {
              delete options.headers.host;
            }
            if ("cookie" in options.headers) {
              delete options.headers.cookie;
            }
            if ("authorization" in options.headers) {
              delete options.headers.authorization;
            }
            if (options.username || options.password) {
              options.username = "";
              options.password = "";
            }
          } else {
            redirectUrl.username = options.username;
            redirectUrl.password = options.password;
          }
          this.redirects.push(redirectString);
          options.url = redirectUrl;
          for (const hook of options.hooks.beforeRedirect) {
            await hook(options, typedResponse);
          }
          this.emit("redirect", typedResponse, options);
          await this._makeRequest();
        } catch (error) {
          this._beforeError(error);
          return;
        }
        return;
      }
      if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
        this._beforeError(new HTTPError(typedResponse));
        return;
      }
      response.on("readable", () => {
        if (this[kTriggerRead]) {
          this._read();
        }
      });
      this.on("resume", () => {
        response.resume();
      });
      this.on("pause", () => {
        response.pause();
      });
      response.once("end", () => {
        this.push(null);
      });
      this.emit("response", response);
      for (const destination of this[kServerResponsesPiped]) {
        if (destination.headersSent) {
          continue;
        }
        for (const key in response.headers) {
          const isAllowed = options.decompress ? key !== "content-encoding" : true;
          const value = response.headers[key];
          if (isAllowed) {
            destination.setHeader(key, value);
          }
        }
        destination.statusCode = statusCode;
      }
    }
    async _onResponse(response) {
      try {
        await this._onResponseBase(response);
      } catch (error) {
        this._beforeError(error);
      }
    }
    _onRequest(request2) {
      const { options } = this;
      const { timeout, url: url2 } = options;
      http_timer_1.default(request2);
      this[kCancelTimeouts] = timed_out_1.default(request2, timeout, url2);
      const responseEventName = options.cache ? "cacheableResponse" : "response";
      request2.once(responseEventName, (response) => {
        void this._onResponse(response);
      });
      request2.once("error", (error) => {
        var _a;
        request2.destroy();
        (_a = request2.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners("end");
        error = error instanceof timed_out_1.TimeoutError ? new TimeoutError2(error, this.timings, this) : new RequestError(error.message, error, this);
        this._beforeError(error);
      });
      this[kUnproxyEvents] = proxy_events_1.default(request2, this, proxiedRequestEvents);
      this[kRequest2] = request2;
      this.emit("uploadProgress", this.uploadProgress);
      const body = this[kBody];
      const currentRequest = this.redirects.length === 0 ? this : request2;
      if (is_12.default.nodeStream(body)) {
        body.pipe(currentRequest);
        body.once("error", (error) => {
          this._beforeError(new UploadError(error, this));
        });
      } else {
        this._unlockWrite();
        if (!is_12.default.undefined(body)) {
          this._writeRequest(body, void 0, () => {
          });
          currentRequest.end();
          this._lockWrite();
        } else if (this._cannotHaveBody || this._noPipe) {
          currentRequest.end();
          this._lockWrite();
        }
      }
      this.emit("request", request2);
    }
    async _createCacheableRequest(url2, options) {
      return new Promise((resolve2, reject) => {
        Object.assign(options, url_to_options_1.default(url2));
        delete options.url;
        let request2;
        const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
          response._readableState.autoDestroy = false;
          if (request2) {
            (await request2).emit("cacheableResponse", response);
          }
          resolve2(response);
        });
        options.url = url2;
        cacheRequest.once("error", reject);
        cacheRequest.once("request", async (requestOrPromise) => {
          request2 = requestOrPromise;
          resolve2(request2);
        });
      });
    }
    async _makeRequest() {
      var _a, _b, _c, _d, _e;
      const { options } = this;
      const { headers } = options;
      for (const key in headers) {
        if (is_12.default.undefined(headers[key])) {
          delete headers[key];
        } else if (is_12.default.null_(headers[key])) {
          throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
        }
      }
      if (options.decompress && is_12.default.undefined(headers["accept-encoding"])) {
        headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
      }
      if (options.cookieJar) {
        const cookieString = await options.cookieJar.getCookieString(options.url.toString());
        if (is_12.default.nonEmptyString(cookieString)) {
          options.headers.cookie = cookieString;
        }
      }
      for (const hook of options.hooks.beforeRequest) {
        const result = await hook(options);
        if (!is_12.default.undefined(result)) {
          options.request = () => result;
          break;
        }
      }
      if (options.body && this[kBody] !== options.body) {
        this[kBody] = options.body;
      }
      const { agent: agent2, request: request2, timeout, url: url2 } = options;
      if (options.dnsCache && !("lookup" in options)) {
        options.lookup = options.dnsCache.lookup;
      }
      if (url2.hostname === "unix") {
        const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url2.pathname}${url2.search}`);
        if (matches === null || matches === void 0 ? void 0 : matches.groups) {
          const { socketPath, path: path2 } = matches.groups;
          Object.assign(options, {
            socketPath,
            path: path2,
            host: ""
          });
        }
      }
      const isHttps = url2.protocol === "https:";
      let fallbackFn;
      if (options.http2) {
        fallbackFn = http2wrapper.auto;
      } else {
        fallbackFn = isHttps ? https2.request : http3.request;
      }
      const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
      const fn = options.cache ? this._createCacheableRequest : realFn;
      if (agent2 && !options.http2) {
        options.agent = agent2[isHttps ? "https" : "http"];
      }
      options[kRequest2] = realFn;
      delete options.request;
      delete options.timeout;
      const requestOptions = options;
      requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
      requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
      requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
      requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
      if (options.dnsLookupIpVersion !== void 0) {
        try {
          requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
        } catch (_f) {
          throw new Error("Invalid `dnsLookupIpVersion` option value");
        }
      }
      if (options.https) {
        if ("rejectUnauthorized" in options.https) {
          requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
        }
        if (options.https.checkServerIdentity) {
          requestOptions.checkServerIdentity = options.https.checkServerIdentity;
        }
        if (options.https.certificateAuthority) {
          requestOptions.ca = options.https.certificateAuthority;
        }
        if (options.https.certificate) {
          requestOptions.cert = options.https.certificate;
        }
        if (options.https.key) {
          requestOptions.key = options.https.key;
        }
        if (options.https.passphrase) {
          requestOptions.passphrase = options.https.passphrase;
        }
        if (options.https.pfx) {
          requestOptions.pfx = options.https.pfx;
        }
      }
      try {
        let requestOrResponse = await fn(url2, requestOptions);
        if (is_12.default.undefined(requestOrResponse)) {
          requestOrResponse = fallbackFn(url2, requestOptions);
        }
        options.request = request2;
        options.timeout = timeout;
        options.agent = agent2;
        if (options.https) {
          if ("rejectUnauthorized" in options.https) {
            delete requestOptions.rejectUnauthorized;
          }
          if (options.https.checkServerIdentity) {
            delete requestOptions.checkServerIdentity;
          }
          if (options.https.certificateAuthority) {
            delete requestOptions.ca;
          }
          if (options.https.certificate) {
            delete requestOptions.cert;
          }
          if (options.https.key) {
            delete requestOptions.key;
          }
          if (options.https.passphrase) {
            delete requestOptions.passphrase;
          }
          if (options.https.pfx) {
            delete requestOptions.pfx;
          }
        }
        if (isClientRequest(requestOrResponse)) {
          this._onRequest(requestOrResponse);
        } else if (this.writable) {
          this.once("finish", () => {
            void this._onResponse(requestOrResponse);
          });
          this._unlockWrite();
          this.end();
          this._lockWrite();
        } else {
          void this._onResponse(requestOrResponse);
        }
      } catch (error) {
        if (error instanceof CacheableRequest2.CacheError) {
          throw new CacheError(error, this);
        }
        throw new RequestError(error.message, error, this);
      }
    }
    async _error(error) {
      try {
        for (const hook of this.options.hooks.beforeError) {
          error = await hook(error);
        }
      } catch (error_) {
        error = new RequestError(error_.message, error_, this);
      }
      this.destroy(error);
    }
    _beforeError(error) {
      if (this[kStopReading]) {
        return;
      }
      const { options } = this;
      const retryCount = this.retryCount + 1;
      this[kStopReading] = true;
      if (!(error instanceof RequestError)) {
        error = new RequestError(error.message, error, this);
      }
      const typedError = error;
      const { response } = typedError;
      void (async () => {
        if (response && !response.body) {
          response.setEncoding(this._readableState.encoding);
          try {
            response.rawBody = await get_buffer_1.default(response);
            response.body = response.rawBody.toString();
          } catch (_a) {
          }
        }
        if (this.listenerCount("retry") !== 0) {
          let backoff;
          try {
            let retryAfter;
            if (response && "retry-after" in response.headers) {
              retryAfter = Number(response.headers["retry-after"]);
              if (Number.isNaN(retryAfter)) {
                retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                if (retryAfter <= 0) {
                  retryAfter = 1;
                }
              } else {
                retryAfter *= 1e3;
              }
            }
            backoff = await options.retry.calculateDelay({
              attemptCount: retryCount,
              retryOptions: options.retry,
              error: typedError,
              retryAfter,
              computedValue: calculate_retry_delay_1.default({
                attemptCount: retryCount,
                retryOptions: options.retry,
                error: typedError,
                retryAfter,
                computedValue: 0
              })
            });
          } catch (error_) {
            void this._error(new RequestError(error_.message, error_, this));
            return;
          }
          if (backoff) {
            const retry = async () => {
              try {
                for (const hook of this.options.hooks.beforeRetry) {
                  await hook(this.options, typedError, retryCount);
                }
              } catch (error_) {
                void this._error(new RequestError(error_.message, error, this));
                return;
              }
              if (this.destroyed) {
                return;
              }
              this.destroy();
              this.emit("retry", retryCount, error);
            };
            this[kRetryTimeout] = setTimeout(retry, backoff);
            return;
          }
        }
        void this._error(typedError);
      })();
    }
    _read() {
      this[kTriggerRead] = true;
      const response = this[kResponse];
      if (response && !this[kStopReading]) {
        if (response.readableLength) {
          this[kTriggerRead] = false;
        }
        let data;
        while ((data = response.read()) !== null) {
          this[kDownloadedSize] += data.length;
          this[kStartedReading] = true;
          const progress = this.downloadProgress;
          if (progress.percent < 1) {
            this.emit("downloadProgress", progress);
          }
          this.push(data);
        }
      }
    }
    _write(chunk, encoding, callback2) {
      const write = () => {
        this._writeRequest(chunk, encoding, callback2);
      };
      if (this.requestInitialized) {
        write();
      } else {
        this[kJobs2].push(write);
      }
    }
    _writeRequest(chunk, encoding, callback2) {
      if (this[kRequest2].destroyed) {
        return;
      }
      this._progressCallbacks.push(() => {
        this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      });
      this[kRequest2].write(chunk, encoding, (error) => {
        if (!error && this._progressCallbacks.length > 0) {
          this._progressCallbacks.shift()();
        }
        callback2(error);
      });
    }
    _final(callback2) {
      const endRequest = () => {
        while (this._progressCallbacks.length !== 0) {
          this._progressCallbacks.shift()();
        }
        if (!(kRequest2 in this)) {
          callback2();
          return;
        }
        if (this[kRequest2].destroyed) {
          callback2();
          return;
        }
        this[kRequest2].end((error) => {
          if (!error) {
            this[kBodySize] = this[kUploadedSize];
            this.emit("uploadProgress", this.uploadProgress);
            this[kRequest2].emit("upload-complete");
          }
          callback2(error);
        });
      };
      if (this.requestInitialized) {
        endRequest();
      } else {
        this[kJobs2].push(endRequest);
      }
    }
    _destroy(error, callback2) {
      var _a;
      this[kStopReading] = true;
      clearTimeout(this[kRetryTimeout]);
      if (kRequest2 in this) {
        this[kCancelTimeouts]();
        if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
          this[kRequest2].destroy();
        }
      }
      if (error !== null && !is_12.default.undefined(error) && !(error instanceof RequestError)) {
        error = new RequestError(error.message, error, this);
      }
      callback2(error);
    }
    get _isAboutToError() {
      return this[kStopReading];
    }
    get ip() {
      var _a;
      return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;
    }
    get aborted() {
      var _a, _b, _c;
      return ((_b = (_a = this[kRequest2]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
    }
    get socket() {
      var _a, _b;
      return (_b = (_a = this[kRequest2]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : void 0;
    }
    get downloadProgress() {
      let percent;
      if (this[kResponseSize]) {
        percent = this[kDownloadedSize] / this[kResponseSize];
      } else if (this[kResponseSize] === this[kDownloadedSize]) {
        percent = 1;
      } else {
        percent = 0;
      }
      return {
        percent,
        transferred: this[kDownloadedSize],
        total: this[kResponseSize]
      };
    }
    get uploadProgress() {
      let percent;
      if (this[kBodySize]) {
        percent = this[kUploadedSize] / this[kBodySize];
      } else if (this[kBodySize] === this[kUploadedSize]) {
        percent = 1;
      } else {
        percent = 0;
      }
      return {
        percent,
        transferred: this[kUploadedSize],
        total: this[kBodySize]
      };
    }
    get timings() {
      var _a;
      return (_a = this[kRequest2]) === null || _a === void 0 ? void 0 : _a.timings;
    }
    get isFromCache() {
      return this[kIsFromCache];
    }
    pipe(destination, options) {
      if (this[kStartedReading]) {
        throw new Error("Failed to pipe. The response has been emitted already.");
      }
      if (destination instanceof http_1.ServerResponse) {
        this[kServerResponsesPiped].add(destination);
      }
      return super.pipe(destination, options);
    }
    unpipe(destination) {
      if (destination instanceof http_1.ServerResponse) {
        this[kServerResponsesPiped].delete(destination);
      }
      super.unpipe(destination);
      return this;
    }
  }
  exports.default = Request;
})(core);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancelError = exports.ParseError = void 0;
  const core_1 = core;
  class ParseError extends core_1.RequestError {
    constructor(error, response) {
      const { options } = response.request;
      super(`${error.message} in "${options.url.toString()}"`, error, response.request);
      this.name = "ParseError";
      this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_BODY_PARSE_FAILURE" : this.code;
    }
  }
  exports.ParseError = ParseError;
  class CancelError2 extends core_1.RequestError {
    constructor(request2) {
      super("Promise was canceled", {}, request2);
      this.name = "CancelError";
      this.code = "ERR_CANCELED";
    }
    get isCanceled() {
      return true;
    }
  }
  exports.CancelError = CancelError2;
  __exportStar(core, exports);
})(types$1);
var parseBody$1 = {};
Object.defineProperty(parseBody$1, "__esModule", { value: true });
const types_1$1 = types$1;
const parseBody = (response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString());
    }
    if (responseType === "buffer") {
      return rawBody;
    }
    throw new types_1$1.ParseError({
      message: `Unknown body type '${responseType}'`,
      name: "Error"
    }, response);
  } catch (error) {
    throw new types_1$1.ParseError(error, response);
  }
};
parseBody$1.default = parseBody;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const events_1 = events$1.exports;
  const is_12 = dist$1.exports;
  const PCancelable2 = pCancelable.exports;
  const types_12 = types$1;
  const parse_body_1 = parseBody$1;
  const core_1 = core;
  const proxy_events_1 = proxyEvents;
  const get_buffer_1 = getBuffer$1;
  const is_response_ok_1 = isResponseOk;
  const proxiedRequestEvents = [
    "request",
    "response",
    "redirect",
    "uploadProgress",
    "downloadProgress"
  ];
  function asPromise2(normalizedOptions) {
    let globalRequest;
    let globalResponse;
    const emitter = new events_1.EventEmitter();
    const promise = new PCancelable2((resolve2, reject, onCancel) => {
      const makeRequest = (retryCount) => {
        const request2 = new core_1.default(void 0, normalizedOptions);
        request2.retryCount = retryCount;
        request2._noPipe = true;
        onCancel(() => request2.destroy());
        onCancel.shouldReject = false;
        onCancel(() => reject(new types_12.CancelError(request2)));
        globalRequest = request2;
        request2.once("response", async (response) => {
          var _a;
          response.retryCount = retryCount;
          if (response.request.aborted) {
            return;
          }
          let rawBody;
          try {
            rawBody = await get_buffer_1.default(request2);
            response.rawBody = rawBody;
          } catch (_b) {
            return;
          }
          if (request2._isAboutToError) {
            return;
          }
          const contentEncoding = ((_a = response.headers["content-encoding"]) !== null && _a !== void 0 ? _a : "").toLowerCase();
          const isCompressed = ["gzip", "deflate", "br"].includes(contentEncoding);
          const { options } = request2;
          if (isCompressed && !options.decompress) {
            response.body = rawBody;
          } else {
            try {
              response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
            } catch (error) {
              response.body = rawBody.toString();
              if (is_response_ok_1.isResponseOk(response)) {
                request2._beforeError(error);
                return;
              }
            }
          }
          try {
            for (const [index2, hook] of options.hooks.afterResponse.entries()) {
              response = await hook(response, async (updatedOptions) => {
                const typedOptions = core_1.default.normalizeArguments(void 0, {
                  ...updatedOptions,
                  retry: {
                    calculateDelay: () => 0
                  },
                  throwHttpErrors: false,
                  resolveBodyOnly: false
                }, options);
                typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index2);
                for (const hook2 of typedOptions.hooks.beforeRetry) {
                  await hook2(typedOptions);
                }
                const promise2 = asPromise2(typedOptions);
                onCancel(() => {
                  promise2.catch(() => {
                  });
                  promise2.cancel();
                });
                return promise2;
              });
            }
          } catch (error) {
            request2._beforeError(new types_12.RequestError(error.message, error, request2));
            return;
          }
          globalResponse = response;
          if (!is_response_ok_1.isResponseOk(response)) {
            request2._beforeError(new types_12.HTTPError(response));
            return;
          }
          request2.destroy();
          resolve2(request2.options.resolveBodyOnly ? response.body : response);
        });
        const onError = (error) => {
          if (promise.isCanceled) {
            return;
          }
          const { options } = request2;
          if (error instanceof types_12.HTTPError && !options.throwHttpErrors) {
            const { response } = error;
            resolve2(request2.options.resolveBodyOnly ? response.body : response);
            return;
          }
          reject(error);
        };
        request2.once("error", onError);
        const previousBody = request2.options.body;
        request2.once("retry", (newRetryCount, error) => {
          var _a, _b;
          if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_12.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
            onError(error);
            return;
          }
          makeRequest(newRetryCount);
        });
        proxy_events_1.default(request2, emitter, proxiedRequestEvents);
      };
      makeRequest(0);
    });
    promise.on = (event, fn) => {
      emitter.on(event, fn);
      return promise;
    };
    const shortcut = (responseType) => {
      const newPromise = (async () => {
        await promise;
        const { options } = globalResponse.request;
        return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
      })();
      Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
      return newPromise;
    };
    promise.json = () => {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && headers.accept === void 0) {
        headers.accept = "application/json";
      }
      return shortcut("json");
    };
    promise.buffer = () => shortcut("buffer");
    promise.text = () => shortcut("text");
    return promise;
  }
  exports.default = asPromise2;
  __exportStar(types$1, exports);
})(asPromise);
var createRejection$1 = {};
Object.defineProperty(createRejection$1, "__esModule", { value: true });
const types_1 = types$1;
function createRejection(error, ...beforeErrorGroups) {
  const promise = (async () => {
    if (error instanceof types_1.RequestError) {
      try {
        for (const hooks of beforeErrorGroups) {
          if (hooks) {
            for (const hook of hooks) {
              error = await hook(error);
            }
          }
        }
      } catch (error_) {
        error = error_;
      }
    }
    throw error;
  })();
  const returnPromise = () => promise;
  promise.json = returnPromise;
  promise.text = returnPromise;
  promise.buffer = returnPromise;
  promise.on = returnPromise;
  return promise;
}
createRejection$1.default = createRejection;
var deepFreeze$1 = {};
Object.defineProperty(deepFreeze$1, "__esModule", { value: true });
const is_1 = dist$1.exports;
function deepFreeze(object) {
  for (const value of Object.values(object)) {
    if (is_1.default.plainObject(value) || is_1.default.array(value)) {
      deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
deepFreeze$1.default = deepFreeze;
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultHandler = void 0;
  const is_12 = dist$1.exports;
  const as_promise_1 = asPromise;
  const create_rejection_1 = createRejection$1;
  const core_1 = core;
  const deep_freeze_1 = deepFreeze$1;
  const errors2 = {
    RequestError: as_promise_1.RequestError,
    CacheError: as_promise_1.CacheError,
    ReadError: as_promise_1.ReadError,
    HTTPError: as_promise_1.HTTPError,
    MaxRedirectsError: as_promise_1.MaxRedirectsError,
    TimeoutError: as_promise_1.TimeoutError,
    ParseError: as_promise_1.ParseError,
    CancelError: as_promise_1.CancelError,
    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
    UploadError: as_promise_1.UploadError
  };
  const delay = async (ms) => new Promise((resolve2) => {
    setTimeout(resolve2, ms);
  });
  const { normalizeArguments: normalizeArguments2 } = core_1.default;
  const mergeOptions = (...sources) => {
    let mergedOptions;
    for (const source2 of sources) {
      mergedOptions = normalizeArguments2(void 0, source2, mergedOptions);
    }
    return mergedOptions;
  };
  const getPromiseOrStream = (options) => options.isStream ? new core_1.default(void 0, options) : as_promise_1.default(options);
  const isGotInstance = (value) => "defaults" in value && "options" in value.defaults;
  const aliases = [
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete"
  ];
  exports.defaultHandler = (options, next) => next(options);
  const callInitHooks = (hooks, options) => {
    if (hooks) {
      for (const hook of hooks) {
        hook(options);
      }
    }
  };
  const create2 = (defaults2) => {
    defaults2._rawHandlers = defaults2.handlers;
    defaults2.handlers = defaults2.handlers.map((fn) => (options, next) => {
      let root2;
      const result = fn(options, (newOptions) => {
        root2 = next(newOptions);
        return root2;
      });
      if (result !== root2 && !options.isStream && root2) {
        const typedResult = result;
        const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
        Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root2));
        Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root2));
        typedResult.then = promiseThen;
        typedResult.catch = promiseCatch;
        typedResult.finally = promiseFianlly;
      }
      return result;
    });
    const got2 = (url2, options = {}, _defaults) => {
      var _a, _b;
      let iteration = 0;
      const iterateHandlers = (newOptions) => {
        return defaults2.handlers[iteration++](newOptions, iteration === defaults2.handlers.length ? getPromiseOrStream : iterateHandlers);
      };
      if (is_12.default.plainObject(url2)) {
        const mergedOptions = {
          ...url2,
          ...options
        };
        core_1.setNonEnumerableProperties([url2, options], mergedOptions);
        options = mergedOptions;
        url2 = void 0;
      }
      try {
        let initHookError;
        try {
          callInitHooks(defaults2.options.hooks.init, options);
          callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
        } catch (error) {
          initHookError = error;
        }
        const normalizedOptions = normalizeArguments2(url2, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults2.options);
        normalizedOptions[core_1.kIsNormalizedAlready] = true;
        if (initHookError) {
          throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
        }
        return iterateHandlers(normalizedOptions);
      } catch (error) {
        if (options.isStream) {
          throw error;
        } else {
          return create_rejection_1.default(error, defaults2.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
        }
      }
    };
    got2.extend = (...instancesOrOptions) => {
      const optionsArray = [defaults2.options];
      let handlers = [...defaults2._rawHandlers];
      let isMutableDefaults;
      for (const value of instancesOrOptions) {
        if (isGotInstance(value)) {
          optionsArray.push(value.defaults.options);
          handlers.push(...value.defaults._rawHandlers);
          isMutableDefaults = value.defaults.mutableDefaults;
        } else {
          optionsArray.push(value);
          if ("handlers" in value) {
            handlers.push(...value.handlers);
          }
          isMutableDefaults = value.mutableDefaults;
        }
      }
      handlers = handlers.filter((handler) => handler !== exports.defaultHandler);
      if (handlers.length === 0) {
        handlers.push(exports.defaultHandler);
      }
      return create2({
        options: mergeOptions(...optionsArray),
        handlers,
        mutableDefaults: Boolean(isMutableDefaults)
      });
    };
    const paginateEach = async function* (url2, options) {
      let normalizedOptions = normalizeArguments2(url2, options, defaults2.options);
      normalizedOptions.resolveBodyOnly = false;
      const pagination = normalizedOptions.pagination;
      if (!is_12.default.object(pagination)) {
        throw new TypeError("`options.pagination` must be implemented");
      }
      const all2 = [];
      let { countLimit } = pagination;
      let numberOfRequests = 0;
      while (numberOfRequests < pagination.requestLimit) {
        if (numberOfRequests !== 0) {
          await delay(pagination.backoff);
        }
        const result = await got2(void 0, void 0, normalizedOptions);
        const parsed = await pagination.transform(result);
        const current = [];
        for (const item of parsed) {
          if (pagination.filter(item, all2, current)) {
            if (!pagination.shouldContinue(item, all2, current)) {
              return;
            }
            yield item;
            if (pagination.stackAllItems) {
              all2.push(item);
            }
            current.push(item);
            if (--countLimit <= 0) {
              return;
            }
          }
        }
        const optionsToMerge = pagination.paginate(result, all2, current);
        if (optionsToMerge === false) {
          return;
        }
        if (optionsToMerge === result.request.options) {
          normalizedOptions = result.request.options;
        } else if (optionsToMerge !== void 0) {
          normalizedOptions = normalizeArguments2(void 0, optionsToMerge, normalizedOptions);
        }
        numberOfRequests++;
      }
    };
    got2.paginate = paginateEach;
    got2.paginate.all = async (url2, options) => {
      const results = [];
      for await (const item of paginateEach(url2, options)) {
        results.push(item);
      }
      return results;
    };
    got2.paginate.each = paginateEach;
    got2.stream = (url2, options) => got2(url2, { ...options, isStream: true });
    for (const method of aliases) {
      got2[method] = (url2, options) => got2(url2, { ...options, method });
      got2.stream[method] = (url2, options) => {
        return got2(url2, { ...options, method, isStream: true });
      };
    }
    Object.assign(got2, errors2);
    Object.defineProperty(got2, "defaults", {
      value: defaults2.mutableDefaults ? defaults2 : deep_freeze_1.default(defaults2),
      writable: defaults2.mutableDefaults,
      configurable: defaults2.mutableDefaults,
      enumerable: true
    });
    got2.mergeOptions = mergeOptions;
    return got2;
  };
  exports.default = create2;
  __exportStar(types, exports);
})(create);
(function(module, exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const url_12 = require$$0$3;
  const create_1 = create;
  const defaults2 = {
    options: {
      method: "GET",
      retry: {
        limit: 2,
        methods: [
          "GET",
          "PUT",
          "HEAD",
          "DELETE",
          "OPTIONS",
          "TRACE"
        ],
        statusCodes: [
          408,
          413,
          429,
          500,
          502,
          503,
          504,
          521,
          522,
          524
        ],
        errorCodes: [
          "ETIMEDOUT",
          "ECONNRESET",
          "EADDRINUSE",
          "ECONNREFUSED",
          "EPIPE",
          "ENOTFOUND",
          "ENETUNREACH",
          "EAI_AGAIN"
        ],
        maxRetryAfter: void 0,
        calculateDelay: ({ computedValue }) => computedValue
      },
      timeout: {},
      headers: {
        "user-agent": "got (https://github.com/sindresorhus/got)"
      },
      hooks: {
        init: [],
        beforeRequest: [],
        beforeRedirect: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      },
      cache: void 0,
      dnsCache: void 0,
      decompress: true,
      throwHttpErrors: true,
      followRedirect: true,
      isStream: false,
      responseType: "text",
      resolveBodyOnly: false,
      maxRedirects: 10,
      prefixUrl: "",
      methodRewriting: true,
      ignoreInvalidCookies: false,
      context: {},
      http2: false,
      allowGetBody: false,
      https: void 0,
      pagination: {
        transform: (response) => {
          if (response.request.options.responseType === "json") {
            return response.body;
          }
          return JSON.parse(response.body);
        },
        paginate: (response) => {
          if (!Reflect.has(response.headers, "link")) {
            return false;
          }
          const items = response.headers.link.split(",");
          let next;
          for (const item of items) {
            const parsed = item.split(";");
            if (parsed[1].includes("next")) {
              next = parsed[0].trimStart().trim();
              next = next.slice(1, -1);
              break;
            }
          }
          if (next) {
            const options = {
              url: new url_12.URL(next)
            };
            return options;
          }
          return false;
        },
        filter: () => true,
        shouldContinue: () => true,
        countLimit: Infinity,
        backoff: 0,
        requestLimit: 1e4,
        stackAllItems: true
      },
      parseJson: (text) => JSON.parse(text),
      stringifyJson: (object) => JSON.stringify(object),
      cacheOptions: {}
    },
    handlers: [create_1.defaultHandler],
    mutableDefaults: false
  };
  const got2 = create_1.default(defaults2);
  exports.default = got2;
  module.exports = got2;
  module.exports.default = got2;
  module.exports.__esModule = true;
  __exportStar(create, exports);
  __exportStar(asPromise, exports);
})(source$4, source$4.exports);
var Stream$1 = require$$0$2__default.Stream;
var util$2 = require$$1;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$2.inherits(DelayedStream$1, Stream$1);
DelayedStream$1.create = function(source2, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source2;
  var realEmit = source2.emit;
  source2.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source2, arguments);
  };
  source2.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source2.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$1.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }
  this._bufferedEvents.push(args);
};
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$1 = require$$1;
var Stream = require$$0$2__default.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$1.inherits(CombinedStream$1, Stream);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
};
CombinedStream$1.isStreamLike = function(stream) {
  return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
};
CombinedStream$1.prototype.append = function(stream) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream);
  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams
      });
      stream.on("data", this._checkDataSize.bind(this));
      stream = newStream;
    }
    this._handleErrors(stream);
    if (this.pauseStreams) {
      stream.pause();
    }
  }
  this._streams.push(stream);
  return this;
};
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream = this._streams.shift();
  if (typeof stream == "undefined") {
    this.end();
    return;
  }
  if (typeof stream !== "function") {
    this._pipeNext(stream);
    return;
  }
  var getStream2 = stream;
  getStream2(function(stream2) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream2);
    if (isStreamLike) {
      stream2.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream2);
    }
    this._pipeNext(stream2);
  }.bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream) {
  this._currentStream = stream;
  var isStreamLike = CombinedStream$1.isStreamLike(stream);
  if (isStreamLike) {
    stream.on("end", this._getNext.bind(this));
    stream.pipe(this, { end: false });
    return;
  }
  var value = stream;
  this.write(value);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream) {
  var self2 = this;
  stream.on("error", function(err) {
    self2._emitError(err);
  });
};
CombinedStream$1.prototype.write = function(data) {
  this.emit("data", data);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
    this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
    this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self2 = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }
    self2.dataSize += stream.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var db = mimeDb;
  var extname = require$$1$4.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup2;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime2 = match && db[match[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime2 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime2);
      if (charset2)
        mime2 += "; charset=" + charset2.toLowerCase();
    }
    return mime2;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime2 = db[type];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from2 = preference.indexOf(db[types2[extension2]].source);
          var to2 = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from2 > to2 || from2 === to2 && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type;
      }
    });
  }
})(mimeTypes);
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback2) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback2(err, result);
    } else {
      defer(function nextTick_callback() {
        callback2(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean.bind(state2));
  state2.jobs = {};
}
function clean(key) {
  if (typeof this.jobs[key] == "function") {
    this.jobs[key]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list2, iterator, state2, callback2) {
  var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key] = runJob(iterator, key, list2[key], function(error, output) {
    if (!(key in state2.jobs)) {
      return;
    }
    delete state2.jobs[key];
    if (error) {
      abort$1(state2);
    } else {
      state2.results[key] = output;
    }
    callback2(error, state2.results);
  });
}
function runJob(iterator, key, item, callback2) {
  var aborter;
  if (iterator.length == 2) {
    aborter = iterator(item, async$1(callback2));
  } else {
    aborter = iterator(item, key, async$1(callback2));
  }
  return aborter;
}
var state_1 = state;
function state(list2, sortMethod) {
  var isNamedList = !Array.isArray(list2), initState2 = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list2).length : list2.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list2[a], list2[b]);
    });
  }
  return initState2;
}
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback2) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback2)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list2, iterator, callback2) {
  var state2 = initState$1(list2);
  while (state2.index < (state2["keyedList"] || list2).length) {
    iterate$1(list2, iterator, state2, function(error, result) {
      if (error) {
        callback2(error, result);
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback2(null, state2.results);
        return;
      }
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback2);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list2, iterator, sortMethod, callback2) {
  var state2 = initState(list2, sortMethod);
  iterate(list2, iterator, state2, function iteratorHandler(error, result) {
    if (error) {
      callback2(error, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list2).length) {
      iterate(list2, iterator, state2, iteratorHandler);
      return;
    }
    callback2(null, state2.results);
  });
  return terminator.bind(state2, callback2);
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function descending(a, b) {
  return -1 * ascending(a, b);
}
var serialOrdered = serialOrdered$2.exports;
var serial_1 = serial;
function serial(list2, iterator, callback2) {
  return serialOrdered(list2, iterator, null, callback2);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrdered$2.exports
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util = require$$1;
var path = require$$1$4;
var http = require$$4;
var https = require$$1$3;
var parseUrl = require$$0$3.parse;
var fs$1 = require$$2$1;
var mime = mimeTypes;
var asynckit = asynckit$1;
var populate = populate$1;
var form_data = FormData$1;
util.inherits(FormData$1, CombinedStream);
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options == "string") {
    options = { filename: options };
  }
  var append = CombinedStream.prototype.append.bind(this);
  if (typeof value == "number") {
    value = "" + value;
  }
  if (util.isArray(value)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();
  append(header);
  append(value);
  append(footer);
  this._trackLength(header, value, options);
};
FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback2) {
  if (value.hasOwnProperty("fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback2(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs$1.stat(value.path, function(err, stat) {
        var fileSize;
        if (err) {
          callback2(err);
          return;
        }
        fileSize = stat.size - (value.start ? value.start : 0);
        callback2(null, fileSize);
      });
    }
  } else if (value.hasOwnProperty("httpVersion")) {
    callback2(null, +value.headers["content-length"]);
  } else if (value.hasOwnProperty("httpModule")) {
    value.on("response", function(response) {
      value.pause();
      callback2(null, +response.headers["content-length"]);
    });
    value.resume();
  } else {
    callback2("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header == "string") {
    return options.header;
  }
  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);
  var contents = "";
  var headers = {
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
    "Content-Type": [].concat(contentType || [])
  };
  if (typeof options.header == "object") {
    populate(headers, options.header);
  }
  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop))
      continue;
    header = headers[prop];
    if (header == null) {
      continue;
    }
    if (!Array.isArray(header)) {
      header = [header];
    }
    if (header.length) {
      contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename, contentDisposition;
  if (typeof options.filepath === "string") {
    filename = path.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value.name || value.path) {
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty("httpVersion")) {
    filename = path.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }
  return contentDisposition;
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType = options.contentType;
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }
  if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
    contentType = value.headers["content-type"];
  }
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType && typeof value == "object") {
    contentType = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType;
};
FormData$1.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }.bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }
    values.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$1.prototype.submit = function(params, cb) {
  var request2, options, defaults2 = { method: "post" };
  if (typeof params == "string") {
    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol == "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol == "https:") {
    request2 = https.request(options);
  } else {
    request2 = http.request(options);
  }
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }
    request2.setHeader("Content-Length", length);
    this.pipe(request2);
    if (cb) {
      var onResponse;
      var callback2 = function(error, responce) {
        request2.removeListener("error", callback2);
        request2.removeListener("response", onResponse);
        return cb.call(this, error, responce);
      };
      onResponse = callback2.bind(this, null);
      request2.on("error", callback2);
      request2.on("response", onResponse);
    }
  }.bind(this));
  return request2;
};
FormData$1.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit("error", err);
  }
};
FormData$1.prototype.toString = function() {
  return "[object FormData]";
};
function parseParam(param) {
  var parts = param.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
  if (!parts)
    return null;
  return {
    key: parts[1],
    value: parts[2]
  };
}
function parseLink(link) {
  var parts = link.match(/<?([^>]*)>(.*)/);
  if (!parts)
    return null;
  var linkUrl = parts[1];
  var linkParams = parts[2].split(";");
  var rel = null;
  var parsedLinkParams = linkParams.reduce(function(result, param) {
    var parsed = parseParam(param);
    if (!parsed)
      return result;
    if (parsed.key === "rel") {
      if (!rel) {
        rel = parsed.value;
      }
      return result;
    }
    result[parsed.key] = parsed.value;
    return result;
  }, {});
  if (!rel)
    return null;
  return {
    url: linkUrl,
    rel,
    params: parsedLinkParams
  };
}
function parseLinkHeader$1(linkHeader) {
  if (!linkHeader)
    return {};
  return linkHeader.split(/,\s*</).reduce(function(result, link) {
    var parsed = parseLink(link);
    if (!parsed)
      return result;
    var splitRel = parsed.rel.split(/\s+/);
    splitRel.forEach(function(rel) {
      if (!result[rel]) {
        result[rel] = {
          url: parsed.url,
          params: parsed.params
        };
      }
    });
    return result;
  }, {});
}
var parseLinkHeader_1 = parseLinkHeader$1;
var parseLinkHeader = parseLinkHeader_1;
function MapiResponse$1(request2, responseData) {
  this.request = request2;
  this.headers = responseData.headers;
  this.rawBody = responseData.body;
  this.statusCode = responseData.statusCode;
  try {
    this.body = JSON.parse(responseData.body || "{}");
  } catch (parseError) {
    this.body = responseData.body;
  }
  this.links = parseLinkHeader(this.headers.link);
}
MapiResponse$1.prototype.hasNextPage = function hasNextPage() {
  return !!this.links.next;
};
MapiResponse$1.prototype.nextPage = function nextPage() {
  if (!this.hasNextPage())
    return null;
  return this.request._extend({
    path: this.links.next.url
  });
};
var mapiResponse = MapiResponse$1;
var constants$4 = {
  API_ORIGIN: "https://api.mapbox.com",
  EVENT_PROGRESS_DOWNLOAD: "downloadProgress",
  EVENT_PROGRESS_UPLOAD: "uploadProgress",
  EVENT_ERROR: "error",
  EVENT_RESPONSE: "response",
  ERROR_HTTP: "HttpError",
  ERROR_REQUEST_ABORTED: "RequestAbortedError"
};
var constants$3 = constants$4;
function MapiError$1(options) {
  var errorType = options.type || constants$3.ERROR_HTTP;
  var body;
  if (options.body) {
    try {
      body = JSON.parse(options.body);
    } catch (e) {
      body = options.body;
    }
  } else {
    body = null;
  }
  var message = options.message || null;
  if (!message) {
    if (typeof body === "string") {
      message = body;
    } else if (body && typeof body.message === "string") {
      message = body.message;
    } else if (errorType === constants$3.ERROR_REQUEST_ABORTED) {
      message = "Request aborted";
    }
  }
  this.message = message;
  this.type = errorType;
  this.statusCode = options.statusCode || null;
  this.request = options.request;
  this.body = body;
}
var mapiError = MapiError$1;
var xtend$4 = immutable;
var fs = require$$2$1;
var got = source$4.exports;
var FormData = form_data;
var MapiResponse = mapiResponse;
var MapiError = mapiError;
var constants$2 = constants$4;
var methodsWithBodies = /* @__PURE__ */ new Set(["PUT", "PATCH", "POST"]);
var requestsUnderway = {};
function nodeAbort(request2) {
  var streams = requestsUnderway[request2.id];
  if (!streams)
    return;
  streams.clientRequest.abort();
  delete requestsUnderway[request2.id];
}
function normalizeGotProgressEvent(progress) {
  return xtend$4(progress, {
    percent: progress.percent * 100
  });
}
function createRequestStreams(request2) {
  var url2 = request2.url(request2.client.accessToken);
  var gotOptions = {
    method: request2.method,
    headers: request2.headers,
    retries: 0,
    followRedirect: false,
    throwHttpErrors: false
  };
  if (typeof request2.file === "string") {
    if (request2.sendFileAs && request2.sendFileAs === "form") {
      const form = new FormData();
      form.append("file", fs.createReadStream(request2.file));
      gotOptions.body = form;
    } else {
      gotOptions.body = fs.createReadStream(request2.file);
    }
  } else if (request2.file && request2.file.pipe) {
    if (request2.sendFileAs && request2.sendFileAs === "form") {
      const form = new FormData();
      form.append("file", request2.file);
      gotOptions.body = form;
    } else {
      gotOptions.body = request2.file;
    }
  } else if (typeof request2.body === "string") {
    gotOptions.body = request2.body;
  } else if (request2.body) {
    gotOptions.body = JSON.stringify(request2.body);
  }
  var gotStream = got.stream(url2, gotOptions);
  gotStream.setEncoding(request2.encoding);
  gotStream.on("downloadProgress", function(progress) {
    request2.emitter.emit(constants$2.EVENT_PROGRESS_DOWNLOAD, normalizeGotProgressEvent(progress));
  });
  gotStream.on("uploadProgress", function(progress) {
    request2.emitter.emit(constants$2.EVENT_PROGRESS_UPLOAD, normalizeGotProgressEvent(progress));
  });
  return new Promise(function(resolve2) {
    gotStream.on("request", function(req) {
      var clientRequest2 = req;
      var streams = { clientRequest: clientRequest2, gotStream };
      requestsUnderway[request2.id] = streams;
      resolve2(streams);
    });
    if (methodsWithBodies.has(request2.method) && gotOptions.body === void 0) {
      gotStream.end();
    }
  });
}
function nodeSend(request2) {
  return Promise.resolve().then(function() {
    return createRequestStreams(request2);
  }).then(function(result) {
    return sendStreams(result.gotStream, result.clientRequest);
  });
  function sendStreams(gotStream, clientRequest2) {
    return new Promise(function(resolve2, reject) {
      var errored = false;
      clientRequest2.on("abort", function() {
        var mapiError2 = new MapiError({
          request: request2,
          type: constants$2.ERROR_REQUEST_ABORTED
        });
        errored = true;
        reject(mapiError2);
      });
      var httpsResponse = void 0;
      var statusCode = void 0;
      gotStream.on("response", function(res) {
        httpsResponse = res;
        statusCode = res.statusCode;
      });
      var body = "";
      gotStream.on("data", function(chunk) {
        body += chunk;
      });
      gotStream.on("end", function() {
        if (errored || !httpsResponse)
          return;
        if (statusCode < 200 || statusCode >= 400) {
          var mapiError2 = new MapiError({
            request: request2,
            body,
            statusCode
          });
          reject(mapiError2);
          return;
        }
        try {
          var response = new MapiResponse(request2, {
            body,
            headers: httpsResponse.headers,
            statusCode: httpsResponse.statusCode
          });
          resolve2(response);
        } catch (responseError) {
          reject(responseError);
        }
      });
      gotStream.on("error", function(error) {
        errored = true;
        reject(error);
      });
    });
  }
}
var nodeLayer = {
  nodeAbort,
  nodeSend
};
var base64$1 = { exports: {} };
/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
(function(module, exports) {
  (function(root2) {
    var freeExports = exports;
    var freeModule = module && module.exports == freeExports && module;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var InvalidCharacterError = function(message) {
      this.message = message;
    };
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    var error = function(message) {
      throw new InvalidCharacterError(message);
    };
    var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
    var decode = function(input) {
      input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
      var length = input.length;
      if (length % 4 == 0) {
        input = input.replace(/==?$/, "");
        length = input.length;
      }
      if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(input)) {
        error("Invalid character: the string to be decoded is not correctly encoded.");
      }
      var bitCounter = 0;
      var bitStorage;
      var buffer2;
      var output = "";
      var position = -1;
      while (++position < length) {
        buffer2 = TABLE.indexOf(input.charAt(position));
        bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer2 : buffer2;
        if (bitCounter++ % 4) {
          output += String.fromCharCode(255 & bitStorage >> (-2 * bitCounter & 6));
        }
      }
      return output;
    };
    var encode = function(input) {
      input = String(input);
      if (/[^\0-\xFF]/.test(input)) {
        error("The string to be encoded contains characters outside of the Latin1 range.");
      }
      var padding = input.length % 3;
      var output = "";
      var position = -1;
      var a;
      var b;
      var c;
      var buffer2;
      var length = input.length - padding;
      while (++position < length) {
        a = input.charCodeAt(position) << 16;
        b = input.charCodeAt(++position) << 8;
        c = input.charCodeAt(++position);
        buffer2 = a + b + c;
        output += TABLE.charAt(buffer2 >> 18 & 63) + TABLE.charAt(buffer2 >> 12 & 63) + TABLE.charAt(buffer2 >> 6 & 63) + TABLE.charAt(buffer2 & 63);
      }
      if (padding == 2) {
        a = input.charCodeAt(position) << 8;
        b = input.charCodeAt(++position);
        buffer2 = a + b;
        output += TABLE.charAt(buffer2 >> 10) + TABLE.charAt(buffer2 >> 4 & 63) + TABLE.charAt(buffer2 << 2 & 63) + "=";
      } else if (padding == 1) {
        buffer2 = input.charCodeAt(position);
        output += TABLE.charAt(buffer2 >> 2) + TABLE.charAt(buffer2 << 4 & 63) + "==";
      }
      return output;
    };
    var base642 = {
      "encode": encode,
      "decode": decode,
      "version": "0.1.0"
    };
    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = base642;
      } else {
        for (var key in base642) {
          base642.hasOwnProperty(key) && (freeExports[key] = base642[key]);
        }
      }
    } else {
      root2.base64 = base642;
    }
  })(commonjsGlobal);
})(base64$1, base64$1.exports);
var base64 = base64$1.exports;
var tokenCache = {};
function parseToken$2(token) {
  if (tokenCache[token]) {
    return tokenCache[token];
  }
  var parts = token.split(".");
  var usage = parts[0];
  var rawPayload = parts[1];
  if (!rawPayload) {
    throw new Error("Invalid token");
  }
  var parsedPayload = parsePaylod(rawPayload);
  var result = {
    usage,
    user: parsedPayload.u
  };
  if (has(parsedPayload, "a"))
    result.authorization = parsedPayload.a;
  if (has(parsedPayload, "exp"))
    result.expires = parsedPayload.exp * 1e3;
  if (has(parsedPayload, "iat"))
    result.created = parsedPayload.iat * 1e3;
  if (has(parsedPayload, "scopes"))
    result.scopes = parsedPayload.scopes;
  if (has(parsedPayload, "client"))
    result.client = parsedPayload.client;
  if (has(parsedPayload, "ll"))
    result.lastLogin = parsedPayload.ll;
  if (has(parsedPayload, "iu"))
    result.impersonator = parsedPayload.iu;
  tokenCache[token] = result;
  return result;
}
function parsePaylod(rawPayload) {
  try {
    return JSON.parse(base64.decode(rawPayload));
  } catch (parseError) {
    throw new Error("Invalid token");
  }
}
function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var parseMapboxToken = parseToken$2;
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once3) {
    this.fn = fn;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn, context, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events2 = this._events) {
      if (has2.call(events2, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener2(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context) {
    return addListener2(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length = listeners2.length; i < length; i++) {
        if (listeners2[i].fn !== fn || once3 && !listeners2[i].once || context && listeners2[i].context !== context) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
function encodeArray(arrayValue) {
  return arrayValue.map(encodeURIComponent).join(",");
}
function encodeValue(value) {
  if (Array.isArray(value)) {
    return encodeArray(value);
  }
  return encodeURIComponent(String(value));
}
function appendQueryParam(url2, key, value) {
  if (value === false || value === null) {
    return url2;
  }
  var punctuation = /\?/.test(url2) ? "&" : "?";
  var query = encodeURIComponent(key);
  if (value !== void 0 && value !== "" && value !== true) {
    query += "=" + encodeValue(value);
  }
  return "" + url2 + punctuation + query;
}
function appendQueryObject(url2, queryObject) {
  if (!queryObject) {
    return url2;
  }
  var result = url2;
  Object.keys(queryObject).forEach(function(key) {
    var value = queryObject[key];
    if (value === void 0) {
      return;
    }
    if (Array.isArray(value)) {
      value = value.filter(function(v2) {
        return v2 !== null && v2 !== void 0;
      }).join(",");
    }
    result = appendQueryParam(result, key, value);
  });
  return result;
}
function prependOrigin(url2, origin) {
  if (!origin) {
    return url2;
  }
  if (url2.slice(0, 4) === "http") {
    return url2;
  }
  var delimiter = url2[0] === "/" ? "" : "/";
  return "" + origin.replace(/\/$/, "") + delimiter + url2;
}
function interpolateRouteParams(route, params) {
  if (!params) {
    return route;
  }
  return route.replace(/\/:([a-zA-Z0-9]+)/g, function(_, paramId) {
    var value = params[paramId];
    if (value === void 0) {
      throw new Error("Unspecified route parameter " + paramId);
    }
    var preppedValue = encodeValue(value);
    return "/" + preppedValue;
  });
}
var urlUtils$1 = {
  appendQueryObject,
  appendQueryParam,
  prependOrigin,
  interpolateRouteParams
};
var parseToken$1 = parseMapboxToken;
var xtend$3 = immutable;
var EventEmitter$1 = eventemitter3.exports;
var urlUtils = urlUtils$1;
var constants$1 = constants$4;
var requestId = 1;
function MapiRequest$1(client2, options) {
  if (!client2) {
    throw new Error("MapiRequest requires a client");
  }
  if (!options || !options.path || !options.method) {
    throw new Error("MapiRequest requires an options object with path and method properties");
  }
  var defaultHeaders = {};
  if (options.body) {
    defaultHeaders["content-type"] = "application/json";
  }
  var headersWithDefaults = xtend$3(defaultHeaders, options.headers);
  var headers = Object.keys(headersWithDefaults).reduce(function(memo, name) {
    memo[name.toLowerCase()] = headersWithDefaults[name];
    return memo;
  }, {});
  this.id = requestId++;
  this._options = options;
  this.emitter = new EventEmitter$1();
  this.client = client2;
  this.response = null;
  this.error = null;
  this.sent = false;
  this.aborted = false;
  this.path = options.path;
  this.method = options.method;
  this.origin = options.origin || client2.origin;
  this.query = options.query || {};
  this.params = options.params || {};
  this.body = options.body || null;
  this.file = options.file || null;
  this.encoding = options.encoding || "utf8";
  this.sendFileAs = options.sendFileAs || null;
  this.headers = headers;
}
MapiRequest$1.prototype.url = function url(accessToken) {
  var url2 = urlUtils.prependOrigin(this.path, this.origin);
  url2 = urlUtils.appendQueryObject(url2, this.query);
  var routeParams = this.params;
  var actualAccessToken = accessToken == null ? this.client.accessToken : accessToken;
  if (actualAccessToken) {
    url2 = urlUtils.appendQueryParam(url2, "access_token", actualAccessToken);
    var accessTokenOwnerId = parseToken$1(actualAccessToken).user;
    routeParams = xtend$3({ ownerId: accessTokenOwnerId }, routeParams);
  }
  url2 = urlUtils.interpolateRouteParams(url2, routeParams);
  return url2;
};
MapiRequest$1.prototype.send = function send2() {
  var self2 = this;
  if (self2.sent) {
    throw new Error("This request has already been sent. Check the response and error properties. Create a new request with clone().");
  }
  self2.sent = true;
  return self2.client.sendRequest(self2).then(function(response) {
    self2.response = response;
    self2.emitter.emit(constants$1.EVENT_RESPONSE, response);
    return response;
  }, function(error) {
    self2.error = error;
    self2.emitter.emit(constants$1.EVENT_ERROR, error);
    throw error;
  });
};
MapiRequest$1.prototype.abort = function abort2() {
  if (this._nextPageRequest) {
    this._nextPageRequest.abort();
    delete this._nextPageRequest;
  }
  if (this.response || this.error || this.aborted)
    return;
  this.aborted = true;
  this.client.abortRequest(this);
};
MapiRequest$1.prototype.eachPage = function eachPage(callback2) {
  var self2 = this;
  function handleResponse(response) {
    function getNextPage() {
      delete self2._nextPageRequest;
      var nextPageRequest = response.nextPage();
      if (nextPageRequest) {
        self2._nextPageRequest = nextPageRequest;
        getPage(nextPageRequest);
      }
    }
    callback2(null, response, getNextPage);
  }
  function handleError(error) {
    callback2(error, null, function() {
    });
  }
  function getPage(request2) {
    request2.send().then(handleResponse, handleError);
  }
  getPage(this);
};
MapiRequest$1.prototype.clone = function clone2() {
  return this._extend();
};
MapiRequest$1.prototype._extend = function _extend(options) {
  var extendedOptions = xtend$3(this._options, options);
  return new MapiRequest$1(this.client, extendedOptions);
};
var mapiRequest = MapiRequest$1;
var parseToken = parseMapboxToken;
var MapiRequest = mapiRequest;
var constants = constants$4;
function MapiClient$2(options) {
  if (!options || !options.accessToken) {
    throw new Error("Cannot create a client without an access token");
  }
  parseToken(options.accessToken);
  this.accessToken = options.accessToken;
  this.origin = options.origin || constants.API_ORIGIN;
}
MapiClient$2.prototype.createRequest = function createRequest(requestOptions) {
  return new MapiRequest(this, requestOptions);
};
var mapiClient = MapiClient$2;
var node = nodeLayer;
var MapiClient$1 = mapiClient;
function NodeClient(options) {
  MapiClient$1.call(this, options);
}
NodeClient.prototype = Object.create(MapiClient$1.prototype);
NodeClient.prototype.constructor = NodeClient;
NodeClient.prototype.sendRequest = node.nodeSend;
NodeClient.prototype.abortRequest = node.nodeAbort;
function createNodeClient(options) {
  return new NodeClient(options);
}
var nodeClient$1 = createNodeClient;
var nodeClient = nodeClient$1;
var client$1 = nodeClient;
var client = client$1;
var mapboxSdk = client;
var toString = Object.prototype.toString;
var isPlainObj = function(x) {
  var prototype;
  return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};
var isPlainObject = isPlainObj;
var xtend$2 = immutable;
var DEFAULT_ERROR_PATH = "value";
var NEWLINE_INDENT = "\n  ";
var v$2 = {};
v$2.assert = function(rootValidator, options) {
  options = options || {};
  return function(value) {
    var message = validate(rootValidator, value);
    if (!message) {
      return;
    }
    var errorMessage = processMessage(message, options);
    if (options.apiName) {
      errorMessage = options.apiName + ": " + errorMessage;
    }
    throw new Error(errorMessage);
  };
};
v$2.shape = function shape(validatorObj) {
  var validators = objectEntries(validatorObj);
  return function shapeValidator(value) {
    var validationResult = validate(v$2.plainObject, value);
    if (validationResult) {
      return validationResult;
    }
    var key, validator2;
    var errorMessages = [];
    for (var i = 0; i < validators.length; i++) {
      key = validators[i].key;
      validator2 = validators[i].value;
      validationResult = validate(validator2, value[key]);
      if (validationResult) {
        errorMessages.push([key].concat(validationResult));
      }
    }
    if (errorMessages.length < 2) {
      return errorMessages[0];
    }
    return function(options) {
      errorMessages = errorMessages.map(function(message) {
        var key2 = message[0];
        var renderedMessage = processMessage(message, options).split("\n").join(NEWLINE_INDENT);
        return "- " + key2 + ": " + renderedMessage;
      });
      var objectId = options.path.join(".");
      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? "" : " of " + objectId;
      return "The following properties" + ofPhrase + " have invalid values:" + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);
    };
  };
};
v$2.strictShape = function strictShape(validatorObj) {
  var shapeValidator = v$2.shape(validatorObj);
  return function strictShapeValidator(value) {
    var shapeResult = shapeValidator(value);
    if (shapeResult) {
      return shapeResult;
    }
    var invalidKeys = Object.keys(value).reduce(function(memo, valueKey) {
      if (validatorObj[valueKey] === void 0) {
        memo.push(valueKey);
      }
      return memo;
    }, []);
    if (invalidKeys.length !== 0) {
      return function() {
        return "The following keys are invalid: " + invalidKeys.join(", ");
      };
    }
  };
};
v$2.arrayOf = function arrayOf(validator2) {
  return createArrayValidator(validator2);
};
v$2.tuple = function tuple() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return createArrayValidator(validators);
};
function createArrayValidator(validators) {
  var validatingTuple = Array.isArray(validators);
  var getValidator = function(index2) {
    if (validatingTuple) {
      return validators[index2];
    }
    return validators;
  };
  return function arrayValidator(value) {
    var validationResult = validate(v$2.plainArray, value);
    if (validationResult) {
      return validationResult;
    }
    if (validatingTuple && value.length !== validators.length) {
      return "an array with " + validators.length + " items";
    }
    for (var i = 0; i < value.length; i++) {
      validationResult = validate(getValidator(i), value[i]);
      if (validationResult) {
        return [i].concat(validationResult);
      }
    }
  };
}
v$2.required = function required(validator2) {
  function requiredValidator(value) {
    if (value == null) {
      return function(options) {
        return formatErrorMessage(options, isArrayCulprit(options.path) ? "cannot be undefined/null." : "is required.");
      };
    }
    return validator2.apply(this, arguments);
  }
  requiredValidator.__required = true;
  return requiredValidator;
};
v$2.oneOfType = function oneOfType() {
  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  return function oneOfTypeValidator(value) {
    var messages = validators.map(function(validator2) {
      return validate(validator2, value);
    }).filter(Boolean);
    if (messages.length !== validators.length) {
      return;
    }
    if (messages.every(function(message) {
      return message.length === 1 && typeof message[0] === "string";
    })) {
      return orList(messages.map(function(m) {
        return m[0];
      }));
    }
    return messages.reduce(function(max, arr) {
      return arr.length > max.length ? arr : max;
    });
  };
};
v$2.equal = function equal(compareWith) {
  return function equalValidator(value) {
    if (value !== compareWith) {
      return JSON.stringify(compareWith);
    }
  };
};
v$2.oneOf = function oneOf() {
  var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
  var validators = options.map(function(value) {
    return v$2.equal(value);
  });
  return v$2.oneOfType.apply(this, validators);
};
v$2.range = function range2(compareWith) {
  var min = compareWith[0];
  var max = compareWith[1];
  return function rangeValidator(value) {
    var validationResult = validate(v$2.number, value);
    if (validationResult || value < min || value > max) {
      return "number between " + min + " & " + max + " (inclusive)";
    }
  };
};
v$2.any = function any() {
  return;
};
v$2.boolean = function boolean(value) {
  if (typeof value !== "boolean") {
    return "boolean";
  }
};
v$2.number = function number(value) {
  if (typeof value !== "number") {
    return "number";
  }
};
v$2.plainArray = function plainArray(value) {
  if (!Array.isArray(value)) {
    return "array";
  }
};
v$2.plainObject = function plainObject(value) {
  if (!isPlainObject(value)) {
    return "object";
  }
};
v$2.string = function string(value) {
  if (typeof value !== "string") {
    return "string";
  }
};
v$2.func = function func(value) {
  if (typeof value !== "function") {
    return "function";
  }
};
function validate(validator2, value) {
  if (value == null && !validator2.hasOwnProperty("__required")) {
    return;
  }
  var result = validator2(value);
  if (result) {
    return Array.isArray(result) ? result : [result];
  }
}
function processMessage(message, options) {
  var len = message.length;
  var result = message[len - 1];
  var path2 = message.slice(0, len - 1);
  if (path2.length === 0) {
    path2 = [DEFAULT_ERROR_PATH];
  }
  options = xtend$2(options, { path: path2 });
  return typeof result === "function" ? result(options) : formatErrorMessage(options, prettifyResult(result));
}
function orList(list2) {
  if (list2.length < 2) {
    return list2[0];
  }
  if (list2.length === 2) {
    return list2.join(" or ");
  }
  return list2.slice(0, -1).join(", ") + ", or " + list2.slice(-1);
}
function prettifyResult(result) {
  return "must be " + addArticle(result) + ".";
}
function addArticle(nounPhrase) {
  if (/^an? /.test(nounPhrase)) {
    return nounPhrase;
  }
  if (/^[aeiou]/i.test(nounPhrase)) {
    return "an " + nounPhrase;
  }
  if (/^[a-z]/i.test(nounPhrase)) {
    return "a " + nounPhrase;
  }
  return nounPhrase;
}
function formatErrorMessage(options, prettyResult) {
  var arrayCulprit = isArrayCulprit(options.path);
  var output = options.path.join(".") + " " + prettyResult;
  var prepend = arrayCulprit ? "Item at position " : "";
  return prepend + output;
}
function isArrayCulprit(path2) {
  return typeof path2[path2.length - 1] == "number" || typeof path2[0] == "number";
}
function objectEntries(obj) {
  return Object.keys(obj || {}).map(function(key) {
    return { key, value: obj[key] };
  });
}
v$2.validate = validate;
v$2.processMessage = processMessage;
var lib$1 = v$2;
var xtend$1 = immutable;
var v$1 = lib$1;
function file(value) {
  if (typeof value === "string" || value.pipe !== void 0) {
    return;
  }
  return "Filename or Readable stream";
}
function assertShape(validatorObj, apiName) {
  return v$1.assert(v$1.strictShape(validatorObj), apiName);
}
function date(value) {
  var msg = "date";
  if (typeof value === "boolean") {
    return msg;
  }
  try {
    var date2 = new Date(value);
    if (date2.getTime && isNaN(date2.getTime())) {
      return msg;
    }
  } catch (e) {
    return msg;
  }
}
function coordinates(value) {
  return v$1.tuple(v$1.number, v$1.number)(value);
}
var validator = xtend$1(v$1, {
  file,
  date,
  coordinates,
  assertShape
});
function pick$1(source2, keys2) {
  var filter = function(key, val) {
    return keys2.indexOf(key) !== -1 && val !== void 0;
  };
  if (typeof keys2 === "function") {
    filter = keys2;
  }
  return Object.keys(source2).filter(function(key) {
    return filter(key, source2[key]);
  }).reduce(function(result, key) {
    result[key] = source2[key];
    return result;
  }, {});
}
var pick_1 = pick$1;
function objectMap$1(obj, cb) {
  return Object.keys(obj).reduce(function(result, key) {
    result[key] = cb(key, obj[key]);
    return result;
  }, {});
}
var objectMap_1 = objectMap$1;
var objectMap = objectMap_1;
function stringifyBoolean(obj) {
  return objectMap(obj, function(_, value) {
    return typeof value === "boolean" ? JSON.stringify(value) : value;
  });
}
var stringifyBooleans$1 = stringifyBoolean;
var MapiClient = mapiClient;
var createClient = client$1;
function createServiceFactory$1(ServicePrototype) {
  return function(clientOrConfig) {
    var client2;
    if (MapiClient.prototype.isPrototypeOf(clientOrConfig)) {
      client2 = clientOrConfig;
    } else {
      client2 = createClient(clientOrConfig);
    }
    var service = Object.create(ServicePrototype);
    service.client = client2;
    return service;
  };
}
var createServiceFactory_1 = createServiceFactory$1;
var xtend = immutable;
var v = validator;
var pick = pick_1;
var stringifyBooleans = stringifyBooleans$1;
var createServiceFactory = createServiceFactory_1;
var Geocoding = {};
var featureTypes = [
  "country",
  "region",
  "postcode",
  "district",
  "place",
  "locality",
  "neighborhood",
  "address",
  "poi",
  "poi.landmark"
];
Geocoding.forwardGeocode = function(config) {
  v.assertShape({
    query: v.required(v.string),
    mode: v.oneOf("mapbox.places", "mapbox.places-permanent"),
    countries: v.arrayOf(v.string),
    proximity: v.oneOf(v.coordinates, "ip"),
    types: v.arrayOf(v.oneOf(featureTypes)),
    autocomplete: v.boolean,
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    routing: v.boolean,
    fuzzyMatch: v.boolean,
    worldview: v.string
  })(config);
  config.mode = config.mode || "mapbox.places";
  var query = stringifyBooleans(xtend({ country: config.countries }, pick(config, [
    "proximity",
    "types",
    "autocomplete",
    "bbox",
    "limit",
    "language",
    "routing",
    "fuzzyMatch",
    "worldview"
  ])));
  return this.client.createRequest({
    method: "GET",
    path: "/geocoding/v5/:mode/:query.json",
    params: pick(config, ["mode", "query"]),
    query
  });
};
Geocoding.reverseGeocode = function(config) {
  v.assertShape({
    query: v.required(v.coordinates),
    mode: v.oneOf("mapbox.places", "mapbox.places-permanent"),
    countries: v.arrayOf(v.string),
    types: v.arrayOf(v.oneOf(featureTypes)),
    bbox: v.arrayOf(v.number),
    limit: v.number,
    language: v.arrayOf(v.string),
    reverseMode: v.oneOf("distance", "score"),
    routing: v.boolean,
    worldview: v.string
  })(config);
  config.mode = config.mode || "mapbox.places";
  var query = stringifyBooleans(xtend({ country: config.countries }, pick(config, [
    "country",
    "types",
    "bbox",
    "limit",
    "language",
    "reverseMode",
    "routing",
    "worldview"
  ])));
  return this.client.createRequest({
    method: "GET",
    path: "/geocoding/v5/:mode/:query.json",
    params: pick(config, ["mode", "query"]),
    query
  });
};
var geocoding = createServiceFactory(Geocoding);
let urlAlphabet$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var urlAlphabet_1 = { urlAlphabet: urlAlphabet$1 };
let crypto = require$$0$6;
let { urlAlphabet } = urlAlphabet_1;
const POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset;
let fillPool = (bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto.randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
};
let random = (bytes) => {
  fillPool(bytes -= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
};
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
let customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
let nanoid$1 = (size = 21) => {
  fillPool(size -= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
};
var nanoid_1 = { nanoid: nanoid$1, customAlphabet, customRandom, urlAlphabet, random };
var nanoid = nanoid_1.nanoid;
function MapboxEventManager$1(options) {
  this.origin = options.origin || "https://api.mapbox.com";
  this.endpoint = "events/v2";
  this.access_token = options.accessToken;
  this.version = "0.2.0";
  this.sessionID = this.generateSessionID();
  this.userAgent = this.getUserAgent();
  this.options = options;
  this.send = this.send.bind(this);
  this.countries = options.countries ? options.countries.split(",") : null;
  this.types = options.types ? options.types.split(",") : null;
  this.bbox = options.bbox ? options.bbox : null;
  this.language = options.language ? options.language.split(",") : null;
  this.limit = options.limit ? +options.limit : null;
  this.locale = navigator.language || null;
  this.enableEventLogging = this.shouldEnableLogging(options);
  this.eventQueue = new Array();
  this.flushInterval = options.flushInterval || 1e3;
  this.maxQueueSize = options.maxQueueSize || 100;
  this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null;
  this.lastSentInput = "";
  this.lastSentIndex = 0;
}
MapboxEventManager$1.prototype = {
  select: function(selected, geocoder) {
    var resultIndex = this.getSelectedIndex(selected, geocoder);
    var payload = this.getEventPayload("search.select", geocoder);
    payload.resultIndex = resultIndex;
    payload.resultPlaceName = selected.place_name;
    payload.resultId = selected.id;
    if (resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput || resultIndex == -1) {
      return;
    }
    this.lastSentIndex = resultIndex;
    this.lastSentInput = payload.queryString;
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  start: function(geocoder) {
    var payload = this.getEventPayload("search.start", geocoder);
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  keyevent: function(keyEvent, geocoder) {
    if (!keyEvent.key)
      return;
    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1)
      return;
    var payload = this.getEventPayload("search.keystroke", geocoder);
    payload.lastAction = keyEvent.key;
    if (!payload.queryString)
      return;
    return this.push(payload);
  },
  send: function(payload, callback2) {
    if (!this.enableEventLogging) {
      if (callback2)
        return callback2();
      return;
    }
    var options = this.getRequestOptions(payload);
    this.request(options, function(err) {
      if (err)
        return this.handleError(err, callback2);
      if (callback2) {
        return callback2();
      }
    }.bind(this));
  },
  getRequestOptions: function(payload) {
    if (!Array.isArray(payload))
      payload = [payload];
    var options = {
      method: "POST",
      host: this.origin,
      path: this.endpoint + "?access_token=" + this.access_token,
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    };
    return options;
  },
  getEventPayload: function(event, geocoder) {
    var proximity;
    if (!geocoder.options.proximity) {
      proximity = null;
    } else if (typeof geocoder.options.proximity === "object") {
      proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];
    } else if (geocoder.options.proximity === "ip") {
      proximity = [999, 999];
    } else {
      proximity = geocoder.options.proximity;
    }
    var zoom = geocoder._map ? geocoder._map.getZoom() : void 0;
    var payload = {
      event,
      created: +new Date(),
      sessionIdentifier: this.sessionID,
      country: this.countries,
      userAgent: this.userAgent,
      language: this.language,
      bbox: this.bbox,
      types: this.types,
      endpoint: "mapbox.places",
      autocomplete: geocoder.options.autocomplete,
      fuzzyMatch: geocoder.options.fuzzyMatch,
      proximity,
      limit: geocoder.options.limit,
      routing: geocoder.options.routing,
      worldview: geocoder.options.worldview,
      mapZoom: zoom,
      keyboardLocale: this.locale
    };
    if (event === "search.select") {
      payload.queryString = geocoder.inputString;
    } else if (event != "search.select" && geocoder._inputEl) {
      payload.queryString = geocoder._inputEl.value;
    } else {
      payload.queryString = geocoder.inputString;
    }
    return payload;
  },
  request: function(opts, callback2) {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
      if (this.readyState == 4) {
        if (this.status == 204) {
          return callback2(null);
        } else {
          return callback2(this.statusText);
        }
      }
    };
    xhttp.open(opts.method, opts.host + "/" + opts.path, true);
    for (var header in opts.headers) {
      var headerValue = opts.headers[header];
      xhttp.setRequestHeader(header, headerValue);
    }
    xhttp.send(opts.body);
  },
  handleError: function(err, callback2) {
    if (callback2)
      return callback2(err);
  },
  generateSessionID: function() {
    return nanoid();
  },
  getUserAgent: function() {
    return "mapbox-gl-geocoder." + this.version + "." + navigator.userAgent;
  },
  getSelectedIndex: function(selected, geocoder) {
    if (!geocoder._typeahead)
      return;
    var results = geocoder._typeahead.data;
    var selectedID = selected.id;
    var resultIDs = results.map(function(feature) {
      return feature.id;
    });
    var selectedIdx = resultIDs.indexOf(selectedID);
    return selectedIdx;
  },
  shouldEnableLogging: function(options) {
    if (options.enableEventLogging === false)
      return false;
    if (options.origin && options.origin !== "https://api.mapbox.com")
      return false;
    if (options.localGeocoder)
      return false;
    if (options.filter)
      return false;
    return true;
  },
  flush: function() {
    if (this.eventQueue.length > 0) {
      this.send(this.eventQueue);
      this.eventQueue = new Array();
    }
    if (this.timer)
      clearTimeout(this.timer);
    if (this.flushInterval)
      this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
  },
  push: function(evt, forceFlush) {
    this.eventQueue.push(evt);
    if (this.eventQueue.length >= this.maxQueueSize || forceFlush) {
      this.flush();
    }
  },
  remove: function() {
    this.flush();
  }
};
var events = MapboxEventManager$1;
var placeholder = {
  "de": "Suche",
  "it": "Ricerca",
  "en": "Search",
  "nl": "Zoeken",
  "fr": "Chercher",
  "ca": "Cerca",
  "he": "\u05DC\u05D7\u05E4\u05E9",
  "ja": "\u30B5\u30FC\u30C1",
  "lv": "Mekl\u0113t",
  "pt": "Procurar",
  "sr": "\u041F\u0440\u0435\u0442\u0440\u0430\u0433\u0430",
  "zh": "\u641C\u7D22",
  "cs": "Vyhled\xE1v\xE1n\xED",
  "hu": "Keres\xE9s",
  "ka": "\u10EB\u10D8\u10D4\u10D1\u10D0",
  "nb": "S\xF8ke",
  "sk": "Vyh\u013Ead\xE1vanie",
  "th": "\u0E04\u0E49\u0E19\u0E2B\u0E32",
  "fi": "Hae",
  "is": "Leita",
  "ko": "\uC218\uC0C9",
  "pl": "Szukaj",
  "sl": "Iskanje",
  "fa": "\u062C\u0633\u062A\u062C\u0648",
  "ru": "\u041F\u043E\u0438\u0441\u043A"
};
var localization$1 = { placeholder };
var subtag$1 = { exports: {} };
(function(module) {
  !function(root2, name, make) {
    if (module.exports)
      module.exports = make();
    else
      root2[name] = make();
  }(commonjsGlobal, "subtag", function() {
    var empty = "";
    var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function match(tag) {
      return tag.match(pattern) || [];
    }
    function split(tag) {
      return match(tag).filter(function(v2, i) {
        return v2 && i;
      });
    }
    function api(tag) {
      tag = match(tag);
      return {
        language: tag[1] || empty,
        extlang: tag[2] || empty,
        script: tag[3] || empty,
        region: tag[4] || empty
      };
    }
    function expose(target, key, value) {
      Object.defineProperty(target, key, {
        value,
        enumerable: true
      });
    }
    function part(position, pattern2, type) {
      function method(tag) {
        return match(tag)[position] || empty;
      }
      expose(method, "pattern", pattern2);
      expose(api, type, method);
    }
    part(1, /^[a-zA-Z]{2,3}$/, "language");
    part(2, /^[a-zA-Z]{3}$/, "extlang");
    part(3, /^[a-zA-Z]{4}$/, "script");
    part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region");
    expose(api, "split", split);
    return api;
  });
})(subtag$1);
function Geolocation$1() {
}
Geolocation$1.prototype = {
  isSupport: function() {
    return Boolean(window.navigator.geolocation);
  },
  getCurrentPosition: function() {
    const positionOptions = {
      enableHighAccuracy: true
    };
    return new Promise(function(resolve2, reject) {
      window.navigator.geolocation.getCurrentPosition(resolve2, reject, positionOptions);
    });
  }
};
var geolocation = Geolocation$1;
function transformFeatureToGeolocationText(feature, accuracy) {
  const addrInfo = getAddressInfo(feature);
  const addressAccuracy = ["address", "street", "place", "country"];
  var currentAccuracy;
  if (typeof accuracy === "function") {
    return accuracy(addrInfo);
  }
  const accuracyIndex = addressAccuracy.indexOf(accuracy);
  if (accuracyIndex === -1) {
    currentAccuracy = addressAccuracy;
  } else {
    currentAccuracy = addressAccuracy.slice(accuracyIndex);
  }
  return currentAccuracy.reduce(function(acc, name) {
    if (!addrInfo[name]) {
      return acc;
    }
    if (acc !== "") {
      acc = acc + ", ";
    }
    return acc + addrInfo[name];
  }, "");
}
function getAddressInfo(feature) {
  const houseNumber = feature.address || "";
  const street = feature.text || "";
  const placeName = feature.place_name || "";
  const address = placeName.split(",")[0];
  const addrInfo = {
    address,
    houseNumber,
    street,
    placeName
  };
  feature.context.forEach(function(context) {
    const layer = context.id.split(".")[0];
    addrInfo[layer] = context.text;
  });
  return addrInfo;
}
const REVERSE_GEOCODE_COORD_RGX = /^[ ]*(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)[ ]*$/;
var utils$1 = {
  transformFeatureToGeolocationText,
  getAddressInfo,
  REVERSE_GEOCODE_COORD_RGX
};
var Typeahead = suggestions;
var debounce = lodash_debounce;
var extend = immutable;
var EventEmitter = events$1.exports.EventEmitter;
var exceptions = exceptions$1;
var MapboxClient = mapboxSdk;
var mbxGeocoder = geocoding;
var MapboxEventManager = events;
var localization = localization$1;
var subtag = subtag$1.exports;
var Geolocation = geolocation;
var utils = utils$1;
const GEOCODE_REQUEST_TYPE = {
  FORWARD: 0,
  LOCAL: 1,
  REVERSE: 2
};
function getFooterNode() {
  var div = document.createElement("div");
  div.className = "mapboxgl-ctrl-geocoder--powered-by";
  div.innerHTML = '<a href="https://www.mapbox.com/search-service" target="_blank">Powered by Mapbox</a>';
  return div;
}
function MapboxGeocoder(options) {
  this._eventEmitter = new EventEmitter();
  this.options = extend({}, this.options, options);
  this.inputString = "";
  this.fresh = true;
  this.lastSelected = null;
  this.geolocation = new Geolocation();
}
MapboxGeocoder.prototype = {
  options: {
    zoom: 16,
    flyTo: true,
    trackProximity: true,
    minLength: 2,
    reverseGeocode: false,
    flipCoordinates: false,
    limit: 5,
    origin: "https://api.mapbox.com",
    enableEventLogging: true,
    marker: true,
    mapboxgl: null,
    collapsed: false,
    clearAndBlurOnEsc: false,
    clearOnBlur: false,
    enableGeolocation: false,
    addressAccuracy: "street",
    getItemValue: function(item) {
      return item.place_name;
    },
    render: function(item) {
      var placeName = item.place_name.split(",");
      return '<div class="mapboxgl-ctrl-geocoder--suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div>";
    }
  },
  addTo: function(container) {
    function addToExistingContainer(geocoder, container2) {
      if (!document.body.contains(container2)) {
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      }
      const el = geocoder.onAdd();
      container2.appendChild(el);
    }
    if (container._controlContainer) {
      container.addControl(this);
    } else if (container instanceof HTMLElement) {
      addToExistingContainer(this, container);
    } else if (typeof container == "string") {
      const parent = document.querySelectorAll(container);
      if (parent.length === 0) {
        throw new Error("Element ", container, "not found.");
      }
      if (parent.length > 1) {
        throw new Error("Geocoder can only be added to a single html element");
      }
      addToExistingContainer(this, parent[0]);
    } else {
      throw new Error("Error: addTo must be a mapbox-gl-js map, an html element, or a CSS selector query for a single html element");
    }
  },
  onAdd: function(map2) {
    if (map2 && typeof map2 != "string") {
      this._map = map2;
    }
    this.setLanguage();
    if (!this.options.localGeocoderOnly) {
      this.geocoderService = mbxGeocoder(MapboxClient({
        accessToken: this.options.accessToken,
        origin: this.options.origin
      }));
    }
    if (this.options.localGeocoderOnly && !this.options.localGeocoder) {
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    }
    this.eventManager = new MapboxEventManager(this.options);
    this._onChange = this._onChange.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onPaste = this._onPaste.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._showButton = this._showButton.bind(this);
    this._hideButton = this._hideButton.bind(this);
    this._onQueryResult = this._onQueryResult.bind(this);
    this.clear = this.clear.bind(this);
    this._updateProximity = this._updateProximity.bind(this);
    this._collapse = this._collapse.bind(this);
    this._unCollapse = this._unCollapse.bind(this);
    this._clear = this._clear.bind(this);
    this._clearOnBlur = this._clearOnBlur.bind(this);
    this._geolocateUser = this._geolocateUser.bind(this);
    var el = this.container = document.createElement("div");
    el.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl";
    var searchIcon = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input");
    this._inputEl.type = "text";
    this._inputEl.className = "mapboxgl-ctrl-geocoder--input";
    this.setPlaceholder();
    if (this.options.collapsed) {
      this._collapse();
      this.container.addEventListener("mouseenter", this._unCollapse);
      this.container.addEventListener("mouseleave", this._collapse);
      this._inputEl.addEventListener("focus", this._unCollapse);
    }
    if (this.options.collapsed || this.options.clearOnBlur) {
      this._inputEl.addEventListener("blur", this._onBlur);
    }
    this._inputEl.addEventListener("keydown", debounce(this._onKeyDown, 200));
    this._inputEl.addEventListener("paste", this._onPaste);
    this._inputEl.addEventListener("change", this._onChange);
    this.container.addEventListener("mouseenter", this._showButton);
    this.container.addEventListener("mouseleave", this._hideButton);
    this._inputEl.addEventListener("keyup", function(e) {
      this.eventManager.keyevent(e, this);
    }.bind(this));
    var actions = document.createElement("div");
    actions.classList.add("mapboxgl-ctrl-geocoder--pin-right");
    this._clearEl = document.createElement("button");
    this._clearEl.setAttribute("aria-label", "Clear");
    this._clearEl.addEventListener("click", this.clear);
    this._clearEl.className = "mapboxgl-ctrl-geocoder--button";
    var buttonIcon = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    this._clearEl.appendChild(buttonIcon);
    this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>');
    actions.appendChild(this._clearEl);
    actions.appendChild(this._loadingEl);
    el.appendChild(searchIcon);
    el.appendChild(this._inputEl);
    el.appendChild(actions);
    if (this.options.enableGeolocation && this.geolocation.isSupport()) {
      this._geolocateEl = document.createElement("button");
      this._geolocateEl.setAttribute("aria-label", "Geolocate");
      this._geolocateEl.addEventListener("click", this._geolocateUser);
      this._geolocateEl.className = "mapboxgl-ctrl-geocoder--button";
      var geolocateIcon = this.createIcon("geolocate", '<path d="M12.999 3.677L2.042 8.269c-.962.403-.747 1.823.29 1.912l5.032.431.431 5.033c.089 1.037 1.509 1.252 1.912.29l4.592-10.957c.345-.822-.477-1.644-1.299-1.299z" fill="#4264fb"/>');
      this._geolocateEl.appendChild(geolocateIcon);
      actions.appendChild(this._geolocateEl);
      this._showGeolocateButton();
    }
    var typeahead = this._typeahead = new Typeahead(this._inputEl, [], {
      filter: false,
      minLength: this.options.minLength,
      limit: this.options.limit
    });
    this.setRenderFunction(this.options.render);
    typeahead.getItemValue = this.options.getItemValue;
    var parentDraw = typeahead.list.draw;
    var footerNode = this._footerNode = getFooterNode();
    typeahead.list.draw = function() {
      parentDraw.call(this);
      footerNode.addEventListener("mousedown", function() {
        this.selectingListItem = true;
      }.bind(this));
      footerNode.addEventListener("mouseup", function() {
        this.selectingListItem = false;
      }.bind(this));
      this.element.appendChild(footerNode);
    };
    this.mapMarker = null;
    this._handleMarker = this._handleMarker.bind(this);
    if (this._map) {
      if (this.options.trackProximity) {
        this._updateProximity();
        this._map.on("moveend", this._updateProximity);
      }
      this._mapboxgl = this.options.mapboxgl;
      if (!this._mapboxgl && this.options.marker) {
        console.error("No mapboxgl detected in options. Map markers are disabled. Please set options.mapboxgl.");
        this.options.marker = false;
      }
    }
    return el;
  },
  _geolocateUser: function() {
    this._hideGeolocateButton();
    this._showLoadingIcon();
    this.geolocation.getCurrentPosition().then(function(geolocationPosition) {
      this._hideLoadingIcon();
      const geojson = {
        geometry: {
          type: "Point",
          coordinates: [geolocationPosition.coords.longitude, geolocationPosition.coords.latitude]
        }
      };
      this._handleMarker(geojson);
      this._fly(geojson);
      this._typeahead.clear();
      this._typeahead.selected = true;
      this.lastSelected = JSON.stringify(geojson);
      this._showClearButton();
      this.fresh = false;
      const config = {
        limit: 1,
        language: [this.options.language],
        query: geojson.geometry.coordinates,
        types: ["address"]
      };
      if (this.options.localGeocoderOnly) {
        const text = geojson.geometry.coordinates[0] + "," + geojson.geometry.coordinates[1];
        this._setInputValue(text);
        this._eventEmitter.emit("result", { result: geojson });
      } else {
        this.geocoderService.reverseGeocode(config).send().then(function(resp) {
          const feature = resp.body.features[0];
          if (feature) {
            const locationText = utils.transformFeatureToGeolocationText(feature, this.options.addressAccuracy);
            this._setInputValue(locationText);
            feature.user_coordinates = geojson.geometry.coordinates;
            this._eventEmitter.emit("result", { result: feature });
          } else {
            this._eventEmitter.emit("result", { result: { user_coordinates: geojson.geometry.coordinates } });
          }
        }.bind(this));
      }
    }.bind(this)).catch(function(error) {
      if (error.code === 1) {
        this._renderUserDeniedGeolocationError();
      } else {
        this._renderLocationError();
      }
      this._hideLoadingIcon();
      this._showGeolocateButton();
      this._hideAttribution();
    }.bind(this));
  },
  createIcon: function(name, path2) {
    var icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    icon.setAttribute("class", "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + name);
    icon.setAttribute("viewBox", "0 0 18 18");
    icon.setAttribute("xml:space", "preserve");
    icon.setAttribute("width", 18);
    icon.setAttribute("height", 18);
    icon.innerHTML = path2;
    return icon;
  },
  onRemove: function() {
    this.container.parentNode.removeChild(this.container);
    if (this.options.trackProximity && this._map) {
      this._map.off("moveend", this._updateProximity);
    }
    this._removeMarker();
    this._map = null;
    return this;
  },
  _setInputValue: function(value) {
    this._inputEl.value = value;
    setTimeout(function() {
      this._inputEl.focus();
      this._inputEl.scrollLeft = 0;
      this._inputEl.setSelectionRange(0, 0);
    }.bind(this), 1);
  },
  _onPaste: function(e) {
    var value = (e.clipboardData || window.clipboardData).getData("text");
    if (value.length >= this.options.minLength) {
      this._geocode(value);
    }
  },
  _onKeyDown: function(e) {
    var ESC_KEY_CODE = 27, TAB_KEY_CODE = 9;
    if (e.keyCode === ESC_KEY_CODE && this.options.clearAndBlurOnEsc) {
      this._clear(e);
      return this._inputEl.blur();
    }
    var target = e.target && e.target.shadowRoot ? e.target.shadowRoot.activeElement : e.target;
    var value = target ? target.value : "";
    if (!value) {
      this.fresh = true;
      if (e.keyCode !== TAB_KEY_CODE)
        this.clear(e);
      this._showGeolocateButton();
      return this._hideClearButton();
    }
    this._hideGeolocateButton();
    if (e.metaKey || [TAB_KEY_CODE, ESC_KEY_CODE, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1)
      return;
    if (target.value.length >= this.options.minLength) {
      this._geocode(target.value);
    }
  },
  _showButton: function() {
    if (this._typeahead.selected)
      this._showClearButton();
  },
  _hideButton: function() {
    if (this._typeahead.selected)
      this._hideClearButton();
  },
  _showClearButton: function() {
    this._clearEl.style.display = "block";
  },
  _hideClearButton: function() {
    this._clearEl.style.display = "none";
  },
  _showGeolocateButton: function() {
    if (this._geolocateEl && this.geolocation.isSupport()) {
      this._geolocateEl.style.display = "block";
    }
  },
  _hideGeolocateButton: function() {
    if (this._geolocateEl) {
      this._geolocateEl.style.display = "none";
    }
  },
  _showLoadingIcon: function() {
    this._loadingEl.style.display = "block";
  },
  _hideLoadingIcon: function() {
    this._loadingEl.style.display = "none";
  },
  _showAttribution: function() {
    this._footerNode.style.display = "block";
  },
  _hideAttribution: function() {
    this._footerNode.style.display = "none";
  },
  _onBlur: function(e) {
    if (this.options.clearOnBlur) {
      this._clearOnBlur(e);
    }
    if (this.options.collapsed) {
      this._collapse();
    }
  },
  _onChange: function() {
    var selected = this._typeahead.selected;
    if (selected && JSON.stringify(selected) !== this.lastSelected) {
      this._hideClearButton();
      if (this.options.flyTo) {
        this._fly(selected);
      }
      if (this.options.marker && this._mapboxgl) {
        this._handleMarker(selected);
      }
      this._inputEl.focus();
      this._inputEl.scrollLeft = 0;
      this._inputEl.setSelectionRange(0, 0);
      this.lastSelected = JSON.stringify(selected);
      this._eventEmitter.emit("result", { result: selected });
      this.eventManager.select(selected, this);
    }
  },
  _fly: function(selected) {
    var flyOptions;
    if (selected.properties && exceptions[selected.properties.short_code]) {
      flyOptions = extend({}, this.options.flyTo);
      if (this._map) {
        this._map.fitBounds(exceptions[selected.properties.short_code].bbox, flyOptions);
      }
    } else if (selected.bbox) {
      var bbox = selected.bbox;
      flyOptions = extend({}, this.options.flyTo);
      if (this._map) {
        this._map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], flyOptions);
      }
    } else {
      var defaultFlyOptions = {
        zoom: this.options.zoom
      };
      flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
      if (selected.center) {
        flyOptions.center = selected.center;
      } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
        flyOptions.center = selected.geometry.coordinates;
      }
      if (this._map) {
        this._map.flyTo(flyOptions);
      }
    }
  },
  _requestType: function(options, search) {
    var type;
    if (options.localGeocoderOnly) {
      type = GEOCODE_REQUEST_TYPE.LOCAL;
    } else if (options.reverseGeocode && utils.REVERSE_GEOCODE_COORD_RGX.test(search)) {
      type = GEOCODE_REQUEST_TYPE.REVERSE;
    } else {
      type = GEOCODE_REQUEST_TYPE.FORWARD;
    }
    return type;
  },
  _setupConfig: function(requestType, search) {
    const keys2 = [
      "bbox",
      "limit",
      "proximity",
      "countries",
      "types",
      "language",
      "reverseMode",
      "mode",
      "autocomplete",
      "fuzzyMatch",
      "routing",
      "worldview"
    ];
    const spacesOrCommaRgx = /[\s,]+/;
    var self2 = this;
    var config = keys2.reduce(function(config2, key) {
      if (self2.options[key] === void 0 || self2.options[key] === null) {
        return config2;
      }
      ["countries", "types", "language"].indexOf(key) > -1 ? config2[key] = self2.options[key].split(spacesOrCommaRgx) : config2[key] = self2.options[key];
      const isCoordKey = typeof self2.options[key].longitude === "number" && typeof self2.options[key].latitude === "number";
      if (key === "proximity" && isCoordKey) {
        const lng = self2.options[key].longitude;
        const lat = self2.options[key].latitude;
        config2[key] = [lng, lat];
      }
      return config2;
    }, {});
    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.REVERSE:
        {
          var coords = search.split(spacesOrCommaRgx).map(function(c) {
            return parseFloat(c, 10);
          });
          if (!self2.options.flipCoordinates) {
            coords.reverse();
          }
          config.types ? [config.types[0]] : ["poi"];
          config = extend(config, { query: coords, limit: 1 });
          ["proximity", "autocomplete", "fuzzyMatch", "bbox"].forEach(function(key) {
            if (key in config) {
              delete config[key];
            }
          });
        }
        break;
      case GEOCODE_REQUEST_TYPE.FORWARD:
        {
          const trimmedSearch = search.trim();
          const reverseGeocodeCoordRgx = /^(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)?$/;
          if (reverseGeocodeCoordRgx.test(trimmedSearch)) {
            search = search.replace(/,/g, " ");
          }
          config = extend(config, { query: search });
        }
        break;
    }
    return config;
  },
  _geocode: function(searchInput) {
    this.inputString = searchInput;
    this._showLoadingIcon();
    this._eventEmitter.emit("loading", { query: searchInput });
    const requestType = this._requestType(this.options, searchInput);
    const config = this._setupConfig(requestType, searchInput);
    var request2;
    switch (requestType) {
      case GEOCODE_REQUEST_TYPE.LOCAL:
        request2 = Promise.resolve();
        break;
      case GEOCODE_REQUEST_TYPE.FORWARD:
        request2 = this.geocoderService.forwardGeocode(config).send();
        break;
      case GEOCODE_REQUEST_TYPE.REVERSE:
        request2 = this.geocoderService.reverseGeocode(config).send();
        break;
    }
    var localGeocoderRes = this.options.localGeocoder ? this.options.localGeocoder(searchInput) || [] : [];
    var externalGeocoderRes = [];
    var geocoderError = null;
    request2.catch(function(error) {
      geocoderError = error;
    }.bind(this)).then(function(response) {
      this._hideLoadingIcon();
      var res = {};
      if (!response) {
        res = {
          type: "FeatureCollection",
          features: []
        };
      } else if (response.statusCode == "200") {
        res = response.body;
        res.request = response.request;
        res.headers = response.headers;
      }
      res.config = config;
      if (this.fresh) {
        this.eventManager.start(this);
        this.fresh = false;
      }
      res.features = res.features ? localGeocoderRes.concat(res.features) : localGeocoderRes;
      if (this.options.externalGeocoder) {
        externalGeocoderRes = this.options.externalGeocoder(searchInput, res.features) || Promise.resolve([]);
        return externalGeocoderRes.then(function(features) {
          res.features = res.features ? features.concat(res.features) : features;
          return res;
        }, function() {
          return res;
        });
      }
      return res;
    }.bind(this)).then(function(res) {
      if (geocoderError) {
        throw geocoderError;
      }
      if (this.options.filter && res.features.length) {
        res.features = res.features.filter(this.options.filter);
      }
      if (res.features.length) {
        this._showClearButton();
        this._hideGeolocateButton();
        this._showAttribution();
        this._eventEmitter.emit("results", res);
        this._typeahead.update(res.features);
      } else {
        this._hideClearButton();
        this._hideAttribution();
        this._typeahead.selected = null;
        this._renderNoResults();
        this._eventEmitter.emit("results", res);
      }
    }.bind(this)).catch(function(err) {
      this._hideLoadingIcon();
      this._hideAttribution();
      if (localGeocoderRes.length && this.options.localGeocoder || externalGeocoderRes.length && this.options.externalGeocoder) {
        this._showClearButton();
        this._hideGeolocateButton();
        this._typeahead.update(localGeocoderRes);
      } else {
        this._hideClearButton();
        this._typeahead.selected = null;
        this._renderError();
      }
      this._eventEmitter.emit("results", { features: localGeocoderRes });
      this._eventEmitter.emit("error", { error: err });
    }.bind(this));
    return request2;
  },
  _clear: function(ev) {
    if (ev)
      ev.preventDefault();
    this._inputEl.value = "";
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._onChange();
    this._hideClearButton();
    this._showGeolocateButton();
    this._removeMarker();
    this.lastSelected = null;
    this._eventEmitter.emit("clear");
    this.fresh = true;
  },
  clear: function(ev) {
    this._clear(ev);
    this._inputEl.focus();
  },
  _clearOnBlur: function(ev) {
    var ctx = this;
    if (ev.relatedTarget) {
      ctx._clear(ev);
    }
  },
  _onQueryResult: function(response) {
    var results = response.body;
    if (!results.features.length)
      return;
    var result = results.features[0];
    this._typeahead.selected = result;
    this._inputEl.value = result.place_name;
    this._onChange();
  },
  _updateProximity: function() {
    if (!this._map || !this.options.trackProximity) {
      return;
    }
    if (this._map.getZoom() > 9) {
      var center = this._map.getCenter().wrap();
      this.setProximity({ longitude: center.lng, latitude: center.lat }, false);
    } else {
      this.setProximity(null, false);
    }
  },
  _collapse: function() {
    if (!this._inputEl.value && this._inputEl !== document.activeElement)
      this.container.classList.add("mapboxgl-ctrl-geocoder--collapsed");
  },
  _unCollapse: function() {
    this.container.classList.remove("mapboxgl-ctrl-geocoder--collapsed");
  },
  query: function(searchInput) {
    this._geocode(searchInput).then(this._onQueryResult);
    return this;
  },
  _renderError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>There was an error reaching the server</div>";
    this._renderMessage(errorMessage);
  },
  _renderLocationError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>A location error has occurred</div>";
    this._renderMessage(errorMessage);
  },
  _renderNoResults: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results'>No results found</div>";
    this._renderMessage(errorMessage);
  },
  _renderUserDeniedGeolocationError: function() {
    var errorMessage = "<div class='mapbox-gl-geocoder--error'>Geolocation permission denied</div>";
    this._renderMessage(errorMessage);
  },
  _renderMessage: function(msg) {
    this._typeahead.update([]);
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._typeahead.renderError(msg);
  },
  _getPlaceholderText: function() {
    if (this.options.placeholder)
      return this.options.placeholder;
    if (this.options.language) {
      var firstLanguage = this.options.language.split(",")[0];
      var language = subtag.language(firstLanguage);
      var localizedValue = localization.placeholder[language];
      if (localizedValue)
        return localizedValue;
    }
    return "Search";
  },
  setInput: function(searchInput) {
    this._inputEl.value = searchInput;
    this._typeahead.selected = null;
    this._typeahead.clear();
    if (searchInput.length >= this.options.minLength) {
      this._geocode(searchInput);
    }
    return this;
  },
  setProximity: function(proximity, disableTrackProximity = true) {
    this.options.proximity = proximity;
    if (disableTrackProximity) {
      this.options.trackProximity = false;
    }
    return this;
  },
  getProximity: function() {
    return this.options.proximity;
  },
  setRenderFunction: function(fn) {
    if (fn && typeof fn == "function") {
      this._typeahead.render = fn;
    }
    return this;
  },
  getRenderFunction: function() {
    return this._typeahead.render;
  },
  setLanguage: function(language) {
    var browserLocale = navigator.language || navigator.userLanguage || navigator.browserLanguage;
    this.options.language = language || this.options.language || browserLocale;
    return this;
  },
  getLanguage: function() {
    return this.options.language;
  },
  getZoom: function() {
    return this.options.zoom;
  },
  setZoom: function(zoom) {
    this.options.zoom = zoom;
    return this;
  },
  getFlyTo: function() {
    return this.options.flyTo;
  },
  setFlyTo: function(flyTo) {
    this.options.flyTo = flyTo;
    return this;
  },
  getPlaceholder: function() {
    return this.options.placeholder;
  },
  setPlaceholder: function(placeholder2) {
    this.placeholder = placeholder2 ? placeholder2 : this._getPlaceholderText();
    this._inputEl.placeholder = this.placeholder;
    this._inputEl.setAttribute("aria-label", this.placeholder);
    return this;
  },
  getBbox: function() {
    return this.options.bbox;
  },
  setBbox: function(bbox) {
    this.options.bbox = bbox;
    return this;
  },
  getCountries: function() {
    return this.options.countries;
  },
  setCountries: function(countries) {
    this.options.countries = countries;
    return this;
  },
  getTypes: function() {
    return this.options.types;
  },
  setTypes: function(types2) {
    this.options.types = types2;
    return this;
  },
  getMinLength: function() {
    return this.options.minLength;
  },
  setMinLength: function(minLength) {
    this.options.minLength = minLength;
    if (this._typeahead)
      this._typeahead.options.minLength = minLength;
    return this;
  },
  getLimit: function() {
    return this.options.limit;
  },
  setLimit: function(limit) {
    this.options.limit = limit;
    if (this._typeahead)
      this._typeahead.options.limit = limit;
    return this;
  },
  getFilter: function() {
    return this.options.filter;
  },
  setFilter: function(filter) {
    this.options.filter = filter;
    return this;
  },
  setOrigin: function(origin) {
    this.options.origin = origin;
    this.geocoderService = mbxGeocoder(MapboxClient({
      accessToken: this.options.accessToken,
      origin: this.options.origin
    }));
    return this;
  },
  getOrigin: function() {
    return this.options.origin;
  },
  setAccessToken: function(accessToken) {
    this.options.accessToken = accessToken;
    this.geocoderService = mbxGeocoder(MapboxClient({
      accessToken: this.options.accessToken,
      origin: this.options.origin
    }));
    return this;
  },
  setAutocomplete: function(value) {
    this.options.autocomplete = value;
    return this;
  },
  getAutocomplete: function() {
    return this.options.autocomplete;
  },
  setFuzzyMatch: function(value) {
    this.options.fuzzyMatch = value;
    return this;
  },
  getFuzzyMatch: function() {
    return this.options.fuzzyMatch;
  },
  setRouting: function(value) {
    this.options.routing = value;
    return this;
  },
  getRouting: function() {
    return this.options.routing;
  },
  setWorldview: function(code2) {
    this.options.worldview = code2;
    return this;
  },
  getWorldview: function() {
    return this.options.worldview;
  },
  _handleMarker: function(selected) {
    if (!this._map) {
      return;
    }
    this._removeMarker();
    var defaultMarkerOptions = {
      color: "#4668F2"
    };
    var markerOptions = extend({}, defaultMarkerOptions, this.options.marker);
    this.mapMarker = new this._mapboxgl.Marker(markerOptions);
    if (selected.center) {
      this.mapMarker.setLngLat(selected.center).addTo(this._map);
    } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
      this.mapMarker.setLngLat(selected.geometry.coordinates).addTo(this._map);
    }
    return this;
  },
  _removeMarker: function() {
    if (this.mapMarker) {
      this.mapMarker.remove();
      this.mapMarker = null;
    }
  },
  on: function(type, fn) {
    this._eventEmitter.on(type, fn);
    return this;
  },
  off: function(type, fn) {
    this._eventEmitter.removeListener(type, fn);
    this.eventManager.remove();
    return this;
  }
};
var lib = MapboxGeocoder;
var dist = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist, "__esModule", { value: true });
const src_1 = __importDefault(src$4);
var _default = dist.default = src_1.default;
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys2;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal2(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var mapboxGlDraw$1 = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = function(t2, e2) {
      var n2 = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, o2 = { on: function(t3, e3, o3) {
        if (n2[t3] === void 0)
          throw new Error("Invalid event type: " + t3);
        n2[t3].push({ selector: e3, fn: o3 });
      }, render: function(t3) {
        e2.store.featureChanged(t3);
      } }, r2 = function(t3, r3) {
        for (var i2 = n2[t3], a2 = i2.length; a2--; ) {
          var s2 = i2[a2];
          if (s2.selector(r3)) {
            s2.fn.call(o2, r3) || e2.store.render(), e2.ui.updateMapClasses();
            break;
          }
        }
      };
      return t2.start.call(o2), { render: t2.render, stop: function() {
        t2.stop && t2.stop();
      }, trash: function() {
        t2.trash && (t2.trash(), e2.store.render());
      }, combineFeatures: function() {
        t2.combineFeatures && t2.combineFeatures();
      }, uncombineFeatures: function() {
        t2.uncombineFeatures && t2.uncombineFeatures();
      }, drag: function(t3) {
        r2("drag", t3);
      }, click: function(t3) {
        r2("click", t3);
      }, mousemove: function(t3) {
        r2("mousemove", t3);
      }, mousedown: function(t3) {
        r2("mousedown", t3);
      }, mouseup: function(t3) {
        r2("mouseup", t3);
      }, mouseout: function(t3) {
        r2("mouseout", t3);
      }, keydown: function(t3) {
        r2("keydown", t3);
      }, keyup: function(t3) {
        r2("keyup", t3);
      }, touchstart: function(t3) {
        r2("touchstart", t3);
      }, touchmove: function(t3) {
        r2("touchmove", t3);
      }, touchend: function(t3) {
        r2("touchend", t3);
      }, tap: function(t3) {
        r2("tap", t3);
      } };
    };
    function e(t2) {
      if (t2.__esModule)
        return t2;
      var e2 = t2.default;
      if (typeof e2 == "function") {
        var n2 = function t3() {
          if (this instanceof t3) {
            var n3 = [null];
            n3.push.apply(n3, arguments);
            var o2 = Function.bind.apply(e2, n3);
            return new o2();
          }
          return e2.apply(this, arguments);
        };
        n2.prototype = e2.prototype;
      } else
        n2 = {};
      return Object.defineProperty(n2, "__esModule", { value: true }), Object.keys(t2).forEach(function(e3) {
        var o2 = Object.getOwnPropertyDescriptor(t2, e3);
        Object.defineProperty(n2, e3, o2.get ? o2 : { enumerable: true, get: function() {
          return t2[e3];
        } });
      }), n2;
    }
    var n = {}, o = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 63567523142e-4 }, r = o;
    function i(t2) {
      var e2 = 0;
      if (t2 && t2.length > 0) {
        e2 += Math.abs(a(t2[0]));
        for (var n2 = 1; n2 < t2.length; n2++)
          e2 -= Math.abs(a(t2[n2]));
      }
      return e2;
    }
    function a(t2) {
      var e2, n2, o2, i2, a2, u2, c2 = 0, l2 = t2.length;
      if (l2 > 2) {
        for (u2 = 0; u2 < l2; u2++)
          u2 === l2 - 2 ? (o2 = l2 - 2, i2 = l2 - 1, a2 = 0) : u2 === l2 - 1 ? (o2 = l2 - 1, i2 = 0, a2 = 1) : (o2 = u2, i2 = u2 + 1, a2 = u2 + 2), e2 = t2[o2], n2 = t2[i2], c2 += (s(t2[a2][0]) - s(e2[0])) * Math.sin(s(n2[1]));
        c2 = c2 * r.RADIUS * r.RADIUS / 2;
      }
      return c2;
    }
    function s(t2) {
      return t2 * Math.PI / 180;
    }
    n.geometry = function t2(e2) {
      var n2, o2 = 0;
      switch (e2.type) {
        case "Polygon":
          return i(e2.coordinates);
        case "MultiPolygon":
          for (n2 = 0; n2 < e2.coordinates.length; n2++)
            o2 += i(e2.coordinates[n2]);
          return o2;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
        case "GeometryCollection":
          for (n2 = 0; n2 < e2.geometries.length; n2++)
            o2 += t2(e2.geometries[n2]);
          return o2;
      }
    }, n.ring = a;
    var u = { CONTROL_BASE: "mapboxgl-ctrl", CONTROL_PREFIX: "mapboxgl-ctrl-", CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn", CONTROL_BUTTON_LINE: "mapbox-gl-draw_line", CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon", CONTROL_BUTTON_POINT: "mapbox-gl-draw_point", CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash", CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine", CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine", CONTROL_GROUP: "mapboxgl-ctrl-group", ATTRIBUTION: "mapboxgl-ctrl-attrib", ACTIVE_BUTTON: "active", BOX_SELECT: "mapbox-gl-draw_boxselect" }, c = { HOT: "mapbox-gl-draw-hot", COLD: "mapbox-gl-draw-cold" }, l = { ADD: "add", MOVE: "move", DRAG: "drag", POINTER: "pointer", NONE: "none" }, d = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, p = { FEATURE: "Feature", POLYGON: "Polygon", LINE_STRING: "LineString", POINT: "Point", FEATURE_COLLECTION: "FeatureCollection", MULTI_PREFIX: "Multi", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon" }, f = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, h3 = { CREATE: "draw.create", DELETE: "draw.delete", UPDATE: "draw.update", SELECTION_CHANGE: "draw.selectionchange", MODE_CHANGE: "draw.modechange", ACTIONABLE: "draw.actionable", RENDER: "draw.render", COMBINE_FEATURES: "draw.combine", UNCOMBINE_FEATURES: "draw.uncombine" }, g = { MOVE: "move", CHANGE_COORDINATES: "change_coordinates" }, y = { FEATURE: "feature", MIDPOINT: "midpoint", VERTEX: "vertex" }, v2 = { ACTIVE: "true", INACTIVE: "false" }, m = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], _ = -85, b = Object.freeze({ __proto__: null, classes: u, sources: c, cursors: l, types: d, geojsonTypes: p, modes: f, events: h3, updateActions: g, meta: y, activeStates: v2, interactions: m, LAT_MIN: -90, LAT_RENDERED_MIN: _, LAT_MAX: 90, LAT_RENDERED_MAX: 85, LNG_MIN: -270, LNG_MAX: 270 }), E = { Point: 0, LineString: 1, MultiLineString: 1, Polygon: 2 };
    function T(t2, e2) {
      var n2 = E[t2.geometry.type] - E[e2.geometry.type];
      return n2 === 0 && t2.geometry.type === p.POLYGON ? t2.area - e2.area : n2;
    }
    function C(t2) {
      return t2.map(function(t3) {
        return t3.geometry.type === p.POLYGON && (t3.area = n.geometry({ type: p.FEATURE, property: {}, geometry: t3.geometry })), t3;
      }).sort(T).map(function(t3) {
        return delete t3.area, t3;
      });
    }
    function O(t2, e2) {
      return e2 === void 0 && (e2 = 0), [[t2.point.x - e2, t2.point.y - e2], [t2.point.x + e2, t2.point.y + e2]];
    }
    function S(t2) {
      if (this._items = {}, this._nums = {}, this._length = t2 ? t2.length : 0, t2)
        for (var e2 = 0, n2 = t2.length; e2 < n2; e2++)
          this.add(t2[e2]), t2[e2] !== void 0 && (typeof t2[e2] == "string" ? this._items[t2[e2]] = e2 : this._nums[t2[e2]] = e2);
    }
    S.prototype.add = function(t2) {
      return this.has(t2) || (this._length++, typeof t2 == "string" ? this._items[t2] = this._length : this._nums[t2] = this._length), this;
    }, S.prototype.delete = function(t2) {
      return this.has(t2) === false || (this._length--, delete this._items[t2], delete this._nums[t2]), this;
    }, S.prototype.has = function(t2) {
      return (typeof t2 == "string" || typeof t2 == "number") && (this._items[t2] !== void 0 || this._nums[t2] !== void 0);
    }, S.prototype.values = function() {
      var t2 = this, e2 = [];
      return Object.keys(this._items).forEach(function(n2) {
        e2.push({ k: n2, v: t2._items[n2] });
      }), Object.keys(this._nums).forEach(function(n2) {
        e2.push({ k: JSON.parse(n2), v: t2._nums[n2] });
      }), e2.sort(function(t3, e3) {
        return t3.v - e3.v;
      }).map(function(t3) {
        return t3.k;
      });
    }, S.prototype.clear = function() {
      return this._length = 0, this._items = {}, this._nums = {}, this;
    };
    var I = [y.FEATURE, y.MIDPOINT, y.VERTEX], x = { click: function(t2, e2, n2) {
      return M(t2, e2, n2, n2.options.clickBuffer);
    }, touch: function(t2, e2, n2) {
      return M(t2, e2, n2, n2.options.touchBuffer);
    } };
    function M(t2, e2, n2, o2) {
      if (n2.map === null)
        return [];
      var r2 = t2 ? O(t2, o2) : e2, i2 = {};
      n2.options.styles && (i2.layers = n2.options.styles.map(function(t3) {
        return t3.id;
      }));
      var a2 = n2.map.queryRenderedFeatures(r2, i2).filter(function(t3) {
        return I.indexOf(t3.properties.meta) !== -1;
      }), s2 = new S(), u2 = [];
      return a2.forEach(function(t3) {
        var e3 = t3.properties.id;
        s2.has(e3) || (s2.add(e3), u2.push(t3));
      }), C(u2);
    }
    function L(t2, e2) {
      var n2 = x.click(t2, null, e2), o2 = { mouse: l.NONE };
      return n2[0] && (o2.mouse = n2[0].properties.active === v2.ACTIVE ? l.MOVE : l.POINTER, o2.feature = n2[0].properties.meta), e2.events.currentModeName().indexOf("draw") !== -1 && (o2.mouse = l.ADD), e2.ui.queueMapClasses(o2), e2.ui.updateMapClasses(), n2[0];
    }
    function N(t2, e2) {
      var n2 = t2.x - e2.x, o2 = t2.y - e2.y;
      return Math.sqrt(n2 * n2 + o2 * o2);
    }
    function A(t2, e2, n2) {
      n2 === void 0 && (n2 = {});
      var o2 = n2.fineTolerance != null ? n2.fineTolerance : 4, r2 = n2.grossTolerance != null ? n2.grossTolerance : 12, i2 = n2.interval != null ? n2.interval : 500;
      t2.point = t2.point || e2.point, t2.time = t2.time || e2.time;
      var a2 = N(t2.point, e2.point);
      return a2 < o2 || a2 < r2 && e2.time - t2.time < i2;
    }
    function P(t2, e2, n2) {
      n2 === void 0 && (n2 = {});
      var o2 = n2.tolerance != null ? n2.tolerance : 25, r2 = n2.interval != null ? n2.interval : 250;
      return t2.point = t2.point || e2.point, t2.time = t2.time || e2.time, N(t2.point, e2.point) < o2 && e2.time - t2.time < r2;
    }
    var F = {}, w = { get exports() {
      return F;
    }, set exports(t2) {
      F = t2;
    } }.exports = function(t2, e2) {
      if (e2 || (e2 = 16), t2 === void 0 && (t2 = 128), t2 <= 0)
        return "0";
      for (var n2 = Math.log(Math.pow(2, t2)) / Math.log(e2), o2 = 2; n2 === 1 / 0; o2 *= 2)
        n2 = Math.log(Math.pow(2, t2 / o2)) / Math.log(e2) * o2;
      var r2 = n2 - Math.floor(n2), i2 = "";
      for (o2 = 0; o2 < Math.floor(n2); o2++) {
        i2 = Math.floor(Math.random() * e2).toString(e2) + i2;
      }
      if (r2) {
        var a2 = Math.pow(e2, r2);
        i2 = Math.floor(Math.random() * a2).toString(e2) + i2;
      }
      var s2 = parseInt(i2, e2);
      return s2 !== 1 / 0 && s2 >= Math.pow(2, t2) ? w(t2, e2) : i2;
    };
    w.rack = function(t2, e2, n2) {
      var o2 = function(o3) {
        var i2 = 0;
        do {
          if (i2++ > 10) {
            if (!n2)
              throw new Error("too many ID collisions, use more bits");
            t2 += n2;
          }
          var a2 = w(t2, e2);
        } while (Object.hasOwnProperty.call(r2, a2));
        return r2[a2] = o3, a2;
      }, r2 = o2.hats = {};
      return o2.get = function(t3) {
        return o2.hats[t3];
      }, o2.set = function(t3, e3) {
        return o2.hats[t3] = e3, o2;
      }, o2.bits = t2 || 128, o2.base = e2 || 16, o2;
    };
    var R2 = function(t2, e2) {
      this.ctx = t2, this.properties = e2.properties || {}, this.coordinates = e2.geometry.coordinates, this.id = e2.id || F(), this.type = e2.geometry.type;
    };
    R2.prototype.changed = function() {
      this.ctx.store.featureChanged(this.id);
    }, R2.prototype.incomingCoords = function(t2) {
      this.setCoordinates(t2);
    }, R2.prototype.setCoordinates = function(t2) {
      this.coordinates = t2, this.changed();
    }, R2.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.coordinates));
    }, R2.prototype.setProperty = function(t2, e2) {
      this.properties[t2] = e2;
    }, R2.prototype.toGeoJSON = function() {
      return JSON.parse(JSON.stringify({ id: this.id, type: p.FEATURE, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } }));
    }, R2.prototype.internal = function(t2) {
      var e2 = { id: this.id, meta: y.FEATURE, "meta:type": this.type, active: v2.INACTIVE, mode: t2 };
      if (this.ctx.options.userProperties)
        for (var n2 in this.properties)
          e2["user_" + n2] = this.properties[n2];
      return { type: p.FEATURE, properties: e2, geometry: { coordinates: this.getCoordinates(), type: this.type } };
    };
    var D = function(t2, e2) {
      R2.call(this, t2, e2);
    };
    (D.prototype = Object.create(R2.prototype)).isValid = function() {
      return typeof this.coordinates[0] == "number" && typeof this.coordinates[1] == "number";
    }, D.prototype.updateCoordinate = function(t2, e2, n2) {
      this.coordinates = arguments.length === 3 ? [e2, n2] : [t2, e2], this.changed();
    }, D.prototype.getCoordinate = function() {
      return this.getCoordinates();
    };
    var k = function(t2, e2) {
      R2.call(this, t2, e2);
    };
    (k.prototype = Object.create(R2.prototype)).isValid = function() {
      return this.coordinates.length > 1;
    }, k.prototype.addCoordinate = function(t2, e2, n2) {
      this.changed();
      var o2 = parseInt(t2, 10);
      this.coordinates.splice(o2, 0, [e2, n2]);
    }, k.prototype.getCoordinate = function(t2) {
      var e2 = parseInt(t2, 10);
      return JSON.parse(JSON.stringify(this.coordinates[e2]));
    }, k.prototype.removeCoordinate = function(t2) {
      this.changed(), this.coordinates.splice(parseInt(t2, 10), 1);
    }, k.prototype.updateCoordinate = function(t2, e2, n2) {
      var o2 = parseInt(t2, 10);
      this.coordinates[o2] = [e2, n2], this.changed();
    };
    var U = function(t2, e2) {
      R2.call(this, t2, e2), this.coordinates = this.coordinates.map(function(t3) {
        return t3.slice(0, -1);
      });
    };
    (U.prototype = Object.create(R2.prototype)).isValid = function() {
      return this.coordinates.length !== 0 && this.coordinates.every(function(t2) {
        return t2.length > 2;
      });
    }, U.prototype.incomingCoords = function(t2) {
      this.coordinates = t2.map(function(t3) {
        return t3.slice(0, -1);
      }), this.changed();
    }, U.prototype.setCoordinates = function(t2) {
      this.coordinates = t2, this.changed();
    }, U.prototype.addCoordinate = function(t2, e2, n2) {
      this.changed();
      var o2 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      });
      this.coordinates[o2[0]].splice(o2[1], 0, [e2, n2]);
    }, U.prototype.removeCoordinate = function(t2) {
      this.changed();
      var e2 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      }), n2 = this.coordinates[e2[0]];
      n2 && (n2.splice(e2[1], 1), n2.length < 3 && this.coordinates.splice(e2[0], 1));
    }, U.prototype.getCoordinate = function(t2) {
      var e2 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      }), n2 = this.coordinates[e2[0]];
      return JSON.parse(JSON.stringify(n2[e2[1]]));
    }, U.prototype.getCoordinates = function() {
      return this.coordinates.map(function(t2) {
        return t2.concat([t2[0]]);
      });
    }, U.prototype.updateCoordinate = function(t2, e2, n2) {
      this.changed();
      var o2 = t2.split("."), r2 = parseInt(o2[0], 10), i2 = parseInt(o2[1], 10);
      this.coordinates[r2] === void 0 && (this.coordinates[r2] = []), this.coordinates[r2][i2] = [e2, n2];
    };
    var j = { MultiPoint: D, MultiLineString: k, MultiPolygon: U }, V = function(t2, e2, n2, o2, r2) {
      var i2 = n2.split("."), a2 = parseInt(i2[0], 10), s2 = i2[1] ? i2.slice(1).join(".") : null;
      return t2[a2][e2](s2, o2, r2);
    }, B = function(t2, e2) {
      if (R2.call(this, t2, e2), delete this.coordinates, this.model = j[e2.geometry.type], this.model === void 0)
        throw new TypeError(e2.geometry.type + " is not a valid type");
      this.features = this._coordinatesToFeatures(e2.geometry.coordinates);
    };
    function G(t2) {
      this.map = t2.map, this.drawConfig = JSON.parse(JSON.stringify(t2.options || {})), this._ctx = t2;
    }
    (B.prototype = Object.create(R2.prototype))._coordinatesToFeatures = function(t2) {
      var e2 = this, n2 = this.model.bind(this);
      return t2.map(function(t3) {
        return new n2(e2.ctx, { id: F(), type: p.FEATURE, properties: {}, geometry: { coordinates: t3, type: e2.type.replace("Multi", "") } });
      });
    }, B.prototype.isValid = function() {
      return this.features.every(function(t2) {
        return t2.isValid();
      });
    }, B.prototype.setCoordinates = function(t2) {
      this.features = this._coordinatesToFeatures(t2), this.changed();
    }, B.prototype.getCoordinate = function(t2) {
      return V(this.features, "getCoordinate", t2);
    }, B.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.features.map(function(t2) {
        return t2.type === p.POLYGON ? t2.getCoordinates() : t2.coordinates;
      })));
    }, B.prototype.updateCoordinate = function(t2, e2, n2) {
      V(this.features, "updateCoordinate", t2, e2, n2), this.changed();
    }, B.prototype.addCoordinate = function(t2, e2, n2) {
      V(this.features, "addCoordinate", t2, e2, n2), this.changed();
    }, B.prototype.removeCoordinate = function(t2) {
      V(this.features, "removeCoordinate", t2), this.changed();
    }, B.prototype.getFeatures = function() {
      return this.features;
    }, G.prototype.setSelected = function(t2) {
      return this._ctx.store.setSelected(t2);
    }, G.prototype.setSelectedCoordinates = function(t2) {
      var e2 = this;
      this._ctx.store.setSelectedCoordinates(t2), t2.reduce(function(t3, n2) {
        return t3[n2.feature_id] === void 0 && (t3[n2.feature_id] = true, e2._ctx.store.get(n2.feature_id).changed()), t3;
      }, {});
    }, G.prototype.getSelected = function() {
      return this._ctx.store.getSelected();
    }, G.prototype.getSelectedIds = function() {
      return this._ctx.store.getSelectedIds();
    }, G.prototype.isSelected = function(t2) {
      return this._ctx.store.isSelected(t2);
    }, G.prototype.getFeature = function(t2) {
      return this._ctx.store.get(t2);
    }, G.prototype.select = function(t2) {
      return this._ctx.store.select(t2);
    }, G.prototype.deselect = function(t2) {
      return this._ctx.store.deselect(t2);
    }, G.prototype.deleteFeature = function(t2, e2) {
      return e2 === void 0 && (e2 = {}), this._ctx.store.delete(t2, e2);
    }, G.prototype.addFeature = function(t2) {
      return this._ctx.store.add(t2);
    }, G.prototype.clearSelectedFeatures = function() {
      return this._ctx.store.clearSelected();
    }, G.prototype.clearSelectedCoordinates = function() {
      return this._ctx.store.clearSelectedCoordinates();
    }, G.prototype.setActionableState = function(t2) {
      t2 === void 0 && (t2 = {});
      var e2 = { trash: t2.trash || false, combineFeatures: t2.combineFeatures || false, uncombineFeatures: t2.uncombineFeatures || false };
      return this._ctx.events.actionable(e2);
    }, G.prototype.changeMode = function(t2, e2, n2) {
      return e2 === void 0 && (e2 = {}), n2 === void 0 && (n2 = {}), this._ctx.events.changeMode(t2, e2, n2);
    }, G.prototype.updateUIClasses = function(t2) {
      return this._ctx.ui.queueMapClasses(t2);
    }, G.prototype.activateUIButton = function(t2) {
      return this._ctx.ui.setActiveButton(t2);
    }, G.prototype.featuresAt = function(t2, e2, n2) {
      if (n2 === void 0 && (n2 = "click"), n2 !== "click" && n2 !== "touch")
        throw new Error("invalid buffer type");
      return x[n2](t2, e2, this._ctx);
    }, G.prototype.newFeature = function(t2) {
      var e2 = t2.geometry.type;
      return e2 === p.POINT ? new D(this._ctx, t2) : e2 === p.LINE_STRING ? new k(this._ctx, t2) : e2 === p.POLYGON ? new U(this._ctx, t2) : new B(this._ctx, t2);
    }, G.prototype.isInstanceOf = function(t2, e2) {
      if (t2 === p.POINT)
        return e2 instanceof D;
      if (t2 === p.LINE_STRING)
        return e2 instanceof k;
      if (t2 === p.POLYGON)
        return e2 instanceof U;
      if (t2 === "MultiFeature")
        return e2 instanceof B;
      throw new Error("Unknown feature class: " + t2);
    }, G.prototype.doRender = function(t2) {
      return this._ctx.store.featureChanged(t2);
    }, G.prototype.onSetup = function() {
    }, G.prototype.onDrag = function() {
    }, G.prototype.onClick = function() {
    }, G.prototype.onMouseMove = function() {
    }, G.prototype.onMouseDown = function() {
    }, G.prototype.onMouseUp = function() {
    }, G.prototype.onMouseOut = function() {
    }, G.prototype.onKeyUp = function() {
    }, G.prototype.onKeyDown = function() {
    }, G.prototype.onTouchStart = function() {
    }, G.prototype.onTouchMove = function() {
    }, G.prototype.onTouchEnd = function() {
    }, G.prototype.onTap = function() {
    }, G.prototype.onStop = function() {
    }, G.prototype.onTrash = function() {
    }, G.prototype.onCombineFeature = function() {
    }, G.prototype.onUncombineFeature = function() {
    }, G.prototype.toDisplayFeatures = function() {
      throw new Error("You must overwrite toDisplayFeatures");
    };
    var J = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, z = Object.keys(J);
    function Y(t2) {
      var e2 = Object.keys(t2);
      return function(n2, o2) {
        o2 === void 0 && (o2 = {});
        var r2 = {}, i2 = e2.reduce(function(e3, n3) {
          return e3[n3] = t2[n3], e3;
        }, new G(n2));
        return { start: function() {
          var e3 = this;
          r2 = i2.onSetup(o2), z.forEach(function(n3) {
            var o3, a2 = J[n3], s2 = function() {
              return false;
            };
            t2[a2] && (s2 = function() {
              return true;
            }), e3.on(n3, s2, (o3 = a2, function(t3) {
              return i2[o3](r2, t3);
            }));
          });
        }, stop: function() {
          i2.onStop(r2);
        }, trash: function() {
          i2.onTrash(r2);
        }, combineFeatures: function() {
          i2.onCombineFeatures(r2);
        }, uncombineFeatures: function() {
          i2.onUncombineFeatures(r2);
        }, render: function(t3, e3) {
          i2.toDisplayFeatures(r2, t3, e3);
        } };
      };
    }
    function $(t2) {
      return [].concat(t2).filter(function(t3) {
        return t3 !== void 0;
      });
    }
    function q() {
      var t2 = this;
      if (!(t2.ctx.map && t2.ctx.map.getSource(c.HOT) !== void 0))
        return u2();
      var e2 = t2.ctx.events.currentModeName();
      t2.ctx.ui.queueMapClasses({ mode: e2 });
      var n2 = [], o2 = [];
      t2.isDirty ? o2 = t2.getAllIds() : (n2 = t2.getChangedIds().filter(function(e3) {
        return t2.get(e3) !== void 0;
      }), o2 = t2.sources.hot.filter(function(e3) {
        return e3.properties.id && n2.indexOf(e3.properties.id) === -1 && t2.get(e3.properties.id) !== void 0;
      }).map(function(t3) {
        return t3.properties.id;
      })), t2.sources.hot = [];
      var r2 = t2.sources.cold.length;
      t2.sources.cold = t2.isDirty ? [] : t2.sources.cold.filter(function(t3) {
        var e3 = t3.properties.id || t3.properties.parent;
        return n2.indexOf(e3) === -1;
      });
      var i2 = r2 !== t2.sources.cold.length || o2.length > 0;
      function a2(n3, o3) {
        var r3 = t2.get(n3).internal(e2);
        t2.ctx.events.currentModeRender(r3, function(e3) {
          t2.sources[o3].push(e3);
        });
      }
      if (n2.forEach(function(t3) {
        return a2(t3, "hot");
      }), o2.forEach(function(t3) {
        return a2(t3, "cold");
      }), i2 && t2.ctx.map.getSource(c.COLD).setData({ type: p.FEATURE_COLLECTION, features: t2.sources.cold }), t2.ctx.map.getSource(c.HOT).setData({ type: p.FEATURE_COLLECTION, features: t2.sources.hot }), t2._emitSelectionChange && (t2.ctx.map.fire(h3.SELECTION_CHANGE, { features: t2.getSelected().map(function(t3) {
        return t3.toGeoJSON();
      }), points: t2.getSelectedCoordinates().map(function(t3) {
        return { type: p.FEATURE, properties: {}, geometry: { type: p.POINT, coordinates: t3.coordinates } };
      }) }), t2._emitSelectionChange = false), t2._deletedFeaturesToEmit.length) {
        var s2 = t2._deletedFeaturesToEmit.map(function(t3) {
          return t3.toGeoJSON();
        });
        t2._deletedFeaturesToEmit = [], t2.ctx.map.fire(h3.DELETE, { features: s2 });
      }
      function u2() {
        t2.isDirty = false, t2.clearChangedIds();
      }
      u2(), t2.ctx.map.fire(h3.RENDER, {});
    }
    function H(t2) {
      var e2, n2 = this;
      this._features = {}, this._featureIds = new S(), this._selectedFeatureIds = new S(), this._selectedCoordinates = [], this._changedFeatureIds = new S(), this._deletedFeaturesToEmit = [], this._emitSelectionChange = false, this._mapInitialConfig = {}, this.ctx = t2, this.sources = { hot: [], cold: [] }, this.render = function() {
        e2 || (e2 = requestAnimationFrame(function() {
          e2 = null, q.call(n2);
        }));
      }, this.isDirty = false;
    }
    function X(t2, e2) {
      var n2 = t2._selectedCoordinates.filter(function(e3) {
        return t2._selectedFeatureIds.has(e3.feature_id);
      });
      t2._selectedCoordinates.length === n2.length || e2.silent || (t2._emitSelectionChange = true), t2._selectedCoordinates = n2;
    }
    H.prototype.createRenderBatch = function() {
      var t2 = this, e2 = this.render, n2 = 0;
      return this.render = function() {
        n2++;
      }, function() {
        t2.render = e2, n2 > 0 && t2.render();
      };
    }, H.prototype.setDirty = function() {
      return this.isDirty = true, this;
    }, H.prototype.featureChanged = function(t2) {
      return this._changedFeatureIds.add(t2), this;
    }, H.prototype.getChangedIds = function() {
      return this._changedFeatureIds.values();
    }, H.prototype.clearChangedIds = function() {
      return this._changedFeatureIds.clear(), this;
    }, H.prototype.getAllIds = function() {
      return this._featureIds.values();
    }, H.prototype.add = function(t2) {
      return this.featureChanged(t2.id), this._features[t2.id] = t2, this._featureIds.add(t2.id), this;
    }, H.prototype.delete = function(t2, e2) {
      var n2 = this;
      return e2 === void 0 && (e2 = {}), $(t2).forEach(function(t3) {
        n2._featureIds.has(t3) && (n2._featureIds.delete(t3), n2._selectedFeatureIds.delete(t3), e2.silent || n2._deletedFeaturesToEmit.indexOf(n2._features[t3]) === -1 && n2._deletedFeaturesToEmit.push(n2._features[t3]), delete n2._features[t3], n2.isDirty = true);
      }), X(this, e2), this;
    }, H.prototype.get = function(t2) {
      return this._features[t2];
    }, H.prototype.getAll = function() {
      var t2 = this;
      return Object.keys(this._features).map(function(e2) {
        return t2._features[e2];
      });
    }, H.prototype.select = function(t2, e2) {
      var n2 = this;
      return e2 === void 0 && (e2 = {}), $(t2).forEach(function(t3) {
        n2._selectedFeatureIds.has(t3) || (n2._selectedFeatureIds.add(t3), n2._changedFeatureIds.add(t3), e2.silent || (n2._emitSelectionChange = true));
      }), this;
    }, H.prototype.deselect = function(t2, e2) {
      var n2 = this;
      return e2 === void 0 && (e2 = {}), $(t2).forEach(function(t3) {
        n2._selectedFeatureIds.has(t3) && (n2._selectedFeatureIds.delete(t3), n2._changedFeatureIds.add(t3), e2.silent || (n2._emitSelectionChange = true));
      }), X(this, e2), this;
    }, H.prototype.clearSelected = function(t2) {
      return t2 === void 0 && (t2 = {}), this.deselect(this._selectedFeatureIds.values(), { silent: t2.silent }), this;
    }, H.prototype.setSelected = function(t2, e2) {
      var n2 = this;
      return e2 === void 0 && (e2 = {}), t2 = $(t2), this.deselect(this._selectedFeatureIds.values().filter(function(e3) {
        return t2.indexOf(e3) === -1;
      }), { silent: e2.silent }), this.select(t2.filter(function(t3) {
        return !n2._selectedFeatureIds.has(t3);
      }), { silent: e2.silent }), this;
    }, H.prototype.setSelectedCoordinates = function(t2) {
      return this._selectedCoordinates = t2, this._emitSelectionChange = true, this;
    }, H.prototype.clearSelectedCoordinates = function() {
      return this._selectedCoordinates = [], this._emitSelectionChange = true, this;
    }, H.prototype.getSelectedIds = function() {
      return this._selectedFeatureIds.values();
    }, H.prototype.getSelected = function() {
      var t2 = this;
      return this._selectedFeatureIds.values().map(function(e2) {
        return t2.get(e2);
      });
    }, H.prototype.getSelectedCoordinates = function() {
      var t2 = this;
      return this._selectedCoordinates.map(function(e2) {
        return { coordinates: t2.get(e2.feature_id).getCoordinate(e2.coord_path) };
      });
    }, H.prototype.isSelected = function(t2) {
      return this._selectedFeatureIds.has(t2);
    }, H.prototype.setFeatureProperty = function(t2, e2, n2) {
      this.get(t2).setProperty(e2, n2), this.featureChanged(t2);
    }, H.prototype.storeMapConfig = function() {
      var t2 = this;
      m.forEach(function(e2) {
        t2.ctx.map[e2] && (t2._mapInitialConfig[e2] = t2.ctx.map[e2].isEnabled());
      });
    }, H.prototype.restoreMapConfig = function() {
      var t2 = this;
      Object.keys(this._mapInitialConfig).forEach(function(e2) {
        t2._mapInitialConfig[e2] ? t2.ctx.map[e2].enable() : t2.ctx.map[e2].disable();
      });
    }, H.prototype.getInitialConfigValue = function(t2) {
      return this._mapInitialConfig[t2] === void 0 || this._mapInitialConfig[t2];
    };
    var W = function() {
      for (var t2 = arguments, e2 = {}, n2 = 0; n2 < arguments.length; n2++) {
        var o2 = t2[n2];
        for (var r2 in o2)
          Z.call(o2, r2) && (e2[r2] = o2[r2]);
      }
      return e2;
    }, Z = Object.prototype.hasOwnProperty;
    var K = ["mode", "feature", "mouse"];
    function Q(e2) {
      var n2 = null, o2 = null, r2 = { onRemove: function() {
        return e2.map.off("load", r2.connect), clearInterval(o2), r2.removeLayers(), e2.store.restoreMapConfig(), e2.ui.removeButtons(), e2.events.removeEventListeners(), e2.ui.clearMapClasses(), e2.map = null, e2.container = null, e2.store = null, n2 && n2.parentNode && n2.parentNode.removeChild(n2), n2 = null, this;
      }, connect: function() {
        e2.map.off("load", r2.connect), clearInterval(o2), r2.addLayers(), e2.store.storeMapConfig(), e2.events.addEventListeners();
      }, onAdd: function(i2) {
        var a2 = i2.fire;
        return i2.fire = function(t2, e3) {
          var n3 = arguments;
          return a2.length === 1 && arguments.length !== 1 && (n3 = [W({}, { type: t2 }, e3)]), a2.apply(i2, n3);
        }, e2.map = i2, e2.events = function(e3) {
          var n3 = Object.keys(e3.options.modes).reduce(function(t2, n4) {
            return t2[n4] = Y(e3.options.modes[n4]), t2;
          }, {}), o3 = {}, r3 = {}, i3 = {}, a3 = null, s2 = null;
          i3.drag = function(t2, n4) {
            n4({ point: t2.point, time: new Date().getTime() }) ? (e3.ui.queueMapClasses({ mouse: l.DRAG }), s2.drag(t2)) : t2.originalEvent.stopPropagation();
          }, i3.mousedrag = function(t2) {
            i3.drag(t2, function(t3) {
              return !A(o3, t3);
            });
          }, i3.touchdrag = function(t2) {
            i3.drag(t2, function(t3) {
              return !P(r3, t3);
            });
          }, i3.mousemove = function(t2) {
            if ((t2.originalEvent.buttons !== void 0 ? t2.originalEvent.buttons : t2.originalEvent.which) === 1)
              return i3.mousedrag(t2);
            var n4 = L(t2, e3);
            t2.featureTarget = n4, s2.mousemove(t2);
          }, i3.mousedown = function(t2) {
            o3 = { time: new Date().getTime(), point: t2.point };
            var n4 = L(t2, e3);
            t2.featureTarget = n4, s2.mousedown(t2);
          }, i3.mouseup = function(t2) {
            var n4 = L(t2, e3);
            t2.featureTarget = n4, A(o3, { point: t2.point, time: new Date().getTime() }) ? s2.click(t2) : s2.mouseup(t2);
          }, i3.mouseout = function(t2) {
            s2.mouseout(t2);
          }, i3.touchstart = function(t2) {
            if (t2.originalEvent.preventDefault(), e3.options.touchEnabled) {
              r3 = { time: new Date().getTime(), point: t2.point };
              var n4 = x.touch(t2, null, e3)[0];
              t2.featureTarget = n4, s2.touchstart(t2);
            }
          }, i3.touchmove = function(t2) {
            if (t2.originalEvent.preventDefault(), e3.options.touchEnabled)
              return s2.touchmove(t2), i3.touchdrag(t2);
          }, i3.touchend = function(t2) {
            if (t2.originalEvent.preventDefault(), e3.options.touchEnabled) {
              var n4 = x.touch(t2, null, e3)[0];
              t2.featureTarget = n4, P(r3, { time: new Date().getTime(), point: t2.point }) ? s2.tap(t2) : s2.touchend(t2);
            }
          };
          var u2 = function(t2) {
            return !(t2 === 8 || t2 === 46 || t2 >= 48 && t2 <= 57);
          };
          function c2(o4, r4, i4) {
            i4 === void 0 && (i4 = {}), s2.stop();
            var u3 = n3[o4];
            if (u3 === void 0)
              throw new Error(o4 + " is not valid");
            a3 = o4;
            var c3 = u3(e3, r4);
            s2 = t(c3, e3), i4.silent || e3.map.fire(h3.MODE_CHANGE, { mode: o4 }), e3.store.setDirty(), e3.store.render();
          }
          i3.keydown = function(t2) {
            (t2.srcElement || t2.target).classList[0] === "mapboxgl-canvas" && (t2.keyCode !== 8 && t2.keyCode !== 46 || !e3.options.controls.trash ? u2(t2.keyCode) ? s2.keydown(t2) : t2.keyCode === 49 && e3.options.controls.point ? c2(f.DRAW_POINT) : t2.keyCode === 50 && e3.options.controls.line_string ? c2(f.DRAW_LINE_STRING) : t2.keyCode === 51 && e3.options.controls.polygon && c2(f.DRAW_POLYGON) : (t2.preventDefault(), s2.trash()));
          }, i3.keyup = function(t2) {
            u2(t2.keyCode) && s2.keyup(t2);
          }, i3.zoomend = function() {
            e3.store.changeZoom();
          }, i3.data = function(t2) {
            if (t2.dataType === "style") {
              var n4 = e3.setup, o4 = e3.map, r4 = e3.options, i4 = e3.store;
              r4.styles.some(function(t3) {
                return o4.getLayer(t3.id);
              }) || (n4.addLayers(), i4.setDirty(), i4.render());
            }
          };
          var d2 = { trash: false, combineFeatures: false, uncombineFeatures: false };
          return { start: function() {
            a3 = e3.options.defaultMode, s2 = t(n3[a3](e3), e3);
          }, changeMode: c2, actionable: function(t2) {
            var n4 = false;
            Object.keys(t2).forEach(function(e4) {
              if (d2[e4] === void 0)
                throw new Error("Invalid action type");
              d2[e4] !== t2[e4] && (n4 = true), d2[e4] = t2[e4];
            }), n4 && e3.map.fire(h3.ACTIONABLE, { actions: d2 });
          }, currentModeName: function() {
            return a3;
          }, currentModeRender: function(t2, e4) {
            return s2.render(t2, e4);
          }, fire: function(t2, e4) {
            i3[t2] && i3[t2](e4);
          }, addEventListeners: function() {
            e3.map.on("mousemove", i3.mousemove), e3.map.on("mousedown", i3.mousedown), e3.map.on("mouseup", i3.mouseup), e3.map.on("data", i3.data), e3.map.on("touchmove", i3.touchmove), e3.map.on("touchstart", i3.touchstart), e3.map.on("touchend", i3.touchend), e3.container.addEventListener("mouseout", i3.mouseout), e3.options.keybindings && (e3.container.addEventListener("keydown", i3.keydown), e3.container.addEventListener("keyup", i3.keyup));
          }, removeEventListeners: function() {
            e3.map.off("mousemove", i3.mousemove), e3.map.off("mousedown", i3.mousedown), e3.map.off("mouseup", i3.mouseup), e3.map.off("data", i3.data), e3.map.off("touchmove", i3.touchmove), e3.map.off("touchstart", i3.touchstart), e3.map.off("touchend", i3.touchend), e3.container.removeEventListener("mouseout", i3.mouseout), e3.options.keybindings && (e3.container.removeEventListener("keydown", i3.keydown), e3.container.removeEventListener("keyup", i3.keyup));
          }, trash: function(t2) {
            s2.trash(t2);
          }, combineFeatures: function() {
            s2.combineFeatures();
          }, uncombineFeatures: function() {
            s2.uncombineFeatures();
          }, getMode: function() {
            return a3;
          } };
        }(e2), e2.ui = function(t2) {
          var e3 = {}, n3 = null, o3 = { mode: null, feature: null, mouse: null }, r3 = { mode: null, feature: null, mouse: null };
          function i3(t3) {
            r3 = W(r3, t3);
          }
          function a3() {
            var e4, n4;
            if (t2.container) {
              var i4 = [], a4 = [];
              K.forEach(function(t3) {
                r3[t3] !== o3[t3] && (i4.push(t3 + "-" + o3[t3]), r3[t3] !== null && a4.push(t3 + "-" + r3[t3]));
              }), i4.length > 0 && (e4 = t2.container.classList).remove.apply(e4, i4), a4.length > 0 && (n4 = t2.container.classList).add.apply(n4, a4), o3 = W(o3, r3);
            }
          }
          function s2(t3, e4) {
            e4 === void 0 && (e4 = {});
            var o4 = document.createElement("button");
            return o4.className = u.CONTROL_BUTTON + " " + e4.className, o4.setAttribute("title", e4.title), e4.container.appendChild(o4), o4.addEventListener("click", function(o5) {
              if (o5.preventDefault(), o5.stopPropagation(), o5.target === n3)
                return c2(), void e4.onDeactivate();
              l2(t3), e4.onActivate();
            }, true), o4;
          }
          function c2() {
            n3 && (n3.classList.remove(u.ACTIVE_BUTTON), n3 = null);
          }
          function l2(t3) {
            c2();
            var o4 = e3[t3];
            o4 && o4 && t3 !== "trash" && (o4.classList.add(u.ACTIVE_BUTTON), n3 = o4);
          }
          return { setActiveButton: l2, queueMapClasses: i3, updateMapClasses: a3, clearMapClasses: function() {
            i3({ mode: null, feature: null, mouse: null }), a3();
          }, addButtons: function() {
            var n4 = t2.options.controls, o4 = document.createElement("div");
            return o4.className = u.CONTROL_GROUP + " " + u.CONTROL_BASE, n4 ? (n4[d.LINE] && (e3[d.LINE] = s2(d.LINE, { container: o4, className: u.CONTROL_BUTTON_LINE, title: "LineString tool " + (t2.options.keybindings ? "(l)" : ""), onActivate: function() {
              return t2.events.changeMode(f.DRAW_LINE_STRING);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4[d.POLYGON] && (e3[d.POLYGON] = s2(d.POLYGON, { container: o4, className: u.CONTROL_BUTTON_POLYGON, title: "Polygon tool " + (t2.options.keybindings ? "(p)" : ""), onActivate: function() {
              return t2.events.changeMode(f.DRAW_POLYGON);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4[d.POINT] && (e3[d.POINT] = s2(d.POINT, { container: o4, className: u.CONTROL_BUTTON_POINT, title: "Marker tool " + (t2.options.keybindings ? "(m)" : ""), onActivate: function() {
              return t2.events.changeMode(f.DRAW_POINT);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4.trash && (e3.trash = s2("trash", { container: o4, className: u.CONTROL_BUTTON_TRASH, title: "Delete", onActivate: function() {
              t2.events.trash();
            } })), n4.combine_features && (e3.combine_features = s2("combineFeatures", { container: o4, className: u.CONTROL_BUTTON_COMBINE_FEATURES, title: "Combine", onActivate: function() {
              t2.events.combineFeatures();
            } })), n4.uncombine_features && (e3.uncombine_features = s2("uncombineFeatures", { container: o4, className: u.CONTROL_BUTTON_UNCOMBINE_FEATURES, title: "Uncombine", onActivate: function() {
              t2.events.uncombineFeatures();
            } })), o4) : o4;
          }, removeButtons: function() {
            Object.keys(e3).forEach(function(t3) {
              var n4 = e3[t3];
              n4.parentNode && n4.parentNode.removeChild(n4), delete e3[t3];
            });
          } };
        }(e2), e2.container = i2.getContainer(), e2.store = new H(e2), n2 = e2.ui.addButtons(), e2.options.boxSelect && (i2.boxZoom.disable(), i2.dragPan.disable(), i2.dragPan.enable()), i2.loaded() ? r2.connect() : (i2.on("load", r2.connect), o2 = setInterval(function() {
          i2.loaded() && r2.connect();
        }, 16)), e2.events.start(), n2;
      }, addLayers: function() {
        e2.map.addSource(c.COLD, { data: { type: p.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e2.map.addSource(c.HOT, { data: { type: p.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e2.options.styles.forEach(function(t2) {
          e2.map.addLayer(t2);
        }), e2.store.setDirty(true), e2.store.render();
      }, removeLayers: function() {
        e2.options.styles.forEach(function(t2) {
          e2.map.getLayer(t2.id) && e2.map.removeLayer(t2.id);
        }), e2.map.getSource(c.COLD) && e2.map.removeSource(c.COLD), e2.map.getSource(c.HOT) && e2.map.removeSource(c.HOT);
      } };
      return e2.setup = r2, r2;
    }
    var tt = [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }];
    function et(t2) {
      return function(e2) {
        var n2 = e2.featureTarget;
        return !!n2 && (!!n2.properties && n2.properties.meta === t2);
      };
    }
    function nt(t2) {
      return !!t2.originalEvent && (!!t2.originalEvent.shiftKey && t2.originalEvent.button === 0);
    }
    function ot(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === v2.ACTIVE && t2.featureTarget.properties.meta === y.FEATURE));
    }
    function rt(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === v2.INACTIVE && t2.featureTarget.properties.meta === y.FEATURE));
    }
    function it(t2) {
      return t2.featureTarget === void 0;
    }
    function at(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && t2.featureTarget.properties.meta === y.FEATURE);
    }
    function st(t2) {
      var e2 = t2.featureTarget;
      return !!e2 && (!!e2.properties && e2.properties.meta === y.VERTEX);
    }
    function ut(t2) {
      return !!t2.originalEvent && t2.originalEvent.shiftKey === true;
    }
    function ct(t2) {
      return t2.keyCode === 27;
    }
    function lt(t2) {
      return t2.keyCode === 13;
    }
    var dt = Object.freeze({ __proto__: null, isOfMetaType: et, isShiftMousedown: nt, isActiveFeature: ot, isInactiveFeature: rt, noTarget: it, isFeature: at, isVertex: st, isShiftDown: ut, isEscapeKey: ct, isEnterKey: lt, isTrue: function() {
      return true;
    } }), pt = ft;
    function ft(t2, e2) {
      this.x = t2, this.y = e2;
    }
    function ht(t2, e2) {
      var n2 = e2.getBoundingClientRect();
      return new pt(t2.clientX - n2.left - (e2.clientLeft || 0), t2.clientY - n2.top - (e2.clientTop || 0));
    }
    function gt(t2, e2, n2, o2) {
      return { type: p.FEATURE, properties: { meta: y.VERTEX, parent: t2, coord_path: n2, active: o2 ? v2.ACTIVE : v2.INACTIVE }, geometry: { type: p.POINT, coordinates: e2 } };
    }
    function yt(t2, e2, n2) {
      var o2 = e2.geometry.coordinates, r2 = n2.geometry.coordinates;
      if (o2[1] > 85 || o2[1] < _ || r2[1] > 85 || r2[1] < _)
        return null;
      var i2 = { lng: (o2[0] + r2[0]) / 2, lat: (o2[1] + r2[1]) / 2 };
      return { type: p.FEATURE, properties: { meta: y.MIDPOINT, parent: t2, lng: i2.lng, lat: i2.lat, coord_path: n2.properties.coord_path }, geometry: { type: p.POINT, coordinates: [i2.lng, i2.lat] } };
    }
    function vt(t2, e2, n2) {
      e2 === void 0 && (e2 = {}), n2 === void 0 && (n2 = null);
      var o2, r2 = t2.geometry, i2 = r2.type, a2 = r2.coordinates, s2 = t2.properties && t2.properties.id, u2 = [];
      function c2(t3, n3) {
        var o3 = "", r3 = null;
        t3.forEach(function(t4, i3) {
          var a3 = n3 != null ? n3 + "." + i3 : String(i3), c3 = gt(s2, t4, a3, l2(a3));
          if (e2.midpoints && r3) {
            var d2 = yt(s2, r3, c3);
            d2 && u2.push(d2);
          }
          r3 = c3;
          var p2 = JSON.stringify(t4);
          o3 !== p2 && u2.push(c3), i3 === 0 && (o3 = p2);
        });
      }
      function l2(t3) {
        return !!e2.selectedPaths && e2.selectedPaths.indexOf(t3) !== -1;
      }
      return i2 === p.POINT ? u2.push(gt(s2, a2, n2, l2(n2))) : i2 === p.POLYGON ? a2.forEach(function(t3, e3) {
        c2(t3, n2 !== null ? n2 + "." + e3 : String(e3));
      }) : i2 === p.LINE_STRING ? c2(a2, n2) : i2.indexOf(p.MULTI_PREFIX) === 0 && (o2 = i2.replace(p.MULTI_PREFIX, ""), a2.forEach(function(n3, r3) {
        var i3 = { type: p.FEATURE, properties: t2.properties, geometry: { type: o2, coordinates: n3 } };
        u2 = u2.concat(vt(i3, e2, r3));
      })), u2;
    }
    ft.prototype = { clone: function() {
      return new ft(this.x, this.y);
    }, add: function(t2) {
      return this.clone()._add(t2);
    }, sub: function(t2) {
      return this.clone()._sub(t2);
    }, multByPoint: function(t2) {
      return this.clone()._multByPoint(t2);
    }, divByPoint: function(t2) {
      return this.clone()._divByPoint(t2);
    }, mult: function(t2) {
      return this.clone()._mult(t2);
    }, div: function(t2) {
      return this.clone()._div(t2);
    }, rotate: function(t2) {
      return this.clone()._rotate(t2);
    }, rotateAround: function(t2, e2) {
      return this.clone()._rotateAround(t2, e2);
    }, matMult: function(t2) {
      return this.clone()._matMult(t2);
    }, unit: function() {
      return this.clone()._unit();
    }, perp: function() {
      return this.clone()._perp();
    }, round: function() {
      return this.clone()._round();
    }, mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, equals: function(t2) {
      return this.x === t2.x && this.y === t2.y;
    }, dist: function(t2) {
      return Math.sqrt(this.distSqr(t2));
    }, distSqr: function(t2) {
      var e2 = t2.x - this.x, n2 = t2.y - this.y;
      return e2 * e2 + n2 * n2;
    }, angle: function() {
      return Math.atan2(this.y, this.x);
    }, angleTo: function(t2) {
      return Math.atan2(this.y - t2.y, this.x - t2.x);
    }, angleWith: function(t2) {
      return this.angleWithSep(t2.x, t2.y);
    }, angleWithSep: function(t2, e2) {
      return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
    }, _matMult: function(t2) {
      var e2 = t2[0] * this.x + t2[1] * this.y, n2 = t2[2] * this.x + t2[3] * this.y;
      return this.x = e2, this.y = n2, this;
    }, _add: function(t2) {
      return this.x += t2.x, this.y += t2.y, this;
    }, _sub: function(t2) {
      return this.x -= t2.x, this.y -= t2.y, this;
    }, _mult: function(t2) {
      return this.x *= t2, this.y *= t2, this;
    }, _div: function(t2) {
      return this.x /= t2, this.y /= t2, this;
    }, _multByPoint: function(t2) {
      return this.x *= t2.x, this.y *= t2.y, this;
    }, _divByPoint: function(t2) {
      return this.x /= t2.x, this.y /= t2.y, this;
    }, _unit: function() {
      return this._div(this.mag()), this;
    }, _perp: function() {
      var t2 = this.y;
      return this.y = this.x, this.x = -t2, this;
    }, _rotate: function(t2) {
      var e2 = Math.cos(t2), n2 = Math.sin(t2), o2 = e2 * this.x - n2 * this.y, r2 = n2 * this.x + e2 * this.y;
      return this.x = o2, this.y = r2, this;
    }, _rotateAround: function(t2, e2) {
      var n2 = Math.cos(t2), o2 = Math.sin(t2), r2 = e2.x + n2 * (this.x - e2.x) - o2 * (this.y - e2.y), i2 = e2.y + o2 * (this.x - e2.x) + n2 * (this.y - e2.y);
      return this.x = r2, this.y = i2, this;
    }, _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    } }, ft.convert = function(t2) {
      return t2 instanceof ft ? t2 : Array.isArray(t2) ? new ft(t2[0], t2[1]) : t2;
    };
    var mt = { enable: function(t2) {
      setTimeout(function() {
        t2.map && t2.map.doubleClickZoom && t2._ctx && t2._ctx.store && t2._ctx.store.getInitialConfigValue && t2._ctx.store.getInitialConfigValue("doubleClickZoom") && t2.map.doubleClickZoom.enable();
      }, 0);
    }, disable: function(t2) {
      setTimeout(function() {
        t2.map && t2.map.doubleClickZoom && t2.map.doubleClickZoom.disable();
      }, 0);
    } }, _t = {}, bt = { get exports() {
      return _t;
    }, set exports(t2) {
      _t = t2;
    } }, Et = function(t2) {
      if (!t2 || !t2.type)
        return null;
      var e2 = Tt[t2.type];
      if (!e2)
        return null;
      if (e2 === "geometry")
        return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: t2 }] };
      if (e2 === "feature")
        return { type: "FeatureCollection", features: [t2] };
      if (e2 === "featurecollection")
        return t2;
    }, Tt = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" };
    var Ct = Object.freeze({ __proto__: null, default: function t2(e2) {
      switch (e2 && e2.type || null) {
        case "FeatureCollection":
          return e2.features = e2.features.reduce(function(e3, n2) {
            return e3.concat(t2(n2));
          }, []), e2;
        case "Feature":
          return e2.geometry ? t2(e2.geometry).map(function(t3) {
            var n2 = { type: "Feature", properties: JSON.parse(JSON.stringify(e2.properties)), geometry: t3 };
            return e2.id !== void 0 && (n2.id = e2.id), n2;
          }) : [e2];
        case "MultiPoint":
          return e2.coordinates.map(function(t3) {
            return { type: "Point", coordinates: t3 };
          });
        case "MultiPolygon":
          return e2.coordinates.map(function(t3) {
            return { type: "Polygon", coordinates: t3 };
          });
        case "MultiLineString":
          return e2.coordinates.map(function(t3) {
            return { type: "LineString", coordinates: t3 };
          });
        case "GeometryCollection":
          return e2.geometries.map(t2).reduce(function(t3, e3) {
            return t3.concat(e3);
          }, []);
        case "Point":
        case "Polygon":
        case "LineString":
          return [e2];
      }
    } }), Ot = Et, St = e(Ct), It = function(t2) {
      return function t3(e2) {
        if (Array.isArray(e2) && e2.length && typeof e2[0] == "number")
          return [e2];
        return e2.reduce(function(e3, n2) {
          return Array.isArray(n2) && Array.isArray(n2[0]) ? e3.concat(t3(n2)) : (e3.push(n2), e3);
        }, []);
      }(t2);
    };
    St instanceof Function || (St = St.default);
    var xt = {}, Mt = { get exports() {
      return xt;
    }, set exports(t2) {
      xt = t2;
    } }.exports = function(t2) {
      return new Lt(t2);
    };
    function Lt(t2) {
      this.value = t2;
    }
    function Nt(t2, e2, n2) {
      var o2 = [], r2 = [], i2 = true;
      return function t3(a2) {
        var s2 = n2 ? At(a2) : a2, u2 = {}, c2 = true, l2 = { node: s2, node_: a2, path: [].concat(o2), parent: r2[r2.length - 1], parents: r2, key: o2.slice(-1)[0], isRoot: o2.length === 0, level: o2.length, circular: null, update: function(t4, e3) {
          l2.isRoot || (l2.parent.node[l2.key] = t4), l2.node = t4, e3 && (c2 = false);
        }, delete: function(t4) {
          delete l2.parent.node[l2.key], t4 && (c2 = false);
        }, remove: function(t4) {
          wt(l2.parent.node) ? l2.parent.node.splice(l2.key, 1) : delete l2.parent.node[l2.key], t4 && (c2 = false);
        }, keys: null, before: function(t4) {
          u2.before = t4;
        }, after: function(t4) {
          u2.after = t4;
        }, pre: function(t4) {
          u2.pre = t4;
        }, post: function(t4) {
          u2.post = t4;
        }, stop: function() {
          i2 = false;
        }, block: function() {
          c2 = false;
        } };
        if (!i2)
          return l2;
        function d2() {
          if (typeof l2.node == "object" && l2.node !== null) {
            l2.keys && l2.node_ === l2.node || (l2.keys = Pt(l2.node)), l2.isLeaf = l2.keys.length == 0;
            for (var t4 = 0; t4 < r2.length; t4++)
              if (r2[t4].node_ === a2) {
                l2.circular = r2[t4];
                break;
              }
          } else
            l2.isLeaf = true, l2.keys = null;
          l2.notLeaf = !l2.isLeaf, l2.notRoot = !l2.isRoot;
        }
        d2();
        var p2 = e2.call(l2, l2.node);
        return p2 !== void 0 && l2.update && l2.update(p2), u2.before && u2.before.call(l2, l2.node), c2 ? (typeof l2.node != "object" || l2.node === null || l2.circular || (r2.push(l2), d2(), Rt(l2.keys, function(e3, r3) {
          o2.push(e3), u2.pre && u2.pre.call(l2, l2.node[e3], e3);
          var i3 = t3(l2.node[e3]);
          n2 && Dt.call(l2.node, e3) && (l2.node[e3] = i3.node), i3.isLast = r3 == l2.keys.length - 1, i3.isFirst = r3 == 0, u2.post && u2.post.call(l2, i3), o2.pop();
        }), r2.pop()), u2.after && u2.after.call(l2, l2.node), l2) : l2;
      }(t2).node;
    }
    function At(t2) {
      if (typeof t2 == "object" && t2 !== null) {
        var e2;
        if (wt(t2))
          e2 = [];
        else if (Ft(t2) === "[object Date]")
          e2 = new Date(t2.getTime ? t2.getTime() : t2);
        else if (function(t3) {
          return Ft(t3) === "[object RegExp]";
        }(t2))
          e2 = new RegExp(t2);
        else if (function(t3) {
          return Ft(t3) === "[object Error]";
        }(t2))
          e2 = { message: t2.message };
        else if (function(t3) {
          return Ft(t3) === "[object Boolean]";
        }(t2))
          e2 = new Boolean(t2);
        else if (function(t3) {
          return Ft(t3) === "[object Number]";
        }(t2))
          e2 = new Number(t2);
        else if (function(t3) {
          return Ft(t3) === "[object String]";
        }(t2))
          e2 = new String(t2);
        else if (Object.create && Object.getPrototypeOf)
          e2 = Object.create(Object.getPrototypeOf(t2));
        else if (t2.constructor === Object)
          e2 = {};
        else {
          var n2 = t2.constructor && t2.constructor.prototype || t2.__proto__ || {}, o2 = function() {
          };
          o2.prototype = n2, e2 = new o2();
        }
        return Rt(Pt(t2), function(n3) {
          e2[n3] = t2[n3];
        }), e2;
      }
      return t2;
    }
    Lt.prototype.get = function(t2) {
      for (var e2 = this.value, n2 = 0; n2 < t2.length; n2++) {
        var o2 = t2[n2];
        if (!e2 || !Dt.call(e2, o2)) {
          e2 = void 0;
          break;
        }
        e2 = e2[o2];
      }
      return e2;
    }, Lt.prototype.has = function(t2) {
      for (var e2 = this.value, n2 = 0; n2 < t2.length; n2++) {
        var o2 = t2[n2];
        if (!e2 || !Dt.call(e2, o2))
          return false;
        e2 = e2[o2];
      }
      return true;
    }, Lt.prototype.set = function(t2, e2) {
      for (var n2 = this.value, o2 = 0; o2 < t2.length - 1; o2++) {
        var r2 = t2[o2];
        Dt.call(n2, r2) || (n2[r2] = {}), n2 = n2[r2];
      }
      return n2[t2[o2]] = e2, e2;
    }, Lt.prototype.map = function(t2) {
      return Nt(this.value, t2, true);
    }, Lt.prototype.forEach = function(t2) {
      return this.value = Nt(this.value, t2, false), this.value;
    }, Lt.prototype.reduce = function(t2, e2) {
      var n2 = arguments.length === 1, o2 = n2 ? this.value : e2;
      return this.forEach(function(e3) {
        this.isRoot && n2 || (o2 = t2.call(this, o2, e3));
      }), o2;
    }, Lt.prototype.paths = function() {
      var t2 = [];
      return this.forEach(function(e2) {
        t2.push(this.path);
      }), t2;
    }, Lt.prototype.nodes = function() {
      var t2 = [];
      return this.forEach(function(e2) {
        t2.push(this.node);
      }), t2;
    }, Lt.prototype.clone = function() {
      var t2 = [], e2 = [];
      return function n2(o2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          if (t2[r2] === o2)
            return e2[r2];
        if (typeof o2 == "object" && o2 !== null) {
          var i2 = At(o2);
          return t2.push(o2), e2.push(i2), Rt(Pt(o2), function(t3) {
            i2[t3] = n2(o2[t3]);
          }), t2.pop(), e2.pop(), i2;
        }
        return o2;
      }(this.value);
    };
    var Pt = Object.keys || function(t2) {
      var e2 = [];
      for (var n2 in t2)
        e2.push(n2);
      return e2;
    };
    function Ft(t2) {
      return Object.prototype.toString.call(t2);
    }
    var wt = Array.isArray || function(t2) {
      return Object.prototype.toString.call(t2) === "[object Array]";
    }, Rt = function(t2, e2) {
      if (t2.forEach)
        return t2.forEach(e2);
      for (var n2 = 0; n2 < t2.length; n2++)
        e2(t2[n2], n2, t2);
    };
    Rt(Pt(Lt.prototype), function(t2) {
      Mt[t2] = function(e2) {
        var n2 = [].slice.call(arguments, 1), o2 = new Lt(e2);
        return o2[t2].apply(o2, n2);
      };
    });
    var Dt = Object.hasOwnProperty || function(t2, e2) {
      return e2 in t2;
    }, kt = Ut;
    function Ut(t2) {
      if (!(this instanceof Ut))
        return new Ut(t2);
      this._bbox = t2 || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!t2;
    }
    Ut.prototype.include = function(t2) {
      return this._valid = true, this._bbox[0] = Math.min(this._bbox[0], t2[0]), this._bbox[1] = Math.min(this._bbox[1], t2[1]), this._bbox[2] = Math.max(this._bbox[2], t2[0]), this._bbox[3] = Math.max(this._bbox[3], t2[1]), this;
    }, Ut.prototype.equals = function(t2) {
      var e2;
      return e2 = t2 instanceof Ut ? t2.bbox() : t2, this._bbox[0] == e2[0] && this._bbox[1] == e2[1] && this._bbox[2] == e2[2] && this._bbox[3] == e2[3];
    }, Ut.prototype.center = function(t2) {
      return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null;
    }, Ut.prototype.union = function(t2) {
      var e2;
      return this._valid = true, e2 = t2 instanceof Ut ? t2.bbox() : t2, this._bbox[0] = Math.min(this._bbox[0], e2[0]), this._bbox[1] = Math.min(this._bbox[1], e2[1]), this._bbox[2] = Math.max(this._bbox[2], e2[2]), this._bbox[3] = Math.max(this._bbox[3], e2[3]), this;
    }, Ut.prototype.bbox = function() {
      return this._valid ? this._bbox : null;
    }, Ut.prototype.contains = function(t2) {
      if (!t2)
        return this._fastContains();
      if (!this._valid)
        return null;
      var e2 = t2[0], n2 = t2[1];
      return this._bbox[0] <= e2 && this._bbox[1] <= n2 && this._bbox[2] >= e2 && this._bbox[3] >= n2;
    }, Ut.prototype.intersect = function(t2) {
      return this._valid ? (e2 = t2 instanceof Ut ? t2.bbox() : t2, !(this._bbox[0] > e2[2] || this._bbox[2] < e2[0] || this._bbox[3] < e2[1] || this._bbox[1] > e2[3])) : null;
      var e2;
    }, Ut.prototype._fastContains = function() {
      if (!this._valid)
        return new Function("return null;");
      var t2 = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
      return new Function("ll", t2);
    }, Ut.prototype.polygon = function() {
      return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null;
    };
    var jt = function(t2) {
      if (!t2)
        return [];
      var e2 = St(Ot(t2)), n2 = [];
      return e2.features.forEach(function(t3) {
        t3.geometry && (n2 = n2.concat(It(t3.geometry.coordinates)));
      }), n2;
    }, Vt = xt, Bt = kt, Gt = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Jt = Object.keys(Gt);
    function zt(t2) {
      for (var e2 = Bt(), n2 = jt(t2), o2 = 0; o2 < n2.length; o2++)
        e2.include(n2[o2]);
      return e2;
    }
    bt.exports = function(t2) {
      return zt(t2).bbox();
    }, _t.polygon = function(t2) {
      return zt(t2).polygon();
    }, _t.bboxify = function(t2) {
      return Vt(t2).map(function(t3) {
        t3 && (Jt.some(function(e2) {
          return !!t3[e2] && Gt[e2].indexOf(t3.type) !== -1;
        }) && (t3.bbox = zt(t3).bbox(), this.update(t3)));
      });
    };
    var Yt = -90;
    function $t(t2, e2) {
      var n2 = Yt, o2 = 90, r2 = Yt, i2 = 90, a2 = 270, s2 = -270;
      t2.forEach(function(t3) {
        var e3 = _t(t3), u3 = e3[1], c2 = e3[3], l2 = e3[0], d2 = e3[2];
        u3 > n2 && (n2 = u3), c2 < o2 && (o2 = c2), c2 > r2 && (r2 = c2), u3 < i2 && (i2 = u3), l2 < a2 && (a2 = l2), d2 > s2 && (s2 = d2);
      });
      var u2 = e2;
      return n2 + u2.lat > 85 && (u2.lat = 85 - n2), r2 + u2.lat > 90 && (u2.lat = 90 - r2), o2 + u2.lat < -85 && (u2.lat = -85 - o2), i2 + u2.lat < Yt && (u2.lat = Yt - i2), a2 + u2.lng <= -270 && (u2.lng += 360 * Math.ceil(Math.abs(u2.lng) / 360)), s2 + u2.lng >= 270 && (u2.lng -= 360 * Math.ceil(Math.abs(u2.lng) / 360)), u2;
    }
    function qt(t2, e2) {
      var n2 = $t(t2.map(function(t3) {
        return t3.toGeoJSON();
      }), e2);
      t2.forEach(function(t3) {
        var e3, o2 = t3.getCoordinates(), r2 = function(t4) {
          var e4 = { lng: t4[0] + n2.lng, lat: t4[1] + n2.lat };
          return [e4.lng, e4.lat];
        }, i2 = function(t4) {
          return t4.map(function(t5) {
            return r2(t5);
          });
        };
        t3.type === p.POINT ? e3 = r2(o2) : t3.type === p.LINE_STRING || t3.type === p.MULTI_POINT ? e3 = o2.map(r2) : t3.type === p.POLYGON || t3.type === p.MULTI_LINE_STRING ? e3 = o2.map(i2) : t3.type === p.MULTI_POLYGON && (e3 = o2.map(function(t4) {
          return t4.map(function(t5) {
            return i2(t5);
          });
        })), t3.incomingCoords(e3);
      });
    }
    var Ht = { onSetup: function(t2) {
      var e2 = this, n2 = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: false, canBoxSelect: false, dragMoving: false, canDragMove: false, initiallySelectedFeatureIds: t2.featureIds || [] };
      return this.setSelected(n2.initiallySelectedFeatureIds.filter(function(t3) {
        return e2.getFeature(t3) !== void 0;
      })), this.fireActionable(), this.setActionableState({ combineFeatures: true, uncombineFeatures: true, trash: true }), n2;
    }, fireUpdate: function() {
      this.map.fire(h3.UPDATE, { action: g.MOVE, features: this.getSelected().map(function(t2) {
        return t2.toGeoJSON();
      }) });
    }, fireActionable: function() {
      var t2 = this, e2 = this.getSelected(), n2 = e2.filter(function(e3) {
        return t2.isInstanceOf("MultiFeature", e3);
      }), o2 = false;
      if (e2.length > 1) {
        o2 = true;
        var r2 = e2[0].type.replace("Multi", "");
        e2.forEach(function(t3) {
          t3.type.replace("Multi", "") !== r2 && (o2 = false);
        });
      }
      var i2 = n2.length > 0, a2 = e2.length > 0;
      this.setActionableState({ combineFeatures: o2, uncombineFeatures: i2, trash: a2 });
    }, getUniqueIds: function(t2) {
      return t2.length ? t2.map(function(t3) {
        return t3.properties.id;
      }).filter(function(t3) {
        return t3 !== void 0;
      }).reduce(function(t3, e2) {
        return t3.add(e2), t3;
      }, new S()).values() : [];
    }, stopExtendedInteractions: function(t2) {
      t2.boxSelectElement && (t2.boxSelectElement.parentNode && t2.boxSelectElement.parentNode.removeChild(t2.boxSelectElement), t2.boxSelectElement = null), this.map.dragPan.enable(), t2.boxSelecting = false, t2.canBoxSelect = false, t2.dragMoving = false, t2.canDragMove = false;
    }, onStop: function() {
      mt.enable(this);
    }, onMouseMove: function(t2) {
      return this.stopExtendedInteractions(t2), true;
    }, onMouseOut: function(t2) {
      return !t2.dragMoving || this.fireUpdate();
    } };
    Ht.onTap = Ht.onClick = function(t2, e2) {
      return it(e2) ? this.clickAnywhere(t2, e2) : et(y.VERTEX)(e2) ? this.clickOnVertex(t2, e2) : at(e2) ? this.clickOnFeature(t2, e2) : void 0;
    }, Ht.clickAnywhere = function(t2) {
      var e2 = this, n2 = this.getSelectedIds();
      n2.length && (this.clearSelectedFeatures(), n2.forEach(function(t3) {
        return e2.doRender(t3);
      })), mt.enable(this), this.stopExtendedInteractions(t2);
    }, Ht.clickOnVertex = function(t2, e2) {
      this.changeMode(f.DIRECT_SELECT, { featureId: e2.featureTarget.properties.parent, coordPath: e2.featureTarget.properties.coord_path, startPos: e2.lngLat }), this.updateUIClasses({ mouse: l.MOVE });
    }, Ht.startOnActiveFeature = function(t2, e2) {
      this.stopExtendedInteractions(t2), this.map.dragPan.disable(), this.doRender(e2.featureTarget.properties.id), t2.canDragMove = true, t2.dragMoveLocation = e2.lngLat;
    }, Ht.clickOnFeature = function(t2, e2) {
      var n2 = this;
      mt.disable(this), this.stopExtendedInteractions(t2);
      var o2 = ut(e2), r2 = this.getSelectedIds(), i2 = e2.featureTarget.properties.id, a2 = this.isSelected(i2);
      if (!o2 && a2 && this.getFeature(i2).type !== p.POINT)
        return this.changeMode(f.DIRECT_SELECT, { featureId: i2 });
      a2 && o2 ? (this.deselect(i2), this.updateUIClasses({ mouse: l.POINTER }), r2.length === 1 && mt.enable(this)) : !a2 && o2 ? (this.select(i2), this.updateUIClasses({ mouse: l.MOVE })) : a2 || o2 || (r2.forEach(function(t3) {
        return n2.doRender(t3);
      }), this.setSelected(i2), this.updateUIClasses({ mouse: l.MOVE })), this.doRender(i2);
    }, Ht.onMouseDown = function(t2, e2) {
      return ot(e2) ? this.startOnActiveFeature(t2, e2) : this.drawConfig.boxSelect && nt(e2) ? this.startBoxSelect(t2, e2) : void 0;
    }, Ht.startBoxSelect = function(t2, e2) {
      this.stopExtendedInteractions(t2), this.map.dragPan.disable(), t2.boxSelectStartLocation = ht(e2.originalEvent, this.map.getContainer()), t2.canBoxSelect = true;
    }, Ht.onTouchStart = function(t2, e2) {
      if (ot(e2))
        return this.startOnActiveFeature(t2, e2);
    }, Ht.onDrag = function(t2, e2) {
      return t2.canDragMove ? this.dragMove(t2, e2) : this.drawConfig.boxSelect && t2.canBoxSelect ? this.whileBoxSelect(t2, e2) : void 0;
    }, Ht.whileBoxSelect = function(t2, e2) {
      t2.boxSelecting = true, this.updateUIClasses({ mouse: l.ADD }), t2.boxSelectElement || (t2.boxSelectElement = document.createElement("div"), t2.boxSelectElement.classList.add(u.BOX_SELECT), this.map.getContainer().appendChild(t2.boxSelectElement));
      var n2 = ht(e2.originalEvent, this.map.getContainer()), o2 = Math.min(t2.boxSelectStartLocation.x, n2.x), r2 = Math.max(t2.boxSelectStartLocation.x, n2.x), i2 = Math.min(t2.boxSelectStartLocation.y, n2.y), a2 = Math.max(t2.boxSelectStartLocation.y, n2.y), s2 = "translate(" + o2 + "px, " + i2 + "px)";
      t2.boxSelectElement.style.transform = s2, t2.boxSelectElement.style.WebkitTransform = s2, t2.boxSelectElement.style.width = r2 - o2 + "px", t2.boxSelectElement.style.height = a2 - i2 + "px";
    }, Ht.dragMove = function(t2, e2) {
      t2.dragMoving = true, e2.originalEvent.stopPropagation();
      var n2 = { lng: e2.lngLat.lng - t2.dragMoveLocation.lng, lat: e2.lngLat.lat - t2.dragMoveLocation.lat };
      qt(this.getSelected(), n2), t2.dragMoveLocation = e2.lngLat;
    }, Ht.onTouchEnd = Ht.onMouseUp = function(t2, e2) {
      var n2 = this;
      if (t2.dragMoving)
        this.fireUpdate();
      else if (t2.boxSelecting) {
        var o2 = [t2.boxSelectStartLocation, ht(e2.originalEvent, this.map.getContainer())], r2 = this.featuresAt(null, o2, "click"), i2 = this.getUniqueIds(r2).filter(function(t3) {
          return !n2.isSelected(t3);
        });
        i2.length && (this.select(i2), i2.forEach(function(t3) {
          return n2.doRender(t3);
        }), this.updateUIClasses({ mouse: l.MOVE }));
      }
      this.stopExtendedInteractions(t2);
    }, Ht.toDisplayFeatures = function(t2, e2, n2) {
      e2.properties.active = this.isSelected(e2.properties.id) ? v2.ACTIVE : v2.INACTIVE, n2(e2), this.fireActionable(), e2.properties.active === v2.ACTIVE && e2.geometry.type !== p.POINT && vt(e2).forEach(n2);
    }, Ht.onTrash = function() {
      this.deleteFeature(this.getSelectedIds()), this.fireActionable();
    }, Ht.onCombineFeatures = function() {
      var t2 = this.getSelected();
      if (!(t2.length === 0 || t2.length < 2)) {
        for (var e2 = [], n2 = [], o2 = t2[0].type.replace("Multi", ""), r2 = 0; r2 < t2.length; r2++) {
          var i2 = t2[r2];
          if (i2.type.replace("Multi", "") !== o2)
            return;
          i2.type.includes("Multi") ? i2.getCoordinates().forEach(function(t3) {
            e2.push(t3);
          }) : e2.push(i2.getCoordinates()), n2.push(i2.toGeoJSON());
        }
        if (n2.length > 1) {
          var a2 = this.newFeature({ type: p.FEATURE, properties: n2[0].properties, geometry: { type: "Multi" + o2, coordinates: e2 } });
          this.addFeature(a2), this.deleteFeature(this.getSelectedIds(), { silent: true }), this.setSelected([a2.id]), this.map.fire(h3.COMBINE_FEATURES, { createdFeatures: [a2.toGeoJSON()], deletedFeatures: n2 });
        }
        this.fireActionable();
      }
    }, Ht.onUncombineFeatures = function() {
      var t2 = this, e2 = this.getSelected();
      if (e2.length !== 0) {
        for (var n2 = [], o2 = [], r2 = function(r3) {
          var i3 = e2[r3];
          t2.isInstanceOf("MultiFeature", i3) && (i3.getFeatures().forEach(function(e3) {
            t2.addFeature(e3), e3.properties = i3.properties, n2.push(e3.toGeoJSON()), t2.select([e3.id]);
          }), t2.deleteFeature(i3.id, { silent: true }), o2.push(i3.toGeoJSON()));
        }, i2 = 0; i2 < e2.length; i2++)
          r2(i2);
        n2.length > 1 && this.map.fire(h3.UNCOMBINE_FEATURES, { createdFeatures: n2, deletedFeatures: o2 }), this.fireActionable();
      }
    };
    var Xt = et(y.VERTEX), Wt = et(y.MIDPOINT), Zt = { fireUpdate: function() {
      this.map.fire(h3.UPDATE, { action: g.CHANGE_COORDINATES, features: this.getSelected().map(function(t2) {
        return t2.toGeoJSON();
      }) });
    }, fireActionable: function(t2) {
      this.setActionableState({ combineFeatures: false, uncombineFeatures: false, trash: t2.selectedCoordPaths.length > 0 });
    }, startDragging: function(t2, e2) {
      this.map.dragPan.disable(), t2.canDragMove = true, t2.dragMoveLocation = e2.lngLat;
    }, stopDragging: function(t2) {
      this.map.dragPan.enable(), t2.dragMoving = false, t2.canDragMove = false, t2.dragMoveLocation = null;
    }, onVertex: function(t2, e2) {
      this.startDragging(t2, e2);
      var n2 = e2.featureTarget.properties, o2 = t2.selectedCoordPaths.indexOf(n2.coord_path);
      ut(e2) || o2 !== -1 ? ut(e2) && o2 === -1 && t2.selectedCoordPaths.push(n2.coord_path) : t2.selectedCoordPaths = [n2.coord_path];
      var r2 = this.pathsToCoordinates(t2.featureId, t2.selectedCoordPaths);
      this.setSelectedCoordinates(r2);
    }, onMidpoint: function(t2, e2) {
      this.startDragging(t2, e2);
      var n2 = e2.featureTarget.properties;
      t2.feature.addCoordinate(n2.coord_path, n2.lng, n2.lat), this.fireUpdate(), t2.selectedCoordPaths = [n2.coord_path];
    }, pathsToCoordinates: function(t2, e2) {
      return e2.map(function(e3) {
        return { feature_id: t2, coord_path: e3 };
      });
    }, onFeature: function(t2, e2) {
      t2.selectedCoordPaths.length === 0 ? this.startDragging(t2, e2) : this.stopDragging(t2);
    }, dragFeature: function(t2, e2, n2) {
      qt(this.getSelected(), n2), t2.dragMoveLocation = e2.lngLat;
    }, dragVertex: function(t2, e2, n2) {
      for (var o2 = t2.selectedCoordPaths.map(function(e3) {
        return t2.feature.getCoordinate(e3);
      }), r2 = $t(o2.map(function(t3) {
        return { type: p.FEATURE, properties: {}, geometry: { type: p.POINT, coordinates: t3 } };
      }), n2), i2 = 0; i2 < o2.length; i2++) {
        var a2 = o2[i2];
        t2.feature.updateCoordinate(t2.selectedCoordPaths[i2], a2[0] + r2.lng, a2[1] + r2.lat);
      }
    }, clickNoTarget: function() {
      this.changeMode(f.SIMPLE_SELECT);
    }, clickInactive: function() {
      this.changeMode(f.SIMPLE_SELECT);
    }, clickActiveFeature: function(t2) {
      t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), t2.feature.changed();
    }, onSetup: function(t2) {
      var e2 = t2.featureId, n2 = this.getFeature(e2);
      if (!n2)
        throw new Error("You must provide a featureId to enter direct_select mode");
      if (n2.type === p.POINT)
        throw new TypeError("direct_select mode doesn't handle point features");
      var o2 = { featureId: e2, feature: n2, dragMoveLocation: t2.startPos || null, dragMoving: false, canDragMove: false, selectedCoordPaths: t2.coordPath ? [t2.coordPath] : [] };
      return this.setSelectedCoordinates(this.pathsToCoordinates(e2, o2.selectedCoordPaths)), this.setSelected(e2), mt.disable(this), this.setActionableState({ trash: true }), o2;
    }, onStop: function() {
      mt.enable(this), this.clearSelectedCoordinates();
    }, toDisplayFeatures: function(t2, e2, n2) {
      t2.featureId === e2.properties.id ? (e2.properties.active = v2.ACTIVE, n2(e2), vt(e2, { map: this.map, midpoints: true, selectedPaths: t2.selectedCoordPaths }).forEach(n2)) : (e2.properties.active = v2.INACTIVE, n2(e2)), this.fireActionable(t2);
    }, onTrash: function(t2) {
      t2.selectedCoordPaths.sort(function(t3, e2) {
        return e2.localeCompare(t3, "en", { numeric: true });
      }).forEach(function(e2) {
        return t2.feature.removeCoordinate(e2);
      }), this.fireUpdate(), t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(t2), t2.feature.isValid() === false && (this.deleteFeature([t2.featureId]), this.changeMode(f.SIMPLE_SELECT, {}));
    }, onMouseMove: function(t2, e2) {
      var n2 = ot(e2), o2 = Xt(e2), r2 = t2.selectedCoordPaths.length === 0;
      return n2 && r2 || o2 && !r2 ? this.updateUIClasses({ mouse: l.MOVE }) : this.updateUIClasses({ mouse: l.NONE }), this.stopDragging(t2), true;
    }, onMouseOut: function(t2) {
      return t2.dragMoving && this.fireUpdate(), true;
    } };
    Zt.onTouchStart = Zt.onMouseDown = function(t2, e2) {
      return Xt(e2) ? this.onVertex(t2, e2) : ot(e2) ? this.onFeature(t2, e2) : Wt(e2) ? this.onMidpoint(t2, e2) : void 0;
    }, Zt.onDrag = function(t2, e2) {
      if (t2.canDragMove === true) {
        t2.dragMoving = true, e2.originalEvent.stopPropagation();
        var n2 = { lng: e2.lngLat.lng - t2.dragMoveLocation.lng, lat: e2.lngLat.lat - t2.dragMoveLocation.lat };
        t2.selectedCoordPaths.length > 0 ? this.dragVertex(t2, e2, n2) : this.dragFeature(t2, e2, n2), t2.dragMoveLocation = e2.lngLat;
      }
    }, Zt.onClick = function(t2, e2) {
      return it(e2) ? this.clickNoTarget(t2, e2) : ot(e2) ? this.clickActiveFeature(t2, e2) : rt(e2) ? this.clickInactive(t2, e2) : void this.stopDragging(t2);
    }, Zt.onTap = function(t2, e2) {
      return it(e2) ? this.clickNoTarget(t2, e2) : ot(e2) ? this.clickActiveFeature(t2, e2) : rt(e2) ? this.clickInactive(t2, e2) : void 0;
    }, Zt.onTouchEnd = Zt.onMouseUp = function(t2) {
      t2.dragMoving && this.fireUpdate(), this.stopDragging(t2);
    };
    var Kt = {};
    function Qt(t2, e2) {
      return !!t2.lngLat && (t2.lngLat.lng === e2[0] && t2.lngLat.lat === e2[1]);
    }
    Kt.onSetup = function() {
      var t2 = this.newFeature({ type: p.FEATURE, properties: {}, geometry: { type: p.POINT, coordinates: [] } });
      return this.addFeature(t2), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(d.POINT), this.setActionableState({ trash: true }), { point: t2 };
    }, Kt.stopDrawingAndRemove = function(t2) {
      this.deleteFeature([t2.point.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT);
    }, Kt.onTap = Kt.onClick = function(t2, e2) {
      this.updateUIClasses({ mouse: l.MOVE }), t2.point.updateCoordinate("", e2.lngLat.lng, e2.lngLat.lat), this.map.fire(h3.CREATE, { features: [t2.point.toGeoJSON()] }), this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.point.id] });
    }, Kt.onStop = function(t2) {
      this.activateUIButton(), t2.point.getCoordinate().length || this.deleteFeature([t2.point.id], { silent: true });
    }, Kt.toDisplayFeatures = function(t2, e2, n2) {
      var o2 = e2.properties.id === t2.point.id;
      if (e2.properties.active = o2 ? v2.ACTIVE : v2.INACTIVE, !o2)
        return n2(e2);
    }, Kt.onTrash = Kt.stopDrawingAndRemove, Kt.onKeyUp = function(t2, e2) {
      if (ct(e2) || lt(e2))
        return this.stopDrawingAndRemove(t2, e2);
    };
    var te = { onSetup: function() {
      var t2 = this.newFeature({ type: p.FEATURE, properties: {}, geometry: { type: p.POLYGON, coordinates: [[]] } });
      return this.addFeature(t2), this.clearSelectedFeatures(), mt.disable(this), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(d.POLYGON), this.setActionableState({ trash: true }), { polygon: t2, currentVertexPosition: 0 };
    }, clickAnywhere: function(t2, e2) {
      if (t2.currentVertexPosition > 0 && Qt(e2, t2.polygon.coordinates[0][t2.currentVertexPosition - 1]))
        return this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      this.updateUIClasses({ mouse: l.ADD }), t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat), t2.currentVertexPosition++, t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat);
    }, clickOnVertex: function(t2) {
      return this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
    }, onMouseMove: function(t2, e2) {
      t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat), st(e2) && this.updateUIClasses({ mouse: l.POINTER });
    } };
    te.onTap = te.onClick = function(t2, e2) {
      return st(e2) ? this.clickOnVertex(t2, e2) : this.clickAnywhere(t2, e2);
    }, te.onKeyUp = function(t2, e2) {
      ct(e2) ? (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT)) : lt(e2) && this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
    }, te.onStop = function(t2) {
      this.updateUIClasses({ mouse: l.NONE }), mt.enable(this), this.activateUIButton(), this.getFeature(t2.polygon.id) !== void 0 && (t2.polygon.removeCoordinate("0." + t2.currentVertexPosition), t2.polygon.isValid() ? this.map.fire(h3.CREATE, { features: [t2.polygon.toGeoJSON()] }) : (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT, {}, { silent: true })));
    }, te.toDisplayFeatures = function(t2, e2, n2) {
      var o2 = e2.properties.id === t2.polygon.id;
      if (e2.properties.active = o2 ? v2.ACTIVE : v2.INACTIVE, !o2)
        return n2(e2);
      if (e2.geometry.coordinates.length !== 0) {
        var r2 = e2.geometry.coordinates[0].length;
        if (!(r2 < 3)) {
          if (e2.properties.meta = y.FEATURE, n2(gt(t2.polygon.id, e2.geometry.coordinates[0][0], "0.0", false)), r2 > 3) {
            var i2 = e2.geometry.coordinates[0].length - 3;
            n2(gt(t2.polygon.id, e2.geometry.coordinates[0][i2], "0." + i2, false));
          }
          if (r2 <= 4) {
            var a2 = [[e2.geometry.coordinates[0][0][0], e2.geometry.coordinates[0][0][1]], [e2.geometry.coordinates[0][1][0], e2.geometry.coordinates[0][1][1]]];
            if (n2({ type: p.FEATURE, properties: e2.properties, geometry: { coordinates: a2, type: p.LINE_STRING } }), r2 === 3)
              return;
          }
          return n2(e2);
        }
      }
    }, te.onTrash = function(t2) {
      this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT);
    };
    var ee = { onSetup: function(t2) {
      var e2, n2, o2 = (t2 = t2 || {}).featureId, r2 = "forward";
      if (o2) {
        if (!(e2 = this.getFeature(o2)))
          throw new Error("Could not find a feature with the provided featureId");
        var i2 = t2.from;
        if (i2 && i2.type === "Feature" && i2.geometry && i2.geometry.type === "Point" && (i2 = i2.geometry), i2 && i2.type === "Point" && i2.coordinates && i2.coordinates.length === 2 && (i2 = i2.coordinates), !i2 || !Array.isArray(i2))
          throw new Error("Please use the `from` property to indicate which point to continue the line from");
        var a2 = e2.coordinates.length - 1;
        if (e2.coordinates[a2][0] === i2[0] && e2.coordinates[a2][1] === i2[1])
          n2 = a2 + 1, e2.addCoordinate.apply(e2, [n2].concat(e2.coordinates[a2]));
        else {
          if (e2.coordinates[0][0] !== i2[0] || e2.coordinates[0][1] !== i2[1])
            throw new Error("`from` should match the point at either the start or the end of the provided LineString");
          r2 = "backwards", n2 = 0, e2.addCoordinate.apply(e2, [n2].concat(e2.coordinates[0]));
        }
      } else
        e2 = this.newFeature({ type: p.FEATURE, properties: {}, geometry: { type: p.LINE_STRING, coordinates: [] } }), n2 = 0, this.addFeature(e2);
      return this.clearSelectedFeatures(), mt.disable(this), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(d.LINE), this.setActionableState({ trash: true }), { line: e2, currentVertexPosition: n2, direction: r2 };
    }, clickAnywhere: function(t2, e2) {
      if (t2.currentVertexPosition > 0 && Qt(e2, t2.line.coordinates[t2.currentVertexPosition - 1]) || t2.direction === "backwards" && Qt(e2, t2.line.coordinates[t2.currentVertexPosition + 1]))
        return this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.line.id] });
      this.updateUIClasses({ mouse: l.ADD }), t2.line.updateCoordinate(t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat), t2.direction === "forward" ? (t2.currentVertexPosition++, t2.line.updateCoordinate(t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat)) : t2.line.addCoordinate(0, e2.lngLat.lng, e2.lngLat.lat);
    }, clickOnVertex: function(t2) {
      return this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.line.id] });
    }, onMouseMove: function(t2, e2) {
      t2.line.updateCoordinate(t2.currentVertexPosition, e2.lngLat.lng, e2.lngLat.lat), st(e2) && this.updateUIClasses({ mouse: l.POINTER });
    } };
    ee.onTap = ee.onClick = function(t2, e2) {
      if (st(e2))
        return this.clickOnVertex(t2, e2);
      this.clickAnywhere(t2, e2);
    }, ee.onKeyUp = function(t2, e2) {
      lt(e2) ? this.changeMode(f.SIMPLE_SELECT, { featureIds: [t2.line.id] }) : ct(e2) && (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT));
    }, ee.onStop = function(t2) {
      mt.enable(this), this.activateUIButton(), this.getFeature(t2.line.id) !== void 0 && (t2.line.removeCoordinate("" + t2.currentVertexPosition), t2.line.isValid() ? this.map.fire(h3.CREATE, { features: [t2.line.toGeoJSON()] }) : (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT, {}, { silent: true })));
    }, ee.onTrash = function(t2) {
      this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(f.SIMPLE_SELECT);
    }, ee.toDisplayFeatures = function(t2, e2, n2) {
      var o2 = e2.properties.id === t2.line.id;
      if (e2.properties.active = o2 ? v2.ACTIVE : v2.INACTIVE, !o2)
        return n2(e2);
      e2.geometry.coordinates.length < 2 || (e2.properties.meta = y.FEATURE, n2(gt(t2.line.id, e2.geometry.coordinates[t2.direction === "forward" ? e2.geometry.coordinates.length - 2 : 1], "" + (t2.direction === "forward" ? e2.geometry.coordinates.length - 2 : 1), false)), n2(e2));
    };
    var ne = { simple_select: Ht, direct_select: Zt, draw_point: Kt, draw_polygon: te, draw_line_string: ee }, oe = { defaultMode: f.SIMPLE_SELECT, keybindings: true, touchEnabled: true, clickBuffer: 2, touchBuffer: 25, boxSelect: true, displayControlsDefault: true, styles: tt, modes: ne, controls: {}, userProperties: false }, re = { point: true, line_string: true, polygon: true, trash: true, combine_features: true, uncombine_features: true }, ie = { point: false, line_string: false, polygon: false, trash: false, combine_features: false, uncombine_features: false };
    function ae(t2, e2) {
      return t2.map(function(t3) {
        return t3.source ? t3 : W(t3, { id: t3.id + "." + e2, source: e2 === "hot" ? c.HOT : c.COLD });
      });
    }
    var se = {};
    !function(t2, e2) {
      var n2 = "__lodash_hash_undefined__", o2 = 9007199254740991, r2 = "[object Arguments]", i2 = "[object Array]", a2 = "[object Boolean]", s2 = "[object Date]", u2 = "[object Error]", c2 = "[object Function]", l2 = "[object Map]", d2 = "[object Number]", p2 = "[object Object]", f2 = "[object Promise]", h4 = "[object RegExp]", g2 = "[object Set]", y2 = "[object String]", v3 = "[object Symbol]", m2 = "[object WeakMap]", _2 = "[object ArrayBuffer]", b2 = "[object DataView]", E2 = /^\[object .+?Constructor\]$/, T2 = /^(?:0|[1-9]\d*)$/, C2 = {};
      C2["[object Float32Array]"] = C2["[object Float64Array]"] = C2["[object Int8Array]"] = C2["[object Int16Array]"] = C2["[object Int32Array]"] = C2["[object Uint8Array]"] = C2["[object Uint8ClampedArray]"] = C2["[object Uint16Array]"] = C2["[object Uint32Array]"] = true, C2[r2] = C2[i2] = C2[_2] = C2[a2] = C2[b2] = C2[s2] = C2[u2] = C2[c2] = C2[l2] = C2[d2] = C2[p2] = C2[h4] = C2[g2] = C2[y2] = C2[m2] = false;
      var O2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, S2 = typeof self == "object" && self && self.Object === Object && self, I2 = O2 || S2 || Function("return this")(), x2 = e2 && !e2.nodeType && e2, M2 = x2 && t2 && !t2.nodeType && t2, L2 = M2 && M2.exports === x2, N2 = L2 && O2.process, A2 = function() {
        try {
          return N2 && N2.binding && N2.binding("util");
        } catch (t3) {
        }
      }(), P2 = A2 && A2.isTypedArray;
      function F2(t3, e3) {
        for (var n3 = -1, o3 = t3 == null ? 0 : t3.length; ++n3 < o3; )
          if (e3(t3[n3], n3, t3))
            return true;
        return false;
      }
      function w2(t3) {
        var e3 = -1, n3 = Array(t3.size);
        return t3.forEach(function(t4, o3) {
          n3[++e3] = [o3, t4];
        }), n3;
      }
      function R3(t3) {
        var e3 = -1, n3 = Array(t3.size);
        return t3.forEach(function(t4) {
          n3[++e3] = t4;
        }), n3;
      }
      var D2, k2, U2, j2 = Array.prototype, V2 = Function.prototype, B2 = Object.prototype, G2 = I2["__core-js_shared__"], J2 = V2.toString, z2 = B2.hasOwnProperty, Y2 = (D2 = /[^.]+$/.exec(G2 && G2.keys && G2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + D2 : "", $2 = B2.toString, q2 = RegExp("^" + J2.call(z2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), H2 = L2 ? I2.Buffer : void 0, X2 = I2.Symbol, W2 = I2.Uint8Array, Z2 = B2.propertyIsEnumerable, K2 = j2.splice, Q2 = X2 ? X2.toStringTag : void 0, tt2 = Object.getOwnPropertySymbols, et2 = H2 ? H2.isBuffer : void 0, nt2 = (k2 = Object.keys, U2 = Object, function(t3) {
        return k2(U2(t3));
      }), ot2 = At2(I2, "DataView"), rt2 = At2(I2, "Map"), it2 = At2(I2, "Promise"), at2 = At2(I2, "Set"), st2 = At2(I2, "WeakMap"), ut2 = At2(Object, "create"), ct2 = Rt2(ot2), lt2 = Rt2(rt2), dt2 = Rt2(it2), pt2 = Rt2(at2), ft2 = Rt2(st2), ht2 = X2 ? X2.prototype : void 0, gt2 = ht2 ? ht2.valueOf : void 0;
      function yt2(t3) {
        var e3 = -1, n3 = t3 == null ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var o3 = t3[e3];
          this.set(o3[0], o3[1]);
        }
      }
      function vt2(t3) {
        var e3 = -1, n3 = t3 == null ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var o3 = t3[e3];
          this.set(o3[0], o3[1]);
        }
      }
      function mt2(t3) {
        var e3 = -1, n3 = t3 == null ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var o3 = t3[e3];
          this.set(o3[0], o3[1]);
        }
      }
      function _t2(t3) {
        var e3 = -1, n3 = t3 == null ? 0 : t3.length;
        for (this.__data__ = new mt2(); ++e3 < n3; )
          this.add(t3[e3]);
      }
      function bt2(t3) {
        var e3 = this.__data__ = new vt2(t3);
        this.size = e3.size;
      }
      function Et2(t3, e3) {
        var n3 = Ut2(t3), o3 = !n3 && kt2(t3), r3 = !n3 && !o3 && jt2(t3), i3 = !n3 && !o3 && !r3 && zt2(t3), a3 = n3 || o3 || r3 || i3, s3 = a3 ? function(t4, e4) {
          for (var n4 = -1, o4 = Array(t4); ++n4 < t4; )
            o4[n4] = e4(n4);
          return o4;
        }(t3.length, String) : [], u3 = s3.length;
        for (var c3 in t3)
          !e3 && !z2.call(t3, c3) || a3 && (c3 == "length" || r3 && (c3 == "offset" || c3 == "parent") || i3 && (c3 == "buffer" || c3 == "byteLength" || c3 == "byteOffset") || wt2(c3, u3)) || s3.push(c3);
        return s3;
      }
      function Tt2(t3, e3) {
        for (var n3 = t3.length; n3--; )
          if (Dt2(t3[n3][0], e3))
            return n3;
        return -1;
      }
      function Ct2(t3) {
        return t3 == null ? t3 === void 0 ? "[object Undefined]" : "[object Null]" : Q2 && Q2 in Object(t3) ? function(t4) {
          var e3 = z2.call(t4, Q2), n3 = t4[Q2];
          try {
            t4[Q2] = void 0;
            var o3 = true;
          } catch (t5) {
          }
          var r3 = $2.call(t4);
          o3 && (e3 ? t4[Q2] = n3 : delete t4[Q2]);
          return r3;
        }(t3) : function(t4) {
          return $2.call(t4);
        }(t3);
      }
      function Ot2(t3) {
        return Jt2(t3) && Ct2(t3) == r2;
      }
      function St2(t3, e3, n3, o3, c3) {
        return t3 === e3 || (t3 == null || e3 == null || !Jt2(t3) && !Jt2(e3) ? t3 != t3 && e3 != e3 : function(t4, e4, n4, o4, c4, f3) {
          var m3 = Ut2(t4), E3 = Ut2(e4), T3 = m3 ? i2 : Ft2(t4), C3 = E3 ? i2 : Ft2(e4), O3 = (T3 = T3 == r2 ? p2 : T3) == p2, S3 = (C3 = C3 == r2 ? p2 : C3) == p2, I3 = T3 == C3;
          if (I3 && jt2(t4)) {
            if (!jt2(e4))
              return false;
            m3 = true, O3 = false;
          }
          if (I3 && !O3)
            return f3 || (f3 = new bt2()), m3 || zt2(t4) ? Mt2(t4, e4, n4, o4, c4, f3) : function(t5, e5, n5, o5, r3, i3, c5) {
              switch (n5) {
                case b2:
                  if (t5.byteLength != e5.byteLength || t5.byteOffset != e5.byteOffset)
                    return false;
                  t5 = t5.buffer, e5 = e5.buffer;
                case _2:
                  return !(t5.byteLength != e5.byteLength || !i3(new W2(t5), new W2(e5)));
                case a2:
                case s2:
                case d2:
                  return Dt2(+t5, +e5);
                case u2:
                  return t5.name == e5.name && t5.message == e5.message;
                case h4:
                case y2:
                  return t5 == e5 + "";
                case l2:
                  var p3 = w2;
                case g2:
                  var f4 = 1 & o5;
                  if (p3 || (p3 = R3), t5.size != e5.size && !f4)
                    return false;
                  var m4 = c5.get(t5);
                  if (m4)
                    return m4 == e5;
                  o5 |= 2, c5.set(t5, e5);
                  var E4 = Mt2(p3(t5), p3(e5), o5, r3, i3, c5);
                  return c5.delete(t5), E4;
                case v3:
                  if (gt2)
                    return gt2.call(t5) == gt2.call(e5);
              }
              return false;
            }(t4, e4, T3, n4, o4, c4, f3);
          if (!(1 & n4)) {
            var x3 = O3 && z2.call(t4, "__wrapped__"), M3 = S3 && z2.call(e4, "__wrapped__");
            if (x3 || M3) {
              var L3 = x3 ? t4.value() : t4, N3 = M3 ? e4.value() : e4;
              return f3 || (f3 = new bt2()), c4(L3, N3, n4, o4, f3);
            }
          }
          if (!I3)
            return false;
          return f3 || (f3 = new bt2()), function(t5, e5, n5, o5, r3, i3) {
            var a3 = 1 & n5, s3 = Lt2(t5), u3 = s3.length, c5 = Lt2(e5).length;
            if (u3 != c5 && !a3)
              return false;
            var l3 = u3;
            for (; l3--; ) {
              var d3 = s3[l3];
              if (!(a3 ? d3 in e5 : z2.call(e5, d3)))
                return false;
            }
            var p3 = i3.get(t5);
            if (p3 && i3.get(e5))
              return p3 == e5;
            var f4 = true;
            i3.set(t5, e5), i3.set(e5, t5);
            var h5 = a3;
            for (; ++l3 < u3; ) {
              var g3 = t5[d3 = s3[l3]], y3 = e5[d3];
              if (o5)
                var v4 = a3 ? o5(y3, g3, d3, e5, t5, i3) : o5(g3, y3, d3, t5, e5, i3);
              if (!(v4 === void 0 ? g3 === y3 || r3(g3, y3, n5, o5, i3) : v4)) {
                f4 = false;
                break;
              }
              h5 || (h5 = d3 == "constructor");
            }
            if (f4 && !h5) {
              var m4 = t5.constructor, _3 = e5.constructor;
              m4 == _3 || !("constructor" in t5) || !("constructor" in e5) || typeof m4 == "function" && m4 instanceof m4 && typeof _3 == "function" && _3 instanceof _3 || (f4 = false);
            }
            return i3.delete(t5), i3.delete(e5), f4;
          }(t4, e4, n4, o4, c4, f3);
        }(t3, e3, n3, o3, St2, c3));
      }
      function It2(t3) {
        return !(!Gt2(t3) || function(t4) {
          return !!Y2 && Y2 in t4;
        }(t3)) && (Vt2(t3) ? q2 : E2).test(Rt2(t3));
      }
      function xt2(t3) {
        if (n3 = (e3 = t3) && e3.constructor, o3 = typeof n3 == "function" && n3.prototype || B2, e3 !== o3)
          return nt2(t3);
        var e3, n3, o3, r3 = [];
        for (var i3 in Object(t3))
          z2.call(t3, i3) && i3 != "constructor" && r3.push(i3);
        return r3;
      }
      function Mt2(t3, e3, n3, o3, r3, i3) {
        var a3 = 1 & n3, s3 = t3.length, u3 = e3.length;
        if (s3 != u3 && !(a3 && u3 > s3))
          return false;
        var c3 = i3.get(t3);
        if (c3 && i3.get(e3))
          return c3 == e3;
        var l3 = -1, d3 = true, p3 = 2 & n3 ? new _t2() : void 0;
        for (i3.set(t3, e3), i3.set(e3, t3); ++l3 < s3; ) {
          var f3 = t3[l3], h5 = e3[l3];
          if (o3)
            var g3 = a3 ? o3(h5, f3, l3, e3, t3, i3) : o3(f3, h5, l3, t3, e3, i3);
          if (g3 !== void 0) {
            if (g3)
              continue;
            d3 = false;
            break;
          }
          if (p3) {
            if (!F2(e3, function(t4, e4) {
              if (a4 = e4, !p3.has(a4) && (f3 === t4 || r3(f3, t4, n3, o3, i3)))
                return p3.push(e4);
              var a4;
            })) {
              d3 = false;
              break;
            }
          } else if (f3 !== h5 && !r3(f3, h5, n3, o3, i3)) {
            d3 = false;
            break;
          }
        }
        return i3.delete(t3), i3.delete(e3), d3;
      }
      function Lt2(t3) {
        return function(t4, e3, n3) {
          var o3 = e3(t4);
          return Ut2(t4) ? o3 : function(t5, e4) {
            for (var n4 = -1, o4 = e4.length, r3 = t5.length; ++n4 < o4; )
              t5[r3 + n4] = e4[n4];
            return t5;
          }(o3, n3(t4));
        }(t3, Yt2, Pt2);
      }
      function Nt2(t3, e3) {
        var n3, o3, r3 = t3.__data__;
        return ((o3 = typeof (n3 = e3)) == "string" || o3 == "number" || o3 == "symbol" || o3 == "boolean" ? n3 !== "__proto__" : n3 === null) ? r3[typeof e3 == "string" ? "string" : "hash"] : r3.map;
      }
      function At2(t3, e3) {
        var n3 = function(t4, e4) {
          return t4 == null ? void 0 : t4[e4];
        }(t3, e3);
        return It2(n3) ? n3 : void 0;
      }
      yt2.prototype.clear = function() {
        this.__data__ = ut2 ? ut2(null) : {}, this.size = 0;
      }, yt2.prototype.delete = function(t3) {
        var e3 = this.has(t3) && delete this.__data__[t3];
        return this.size -= e3 ? 1 : 0, e3;
      }, yt2.prototype.get = function(t3) {
        var e3 = this.__data__;
        if (ut2) {
          var o3 = e3[t3];
          return o3 === n2 ? void 0 : o3;
        }
        return z2.call(e3, t3) ? e3[t3] : void 0;
      }, yt2.prototype.has = function(t3) {
        var e3 = this.__data__;
        return ut2 ? e3[t3] !== void 0 : z2.call(e3, t3);
      }, yt2.prototype.set = function(t3, e3) {
        var o3 = this.__data__;
        return this.size += this.has(t3) ? 0 : 1, o3[t3] = ut2 && e3 === void 0 ? n2 : e3, this;
      }, vt2.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, vt2.prototype.delete = function(t3) {
        var e3 = this.__data__, n3 = Tt2(e3, t3);
        return !(n3 < 0) && (n3 == e3.length - 1 ? e3.pop() : K2.call(e3, n3, 1), --this.size, true);
      }, vt2.prototype.get = function(t3) {
        var e3 = this.__data__, n3 = Tt2(e3, t3);
        return n3 < 0 ? void 0 : e3[n3][1];
      }, vt2.prototype.has = function(t3) {
        return Tt2(this.__data__, t3) > -1;
      }, vt2.prototype.set = function(t3, e3) {
        var n3 = this.__data__, o3 = Tt2(n3, t3);
        return o3 < 0 ? (++this.size, n3.push([t3, e3])) : n3[o3][1] = e3, this;
      }, mt2.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new yt2(), map: new (rt2 || vt2)(), string: new yt2() };
      }, mt2.prototype.delete = function(t3) {
        var e3 = Nt2(this, t3).delete(t3);
        return this.size -= e3 ? 1 : 0, e3;
      }, mt2.prototype.get = function(t3) {
        return Nt2(this, t3).get(t3);
      }, mt2.prototype.has = function(t3) {
        return Nt2(this, t3).has(t3);
      }, mt2.prototype.set = function(t3, e3) {
        var n3 = Nt2(this, t3), o3 = n3.size;
        return n3.set(t3, e3), this.size += n3.size == o3 ? 0 : 1, this;
      }, _t2.prototype.add = _t2.prototype.push = function(t3) {
        return this.__data__.set(t3, n2), this;
      }, _t2.prototype.has = function(t3) {
        return this.__data__.has(t3);
      }, bt2.prototype.clear = function() {
        this.__data__ = new vt2(), this.size = 0;
      }, bt2.prototype.delete = function(t3) {
        var e3 = this.__data__, n3 = e3.delete(t3);
        return this.size = e3.size, n3;
      }, bt2.prototype.get = function(t3) {
        return this.__data__.get(t3);
      }, bt2.prototype.has = function(t3) {
        return this.__data__.has(t3);
      }, bt2.prototype.set = function(t3, e3) {
        var n3 = this.__data__;
        if (n3 instanceof vt2) {
          var o3 = n3.__data__;
          if (!rt2 || o3.length < 199)
            return o3.push([t3, e3]), this.size = ++n3.size, this;
          n3 = this.__data__ = new mt2(o3);
        }
        return n3.set(t3, e3), this.size = n3.size, this;
      };
      var Pt2 = tt2 ? function(t3) {
        return t3 == null ? [] : (t3 = Object(t3), function(t4, e3) {
          for (var n3 = -1, o3 = t4 == null ? 0 : t4.length, r3 = 0, i3 = []; ++n3 < o3; ) {
            var a3 = t4[n3];
            e3(a3, n3, t4) && (i3[r3++] = a3);
          }
          return i3;
        }(tt2(t3), function(e3) {
          return Z2.call(t3, e3);
        }));
      } : function() {
        return [];
      }, Ft2 = Ct2;
      function wt2(t3, e3) {
        return !!(e3 = e3 == null ? o2 : e3) && (typeof t3 == "number" || T2.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e3;
      }
      function Rt2(t3) {
        if (t3 != null) {
          try {
            return J2.call(t3);
          } catch (t4) {
          }
          try {
            return t3 + "";
          } catch (t4) {
          }
        }
        return "";
      }
      function Dt2(t3, e3) {
        return t3 === e3 || t3 != t3 && e3 != e3;
      }
      (ot2 && Ft2(new ot2(new ArrayBuffer(1))) != b2 || rt2 && Ft2(new rt2()) != l2 || it2 && Ft2(it2.resolve()) != f2 || at2 && Ft2(new at2()) != g2 || st2 && Ft2(new st2()) != m2) && (Ft2 = function(t3) {
        var e3 = Ct2(t3), n3 = e3 == p2 ? t3.constructor : void 0, o3 = n3 ? Rt2(n3) : "";
        if (o3)
          switch (o3) {
            case ct2:
              return b2;
            case lt2:
              return l2;
            case dt2:
              return f2;
            case pt2:
              return g2;
            case ft2:
              return m2;
          }
        return e3;
      });
      var kt2 = Ot2(function() {
        return arguments;
      }()) ? Ot2 : function(t3) {
        return Jt2(t3) && z2.call(t3, "callee") && !Z2.call(t3, "callee");
      }, Ut2 = Array.isArray;
      var jt2 = et2 || function() {
        return false;
      };
      function Vt2(t3) {
        if (!Gt2(t3))
          return false;
        var e3 = Ct2(t3);
        return e3 == c2 || e3 == "[object GeneratorFunction]" || e3 == "[object AsyncFunction]" || e3 == "[object Proxy]";
      }
      function Bt2(t3) {
        return typeof t3 == "number" && t3 > -1 && t3 % 1 == 0 && t3 <= o2;
      }
      function Gt2(t3) {
        var e3 = typeof t3;
        return t3 != null && (e3 == "object" || e3 == "function");
      }
      function Jt2(t3) {
        return t3 != null && typeof t3 == "object";
      }
      var zt2 = P2 ? function(t3) {
        return function(e3) {
          return t3(e3);
        };
      }(P2) : function(t3) {
        return Jt2(t3) && Bt2(t3.length) && !!C2[Ct2(t3)];
      };
      function Yt2(t3) {
        return (e3 = t3) != null && Bt2(e3.length) && !Vt2(e3) ? Et2(t3) : xt2(t3);
        var e3;
      }
      t2.exports = function(t3, e3) {
        return St2(t3, e3);
      };
    }({ get exports() {
      return se;
    }, set exports(t2) {
      se = t2;
    } }, se);
    var ue = se;
    function ce(t2, e2) {
      return t2.length === e2.length && JSON.stringify(t2.map(function(t3) {
        return t3;
      }).sort()) === JSON.stringify(e2.map(function(t3) {
        return t3;
      }).sort());
    }
    var le = { Polygon: U, LineString: k, Point: D, MultiPolygon: B, MultiLineString: B, MultiPoint: B };
    var de = Object.freeze({ __proto__: null, CommonSelectors: dt, constrainFeatureMovement: $t, createMidPoint: yt, createSupplementaryPoints: vt, createVertex: gt, doubleClickZoom: mt, euclideanDistance: N, featuresAt: x, getFeatureAtAndSetCursors: L, isClick: A, isEventAtCoordinates: Qt, isTap: P, mapEventToBoundingBox: O, ModeHandler: t, moveFeatures: qt, sortFeatures: C, stringSetsAreEqual: ce, StringSet: S, theme: tt, toDenseArray: $ }), pe = function(t2, e2) {
      var n2 = { options: t2 = function(t3) {
        t3 === void 0 && (t3 = {});
        var e3 = W(t3);
        return t3.controls || (e3.controls = {}), t3.displayControlsDefault === false ? e3.controls = W(ie, t3.controls) : e3.controls = W(re, t3.controls), (e3 = W(oe, e3)).styles = ae(e3.styles, "cold").concat(ae(e3.styles, "hot")), e3;
      }(t2) };
      e2 = function(t3, e3) {
        return e3.modes = f, e3.getFeatureIdsAt = function(e4) {
          return x.click({ point: e4 }, null, t3).map(function(t4) {
            return t4.properties.id;
          });
        }, e3.getSelectedIds = function() {
          return t3.store.getSelectedIds();
        }, e3.getSelected = function() {
          return { type: p.FEATURE_COLLECTION, features: t3.store.getSelectedIds().map(function(e4) {
            return t3.store.get(e4);
          }).map(function(t4) {
            return t4.toGeoJSON();
          }) };
        }, e3.getSelectedPoints = function() {
          return { type: p.FEATURE_COLLECTION, features: t3.store.getSelectedCoordinates().map(function(t4) {
            return { type: p.FEATURE, properties: {}, geometry: { type: p.POINT, coordinates: t4.coordinates } };
          }) };
        }, e3.set = function(n3) {
          if (n3.type === void 0 || n3.type !== p.FEATURE_COLLECTION || !Array.isArray(n3.features))
            throw new Error("Invalid FeatureCollection");
          var o3 = t3.store.createRenderBatch(), r2 = t3.store.getAllIds().slice(), i2 = e3.add(n3), a2 = new S(i2);
          return (r2 = r2.filter(function(t4) {
            return !a2.has(t4);
          })).length && e3.delete(r2), o3(), i2;
        }, e3.add = function(e4) {
          var n3 = JSON.parse(JSON.stringify(Et(e4))).features.map(function(e5) {
            if (e5.id = e5.id || F(), e5.geometry === null)
              throw new Error("Invalid geometry: null");
            if (t3.store.get(e5.id) === void 0 || t3.store.get(e5.id).type !== e5.geometry.type) {
              var n4 = le[e5.geometry.type];
              if (n4 === void 0)
                throw new Error("Invalid geometry type: " + e5.geometry.type + ".");
              var o3 = new n4(t3, e5);
              t3.store.add(o3);
            } else {
              var r2 = t3.store.get(e5.id);
              r2.properties = e5.properties, ue(r2.getCoordinates(), e5.geometry.coordinates) || r2.incomingCoords(e5.geometry.coordinates);
            }
            return e5.id;
          });
          return t3.store.render(), n3;
        }, e3.get = function(e4) {
          var n3 = t3.store.get(e4);
          if (n3)
            return n3.toGeoJSON();
        }, e3.getAll = function() {
          return { type: p.FEATURE_COLLECTION, features: t3.store.getAll().map(function(t4) {
            return t4.toGeoJSON();
          }) };
        }, e3.delete = function(n3) {
          return t3.store.delete(n3, { silent: true }), e3.getMode() !== f.DIRECT_SELECT || t3.store.getSelectedIds().length ? t3.store.render() : t3.events.changeMode(f.SIMPLE_SELECT, void 0, { silent: true }), e3;
        }, e3.deleteAll = function() {
          return t3.store.delete(t3.store.getAllIds(), { silent: true }), e3.getMode() === f.DIRECT_SELECT ? t3.events.changeMode(f.SIMPLE_SELECT, void 0, { silent: true }) : t3.store.render(), e3;
        }, e3.changeMode = function(n3, o3) {
          return o3 === void 0 && (o3 = {}), n3 === f.SIMPLE_SELECT && e3.getMode() === f.SIMPLE_SELECT ? (ce(o3.featureIds || [], t3.store.getSelectedIds()) || (t3.store.setSelected(o3.featureIds, { silent: true }), t3.store.render()), e3) : (n3 === f.DIRECT_SELECT && e3.getMode() === f.DIRECT_SELECT && o3.featureId === t3.store.getSelectedIds()[0] || t3.events.changeMode(n3, o3, { silent: true }), e3);
        }, e3.getMode = function() {
          return t3.events.getMode();
        }, e3.trash = function() {
          return t3.events.trash({ silent: true }), e3;
        }, e3.combineFeatures = function() {
          return t3.events.combineFeatures({ silent: true }), e3;
        }, e3.uncombineFeatures = function() {
          return t3.events.uncombineFeatures({ silent: true }), e3;
        }, e3.setFeatureProperty = function(n3, o3, r2) {
          return t3.store.setFeatureProperty(n3, o3, r2), e3;
        }, e3;
      }(n2, e2), n2.api = e2;
      var o2 = Q(n2);
      return e2.onAdd = o2.onAdd, e2.onRemove = o2.onRemove, e2.types = d, e2.options = t2, e2;
    };
    function fe(t2) {
      pe(t2, this);
    }
    return fe.modes = ne, fe.constants = b, fe.lib = de, fe;
  });
})(mapboxGlDraw$1);
const MapboxDrawControl = /* @__PURE__ */ getDefaultExportFromCjs(mapboxGlDraw$1.exports);
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
const slotIsNotEmpty = (el) => el && el.outerHTML !== "<div></div>";
const filterObject = (object, keys2, blacklist = [void 0]) => {
  const result = {};
  const _keys = keys2 || Object.keys(object);
  for (const key of _keys) {
    if (!blacklist.some((b) => b === object[key])) {
      result[key] = object[key];
    }
  }
  return result;
};
const parentsNameIs = (instance, parentName) => {
  if (!instance.parent)
    return false;
  if (instance.parent.type)
    return instance.parent.type.name === parentName;
  if (instance.parent.vnode.tag)
    return instance.parent.vnode.tag.endsWith(parentName);
  return false;
};
const parentNameContains = (instance, parentNameFragment) => {
  if (!instance.parent)
    return false;
  if (instance.parent.type)
    return instance.parent.type.name.includes(parentNameFragment);
  if (instance.parent.vnode.tag)
    return instance.parent.vnode.tag.includes(parentNameFragment);
  return false;
};
const duplicateEvents = (object, instance, events2) => {
  for (const event of events2)
    object.on(event, (evt) => {
      instance.emit(event, evt);
    });
};
var browserIsSafari = () => navigator.userAgent.toLowerCase().includes("safari") && !navigator.userAgent.toLocaleLowerCase().includes("chrome");
const mountGeocoderControl = (vmb_map, vmb_geocoder, props, instance) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = vmb_map ? yield vmb_map.promise : null;
  const options = getGeocoderControlOptions(props);
  const geocoder = new lib(options);
  if (parentsNameIs(instance, "MapboxMap") && map2)
    map2.addControl(geocoder);
  else {
    if (instance.parent)
      geocoder.addTo(instance.refs.geocoder);
    if (slotIsNotEmpty(instance.refs["custom-input"])) {
      attachToInput(instance.refs["custom-input"], geocoder, instance);
    }
  }
  vmb_geocoder.resolve(geocoder);
});
const mountGeocoderEvents = (vmb_geocoder, instance) => __awaiter(void 0, void 0, void 0, function* () {
  const geocoder = yield vmb_geocoder.promise;
  geocoder.on("result", (res) => {
    instance.emit("result", res.result);
    instance.proxy.geocoderState.result = res.result;
  });
  geocoder.on("results", (res) => {
    instance.emit("results", res);
    instance.proxy.geocoderState.results = res;
  });
  geocoder.on("error", (err) => {
    instance.emit("error", err);
    instance.proxy.geocoderState.error = err;
  });
  geocoder.on("loading", (query) => {
    instance.emit("loading", query);
    instance.proxy.geocoderState.loading = query;
  });
  geocoder.on("clear", () => {
    instance.emit("clear");
  });
});
const getGeocoderControlOptions = (props) => {
  const options = filterObject(props);
  options.accessToken = props.accessToken || mapboxgl.accessToken;
  options.mapboxgl = mapboxgl;
  return options;
};
const attachToInput = (ref2, geocoder, instance) => {
  if (instance && instance.proxy) {
    if (instance.proxy.showOriginalGeocoder)
      instance.proxy.showOriginalGeocoder = false;
    const inputs = ref2.getElementsByTagName("input");
    if (!inputs)
      throw new Error("MapboxGeocoderControl: No inputs found");
    const input = inputs[0];
    input.addEventListener("keyup", (evt) => {
      geocoder.query(input.value);
      if (browserIsSafari()) {
        setTimeout(() => {
          input.focus();
        }, 100);
        setTimeout(() => {
          input.focus();
        }, 200);
      }
    });
  }
};
var script$g = vue_cjs_prod.defineComponent({
  name: "MapboxGeocoderControl",
  props: {
    accessToken: { type: String, default: "" },
    origin: { type: String },
    zoom: { type: Number },
    flyTo: { type: [Boolean, Object], default: () => void 0 },
    placeholder: { type: String },
    proximity: { type: Object },
    trackProximity: { type: Boolean, default: () => void 0 },
    collapsed: { type: Boolean, default: () => void 0 },
    clearAndBlurOnEsc: { type: Boolean, default: () => void 0 },
    clearOnBlur: { type: Boolean, default: () => void 0 },
    bbox: { type: Array },
    countries: { type: String },
    types: { type: String },
    minLength: { type: Number },
    limit: { type: Number },
    language: { type: String },
    filter: { type: Function },
    localGeocoder: { type: Function },
    externalGeocoder: { type: Function },
    reverseGeocode: { type: Boolean, default: () => void 0 },
    enableEventLogging: { type: Boolean, default: () => void 0 },
    marker: { type: Boolean, default: () => void 0 },
    render: { type: Function },
    getItemValue: { type: Function },
    mode: { type: String },
    localGeocoderOnly: { type: Boolean, default: () => void 0 }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_geocoder = new _default$1();
    const showOriginalGeocoder = vue_cjs_prod.ref(true);
    const geocoderState = vue_cjs_prod.ref({
      result: {},
      results: {},
      error: null,
      loading: null
    });
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      const instance = vue_cjs_prod.getCurrentInstance();
      if (instance)
        yield mountGeocoderControl(vmb_map, vmb_geocoder, props, instance);
      if (instance)
        yield mountGeocoderEvents(vmb_geocoder, instance);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      const geocoder = yield vmb_geocoder.promise;
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        if (!map2._removed)
          map2.removeControl(geocoder);
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
    }));
    return { showOriginalGeocoder, geocoderState };
  }
});
const _hoisted_1$8 = { ref: "geocoder" };
const _hoisted_2$1 = { ref: "custom-input" };
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", null, [
    vue_cjs_prod.withDirectives(vue_cjs_prod.createElementVNode("div", _hoisted_1$8, null, 512), [
      [vue_cjs_prod.vShow, _ctx.showOriginalGeocoder]
    ]),
    vue_cjs_prod.createElementVNode("div", _hoisted_2$1, [
      vue_cjs_prod.renderSlot(_ctx.$slots, "input", {
        result: _ctx.geocoderState.result,
        results: _ctx.geocoderState.results,
        error: _ctx.geocoderState.error,
        loading: _ctx.geocoderState.loading
      })
    ], 512)
  ]);
}
script$g.render = render$g;
var conditionalWatch = (ref2, cb, options) => {
  if (ref2 && ref2.value !== void 0)
    return vue_cjs_prod.watch(ref2, cb, options);
  else
    return null;
};
function enableAutoResize(rootContainerRef, map2, autoResizeDelay) {
  if (window.ResizeObserver) {
    enableAutoResizeWithResizeObserver(rootContainerRef, map2);
  } else {
    const containerSize = enableAutoResizeWithEventListener(rootContainerRef, autoResizeDelay);
    vue_cjs_prod.watch(containerSize, () => {
      map2.resize();
    });
  }
}
function enableTouchZoomRotate(map2, touchZoomRotate) {
  if (touchZoomRotate.value)
    map2.touchZoomRotate.enable();
  vue_cjs_prod.watch(touchZoomRotate, (val) => {
    if (val)
      map2.touchZoomRotate.enable();
    else
      map2.touchZoomRotate.disable();
  });
}
function enableAutoResizeWithResizeObserver(rootContainerRef, map2) {
  if (!rootContainerRef.value)
    throw new Error("Could not enable auto-resize because root container could not be found");
  const observer = new window.ResizeObserver(() => map2.resize());
  observer.observe(rootContainerRef.value);
}
function enableAutoResizeWithEventListener(watchedRef, autoResizeDelay) {
  const instance = vue_cjs_prod.getCurrentInstance();
  const result = vue_cjs_prod.reactive(new DOMRect(0, 0, 0, 0).toJSON());
  if (instance) {
    let boundingBox = watchedRef.value ? watchedRef.value.getBoundingClientRect() : new DOMRect(0, 0, 0, 0);
    addEventListener("resize", (val) => {
      setTimeout(() => {
        if (watchedRef.value) {
          const newBoundingBox = watchedRef.value.getBoundingClientRect().toJSON();
          const boundingBoxHasChanged = boundingBox.width !== newBoundingBox.width || boundingBox.height !== newBoundingBox.height;
          boundingBox = newBoundingBox;
          if (boundingBoxHasChanged)
            Object.assign(result, newBoundingBox);
        }
      }, autoResizeDelay || 0);
    });
  }
  return result;
}
const getStyle = (props) => ({
  height: props.height,
  width: props.width,
  "--zoom-logo": props.zoomLogo >= 0.8 ? props.zoomLogo : 1
});
const getMapStyle = (raw) => raw.includes("/") ? raw : `mapbox://styles/mapbox/${raw}`;
const getMapboxOptions = (props, el) => {
  const opts = filterObject(props, [
    "accessToken",
    "antialias",
    "attributionControl",
    "bearing",
    "bearingSnap",
    "bounds",
    "boxZoom",
    "center",
    "clickTolerance",
    "collectResourceTiming",
    "container",
    "cooperativeGestures",
    "crossSourceCollisions",
    "customAttribution",
    "doubleClickZoom",
    "dragPan",
    "dragRotate",
    "fadeDuration",
    "failIfMajorPerformanceCaveat",
    "fitBoundsOptions",
    "hash",
    "interactive",
    "keyboard",
    "localIdeographFontFamily",
    "logoPosition",
    "maxBounds",
    "maxPitch",
    "maxTileCacheSize",
    "maxZoom",
    "minPitch",
    "minZoom",
    "pitch",
    "pitchWithRotate",
    "preserveDrawingBuffer",
    "projection",
    "refreshExpiredTiles",
    "renderWorldCopies",
    "scrollZoom",
    "touchZoomRotate",
    "trackResize",
    "transformRequest",
    "zoom"
  ]);
  opts.style = getMapStyle(props.mapStyle);
  opts.container = el;
  return opts;
};
const mountMap = (props, vmb_map, mapContainerRef, rootContainerRef) => (() => {
  const element = mapContainerRef.value;
  const mapOptions = getMapboxOptions(props, element);
  const map2 = new mapboxgl.Map(mapOptions);
  map2.on("load", () => {
    vmb_map.resolve(map2);
  });
  if (props.autoResize) {
    enableAutoResize(rootContainerRef, map2, props.autoResizeDelay);
  }
  if (props.touchZoomRotate) {
    enableTouchZoomRotate(map2, vue_cjs_prod.toRef(props, "touchZoomRotate"));
  }
})();
const updateStyle = (props, style) => {
  style.value = getStyle(props);
};
function mapWatcher(vmb_map, props, propsReactive) {
  return __awaiter(this, void 0, void 0, function* () {
    const { cooperativeGestures, width, height, bearing, maxBounds, maxPitch, minZoom, maxZoom, minPitch, pitch, projection, renderWorldCopies, zoom, mapStyle } = vue_cjs_prod.toRefs(props);
    const { center, flyToOptions } = propsReactive;
    yield watchDimensions(vmb_map, width, height);
    yield watchRegular(vmb_map, { bearing, maxBounds, maxPitch, minPitch, pitch, renderWorldCopies });
    yield watchPosition(vmb_map, { maxZoom, center, flyToOptions, minZoom, zoom });
    yield watchMapStyle(vmb_map, mapStyle);
    yield watchProjection(vmb_map, projection);
  });
}
function watchMapStyle(vmb_map, mapStyle) {
  return __awaiter(this, void 0, void 0, function* () {
    const map2 = yield vmb_map.promise;
    vue_cjs_prod.watch(mapStyle, (newStyle) => map2.setStyle(newStyle));
  });
}
function watchDimensions(vmb_map, width, height) {
  return __awaiter(this, void 0, void 0, function* () {
    const map2 = yield vmb_map.promise;
    vue_cjs_prod.watch(width, () => map2.resize());
    vue_cjs_prod.watch(height, () => map2.resize());
  });
}
function watchRegular(vmb_map, refs) {
  return __awaiter(this, void 0, void 0, function* () {
    const map2 = yield vmb_map.promise;
    conditionalWatch(refs.bearing, (val) => map2.setBearing(val));
    conditionalWatch(refs.maxBounds, (val) => map2.setMaxBounds(val));
    conditionalWatch(refs.maxPitch, (val) => map2.setMaxPitch(val));
    conditionalWatch(refs.minPitch, (val) => map2.setMinPitch(val));
    conditionalWatch(refs.pitch, (val) => map2.setPitch(val));
    conditionalWatch(refs.renderWorldCopies, (val) => map2.setRenderWorldCopies(val));
  });
}
function watchPosition(vmb_map, refs) {
  conditionalWatch(refs.center, (center) => updateMapPosition(vmb_map, { center }), { deep: true });
  conditionalWatch(refs.flyToOptions, (flyToOptions) => updateMapPosition(vmb_map, { flyToOptions }), { deep: true });
  conditionalWatch(refs.maxZoom, (maxZoom) => updateMapPosition(vmb_map, { maxZoom }));
  conditionalWatch(refs.minZoom, (minZoom) => updateMapPosition(vmb_map, { minZoom }));
  conditionalWatch(refs.zoom, (zoom) => updateMapPosition(vmb_map, { zoom }));
}
function watchProjection(vmb_map, projectionRef) {
  return __awaiter(this, void 0, void 0, function* () {
    const map2 = yield vmb_map.promise;
    conditionalWatch(projectionRef, (proj) => map2.setProjection(proj));
  });
}
function updateMapPosition(vmb_map, posProps) {
  return __awaiter(this, void 0, void 0, function* () {
    const map2 = yield vmb_map.promise;
    const opts = posProps.flyToOptions ? filterObject(posProps.flyToOptions, ["curve", "maxDuration", "minZoom", "screenSpeed", "speed"]) : {};
    if (posProps.center)
      opts.center = posProps.center;
    if (posProps.zoom)
      opts.zoom = posProps.zoom;
    map2.flyTo(opts);
  });
}
const MapGlEvents = [
  "boxzoomstart",
  "click",
  "contextmenu",
  "data",
  "dataloading",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "error",
  "idle",
  "load",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemouve",
  "mouseout",
  "mouseover",
  "mouseup",
  "move",
  "moveend",
  "movestart",
  "pitch",
  "pitchend",
  "pitchstart",
  "remove",
  "resize",
  "rotate",
  "rotateend",
  "rotatestart",
  "sourcedata",
  "sourcedataloading",
  "styledata",
  "styledataloading",
  "styleimagemissing",
  "touchcancel",
  "touchend",
  "touchstart",
  "webglcontextlost",
  "webglcontextrestored",
  "wheel",
  "zoom",
  "zoomend",
  "zoomstart"
];
const MapEmits = [
  ...MapGlEvents,
  "update:center",
  "update:flyToOptions",
  "update:zoom",
  "update:pitch",
  "update:bearing",
  "loaded"
];
const registerMapEvents = (vmb_map, instance) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  duplicateEvents(map2, instance, MapGlEvents);
  instance.emit("loaded", map2);
  map2.on("zoomend", (evt) => {
    instance.emit("update:zoom", evt.target.getZoom());
    instance.emit("update:center", evt.target.getCenter().toArray());
  });
  map2.on("dragend", (evt) => {
    instance.emit("update:center", evt.target.getCenter().toArray());
  });
  map2.on("pitchend", (evt) => {
    instance.emit("update:pitch", evt.target.getPitch());
  });
  map2.on("rotateend", (evt) => {
    instance.emit("update:bearing", evt.target.getBearing());
  });
});
const isPrimitive = (input) => {
  const primitives = ["string", "number", "boolean"];
  let isPrimitive2 = false;
  if (input === null)
    isPrimitive2 = true;
  if (primitives.some((p) => typeof input === p))
    isPrimitive2 = true;
  return isPrimitive2;
};
function vmodel(propertyValue, eventName = "change", modelName = "value") {
  const instance = vue_cjs_prod.getCurrentInstance();
  const eventNames2 = eventName instanceof Array ? eventName : [eventName];
  if (!instance)
    throw new Error("vmodel: Instance not found");
  const internal = vue_cjs_prod.ref(instance.props[modelName] || propertyValue);
  for (const eventName2 of eventNames2)
    vue_cjs_prod.watch(internal, (_val) => {
      instance.emit(eventName2, internal.value);
    });
  vue_cjs_prod.watch(instance.props, () => {
    if (isPrimitive(instance.props[modelName]) ? instance.props[modelName] !== internal.value : !fastDeepEqual(instance.props[modelName], internal.value))
      internal.value = instance.props[modelName];
  });
  return internal;
}
var script$f = vue_cjs_prod.defineComponent({
  name: "MapboxMap",
  emits: MapEmits,
  props: {
    accessToken: {
      type: String,
      required: true
    },
    height: {
      type: String,
      default: "100%"
    },
    width: {
      type: String,
      default: "100%"
    },
    container: {
      type: [Object, String],
      default: ""
    },
    minZoom: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 22
    },
    minPitch: {
      type: Number,
      default: 0
    },
    maxPitch: {
      type: Number,
      default: 60
    },
    mapStyle: {
      type: [Object, String],
      default: "mapbox://styles/mapbox/streets-v11"
    },
    hash: {
      type: Boolean
    },
    interactive: {
      type: Boolean,
      default: true
    },
    bearingSnap: {
      type: Number
    },
    pitchWithRotate: {
      type: Boolean,
      default: true
    },
    clickTolerance: {
      type: Number
    },
    attributionControl: {
      type: Boolean,
      default: true
    },
    customAttribution: {
      type: Array
    },
    logoPosition: {
      type: String,
      default: "bottom-left"
    },
    failIfMajorPerformanceCaveat: {
      type: Boolean
    },
    preserveDrawingBuffer: {
      type: Boolean
    },
    antialias: {
      type: Boolean
    },
    refreshExpiredTiles: {
      type: Boolean
    },
    maxBounds: {
      type: [Array, Object]
    },
    scrollZoom: {
      type: [Boolean, Object],
      default: true
    },
    boxZoom: {
      type: Boolean
    },
    dragRotate: {
      type: Boolean,
      default: true
    },
    dragPan: {
      type: [Object, Boolean],
      default: true
    },
    keyboard: {
      type: Boolean
    },
    doubleClickZoom: {
      type: Boolean
    },
    touchZoomRotate: {
      type: [Boolean, Object],
      default: true
    },
    trackResize: {
      type: Boolean,
      default: true
    },
    center: {
      default: () => [0, 0]
    },
    zoom: {
      type: Number
    },
    bearing: {
      type: Number
    },
    pitch: {
      type: Number
    },
    bounds: {
      type: Array
    },
    fitBoundsOptions: {
      type: Object
    },
    renderWorldCopies: {
      type: Boolean,
      default: true
    },
    maxTileCacheSize: {
      type: Number,
      default: null
    },
    localIdeographFontFamily: {
      type: String,
      default: "sans-serif"
    },
    transformRequest: {
      type: Function,
      default: null
    },
    collectResourceTiming: {
      type: Boolean,
      default: false
    },
    fadeDuration: {
      type: Number,
      default: 300
    },
    crossSourceCollisions: {
      type: Boolean,
      default: true
    },
    zoomLogo: {
      type: Number,
      default: 1
    },
    flyToOptions: {
      default: () => ({})
    },
    autoResize: {
      type: Boolean,
      default: false
    },
    autoResizeDelay: {
      type: Number
    },
    cooperativeGestures: {
      type: Boolean,
      default: false
    },
    projection: {
      type: String
    }
  },
  setup: (props) => {
    const root2 = vue_cjs_prod.ref(null);
    const mapContainer = vue_cjs_prod.ref(null);
    const vmb_map = new _default();
    vue_cjs_prod.provide("vmb_map", vmb_map);
    const i_center = vmodel(props, "update:center", "center");
    const i_flyToOptions = vmodel(props, "update:flyToOptions", "flyToOptions");
    const style = vue_cjs_prod.ref(getStyle(props));
    vue_cjs_prod.watch(props, (p) => __awaiter(void 0, void 0, void 0, function* () {
      updateStyle(p, style);
    }));
    mapWatcher(vmb_map, props, { center: i_center, flyToOptions: i_flyToOptions });
    vue_cjs_prod.onMounted(() => __awaiter(void 0, void 0, void 0, function* () {
      const instance = vue_cjs_prod.getCurrentInstance();
      mapboxgl.accessToken = props.accessToken;
      mountMap(props, vmb_map, mapContainer, root2);
      if (instance)
        yield registerMapEvents(vmb_map, instance);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(void 0, void 0, void 0, function* () {
      const map2 = yield vmb_map.promise;
      map2.remove();
    }));
    return {
      vmb_map,
      root: root2,
      style,
      i_center,
      i_flyToOptions,
      mapContainer
    };
  }
});
const _hoisted_1$7 = { key: 1 };
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", {
    style: vue_cjs_prod.normalizeStyle(_ctx.style),
    ref: "root",
    class: "mapbox-map"
  }, [
    vue_cjs_prod.createElementVNode("div", null, [
      vue_cjs_prod.renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.vmb_map.isResolved ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", {
      key: 0,
      ref: "mapContainer",
      class: "map-container",
      style: vue_cjs_prod.normalizeStyle({ height: _ctx.height, width: _ctx.width })
    }, null, 4)) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$7, [
      vue_cjs_prod.renderSlot(_ctx.$slots, "loader", {}, () => [
        vue_cjs_prod.createElementVNode("div", {
          style: vue_cjs_prod.normalizeStyle(_ctx.style)
        }, null, 4)
      ])
    ]))
  ], 4);
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || true) {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z = "[data-v-55cc3ed8] .mapboxgl-ctrl-logo {\n  zoom: var(--zoom-logo);\n}";
styleInject(css_248z);
script$f.render = render$f;
script$f.__scopeId = "data-v-55cc3ed8";
var injectMap = {
  setup() {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    return { vmb_map };
  }
};
const parentIsMarker = (instance) => parentsNameIs(instance, "MapboxMarker");
const getMarkerOptions = (props) => filterObject(props, [
  "element",
  "offset",
  "anchor",
  "color",
  "draggable",
  "clickTolerance",
  "rotation",
  "rotationAlignment",
  "pitchAlignment",
  "scale"
]);
const MarkerGlEvents = ["drag", "dragend", "dragstart"];
const MarkerEmits = [...MarkerGlEvents, "update:lngLat", "click"];
const registerMarkerEvents = (marker, component) => {
  duplicateEvents(marker, component, MarkerGlEvents);
  marker.on("dragend", (evt) => component.emit("update:lngLat", evt.target._lngLat.toArray()));
  marker.getElement().addEventListener("click", (_ev) => component.emit("click", _ev));
};
const updateMarker = (props, vmb_marker) => __awaiter(void 0, void 0, void 0, function* () {
  const marker = yield vmb_marker.promise;
  const opts = filterObject(props);
  if (typeof opts.draggable === "boolean")
    marker.setDraggable(opts.draggable);
  if (opts.lngLat)
    marker.setLngLat(opts.lngLat);
  if (opts.offset)
    marker.setOffset(opts.offset);
  if (opts.rotation)
    marker.setRotation(opts.rotation);
  if (opts.pitchAlignment)
    marker.setPitchAlignment(opts.pitchAlignment);
  if (opts.rotationAlignment)
    marker.setRotationAlignment(opts.rotationAlignment);
});
const mountMarker = (options, vmb_map, vmb_marker, instance, lngLat, element) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  if (element && slotIsNotEmpty(element.value))
    options.element = element.value;
  const marker = new mapboxGl$1.exports.Marker(options).setLngLat(lngLat);
  marker.addTo(map2);
  vmb_marker.resolve(marker);
});
var script$e = vue_cjs_prod.defineComponent({
  name: "MapboxMarker",
  emits: MarkerEmits,
  props: {
    lngLat: {
      default: () => [0, 0]
    },
    offset: {
      type: [Array],
      default: () => [0, 0]
    },
    anchor: {
      type: String,
      default: () => "bottom"
    },
    color: {
      type: String,
      default: "#4668F2"
    },
    scale: {
      type: Number,
      default: 1
    },
    draggable: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    pitchAlignment: {
      type: String,
      default: "auto"
    },
    rotationAlignment: {
      type: String,
      default: "auto"
    }
  },
  setup(props) {
    const { vmb_map } = injectMap.setup();
    const vmb_marker = new _default$1();
    const icon = vue_cjs_prod.ref(null);
    const options = getMarkerOptions(props);
    vue_cjs_prod.provide("vmb_marker", vmb_marker);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      const instance = vue_cjs_prod.getCurrentInstance();
      if (instance && vmb_map) {
        yield mountMarker(options, vmb_map, vmb_marker, instance, props.lngLat, icon);
        const marker = yield vmb_marker.promise;
        registerMarkerEvents(marker, instance);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      const marker = yield vmb_marker.promise;
      marker.remove();
    }));
    vue_cjs_prod.watch(props, (p) => __awaiter(this, void 0, void 0, function* () {
      yield updateMarker(p, vmb_marker);
    }));
    return { icon };
  }
});
const _hoisted_1$6 = { ref: "icon" };
const _hoisted_2 = ["height", "width"];
const _hoisted_3 = { "fill-rule": "nonzero" };
const _hoisted_4 = /* @__PURE__ */ vue_cjs_prod.createStaticVNode('<g transform="translate(3.0, 29.0)" fill="#000000"><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="10.5" ry="5.25002273"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="10.5" ry="5.25002273"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="9.5" ry="4.77275007"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="8.5" ry="4.29549936"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="7.5" ry="3.81822308"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="6.5" ry="3.34094679"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="5.5" ry="2.86367051"></ellipse><ellipse opacity="0.04" cx="10.5" cy="5.80029008" rx="4.5" ry="2.38636864"></ellipse></g>', 1);
const _hoisted_5 = ["fill"];
const _hoisted_6 = /* @__PURE__ */ vue_cjs_prod.createElementVNode("path", { d: "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z" }, null, -1);
const _hoisted_7 = [
  _hoisted_6
];
const _hoisted_8 = /* @__PURE__ */ vue_cjs_prod.createStaticVNode('<g opacity="0.25" fill="#000000"><path d="M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"></path></g><g transform="translate(6.0, 7.0)" fill="#FFFFFF"></g><g transform="translate(8.0, 8.0)"><circle fill="#000000" opacity="0.25" cx="5.5" cy="5.5" r="5.4999962"></circle><circle fill="#FFFFFF" cx="5.5" cy="5.5" r="5.4999962"></circle></g>', 3);
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", null, [
    vue_cjs_prod.createElementVNode("div", _hoisted_1$6, [
      vue_cjs_prod.renderSlot(_ctx.$slots, "icon", {}, () => [
        (vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("svg", {
          display: "block",
          height: 42 * _ctx.scale + "px",
          width: 27 * _ctx.scale + "px",
          viewBox: "0 0 27 41"
        }, [
          vue_cjs_prod.createElementVNode("g", _hoisted_3, [
            _hoisted_4,
            vue_cjs_prod.createElementVNode("g", { fill: _ctx.color }, _hoisted_7, 8, _hoisted_5),
            _hoisted_8
          ])
        ], 8, _hoisted_2))
      ])
    ], 512),
    vue_cjs_prod.renderSlot(_ctx.$slots, "default")
  ]);
}
script$e.render = render$e;
const getNavigationControlOptions = (props) => {
  const { showCompass, showZoom, vizualizePitch } = props;
  return {
    showCompass,
    showZoom,
    vizualizePitch
  };
};
const mountNavigationControl = (nav, vmb_map, position) => (() => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  map2.addControl(nav, position);
}))();
var script$d = vue_cjs_prod.defineComponent({
  name: "MapboxNavigationControl",
  props: {
    showCompass: {
      type: Boolean,
      default: true
    },
    showZoom: {
      type: Boolean,
      default: true
    },
    visualizePitch: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: () => "top-right"
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const navOptions = getNavigationControlOptions(props);
    const vmb_navigationControl = new mapboxgl.NavigationControl(navOptions);
    const position = props.position;
    vue_cjs_prod.onMounted(() => {
      if (vmb_map)
        mountNavigationControl(vmb_navigationControl, vmb_map, position);
    });
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_navigationControl);
      }
    }));
  }
});
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$d.render = render$d;
const removeLayerIfPresent = (id, map2) => {
  const layer = map2.getLayer(id);
  if (layer)
    map2.removeLayer(id);
};
const removeSourceIfPresent = (id, map2) => {
  const source2 = map2.getSource(id);
  if (source2)
    map2.removeSource(id);
};
const parentIsGeogeometry = (instance) => parentNameContains(instance, "MapboxGeogeometry");
const distanceToLat = (km) => km / 110.574;
const distanceToLong = (km, lat) => km / (Math.cos(lat * Math.PI / 180) * 111.32);
const mountGeogeometry = (vmb_map, vmb_geogeometry) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  const geogeometry = vmb_geogeometry;
  removeLayerIfPresent(geogeometry.id, map2);
  removeSourceIfPresent(geogeometry.id, map2);
  map2.addSource(geogeometry.id, geogeometry.getGeoJSON());
});
const updateGeogeometry = (props, vmb_map, vmb_geogeometry) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  const geo = vmb_geogeometry;
  const opts = filterObject(props);
  const source2 = map2.getSource(geo.id);
  geo.updateOptions(opts);
  source2.setData(geo.getGeoJSON().data);
});
const attachToMarker = (instance, vmb_marker, popup) => __awaiter(void 0, void 0, void 0, function* () {
  if (vmb_marker) {
    const marker = yield vmb_marker.promise;
    marker.setPopup(popup);
  }
});
const attachToGeogeometry = (vmb_map, vmb_geo_paint, popup) => __awaiter(void 0, void 0, void 0, function* () {
  const paint = yield vmb_geo_paint.promise;
  const map2 = yield vmb_map.promise;
  if (paint.id) {
    const geo = yield paint.geogeometry.promise;
    map2.on("click", paint.id, (e) => {
      const coordinates2 = geo.center;
      popup.setLngLat(coordinates2).addTo(map2);
    });
  }
});
const getPopupOptions = (props) => filterObject(props, [
  "closeButton",
  "closeOnClick",
  "closeOnMove",
  "focusAfterOpen",
  "anchor",
  "offset",
  "className",
  "maxWidth"
]);
const mountPopup = (instance, vmb_map, vmb_popup, vmb_marker, vmb_geogeometry_paint, content) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  const popup = vmb_popup;
  if (content.value)
    popup.setDOMContent(content.value);
  if (parentIsMarker(instance))
    yield attachToMarker(instance, vmb_marker, popup);
  else if (parentIsGeogeometry(instance) && vmb_geogeometry_paint) {
    yield attachToGeogeometry(vmb_map, vmb_geogeometry_paint, popup);
  } else {
    popup.addTo(map2);
  }
});
const PopupGlEvents = ["close", "open"];
const PopupEmits = [...PopupGlEvents];
const registerPopupEvents = (vmb_popup, instance) => {
  duplicateEvents(vmb_popup, instance, PopupGlEvents);
};
const updatePopup = (props, vmb_popup) => __awaiter(void 0, void 0, void 0, function* () {
  const opts = getPopupOptions(props);
  if (opts.maxWidth)
    vmb_popup.setMaxWidth(opts.maxWidth);
  if (opts.offset)
    vmb_popup.setOffset(opts.offset);
  if (props.lngLat)
    vmb_popup.setLngLat(props.lngLat);
});
var script$c = vue_cjs_prod.defineComponent({
  name: "MapboxPopup",
  emits: PopupEmits,
  props: {
    lngLat: {
      type: [Object, Array],
      default: () => [0, 0]
    },
    closeButton: {
      type: Boolean,
      default: false
    },
    closeOnClick: {
      type: Boolean,
      default: true
    },
    closeOnMove: {
      type: Boolean,
      default: false
    },
    anchor: {
      type: String,
      default: void 0
    },
    offset: {
      type: [Number, Array],
      default: void 0
    },
    className: {
      type: String
    },
    focusAfterOpen: {
      type: Boolean,
      default: true
    },
    maxWidth: {
      type: String,
      default: "500px"
    },
    renderless: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const content = vue_cjs_prod.ref(null);
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_marker = vue_cjs_prod.inject("vmb_marker", null);
    const vmb_paint = vue_cjs_prod.inject("vmb_geogeometry_paint", null);
    const popupOptions = getPopupOptions(props);
    const vmb_popup = new mapboxgl.Popup(popupOptions).setLngLat(props.lngLat);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      const instance = vue_cjs_prod.getCurrentInstance();
      if (vmb_map && instance) {
        yield mountPopup(instance, vmb_map, vmb_popup, vmb_marker, vmb_paint, content);
        registerPopupEvents(vmb_popup, instance);
      }
    }));
    vue_cjs_prod.watch(props, (props2) => {
      updatePopup(props2, vmb_popup);
    });
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      vmb_popup.remove();
    }));
    return { content };
  }
});
const _hoisted_1$5 = { ref: "content" };
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$5, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default")
  ], 512);
}
script$c.render = render$c;
const getAttributionControlOptions = (props) => filterObject(props);
const mountAttributionControl = (vmb_map, vmb_attributionControl) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  map2.addControl(vmb_attributionControl);
});
var script$b = vue_cjs_prod.defineComponent({
  name: "MapboxAttributionControl",
  props: {
    compact: {
      type: Boolean,
      default: false
    },
    customAttribution: {
      type: [String, Array],
      default: void 0
    }
  },
  setup(props) {
    const opts = getAttributionControlOptions(props);
    const vmb_attributionControl = new mapboxgl.AttributionControl(opts);
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map)
        mountAttributionControl(vmb_map, vmb_attributionControl);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_attributionControl);
      }
    }));
  }
});
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$b.render = render$b;
const getScaleControlOptions = (props) => {
  const { maxWidth, unit } = props;
  return {
    maxWidth,
    unit
  };
};
const mountScaleControl = (vmb_map, vmb_scaleControl) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  map2.addControl(vmb_scaleControl);
});
var script$a = vue_cjs_prod.defineComponent({
  name: "MapboxScaleControl",
  props: {
    maxWidth: {
      type: Number,
      default: 100
    },
    unit: {
      type: String,
      default: "metric"
    }
  },
  setup(props) {
    const options = getScaleControlOptions(props);
    const vmb_scaleControl = new mapboxgl.ScaleControl(options);
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map)
        yield mountScaleControl(vmb_map, vmb_scaleControl);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_scaleControl);
      }
    }));
  }
});
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$a.render = render$a;
const getFullscreenControlOptions = (props) => filterObject(props);
const mountFullscreenControl = (vmb_fullscreenControl, vmb_map) => __awaiter(void 0, void 0, void 0, function* () {
  const map2 = yield vmb_map.promise;
  map2.addControl(vmb_fullscreenControl);
});
var script$9 = vue_cjs_prod.defineComponent({
  name: "MapboxFullscreenControl",
  props: {
    container: {
      type: Object,
      default: void 0
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const options = getFullscreenControlOptions(props);
    const vmb_fullscreenControl = new mapboxgl.FullscreenControl(options);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map)
        yield mountFullscreenControl(vmb_fullscreenControl, vmb_map);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_fullscreenControl);
      }
    }));
  }
});
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$9.render = render$9;
const getDrawControlOptions = (props) => filterObject(props, ["position"]);
const mapDrawEvents = (vmb_map, component) => {
  vmb_map.on("draw.create", (e) => {
    component.emit("create", e);
  });
  vmb_map.on("draw.update", (e) => {
    component.emit("update", e);
  });
  vmb_map.on("draw.delete", (e) => {
    component.emit("delete", e);
  });
  vmb_map.on("draw.selectionchange", (e) => {
    component.emit("selectionchange", e);
  });
};
const mountDrawControl = (vmb_map, vmb_drawControl, opts, component) => __awaiter(void 0, void 0, void 0, function* () {
  component.emit("loaded", vmb_drawControl);
  const map2 = yield vmb_map.promise;
  mapDrawEvents(map2, component);
  map2.addControl(vmb_drawControl, opts.position);
});
var script$8 = vue_cjs_prod.defineComponent({
  name: "MapboxDrawControl",
  props: {
    position: {
      type: String,
      default: "top-left"
    }
  },
  setup(props) {
    const opts = getDrawControlOptions(props);
    const vmb_drawControl = new MapboxDrawControl();
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      const component = vue_cjs_prod.getCurrentInstance();
      if (vmb_map && component)
        mountDrawControl(vmb_map, vmb_drawControl, opts, component);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_drawControl);
      }
    }));
  }
});
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$8.render = render$8;
var script$7 = vue_cjs_prod.defineComponent({
  name: "MapboxSourceGeoJson",
  props: {
    container: {
      type: Object,
      default: void 0
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    new mapboxGl$1.exports.GeoJSONSource();
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.addSource;
      }
    }));
  }
});
const _hoisted_1$4 = { ref: "features" };
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$4, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default")
  ], 512);
}
script$7.render = render$7;
const getGeolocationControlOptions = (props) => filterObject(props);
var script$6 = vue_cjs_prod.defineComponent({
  name: "MapboxGeolocateControl",
  props: {
    positionOptions: {
      type: Object,
      default: () => ({ enableHighAccuracy: false, timeout: 6e3 })
    },
    fitBoundsOptions: {
      type: Object,
      default: () => ({ maxZoom: 15 })
    },
    trackUserLocation: {
      type: Boolean,
      default: false
    },
    showAccuracyCircle: {
      type: Boolean,
      default: true
    },
    showUserLocation: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const options = getGeolocationControlOptions(props);
    const vmb_geolocationControl = new mapboxgl.GeolocateControl(options);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.addControl(vmb_geolocationControl);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeControl(vmb_geolocationControl);
      }
    }));
  }
});
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script$6.render = render$6;
class Geogeometry {
  constructor(input) {
    this.id = input.id;
    this.fillColor = input.fillColor || "#4668F2";
    this.antialias = typeof input.antialias === "boolean" ? input.antialias : true;
    this.opacity = typeof input.opacity === "number" ? input.opacity : 0.6;
    if (input.outlineColor)
      this.outlineColor = input.outlineColor;
    this.deferred = new _default$1();
    vue_cjs_prod.provide("vmb_geogeometry", this.deferred);
  }
  updateOptions(input) {
    if (input.fillColor)
      this.fillColor = input.fillColor;
    if (typeof input.antialias === "boolean")
      this.antialias = input.antialias;
    if (typeof input.opacity === "number")
      this.opacity = input.opacity;
    if (input.outlineColor)
      this.outlineColor = input.outlineColor;
  }
  getPaint() {
    const paint = {};
    if (this.fillColor)
      paint["fill-color"] = this.fillColor;
    if (this.antialias)
      paint["fill-antialias"] = this.antialias;
    if (this.opacity)
      paint["fill-opacity"] = this.opacity;
    if (this.outlineColor)
      paint["fill-outline-color"] = this.outlineColor;
    return paint;
  }
  getLayer() {
    return {
      "id": this.id,
      "type": "fill",
      "source": this.id,
      "layout": {},
      "paint": this.getPaint()
    };
  }
}
class Circle extends Geogeometry {
  constructor(input) {
    super(input);
    this.edges = input.edges || 10;
    this.radius = input.radius;
    this.center = input.center;
  }
  updateOptions(input) {
    super.updateOptions(input);
    if (input.edges)
      this.edges = input.edges;
    if (input.radius)
      this.radius = input.radius;
    if (input.center)
      this.center = input.center;
  }
  getGeoJSON() {
    const points = this.edges;
    const long = distanceToLong(this.radius, this.center[1]);
    const lat = distanceToLat(this.radius);
    const path2 = [];
    for (let i = 0; i < points; i++) {
      const theta = i / points * (2 * Math.PI);
      const x = long * Math.cos(theta);
      const y = lat * Math.sin(theta);
      path2.push([this.center[0] + x, this.center[1] + y]);
    }
    path2.push(path2[0]);
    return {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [path2]
          },
          properties: {}
        }]
      }
    };
  }
}
class GeogeometryPaint {
  constructor(input) {
    this.geogeometry = input.geogeometry;
    this.deferred = new _default$1();
    vue_cjs_prod.provide("vmb_geogeometry_paint", this.deferred);
  }
  _init(paintType, id) {
    return __awaiter(this, void 0, void 0, function* () {
      const geogeometry = yield this.geogeometry.promise;
      this.geoId = geogeometry.id;
      this.id = `${this.geoId}-${paintType}-${id}`;
    });
  }
  setGeoId(id) {
    this.geoId = id;
  }
}
let fillsAdded = 0;
class GeogeometryFill extends GeogeometryPaint {
  constructor(input) {
    super(input);
    this.geoId = input.geoId;
    this.id = `${input.geoId}-fill-${fillsAdded++}`;
    this.color = input.color || "#4668F2";
    this.antialias = typeof input.antialias === "boolean" ? input.antialias : true;
    this.opacity = typeof input.opacity === "number" ? input.opacity : 0.6;
    if (input.outlineColor)
      this.outlineColor = input.outlineColor;
  }
  init() {
    const _super = Object.create(null, {
      _init: { get: () => super._init }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super._init.call(this, "fill", fillsAdded++);
    });
  }
  getPaint() {
    const paint = {};
    if (this.color)
      paint["fill-color"] = this.color;
    if (this.antialias)
      paint["fill-antialias"] = this.antialias;
    if (this.opacity)
      paint["fill-opacity"] = this.opacity;
    if (this.outlineColor)
      paint["fill-outline-color"] = this.outlineColor;
    return paint;
  }
  update(props, vmb_map) {
    return __awaiter(this, void 0, void 0, function* () {
      const map2 = yield vmb_map.promise;
      const opts = filterObject(props);
      if (this.id) {
        if (opts.color && opts.color !== this.color) {
          map2.setPaintProperty(this.id, "fill-color", opts.color);
          this.color = opts.color;
        }
        if (typeof opts.antialias === "boolean" && opts.antialias !== this.antialias) {
          map2.setPaintProperty(this.id, "fill-antialias", opts.antialias);
          this.antialias = opts.antialias;
        }
        if (typeof opts.opacity === "number" && opts.opacity !== this.opacity) {
          map2.setPaintProperty(this.id, "fill-opacity", opts.opacity);
          this.opacity = opts.opacity;
        }
        if (opts.outlineColor && opts.outlineColor !== this.outlineColor) {
          map2.setPaintProperty(this.id, "fill-outline-color", opts.outlineColor);
          this.outlineColor = opts.outlineColor;
        }
      }
    });
  }
  getLayer() {
    if (this.id) {
      return {
        id: this.id,
        type: "fill",
        source: this.geoId,
        layout: {},
        paint: this.getPaint()
      };
    } else {
      throw new Error("Geogeometry.Paint.Fill: Cannot get layer. Not initialized");
    }
  }
}
var script$5 = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryFill",
  props: {
    color: {
      type: String,
      default: "#4668F2"
    },
    antialias: {
      type: Boolean,
      default: true
    },
    opacity: {
      type: Number,
      default: 0.6
    },
    outlineColor: {
      type: String
    }
  },
  setup(props) {
    const vmb_geogeometry = vue_cjs_prod.inject("vmb_geogeometry", null);
    const vmb_fill = new _default$1();
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    if (!vmb_geogeometry)
      throw new Error("MapboxGeogeometryFill: no geogeometry found as parent");
    const fill2 = new GeogeometryFill(Object.assign(Object.assign({}, filterObject(props)), { geogeometry: vmb_geogeometry }));
    vue_cjs_prod.provide("vmb_fill", vmb_fill);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map && vmb_geogeometry) {
        const map2 = yield vmb_map.promise;
        const geogeometry = yield vmb_geogeometry.promise;
        if (geogeometry && map2) {
          yield fill2.init();
          map2.addLayer(fill2.getLayer());
          vmb_fill.resolve(fill2);
          fill2.deferred.resolve(fill2);
        }
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      const fill3 = yield vmb_fill.promise;
      if (fill3 && vmb_map)
        fill3.update(props, vmb_map);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map && fill2.id) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(fill2.id);
      }
    }));
    return {};
  }
});
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", null, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default")
  ]);
}
script$5.render = render$5;
let circlesAdded = 0;
var script$4 = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryCircle",
  components: {
    MapboxGeogeometryFill: script$5
  },
  props: {
    id: {
      type: String,
      default: "circle"
    },
    center: {
      type: Array,
      required: true
    },
    radius: {
      type: Number,
      required: true
    },
    edges: {
      type: Number,
      default: 10
    },
    fillColor: {
      type: String
    },
    outlineColor: {
      type: String
    },
    opacity: {
      type: Number
    },
    antialias: {
      type: Boolean
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_circle = new _default();
    const id = `${props.id}-${circlesAdded++}`;
    const circle = new Circle(filterObject(Object.assign(Object.assign({}, props), { id }), [
      "id",
      "radius",
      "center",
      "edges",
      "fillColor",
      "outlineColor",
      "opacity",
      "antialias"
    ]));
    vue_cjs_prod.provide("vmb_circle", vmb_circle);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield mountGeogeometry(vmb_map, circle);
        vmb_circle.resolve(circle);
        circle.deferred.resolve(circle);
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield updateGeogeometry(props, vmb_map, circle);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(circle.id);
      }
    }));
  }
});
const _hoisted_1$3 = { ref: "features" };
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_mapbox_geogeometry_fill = vue_cjs_prod.resolveComponent("mapbox-geogeometry-fill");
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$3, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, () => [
      vue_cjs_prod.createVNode(_component_mapbox_geogeometry_fill, {
        color: _ctx.fillColor,
        outlineColor: _ctx.outlineColor,
        opacity: _ctx.opacity,
        antialias: _ctx.antialias
      }, {
        default: vue_cjs_prod.withCtx(() => [
          vue_cjs_prod.renderSlot(_ctx.$slots, "popup")
        ]),
        _: 3
      }, 8, ["color", "outlineColor", "opacity", "antialias"])
    ])
  ], 512);
}
script$4.render = render$4;
class Polygon extends Geogeometry {
  constructor(input) {
    super(input);
    this.path = input.path;
  }
  updateOptions(input) {
    super.updateOptions(input);
    if (input.path)
      this.path = input.path;
  }
  get center() {
    const sum = this.path.reduce((acc, c) => [acc[0] + c[0], acc[1] + c[1]]);
    return [sum[0] / this.path.length, sum[1] / this.path.length];
  }
  getGeoJSON() {
    return {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [this.path]
          },
          properties: {}
        }]
      }
    };
  }
}
let polygonsAdded = 0;
var script$3 = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryPolygon",
  components: {
    MapboxGeogeometryFill: script$5
  },
  props: {
    id: {
      type: String,
      default: "polygon"
    },
    path: {
      type: Array,
      required: true
    },
    fillColor: {
      type: String
    },
    outlineColor: {
      type: String
    },
    opacity: {
      type: Number
    },
    antialias: {
      type: Boolean
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_polygon = new _default();
    const id = `${props.id}-${polygonsAdded++}`;
    const polygon = new Polygon(filterObject(Object.assign(Object.assign({}, props), { id }), [
      "id",
      "path",
      "fillColor",
      "outlineColor",
      "opacity",
      "antialias"
    ]));
    vue_cjs_prod.provide("vmb_polygon", vmb_polygon);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield mountGeogeometry(vmb_map, polygon);
        vmb_polygon.resolve(polygon);
        polygon.deferred.resolve(polygon);
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        polygon.updateOptions(props);
        yield updateGeogeometry(props, vmb_map, polygon);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(polygon.id);
      }
    }));
  }
});
const _hoisted_1$2 = { ref: "features" };
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_mapbox_geogeometry_fill = vue_cjs_prod.resolveComponent("mapbox-geogeometry-fill");
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$2, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, () => [
      vue_cjs_prod.createVNode(_component_mapbox_geogeometry_fill, {
        color: _ctx.fillColor,
        outlineColor: _ctx.outlineColor,
        opacity: _ctx.opacity,
        antialias: _ctx.antialias
      }, {
        default: vue_cjs_prod.withCtx(() => [
          vue_cjs_prod.renderSlot(_ctx.$slots, "popup")
        ]),
        _: 3
      }, 8, ["color", "outlineColor", "opacity", "antialias"])
    ])
  ], 512);
}
script$3.render = render$3;
const rotateRectangle = (coords, angleDeg) => {
  if (coords.length !== 4)
    throw "MapboxGeogeometryRectangle.rotateRectagle: Not a rectangle. Please supply exactly four coordinates";
  const angleRad = angleDeg * Math.PI / 180;
  const rotatedCoords = [];
  for (let i = 0; i < coords.length; i++) {
    rotatedCoords.push([
      coords[i][0] * Math.cos(angleRad) - coords[i][1] * Math.sin(angleRad),
      coords[i][0] * Math.sin(angleRad) + coords[i][1] * Math.cos(angleRad)
    ]);
  }
  return rotatedCoords;
};
class Rectangle extends Geogeometry {
  constructor(input) {
    super(input);
    this.width = input.width;
    this.height = input.height;
    this.center = input.center;
    this.rotationDeg = input.rotationDeg || 0;
  }
  updateOptions(input) {
    super.updateOptions(input);
    if (input.width)
      this.width = input.width;
    if (input.height)
      this.height = input.height;
    if (typeof input.rotationDeg === "number" && input.rotationDeg !== this.rotationDeg)
      this.rotationDeg = input.rotationDeg;
  }
  get coordinates() {
    const xy = rotateRectangle([
      [this.width / 2, this.height / 2],
      [-this.width / 2, this.height / 2],
      [-this.width / 2, -this.height / 2],
      [this.width / 2, -this.height / 2]
    ], this.rotationDeg);
    const coords = [
      [this.center[0] + distanceToLong(xy[0][0], this.center[1]), this.center[1] + distanceToLat(xy[0][1])],
      [this.center[0] + distanceToLong(xy[1][0], this.center[1]), this.center[1] + distanceToLat(xy[1][1])],
      [this.center[0] + distanceToLong(xy[2][0], this.center[1]), this.center[1] + distanceToLat(xy[2][1])],
      [this.center[0] + distanceToLong(xy[3][0], this.center[1]), this.center[1] + distanceToLat(xy[3][1])]
    ];
    return coords;
  }
  getGeoJSON() {
    const path2 = [
      ...this.coordinates,
      this.coordinates[0]
    ];
    return {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [path2]
          },
          properties: {}
        }]
      }
    };
  }
}
let rectanglesAdded = 0;
var script$2 = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryRectangle",
  components: {
    MapboxGeogeometryFill: script$5
  },
  props: {
    id: {
      type: String,
      default: "rectangle"
    },
    center: {
      type: Array,
      required: true
    },
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    fillColor: {
      type: String
    },
    outlineColor: {
      type: String
    },
    opacity: {
      type: Number,
      default: 0.6
    },
    antialias: {
      type: Boolean,
      default: true
    },
    rotationDeg: {
      type: Number
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_rectangle = new _default();
    const id = `${props.id}-${rectanglesAdded++}`;
    const rectangle = new Rectangle(filterObject(Object.assign(Object.assign({}, props), { id }), [
      "id",
      "width",
      "height",
      "center",
      "fillColor",
      "outlineColor",
      "opacity",
      "antialias",
      "rotationDeg"
    ]));
    vue_cjs_prod.provide("vmb_rectangle", vmb_rectangle);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield mountGeogeometry(vmb_map, rectangle);
        vmb_rectangle.resolve(rectangle);
        rectangle.deferred.resolve(rectangle);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(rectangle.id);
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield updateGeogeometry(props, vmb_map, rectangle);
      }
    }));
  }
});
const _hoisted_1$1 = { ref: "features" };
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_mapbox_geogeometry_fill = vue_cjs_prod.resolveComponent("mapbox-geogeometry-fill");
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1$1, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, () => [
      vue_cjs_prod.createVNode(_component_mapbox_geogeometry_fill, {
        color: _ctx.fillColor,
        outlineColor: _ctx.outlineColor,
        opacity: _ctx.opacity,
        antialias: _ctx.antialias
      }, {
        default: vue_cjs_prod.withCtx(() => [
          vue_cjs_prod.renderSlot(_ctx.$slots, "popup")
        ]),
        _: 3
      }, 8, ["color", "outlineColor", "opacity", "antialias"])
    ])
  ], 512);
}
script$2.render = render$2;
const pathIsClosed = (pos) => {
  if (pos.length <= 1)
    return false;
  else {
    return pos[0][0] === pos[pos.length - 1][0] && pos[0][1] === pos[pos.length - 1][1];
  }
};
const inputIsPath = (potentialPath) => {
  if (potentialPath.length === 0)
    return true;
  if (potentialPath[0].length === 2 && typeof potentialPath[0][0] === "number" && typeof potentialPath[0][1] === "number")
    return true;
  return false;
};
const getCenterForCoordinates = (input, inputVisited = 0, inputCenter = [0, 0]) => {
  let visited = inputVisited;
  const center = [inputCenter[0], inputCenter[1]];
  if (inputIsPath(input)) {
    if (pathIsClosed(input))
      input.pop();
    for (const pos of input) {
      center[0] = (pos[0] + center[0] * visited) / (visited + 1);
      center[1] = (pos[1] + center[1] * visited) / (visited + 1);
      visited++;
    }
  } else {
    for (const pos of input) {
      const { visited: visitedLocal, center: centerLoacl } = getCenterForCoordinates(pos);
      center[0] = (center[0] * visited + centerLoacl[0] * visitedLocal) / (visitedLocal + visited);
      center[1] = (center[1] * visited + centerLoacl[1] * visitedLocal) / (visitedLocal + visited);
      visited += visitedLocal;
    }
  }
  return {
    visited,
    center
  };
};
const getCenterForFeature = (feature, inputVisited = 0, inputCenter = [0, 0]) => {
  let visited = inputVisited;
  const center = [inputCenter[0], inputCenter[1]];
  switch (feature.geometry.type) {
    case "Polygon":
    case "LineString": {
      const { center: centerLocal, visited: visitedLocal } = getCenterForCoordinates(feature.geometry.coordinates);
      center[0] = (center[0] * visited + centerLocal[0] * visitedLocal) / (visitedLocal + visited);
      center[1] = (center[1] * visited + centerLocal[1] * visitedLocal) / (visitedLocal + visited);
      visited += visitedLocal;
      break;
    }
  }
  return { visited, center };
};
const getCenterForFeatureCollection = (featureCollection, inputVisited = 0, inputCenter = [0, 0]) => {
  let visited = inputVisited;
  const center = [inputCenter[0], inputCenter[1]];
  for (const feature of featureCollection.features) {
    const { center: centerLocal, visited: visitedLocal } = getCenterForFeature(feature);
    center[0] = (center[0] * visited + centerLocal[0] * visitedLocal) / (visitedLocal + visited);
    center[1] = (center[1] * visited + centerLocal[1] * visitedLocal) / (visitedLocal + visited);
    visited += visitedLocal;
    break;
  }
  return { visited, center };
};
class Raw extends Geogeometry {
  constructor(input) {
    super(input);
    this.source = input.source;
  }
  updateOptions(input) {
    super.updateOptions(input);
    if (input.source)
      this.source = input.source;
  }
  get center() {
    const data = this.getGeoJSONData();
    if (!data || !data.type) {
      console.warn("Geogeometry Raw: Could not get center. Coordinates could not be obtained");
      return [0, 0];
    }
    if (data.type === "Feature") {
      return getCenterForFeature(data).center;
    }
    if (data.type === "FeatureCollection") {
      return getCenterForFeatureCollection(data).center;
    }
    throw new Error("Geogeometry Raw: Unknown Error getting Center");
  }
  getGeoJSON() {
    if (this.source.type === "geojson")
      return this.source;
    else {
      return {
        type: "geojson",
        data: this.source
      };
    }
  }
  getGeoJSONData() {
    return this.getGeoJSON().data;
  }
}
let rawDataAdded = 0;
var script$1 = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryRaw",
  components: {
    MapboxGeogeometryFill: script$5
  },
  props: {
    source: {
      type: Object,
      required: true
    },
    id: {
      type: String,
      default: "raw"
    },
    fillColor: {
      type: String,
      default: "red"
    },
    outlineColor: {
      type: String
    },
    opacity: {
      type: Number
    },
    antialias: {
      type: Boolean
    }
  },
  setup(props) {
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    const vmb_raw = new _default$1();
    const id = `${props.id}-${rawDataAdded++}`;
    const raw = new Raw(filterObject(Object.assign(Object.assign({}, props), { id }), [
      "source",
      "id",
      "fillColor",
      "outlineColor",
      "opacity",
      "antialias"
    ]));
    vue_cjs_prod.provide("vmb_raw", vmb_raw);
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        yield mountGeogeometry(vmb_map, raw);
        vmb_raw.resolve(raw);
        raw.deferred.resolve(raw);
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        raw.updateOptions(props);
        yield updateGeogeometry(props, vmb_map, raw);
      }
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(raw.id);
      }
    }));
  }
});
const _hoisted_1 = { ref: "features" };
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  vue_cjs_prod.resolveComponent("mapbox-geogeometry-fill");
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div", _hoisted_1, [
    vue_cjs_prod.renderSlot(_ctx.$slots, "default", {}, () => [
      vue_cjs_prod.createCommentVNode("", true)
    ])
  ], 512);
}
script$1.render = render$1;
let linesAdded = 0;
class GeogeometryLine extends GeogeometryPaint {
  constructor(input) {
    super(input);
    this.color = input.color || "#000";
    this.opacity = typeof input.opacity === "number" ? input.opacity : 0.6;
    if (input.geoId) {
      this.geoId = input.geoId;
    }
    if (typeof input.blur === "number")
      this.blur = input.blur;
    if (input.cap)
      this.cap = input.cap;
    if (input.join)
      this.join = input.join;
    if (typeof input.width === "number")
      this.width = input.width;
    if (input.translate)
      this.translate = input.translate;
    if (typeof input.offset === "number")
      this.offset = input.offset;
    if (input.dasharray)
      this.dasharray = input.dasharray;
    if (typeof input.gapWidth === "number")
      this.gapWidth = input.gapWidth;
    if (input.gradient)
      this.gradient = input.gradient;
    if (typeof input.miterLimit === "number")
      this.miterLimit = input.miterLimit;
    if (typeof input.roundLimit === "number")
      this.roundLimit = input.roundLimit;
    if (typeof input.sortKey === "number")
      this.sortKey = input.sortKey;
    if (input.translateAnchor)
      this.translateAnchor = input.translateAnchor;
  }
  getPaint() {
    const paintRaw = {
      "line-blur": this.blur,
      "line-opacity": this.opacity,
      "line-color": this.color,
      "line-width": this.width,
      "line-translate": this.translate,
      "line-offset": this.offset,
      "line-dasharray": this.dasharray,
      "line-gap-width": this.gapWidth,
      "line-translate-anchor": this.translateAnchor
    };
    const paint = filterObject(paintRaw);
    console.log(paint);
    return paint;
  }
  getLayout() {
    const layoutRaw = {
      "line-cap": this.cap,
      "line-join": this.join,
      "line-miter-limit": this.miterLimit,
      "line-round-limit": this.roundLimit,
      "line-sort-key": this.sortKey
    };
    const layout = filterObject(layoutRaw);
    console.log(layout);
    return layout;
  }
  init() {
    super._init("line", linesAdded++);
    return this;
  }
  update(props, vmb_map) {
    return __awaiter(this, void 0, void 0, function* () {
      const map2 = yield vmb_map.promise;
      const opts = filterObject(props);
      if (this.id) {
        if (opts.color && opts.color !== this.color) {
          map2.setPaintProperty(this.id, "line-color", opts.color);
          this.color = opts.color;
        }
        if (typeof opts.blur === "number" && opts.blur !== this.blur) {
          map2.setPaintProperty(this.id, "line-blur", opts.blur);
          this.blur = opts.blur;
        }
        if (opts.cap && opts.cap !== this.cap) {
          map2.setPaintProperty(this.id, "line-cap", opts.cap);
          this.cap = opts.cap;
        }
        if (opts.join && opts.join !== this.join) {
          map2.setPaintProperty(this.id, "line-join", opts.join);
          this.join = opts.join;
        }
        if (typeof opts.opacity === "number" && opts.opacity !== this.opacity) {
          map2.setPaintProperty(this.id, "line-opacity", opts.opacity);
          this.opacity = opts.opacity;
        }
        if (typeof opts.width === "number" && opts.width !== this.width) {
          map2.setPaintProperty(this.id, "line-width", opts.width);
          this.width = opts.width;
        }
        if (opts.translate && this.translate && (opts.translate[0] !== this.translate[0] || opts.translate[1] !== this.translate[1])) {
          map2.setPaintProperty(this.id, "line-translate", opts.translate);
          this.translate = opts.translate;
        }
        if (typeof opts.offset === "number" && this.offset !== opts.offset) {
          map2.setPaintProperty(this.id, "line-offset", opts.offset);
          this.offset = opts.offset;
        }
        if (opts.dasharray && !fastDeepEqual(this.dasharray, opts.dasharray)) {
          map2.setPaintProperty(this.id, "line-dasharray", opts.dasharray);
          this.dasharray = opts.dasharray;
        }
        if (typeof opts.gapWidth === "number" && this.gapWidth !== opts.gapWidth) {
          map2.setPaintProperty(this.id, "line-gap-width", opts.gapWidth);
          this.gapWidth = opts.gapWidth;
        }
        if (typeof opts.miterLimit === "number" && this.miterLimit !== opts.miterLimit) {
          map2.setPaintProperty(this.id, "line-miter-limit", opts.miterLimit);
          this.miterLimit = opts.miterLimit;
        }
        if (typeof opts.roundLimit === "number" && this.roundLimit !== opts.roundLimit) {
          map2.setPaintProperty(this.id, "line-round-limit", opts.roundLimit);
          this.roundLimit = opts.roundLimit;
        }
        if (typeof opts.sortKey === "number") {
          map2.setPaintProperty(this.id, "line-sort-key", opts.sortKey);
          this.sortKey = opts.sortKey;
        }
        if (opts.translateAnchor && this.translateAnchor !== opts.translateAnchor) {
          map2.setPaintProperty(this.id, "line-translate-anchor", opts.translateAnchor);
          this.translateAnchor = opts.translateAnchor;
        }
      }
    });
  }
  getLayer() {
    if (this.id) {
      return {
        id: this.id,
        type: "line",
        source: this.geoId,
        layout: this.getLayout(),
        paint: this.getPaint()
      };
    } else {
      throw new Error("Geogeometry.Paint.Line: Cannot get Layer. Not initialized");
    }
  }
}
var script = vue_cjs_prod.defineComponent({
  name: "MapboxGeogeometryLine",
  props: {
    blur: {
      type: Number
    },
    cap: {
      type: String
    },
    join: {
      type: String
    },
    opacity: {
      type: Number,
      default: 1
    },
    color: {
      type: String,
      default: "#4668F2"
    },
    width: {
      type: Number
    },
    translate: {
      type: Array
    },
    offset: {
      type: Number
    },
    dasharray: {
      type: Array
    },
    gapWidth: {
      type: Number
    }
  },
  setup(props) {
    const vmb_geogeometry = vue_cjs_prod.inject("vmb_geogeometry", null);
    const vmb_line = new _default$1();
    const vmb_map = vue_cjs_prod.inject("vmb_map", null);
    vue_cjs_prod.provide("vmb_paint", vmb_line);
    if (!vmb_geogeometry)
      throw new Error("MapboxGeogeometryLine: no geogeometry found as parent");
    const line = new GeogeometryLine(Object.assign(Object.assign({}, filterObject(props)), { geogeometry: vmb_geogeometry }));
    vue_cjs_prod.onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map && vmb_geogeometry) {
        yield line.init();
        const map2 = yield vmb_map.promise;
        const geogeometry = yield vmb_geogeometry.promise;
        if (geogeometry && map2) {
          map2.addLayer(line.getLayer());
          vmb_line.resolve(line);
        }
      }
    }));
    vue_cjs_prod.watch(props, () => __awaiter(this, void 0, void 0, function* () {
      const line2 = yield vmb_line.promise;
      if (line2 && vmb_map)
        line2.update(props, vmb_map);
    }));
    vue_cjs_prod.onUnmounted(() => __awaiter(this, void 0, void 0, function* () {
      if (vmb_map && line.id) {
        const map2 = yield vmb_map.promise;
        map2.removeLayer(line.id);
      }
    }));
    return {};
  }
});
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue_cjs_prod.openBlock(), vue_cjs_prod.createElementBlock("div");
}
script.render = render;
var components = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MapboxGeocoderControl: script$g,
  MapboxMap: script$f,
  MapboxMarker: script$e,
  MapboxNavigationControl: script$d,
  MapboxPopup: script$c,
  MapboxAttributionControl: script$b,
  MapboxScaleControl: script$a,
  MapboxFullscreenControl: script$9,
  MapboxDrawControl: script$8,
  MapboxSourceGeoJson: script$7,
  MapboxGeolocateControl: script$6,
  MapboxGeogeometryCircle: script$4,
  MapboxGeogeometryPolygon: script$3,
  MapboxGeogeometryRectangle: script$2,
  MapboxGeogeometryRaw: script$1,
  MapboxGeogeometryFill: script$5,
  MapboxGeogeometryLine: script
});
var install = (instance) => {
  Object.keys(components).forEach((name) => {
    instance.component(name, components[name]);
  });
};
const _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47vue_45mapbox_46js = defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(install);
});
const _plugins = [
  preload,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47_46nuxt_47components_46plugin_46mjs,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47head_47runtime_47lib_47vueuse_45head_46plugin,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47head_47runtime_47plugin,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47node_modules_47nuxt_47dist_47pages_47runtime_47router,
  PiniaNuxtPlugin,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47fontawesome_46js,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47vue_45mapbox_46js,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47fontawesome_46js,
  _47Users_47jcm_47Local_32Documents_47GitHub_47wheretheystand_45client_47wts_45client_47plugins_47vue_45mapbox_46js
];
const _sfc_main$s = {
  __name: "error-404",
  __ssrInlineRender: true,
  props: {
    appName: {
      type: String,
      default: "Nuxt"
    },
    version: {
      type: String,
      default: ""
    },
    statusCode: {
      type: String,
      default: "404"
    },
    statusMessage: {
      type: String,
      default: "Not Found"
    },
    description: {
      type: String,
      default: "Sorry, the page you are looking for could not be found."
    },
    backHome: {
      type: String,
      default: "Go back home"
    }
  },
  setup(__props) {
    const props = __props;
    useHead({
      title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
      script: [],
      style: [
        {
          children: `*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}a{color:inherit;text-decoration:inherit}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}`
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_1$7;
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden" }, _attrs))} data-v-011aae6d><div class="fixed left-0 right-0 spotlight z-10" data-v-011aae6d></div><div class="max-w-520px text-center z-20" data-v-011aae6d><h1 class="text-8xl sm:text-10xl font-medium mb-8" data-v-011aae6d>${serverRenderer.exports.ssrInterpolate(__props.statusCode)}</h1><p class="text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight" data-v-011aae6d>${serverRenderer.exports.ssrInterpolate(__props.description)}</p><div class="w-full flex items-center justify-center" data-v-011aae6d>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
        to: "/",
        class: "gradient-border text-md sm:text-xl py-2 px-4 sm:py-3 sm:px-6 cursor-pointer"
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${serverRenderer.exports.ssrInterpolate(__props.backHome)}`);
          } else {
            return [
              vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(__props.backHome), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div>`);
    };
  }
};
const _sfc_setup$s = _sfc_main$s.setup;
_sfc_main$s.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("node_modules/@nuxt/ui-templates/dist/templates/error-404.vue");
  return _sfc_setup$s ? _sfc_setup$s(props, ctx) : void 0;
};
const Error404 = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-011aae6d"]]);
const _sfc_main$r = {
  __name: "error-500",
  __ssrInlineRender: true,
  props: {
    appName: {
      type: String,
      default: "Nuxt"
    },
    version: {
      type: String,
      default: ""
    },
    statusCode: {
      type: String,
      default: "500"
    },
    statusMessage: {
      type: String,
      default: "Server error"
    },
    description: {
      type: String,
      default: "This page is temporarily unavailable."
    }
  },
  setup(__props) {
    const props = __props;
    useHead({
      title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
      script: [],
      style: [
        {
          children: `*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}`
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden" }, _attrs))} data-v-6aee6495><div class="fixed -bottom-1/2 left-0 right-0 h-1/2 spotlight" data-v-6aee6495></div><div class="max-w-520px text-center" data-v-6aee6495><h1 class="text-8xl sm:text-10xl font-medium mb-8" data-v-6aee6495>${serverRenderer.exports.ssrInterpolate(__props.statusCode)}</h1><p class="text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight" data-v-6aee6495>${serverRenderer.exports.ssrInterpolate(__props.description)}</p></div></div>`);
    };
  }
};
const _sfc_setup$r = _sfc_main$r.setup;
_sfc_main$r.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("node_modules/@nuxt/ui-templates/dist/templates/error-500.vue");
  return _sfc_setup$r ? _sfc_setup$r(props, ctx) : void 0;
};
const Error500 = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-6aee6495"]]);
const _sfc_main$p = {
  __name: "nuxt-error-page",
  __ssrInlineRender: true,
  props: {
    error: Object
  },
  setup(__props) {
    var _a;
    const props = __props;
    const error = props.error;
    (error.stack || "").split("\n").splice(1).map((line) => {
      const text = line.replace("webpack:/", "").replace(".vue", ".js").trim();
      return {
        text,
        internal: line.includes("node_modules") && !line.includes(".cache") || line.includes("internal") || line.includes("new Promise")
      };
    }).map((i) => `<span class="stack${i.internal ? " internal" : ""}">${i.text}</span>`).join("\n");
    const statusCode = String(error.statusCode || 500);
    const is404 = statusCode === "404";
    const statusMessage = (_a = error.statusMessage) != null ? _a : is404 ? "Page Not Found" : "Internal Server Error";
    const description = error.message || error.toString();
    const stack = void 0;
    const ErrorTemplate = is404 ? Error404 : Error500;
    return (_ctx, _push, _parent, _attrs) => {
      _push(serverRenderer.exports.ssrRenderComponent(vue_cjs_prod.unref(ErrorTemplate), vue_cjs_prod.mergeProps({ statusCode: vue_cjs_prod.unref(statusCode), statusMessage: vue_cjs_prod.unref(statusMessage), description: vue_cjs_prod.unref(description), stack: vue_cjs_prod.unref(stack) }, _attrs), null, _parent));
    };
  }
};
const _sfc_setup$p = _sfc_main$p.setup;
_sfc_main$p.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("node_modules/nuxt/dist/app/components/nuxt-error-page.vue");
  return _sfc_setup$p ? _sfc_setup$p(props, ctx) : void 0;
};
const _sfc_main$o = {
  __name: "nuxt-root",
  __ssrInlineRender: true,
  setup(__props) {
    const nuxtApp = useNuxtApp();
    nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), "vue:setup");
    const error = useError();
    vue_cjs_prod.onErrorCaptured((err, target, info) => {
      nuxtApp.hooks.callHook("vue:error", err, target, info).catch((hookError) => console.error("[nuxt] Error in `vue:error` hook", hookError));
      {
        callWithNuxt(nuxtApp, throwError, [err]);
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_App = vue_cjs_prod.resolveComponent("App");
      serverRenderer.exports.ssrRenderSuspense(_push, {
        default: () => {
          if (vue_cjs_prod.unref(error)) {
            _push(serverRenderer.exports.ssrRenderComponent(vue_cjs_prod.unref(_sfc_main$p), { error: vue_cjs_prod.unref(error) }, null, _parent));
          } else {
            _push(serverRenderer.exports.ssrRenderComponent(_component_App, null, null, _parent));
          }
        },
        _: 1
      });
    };
  }
};
const _sfc_setup$o = _sfc_main$o.setup;
_sfc_main$o.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("node_modules/nuxt/dist/app/components/nuxt-root.vue");
  return _sfc_setup$o ? _sfc_setup$o(props, ctx) : void 0;
};
const _sfc_main$n = {
  name: "Banners",
  setup() {
    const notificationsStore = useNotificationsStore$1();
    return { notificationsStore };
  },
  methods: {
    closeBanner(id) {
      this.notificationsStore.closeBanner(id);
    }
  },
  created() {
    this.notificationsStore.fetch();
  }
};
function _sfc_ssrRender$l(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = vue_cjs_prod.resolveComponent("font-awesome-icon");
  const _component_NuxtLink = __nuxt_component_1$7;
  _push(`<!--[-->`);
  serverRenderer.exports.ssrRenderList($setup.notificationsStore.banners, (banner) => {
    _push(`<div data-v-0c162054><div class="jumbotron jumbotron-fluid py-3" data-v-0c162054><div class="container text-center" data-v-0c162054><div class="row" data-v-0c162054>`);
    if (banner.linkBehaviour === "new") {
      _push(`<div data-v-0c162054><a${serverRenderer.exports.ssrRenderAttr("href", banner.link)} target="_blank" data-v-0c162054>`);
      if (banner.title) {
        _push(`<strong data-v-0c162054>${serverRenderer.exports.ssrInterpolate(banner.title)}: </strong>`);
      } else {
        _push(`<!---->`);
      }
      _push(`${serverRenderer.exports.ssrInterpolate(banner.message)} `);
      _push(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
        class: "ms-2",
        icon: ["fas", "external-link-alt"]
      }, null, _parent));
      _push(`</a><button type="button" class="btn ms-4 btn-sm btn-outline-light text-uppercase" data-v-0c162054>Dismiss</button></div>`);
    } else if (banner.linkBehaviour === "none") {
      _push(`<div class="basic-banner" data-v-0c162054>`);
      if (banner.title) {
        _push(`<strong data-v-0c162054>${serverRenderer.exports.ssrInterpolate(banner.title)}: </strong>`);
      } else {
        _push(`<!---->`);
      }
      _push(`${serverRenderer.exports.ssrInterpolate(banner.message)} <button type="button" class="btn ms-2 btn-sm btn-outline-light text-uppercase" data-v-0c162054>Dismiss</button></div>`);
    } else if (banner.linkBehaviour === "same") {
      _push(`<div data-v-0c162054>`);
      if (banner.linkType === "external") {
        _push(`<a${serverRenderer.exports.ssrRenderAttr("href", banner.link)} data-v-0c162054>`);
        if (banner.title) {
          _push(`<strong data-v-0c162054>${serverRenderer.exports.ssrInterpolate(banner.title)}: </strong>`);
        } else {
          _push(`<!---->`);
        }
        _push(`${serverRenderer.exports.ssrInterpolate(banner.message)} `);
        _push(serverRenderer.exports.ssrRenderComponent(_component_font_awesome_icon, {
          class: "ms-2",
          icon: ["fas", "external-link-alt"]
        }, null, _parent));
        _push(`</a>`);
      } else if (banner.linkType === "internal") {
        _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
          to: banner.link
        }, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (banner.title) {
                _push2(`<strong data-v-0c162054${_scopeId}>${serverRenderer.exports.ssrInterpolate(banner.title)}: </strong>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`${serverRenderer.exports.ssrInterpolate(banner.message)}`);
            } else {
              return [
                banner.title ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("strong", { key: 0 }, vue_cjs_prod.toDisplayString(banner.title) + ": ", 1)) : vue_cjs_prod.createCommentVNode("", true),
                vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(banner.message), 1)
              ];
            }
          }),
          _: 2
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`<button type="button" class="btn ms-4 btn-sm btn-outline-light text-uppercase" data-v-0c162054>Dismiss</button></div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div></div></div></div>`);
  });
  _push(`<!--]-->`);
}
const _sfc_setup$n = _sfc_main$n.setup;
_sfc_main$n.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Banners.vue");
  return _sfc_setup$n ? _sfc_setup$n(props, ctx) : void 0;
};
const __nuxt_component_0 = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["ssrRender", _sfc_ssrRender$l], ["__scopeId", "data-v-0c162054"]]);
const _sfc_main$m = {
  name: "Navbar"
};
function _sfc_ssrRender$k(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_NuxtLink = __nuxt_component_1$7;
  _push(`<nav${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "navbar navbar-expand-lg navbar-dark bg-theme1" }, _attrs))} data-v-96395c74><div class="container-fluid" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: "navbar-brand",
    to: "/"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`WhereTheyStand`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("WhereTheyStand")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" data-v-96395c74><span class="navbar-toggler-icon" data-v-96395c74></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent" data-v-96395c74><ul class="navbar-nav me-auto" data-v-96395c74><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/people/") ? "active nav-link" : "nav-link"],
    to: "/people/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`People`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("People")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/parties/") ? "active nav-link" : "nav-link"],
    to: "/parties/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Parties`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Parties")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/electorates/") ? "active nav-link" : "nav-link"],
    to: "/electorates/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Electorates`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Electorates")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/bills/") ? "active nav-link" : "nav-link"],
    to: "/bills/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Bills `);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Bills ")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/votes/") ? "active nav-link" : "nav-link"],
    to: "/votes/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Votes `);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Votes ")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
    class: [_ctx.$route.fullPath.startsWith("/about/") ? "active nav-link" : "nav-link"],
    to: "/about/",
    "active-class": "active"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`About`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("About")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li class="nav-item" data-v-96395c74><a class="${serverRenderer.exports.ssrRenderClass([_ctx.$route.fullPath.startsWith("/search/") ? "active nav-link" : "nav-link"])}" href="/search/" active-class="active" data-v-96395c74>Search</a></li></ul></div></div></nav>`);
}
const _sfc_setup$m = _sfc_main$m.setup;
_sfc_main$m.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Navbar.vue");
  return _sfc_setup$m ? _sfc_setup$m(props, ctx) : void 0;
};
const __nuxt_component_1 = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["ssrRender", _sfc_ssrRender$k], ["__scopeId", "data-v-96395c74"]]);
const _sfc_main$l = {
  name: "Footer"
};
function _sfc_ssrRender$j(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_RouterLink = vue_cjs_prod.resolveComponent("RouterLink");
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  const _component_Card = __nuxt_component_2$4;
  _push(`<footer${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "footer text-light" }, _attrs))} data-v-1100fbed><div class="container" data-v-1100fbed><div class="row" data-v-1100fbed><div class="col-12 col-lg-4" data-v-1100fbed><h5 data-v-1100fbed>Pages</h5><hr data-v-1100fbed><ul style="${serverRenderer.exports.ssrRenderStyle({ "list-style": "none", "padding-left": "0" })}" data-v-1100fbed><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/people"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`People`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("People")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/parties"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Parties`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Parties")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/electorates"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Electorates`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Electorates")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/bills"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Bills`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Bills")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/votes"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Votes`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Votes")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li></ul></div><div class="col-12 col-lg-4" data-v-1100fbed><h5 data-v-1100fbed>About</h5><hr data-v-1100fbed><ul style="${serverRenderer.exports.ssrRenderStyle({ "list-style": "none", "padding-left": "0" })}" data-v-1100fbed><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/about"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`About WhereTheyStand`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("About WhereTheyStand")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li><li data-v-1100fbed><a class="text-light footer-link" href="/feedback" data-v-1100fbed>Feedback</a></li><li data-v-1100fbed><a class="text-light footer-link" href="/corrections" data-v-1100fbed>Corrections</a></li><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_RouterLink, {
    class: "text-light footer-link",
    to: "/terms"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Copyright and Privacy`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Copyright and Privacy")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li></ul></div><div class="col-12 col-lg-4" data-v-1100fbed><h5 data-v-1100fbed>Social media</h5><hr data-v-1100fbed><ul style="${serverRenderer.exports.ssrRenderStyle({ "list-style": "none", "padding-left": "0" })}" data-v-1100fbed><li data-v-1100fbed>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
    class: "text-light footer-link",
    link: "https://twitter.com/wherestandnz"
  }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Twitter`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Twitter")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</li>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { gradient: true }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h5 data-v-1100fbed${_scopeId}>Like WhereTheyStand?</h5> You can shout me a hot chocolate (or two).<br data-v-1100fbed${_scopeId}>`);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
          class: "text-light footer-link",
          link: "https://www.buymeacoffee.com/jamescmacey"
        }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`buymeacoffee.com/jamescmacey`);
            } else {
              return [
                vue_cjs_prod.createTextVNode("buymeacoffee.com/jamescmacey")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode("h5", null, "Like WhereTheyStand?"),
          vue_cjs_prod.createTextVNode(" You can shout me a hot chocolate (or two)."),
          vue_cjs_prod.createVNode("br"),
          vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
            class: "text-light footer-link",
            link: "https://www.buymeacoffee.com/jamescmacey"
          }, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createTextVNode("buymeacoffee.com/jamescmacey")
            ]),
            _: 1
          })
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</ul></div></div>`);
  if (_ctx.$route.fullPath.length <= 1) {
    _push(`<small data-v-1100fbed>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
      class: "text-light footer-link",
      link: "https://commons.wikimedia.org/wiki/File:Beehive_and_Parliament_House_in_New_Zealand.jpg"
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(` Header image by Wikimedia user &quot;Melonblob&quot;, used under CC BY-SA 4.0. Cropped and resized. `);
        } else {
          return [
            vue_cjs_prod.createTextVNode(' Header image by Wikimedia user "Melonblob", used under CC BY-SA 4.0. Cropped and resized. ')
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</small>`);
  } else {
    _push(`<!---->`);
  }
  _push(`<hr data-v-1100fbed><h4 data-v-1100fbed><a class="footer-link text-light special-font" href="https://wheretheystand.nz" data-v-1100fbed>wheretheystand.nz</a></h4></div></footer>`);
}
const _sfc_setup$l = _sfc_main$l.setup;
_sfc_main$l.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Footer.vue");
  return _sfc_setup$l ? _sfc_setup$l(props, ctx) : void 0;
};
const __nuxt_component_2 = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["ssrRender", _sfc_ssrRender$j], ["__scopeId", "data-v-1100fbed"]]);
const _sfc_main$k = {
  name: "Toasts",
  setup() {
    const notificationsStore = useNotificationsStore$1();
    return { notificationsStore };
  },
  methods: {
    closeToast(id) {
      this.notificationsStore.closeToast(id);
    }
  }
};
function _sfc_ssrRender$i(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  if ($setup.notificationsStore.toasts.length > 0) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "toast-container position-absolute p-3 top-0 end-0" }, _attrs))} data-v-76e4e4b0><!--[-->`);
    serverRenderer.exports.ssrRenderList($setup.notificationsStore.toasts, (toast) => {
      _push(`<div class="toast show" role="alert" aria-live="assertive" aria-atomic="true" data-v-76e4e4b0><div class="toast-header" data-v-76e4e4b0><strong class="me-auto" data-v-76e4e4b0>${serverRenderer.exports.ssrInterpolate(toast.title)}</strong><button type="button" class="btn-close" aria-label="Close" data-v-76e4e4b0></button></div><div class="toast-body" data-v-76e4e4b0>${serverRenderer.exports.ssrInterpolate(toast.message)}</div></div>`);
    });
    _push(`<!--]--></div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$k = _sfc_main$k.setup;
_sfc_main$k.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Toasts.vue");
  return _sfc_setup$k ? _sfc_setup$k(props, ctx) : void 0;
};
const __nuxt_component_3 = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["ssrRender", _sfc_ssrRender$i], ["__scopeId", "data-v-76e4e4b0"]]);
const _sfc_main$j = {
  __name: "app",
  __ssrInlineRender: true,
  setup(__props) {
    useHead({
      titleTemplate: (titleChunk) => {
        return titleChunk ? `${titleChunk} - WhereTheyStand` : "WhereTheyStand";
      },
      meta: [
        { name: "description", content: "WhereTheyStand aggregates and links information about Members of Parliament and political parties, allowing you to find relevant information easily." }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Head = vue_cjs_prod.resolveComponent("Head");
      const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
      const _component_Link = vue_cjs_prod.resolveComponent("Link");
      const _component_Banners = __nuxt_component_0;
      const _component_Navbar = __nuxt_component_1;
      const _component_NuxtPage = vue_cjs_prod.resolveComponent("NuxtPage");
      const _component_Footer = __nuxt_component_2;
      const _component_Toasts = __nuxt_component_3;
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "app" }, _attrs))}>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "twitter:card",
              content: "summary"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "twitter:site",
              content: "@wherestandnz"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "twitter:title",
              content: "WhereTheyStand"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "twitter:description",
              content: "See where your MP stands at wheretheystand.nz"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              property: "og:site_name",
              content: "WhereTheyStand"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              property: "og:locale",
              content: "en_NZ"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              property: "og:title",
              content: "WhereTheyStand"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              property: "og:description",
              content: "See where your MP stands at wheretheystand.nz"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "apple-touch-icon",
              sizes: "180x180",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/apple-touch-icon.png"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "icon",
              type: "image/png",
              sizes: "32x32",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon-32x32.png"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "icon",
              type: "image/png",
              sizes: "16x16",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon-16x16.png"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "manifest",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/site.webmanifest"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "mask-icon",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/safari-pinned-tab.svg",
              color: "#58787f"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Link, {
              rel: "shortcut icon",
              href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon.ico"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "msapplication-TileColor",
              content: "#58787f"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "msapplication-config",
              content: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/browserconfig.xml"
            }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "theme-color",
              content: "#58787f"
            }, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "twitter:card",
                content: "summary"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "twitter:site",
                content: "@wherestandnz"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "twitter:title",
                content: "WhereTheyStand"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "twitter:description",
                content: "See where your MP stands at wheretheystand.nz"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                property: "og:site_name",
                content: "WhereTheyStand"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                property: "og:locale",
                content: "en_NZ"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                property: "og:title",
                content: "WhereTheyStand"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                property: "og:description",
                content: "See where your MP stands at wheretheystand.nz"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "apple-touch-icon",
                sizes: "180x180",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/apple-touch-icon.png"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "icon",
                type: "image/png",
                sizes: "32x32",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon-32x32.png"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "icon",
                type: "image/png",
                sizes: "16x16",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon-16x16.png"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "manifest",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/site.webmanifest"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "mask-icon",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/safari-pinned-tab.svg",
                color: "#58787f"
              }),
              vue_cjs_prod.createVNode(_component_Link, {
                rel: "shortcut icon",
                href: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/favicon.ico"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "msapplication-TileColor",
                content: "#58787f"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "msapplication-config",
                content: "https://storage.googleapis.com/wheretheystand-nz/nzpm_app/favicons/browserconfig.xml"
              }),
              vue_cjs_prod.createVNode(_component_Meta, {
                name: "theme-color",
                content: "#58787f"
              })
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="flex-wrapper-gx"><div class="gx-non-footer">`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Banners, null, null, _parent));
      _push(serverRenderer.exports.ssrRenderComponent(_component_Navbar, null, null, _parent));
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtPage, { class: "content-wrapper" }, null, _parent));
      _push(`</div>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Footer, null, null, _parent));
      _push(`</div>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Toasts, null, null, _parent));
      _push(`</div>`);
    };
  }
};
const _sfc_setup$j = _sfc_main$j.setup;
_sfc_main$j.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("app.vue");
  return _sfc_setup$j ? _sfc_setup$j(props, ctx) : void 0;
};
if (!globalThis.$fetch) {
  globalThis.$fetch = $fetch$1.create({
    baseURL: baseURL()
  });
}
let entry;
const plugins = normalizePlugins(_plugins);
{
  entry = async function createNuxtAppServer(ssrContext) {
    const vueApp = vue_cjs_prod.createApp(_sfc_main$o);
    vueApp.component("App", _sfc_main$j);
    const nuxt = createNuxtApp({ vueApp, ssrContext });
    try {
      await applyPlugins(nuxt, plugins);
      await nuxt.hooks.callHook("app:created", vueApp);
    } catch (err) {
      await nuxt.callHook("app:error", err);
      ssrContext.error = ssrContext.error || err;
    }
    return vueApp;
  };
}
const entry$1 = (ctx) => entry(ctx);
const _sfc_main$i = {
  name: "About",
  components: ["ExternalLinkInline", "ExternalLinkButton"]
};
function _sfc_ssrRender$h(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_Card = __nuxt_component_2$4;
  const _component_ExternalLinkButton = __nuxt_component_0$2;
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)}>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "About WhereTheyStand" }, null, _parent));
  _push(`<div class="container"><div class="row mt-3"><div class="col-12">`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h4${_scopeId}>WhereTheyStand aims to aggregate key data about New Zealand&#39;s politicians, Parliament, and political parties.</h4><h5${_scopeId}>Historical reach</h5><p${_scopeId}>Information on WhereTheyStand goes back as far as the 51st Parliament (2014-2017). Members of Parliament who were members of that or any subsequent parliamentary terms have profiles on WhereTheyStand.</p><h5${_scopeId}>Site development</h5><p${_scopeId}>WhereTheyStand is a personal side-project by me, James Macey. I am a fourth-year law and commerce student at Victoria University of Wellington, and I work on this site when I have free time. I aim to keep WhereTheyStand completly apolitical; editorial annotations to substantive content will be made rarely and with substantial disclosure.</p><p${_scopeId}>Most of the funding for running WhereTheyStand comes from me. Of course, I&#39;ve taken steps to keep costs down, including by utilising student discounts I have access to, and reserving cloud capacity ahead of time. </p>`);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, { link: "https://www.buymeacoffee.com/jamescmacey" }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`If you really like this site, please consider buying me a hot choccy!`);
            } else {
              return [
                vue_cjs_prod.createTextVNode("If you really like this site, please consider buying me a hot choccy!")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
        _push2(`<h5${_scopeId}>Acknowledgements and inspiration</h5><p${_scopeId}>First, great Parliamentary monitoring sites overseas have given me a lot of ideas and inspiration for WhereTheyStand. `);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://www.theyworkforyou.com/" }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`TheyWorkForYou `);
            } else {
              return [
                vue_cjs_prod.createTextVNode("TheyWorkForYou ")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
        _push2(` is a great site built by the mySociety charity in the UK. It sets a gold standard for sites like these and I can only hope to get there with WhereTheyStand one day.</p><p${_scopeId}>Secondly, the data and information that is presented on WhereTheyStand comes from a wide range of organisations. They are not affiliated with WhereTheyStand, but public information they provide is used on WhereTheyStand: <ul${_scopeId}><li${_scopeId}><strong${_scopeId}>Office of the Clerk of the House of Representatives</strong>: Bill data, Hansard (Parliamentary debates and votes), Register of Members&#39; Pecuinary and Other Interests, MPs&#39; expenses, MPs&#39; email addresses</li><li${_scopeId}><strong${_scopeId}>Parliamentary Counsel Office</strong>: Substantive bill content</li><li${_scopeId}><strong${_scopeId}>Department of Internal Affairs</strong>: Ministers&#39; expenses</li><li${_scopeId}><strong${_scopeId}>Ministry of Business, Innovation and Employment</strong>: Companies Register information</li><li${_scopeId}><strong${_scopeId}>Electoral Commission</strong>: Party name and registration information</li><li${_scopeId}><strong${_scopeId}>Stats NZ, the Representation Commission and the Electoral Commission</strong>: Electorate boundaries and geographic statistics</li><li${_scopeId}><strong${_scopeId}>Twitter</strong>: MP and Party Twitter account statistics</li></ul></p>`);
      } else {
        return [
          vue_cjs_prod.createVNode("h4", null, "WhereTheyStand aims to aggregate key data about New Zealand's politicians, Parliament, and political parties."),
          vue_cjs_prod.createVNode("h5", null, "Historical reach"),
          vue_cjs_prod.createVNode("p", null, "Information on WhereTheyStand goes back as far as the 51st Parliament (2014-2017). Members of Parliament who were members of that or any subsequent parliamentary terms have profiles on WhereTheyStand."),
          vue_cjs_prod.createVNode("h5", null, "Site development"),
          vue_cjs_prod.createVNode("p", null, "WhereTheyStand is a personal side-project by me, James Macey. I am a fourth-year law and commerce student at Victoria University of Wellington, and I work on this site when I have free time. I aim to keep WhereTheyStand completly apolitical; editorial annotations to substantive content will be made rarely and with substantial disclosure."),
          vue_cjs_prod.createVNode("p", null, "Most of the funding for running WhereTheyStand comes from me. Of course, I've taken steps to keep costs down, including by utilising student discounts I have access to, and reserving cloud capacity ahead of time. "),
          vue_cjs_prod.createVNode(_component_ExternalLinkButton, { link: "https://www.buymeacoffee.com/jamescmacey" }, {
            default: vue_cjs_prod.withCtx(() => [
              vue_cjs_prod.createTextVNode("If you really like this site, please consider buying me a hot choccy!")
            ]),
            _: 1
          }),
          vue_cjs_prod.createVNode("h5", null, "Acknowledgements and inspiration"),
          vue_cjs_prod.createVNode("p", null, [
            vue_cjs_prod.createTextVNode("First, great Parliamentary monitoring sites overseas have given me a lot of ideas and inspiration for WhereTheyStand. "),
            vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://www.theyworkforyou.com/" }, {
              default: vue_cjs_prod.withCtx(() => [
                vue_cjs_prod.createTextVNode("TheyWorkForYou ")
              ]),
              _: 1
            }),
            vue_cjs_prod.createTextVNode(" is a great site built by the mySociety charity in the UK. It sets a gold standard for sites like these and I can only hope to get there with WhereTheyStand one day.")
          ]),
          vue_cjs_prod.createVNode("p", null, [
            vue_cjs_prod.createTextVNode("Secondly, the data and information that is presented on WhereTheyStand comes from a wide range of organisations. They are not affiliated with WhereTheyStand, but public information they provide is used on WhereTheyStand: "),
            vue_cjs_prod.createVNode("ul", null, [
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Office of the Clerk of the House of Representatives"),
                vue_cjs_prod.createTextVNode(": Bill data, Hansard (Parliamentary debates and votes), Register of Members' Pecuinary and Other Interests, MPs' expenses, MPs' email addresses")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Parliamentary Counsel Office"),
                vue_cjs_prod.createTextVNode(": Substantive bill content")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Department of Internal Affairs"),
                vue_cjs_prod.createTextVNode(": Ministers' expenses")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Ministry of Business, Innovation and Employment"),
                vue_cjs_prod.createTextVNode(": Companies Register information")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Electoral Commission"),
                vue_cjs_prod.createTextVNode(": Party name and registration information")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Stats NZ, the Representation Commission and the Electoral Commission"),
                vue_cjs_prod.createTextVNode(": Electorate boundaries and geographic statistics")
              ]),
              vue_cjs_prod.createVNode("li", null, [
                vue_cjs_prod.createVNode("strong", null, "Twitter"),
                vue_cjs_prod.createTextVNode(": MP and Party Twitter account statistics")
              ])
            ])
          ])
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</div></div></div></div>`);
}
const _sfc_setup$i = _sfc_main$i.setup;
_sfc_main$i.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/about.vue");
  return _sfc_setup$i ? _sfc_setup$i(props, ctx) : void 0;
};
const about = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["ssrRender", _sfc_ssrRender$h]]);
const about$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": about
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$h = {
  name: "Bill",
  setup() {
    const billsStore = useBillsStore();
    return { billsStore };
  },
  created() {
    this.billsStore.fetch(this.$route.params.id);
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    },
    formatDateTime(datetime) {
      return format(parseISO(datetime), "d MMMM yyyy 'at' HH:mm OOOO");
    }
  },
  computed: {
    bill() {
      return this.billsStore.byID(this.$route.params.id);
    },
    progressExplanation() {
      if (!this.bill) {
        return "";
      } else if (this.bill.progress === "inp") {
        if (this.bill.dates.whole_house_date) {
          return "The Committee of the whole House concluded its consideration of this Bill on " + this.formatDate(this.bill.dates.whole_house_date) + " and the Bill is awaiting its third reading.";
        } else if (this.bill.dates.second_reading_date) {
          return "This Bill passed its second reading on " + this.formatDate(this.bill.dates.second_reading_date) + " and is awaiting the Commitee of the whole House stage.";
        } else if (this.bill.dates.first_reading_date) {
          var msg = "This Bill passed its first reading on " + this.formatDate(this.bill.dates.first_reading_date) + ". ";
          if (this.bill.dates.report_back_date) {
            msg = msg + "The Select Committee reported back on " + this.formatDate(this.bill.dates.report_back_date) + " and the Bill is awaiting its second reading. ";
          } else if (this.bill.dates.submissions_due_date) {
            msg = msg + "Public submissions are due on " + this.formatDate(this.bill.dates.submissions_due_date) + ". ";
          }
          return msg;
        } else if (this.bill.dates.introduction_date) {
          return "This Bill was introduced on " + this.formatDate(this.bill.dates.introduction_date) + " and is awaiting its first reading.";
        }
      }
      const EXPLANATIONS = {
        ena: "This Bill has been passed by Parliament, and signed into law by the Governor-General in a step called Royal Assent. This doesn't mean that everything the Act implements has come into force yet, but it does mean that the Act is on the statute books.",
        pas: "This Bill has been passed by Parliament, but hasn't been given Royal Assent by the Governor-General. Once this happens, the Bill will become law.",
        def: "This Bill has been defeated in a vote of MPs, which means that it will not be progressing and will not become law.",
        wit: "This Bill has been withdrawn, which means that it will not be progressing and will not become law.",
        lap: "This Bill has lapsed. At the end of each Parliamentary term, bills which are still in progress lapse unless they are reinstated in the next term.",
        unx: "This Bill is classed as 'not current' on Parliament's website, which means it is likely that the Bill was either defeated or withdrawn. Unfortunately, WhereTheyStand has not been able to ascertain this information based on the Bill's page on the Parliament website.",
        div: "This Bill has been divided into multiple bills.",
        unk: "WhereTheyStand isn't sure what's happening with this Bill.",
        dis: "This Bill has been discharged by Parliament, which means that it will not be progressing and will not become law."
      };
      return EXPLANATIONS[this.bill.progress];
    },
    firstReading() {
      return this.bill.votes.find((vote) => vote.reading === 1);
    },
    secondReading() {
      return this.bill.votes.find((vote) => vote.reading === 2);
    },
    thirdReading() {
      return this.bill.votes.find((vote) => vote.reading === 3);
    },
    actUrl() {
      if (!this.bill.enactment.act_number || !this.bill.enactment.act_year) {
        return null;
      } else {
        return "https://legislation.govt.nz/act/results.aspx?search=ad_act___" + this.bill.enactment.act_year + "_" + this.bill.enactment.act_number + "__25_ac@bn@rn@dn@apub@aloc@apri@apro@aimp@bgov@bloc@bpri@bmem@rpub@rimp_ac@ainf@anif@aaif@aase@arep@bcur@rinf@rnif_a_aw_se_&p=1";
      }
    },
    relativeDate() {
      return formatDistanceToNow(parseISO(this.bill.last_retrieved)) + " ago";
    }
  }
};
function _sfc_ssrRender$g(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_Card = __nuxt_component_2$4;
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  const _component_DownloadLink = __nuxt_component_4$1;
  const _component_PersonCard = __nuxt_component_6;
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_VoteSummary = __nuxt_component_1$6;
  const _component_VoteSummaryBare = __nuxt_component_7$1;
  if ($options.bill) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "bill-view" }, _attrs))} data-v-7fb37eb8>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:title",
            content: $options.bill.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:description",
            content: $options.bill.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "description",
            content: $options.bill.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:title",
            content: $options.bill.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:description",
            content: $options.bill.description
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:title",
              content: $options.bill.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:description",
              content: $options.bill.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "description",
              content: $options.bill.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:title",
              content: $options.bill.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:description",
              content: $options.bill.description
            }, null, 8, ["content"])
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
      pageTitle: $options.bill.name,
      pageSubtitle: $options.bill.type_desc
    }, null, _parent));
    _push(`<div class="container mt-3" data-v-7fb37eb8><div class="row" data-v-7fb37eb8><div class="col-12 col-lg-8" data-v-7fb37eb8><h4 data-v-7fb37eb8>About this bill</h4>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`${serverRenderer.exports.ssrInterpolate($options.bill.description)} `);
          if ($options.bill.voting_method != "unk") {
            _push2(`<h5 class="mt-3" data-v-7fb37eb8${_scopeId}>Voting method</h5>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.voting_method == "per") {
            _push2(`<span data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "person"] }, null, _parent2, _scopeId));
            _push2(` <strong data-v-7fb37eb8${_scopeId}>Personal voting: </strong> MPs voted individually on this bill. </span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.voting_method == "par") {
            _push2(`<span data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent2, _scopeId));
            _push2(` <strong data-v-7fb37eb8${_scopeId}>Party voting: </strong> Parties decided whether or not to support this bill and cast votes on behalf of all their MPs. </span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.voting_method == "mix") {
            _push2(`<span data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent2, _scopeId));
            _push2(` / `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "person"] }, null, _parent2, _scopeId));
            _push2(` <strong data-v-7fb37eb8${_scopeId}>Mixed voting: </strong> Both personal and party voting were used at different stages of this bill&#39;s progression. </span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.urgency_used || $options.bill.extended_sittings_used) {
            _push2(`<h5 class="mt-3" data-v-7fb37eb8${_scopeId}>Procedural notes</h5>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<ul class="procedural-list pb-0 ps-0" data-v-7fb37eb8${_scopeId}>`);
          if ($options.bill.urgency_used) {
            _push2(`<li class="procedural-list" data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
              class: "me-2",
              icon: ["fas", "forward-fast"]
            }, null, _parent2, _scopeId));
            _push2(`<strong data-v-7fb37eb8${_scopeId}>Urgency used: </strong> This bill was progressed through one or more stages using urgency. Urgency allows the Government to fast-track the legislative process by extending the sitting hours of the House of Representatives and skipping the select committee stage of a bill, and allows bills to pass through more than one stage per sitting day. <br data-v-7fb37eb8${_scopeId}><small data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://www.parliament.nz/en/visit-and-learn/how-parliament-works/fact-sheets/what-is-urgency/" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Learn more about urgency`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(" Learn more about urgency")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</small></li>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.extended_sittings_used) {
            _push2(`<li class="procedural-list" data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
              class: "me-2",
              icon: ["fa", "calendar"]
            }, null, _parent2, _scopeId));
            _push2(`<strong data-v-7fb37eb8${_scopeId}>Extended sittings used: </strong> This bill was progressed during one or more extended sittings of the House of Representatives. This enables MPs to meet for longer than normal to consider legislation. It does not alter the stages that a bill must pass through to become law. <br data-v-7fb37eb8${_scopeId}><small data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://www.parliament.nz/en/visit-and-learn/how-parliament-works/fact-sheets/a-closer-look-at-extended-hours/" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Learn more about extended sittings`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(" Learn more about extended sittings")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</small></li>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`</ul>`);
          if ($options.bill.pco_url || $options.actUrl) {
            _push2(`<h5 class="mt-3" data-v-7fb37eb8${_scopeId}>Read the bill</h5>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.pco_url) {
            _push2(`<span data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
              class: "me-2",
              icon: ["fas", "file-lines"]
            }, null, _parent2, _scopeId));
            _push2(`Bill text: `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
              link: $options.bill.pco_url
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate($options.bill.name)} (legislation.govt.nz)`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.bill.name) + " (legislation.govt.nz)", 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.bill.pco_url && $options.actUrl) {
            _push2(`<br data-v-7fb37eb8${_scopeId}>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.actUrl) {
            _push2(`<span data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, {
              class: "me-2",
              icon: ["fas", "book"]
            }, null, _parent2, _scopeId));
            _push2(`Act text: `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: $options.actUrl }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate($options.bill.enactment.act)} (legislation.govt.nz)`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.bill.enactment.act) + " (legislation.govt.nz)", 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</span>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<hr data-v-7fb37eb8${_scopeId}><div class="row" data-v-7fb37eb8${_scopeId}>`);
          if (!$options.bill.parliament_api_id) {
            _push2(`<div class="col-12 col-xl-6" data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
              link: "https://www.parliament.nz/en/pb/bills-and-laws/bills-proposed-laws/document/" + $options.bill.legacy_document_id
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` View on Parliament website (legacy)`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(" View on Parliament website (legacy)")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div>`);
          } else {
            _push2(`<div class="col-12 col-xl-6" data-v-7fb37eb8${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
              link: "https://bills.parliament.nz/v/6/" + $options.bill.parliament_api_id
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` View on Parliament website`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(" View on Parliament website")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div>`);
          }
          _push2(`<div class="col-12 col-xl-6 text-xl-end" data-v-7fb37eb8${_scopeId}>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_DownloadLink, {
            class: "ms-xl-2 me-xl-0",
            resourceType: "bill",
            fileType: "json",
            friendlyName: $options.bill.name,
            resourceId: $options.bill.id
          }, null, _parent2, _scopeId));
          _push2(`</div></div>`);
        } else {
          return [
            vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.bill.description) + " ", 1),
            $options.bill.voting_method != "unk" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", {
              key: 0,
              class: "mt-3"
            }, "Voting method")) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.voting_method == "per" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "person"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Personal voting: "),
              vue_cjs_prod.createTextVNode(" MPs voted individually on this bill. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.voting_method == "par" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 2 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Party voting: "),
              vue_cjs_prod.createTextVNode(" Parties decided whether or not to support this bill and cast votes on behalf of all their MPs. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.voting_method == "mix" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 3 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }),
              vue_cjs_prod.createTextVNode(" / "),
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "person"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Mixed voting: "),
              vue_cjs_prod.createTextVNode(" Both personal and party voting were used at different stages of this bill's progression. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.urgency_used || $options.bill.extended_sittings_used ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", {
              key: 4,
              class: "mt-3"
            }, "Procedural notes")) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode("ul", { class: "procedural-list pb-0 ps-0" }, [
              $options.bill.urgency_used ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                key: 0,
                class: "procedural-list"
              }, [
                vue_cjs_prod.createVNode(_component_FontAwesomeIcon, {
                  class: "me-2",
                  icon: ["fas", "forward-fast"]
                }),
                vue_cjs_prod.createVNode("strong", null, "Urgency used: "),
                vue_cjs_prod.createTextVNode(" This bill was progressed through one or more stages using urgency. Urgency allows the Government to fast-track the legislative process by extending the sitting hours of the House of Representatives and skipping the select committee stage of a bill, and allows bills to pass through more than one stage per sitting day. "),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode("small", null, [
                  vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://www.parliament.nz/en/visit-and-learn/how-parliament-works/fact-sheets/what-is-urgency/" }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(" Learn more about urgency")
                    ]),
                    _: 1
                  })
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true),
              $options.bill.extended_sittings_used ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                key: 1,
                class: "procedural-list"
              }, [
                vue_cjs_prod.createVNode(_component_FontAwesomeIcon, {
                  class: "me-2",
                  icon: ["fa", "calendar"]
                }),
                vue_cjs_prod.createVNode("strong", null, "Extended sittings used: "),
                vue_cjs_prod.createTextVNode(" This bill was progressed during one or more extended sittings of the House of Representatives. This enables MPs to meet for longer than normal to consider legislation. It does not alter the stages that a bill must pass through to become law. "),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode("small", null, [
                  vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://www.parliament.nz/en/visit-and-learn/how-parliament-works/fact-sheets/a-closer-look-at-extended-hours/" }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(" Learn more about extended sittings")
                    ]),
                    _: 1
                  })
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ]),
            $options.bill.pco_url || $options.actUrl ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", {
              key: 5,
              class: "mt-3"
            }, "Read the bill")) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.pco_url ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 6 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, {
                class: "me-2",
                icon: ["fas", "file-lines"]
              }),
              vue_cjs_prod.createTextVNode("Bill text: "),
              vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
                link: $options.bill.pco_url
              }, {
                default: vue_cjs_prod.withCtx(() => [
                  vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.bill.name) + " (legislation.govt.nz)", 1)
                ]),
                _: 1
              }, 8, ["link"])
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.bill.pco_url && $options.actUrl ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("br", { key: 7 })) : vue_cjs_prod.createCommentVNode("", true),
            $options.actUrl ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 8 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, {
                class: "me-2",
                icon: ["fas", "book"]
              }),
              vue_cjs_prod.createTextVNode("Act text: "),
              vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: $options.actUrl }, {
                default: vue_cjs_prod.withCtx(() => [
                  vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.bill.enactment.act) + " (legislation.govt.nz)", 1)
                ]),
                _: 1
              }, 8, ["link"])
            ])) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode("hr"),
            vue_cjs_prod.createVNode("div", { class: "row" }, [
              !$options.bill.parliament_api_id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                key: 0,
                class: "col-12 col-xl-6"
              }, [
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
                  link: "https://www.parliament.nz/en/pb/bills-and-laws/bills-proposed-laws/document/" + $options.bill.legacy_document_id
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode(" View on Parliament website (legacy)")
                  ]),
                  _: 1
                }, 8, ["link"])
              ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                key: 1,
                class: "col-12 col-xl-6"
              }, [
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
                  link: "https://bills.parliament.nz/v/6/" + $options.bill.parliament_api_id
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode(" View on Parliament website")
                  ]),
                  _: 1
                }, 8, ["link"])
              ])),
              vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-6 text-xl-end" }, [
                vue_cjs_prod.createVNode(_component_DownloadLink, {
                  class: "ms-xl-2 me-xl-0",
                  resourceType: "bill",
                  fileType: "json",
                  friendlyName: $options.bill.name,
                  resourceId: $options.bill.id
                }, null, 8, ["friendlyName", "resourceId"])
              ])
            ])
          ];
        }
      }),
      _: 1
    }, _parent));
    if ($options.bill.people_responsible.length > 0) {
      _push(`<h4 data-v-7fb37eb8>Member`);
      if ($options.bill.people_responsible.length > 1) {
        _push(`<span data-v-7fb37eb8>s</span>`);
      } else {
        _push(`<!---->`);
      }
      _push(` responsible</h4>`);
    } else {
      _push(`<!---->`);
    }
    _push(`<div class="row" data-v-7fb37eb8><!--[-->`);
    serverRenderer.exports.ssrRenderList($options.bill.people_responsible, (person) => {
      _push(`<div class="col-12 col-lg-6" data-v-7fb37eb8>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, { person }, null, _parent));
      _push(`</div>`);
    });
    _push(`<!--]--></div></div><div class="col-12 col-lg-4" data-v-7fb37eb8><h4 data-v-7fb37eb8>Progress</h4>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { gradient: true }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h3 data-v-7fb37eb8${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.bill.progress_desc)}</h3><p data-v-7fb37eb8${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.progressExplanation)}</p>`);
        } else {
          return [
            vue_cjs_prod.createVNode("h3", null, vue_cjs_prod.toDisplayString($options.bill.progress_desc), 1),
            vue_cjs_prod.createVNode("p", null, vue_cjs_prod.toDisplayString($options.progressExplanation), 1)
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div><h3 data-v-7fb37eb8>Votes</h3><div class="row" data-v-7fb37eb8><div class="col-12 col-lg-4" data-v-7fb37eb8>`);
    if ($options.firstReading) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
        class: "vote-link",
        to: "/votes/" + $options.firstReading.id
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_VoteSummary, { vote: $options.firstReading }, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode(_component_VoteSummary, { vote: $options.firstReading }, null, 8, ["vote"])
            ];
          }
        }),
        _: 1
      }, _parent));
    } else if ($options.bill.dates.first_reading_date) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        reading: 1,
        passed: true,
        date: $options.bill.dates.first_reading_date
      }, null, _parent));
    } else if ($options.bill.dates.defeated_date && $options.bill.defeated_at_reading === 1) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        passed: false,
        reading: 1,
        date: $options.bill.dates.defeated_date
      }, null, _parent));
    } else if (!$options.bill.defeated_at_reading || $options.bill.defeated_at_reading >= 1) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { missing: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h6 class="text-uppercase text-muted" data-v-7fb37eb8${_scopeId}><strong data-v-7fb37eb8${_scopeId}>1st reading</strong></h6><h6 class="text-muted" data-v-7fb37eb8${_scopeId}>This vote has not yet occurred, or is not yet recorded on WhereTheyStand.</h6>`);
          } else {
            return [
              vue_cjs_prod.createVNode("h6", { class: "text-uppercase text-muted" }, [
                vue_cjs_prod.createVNode("strong", null, "1st reading")
              ]),
              vue_cjs_prod.createVNode("h6", { class: "text-muted" }, "This vote has not yet occurred, or is not yet recorded on WhereTheyStand.")
            ];
          }
        }),
        _: 1
      }, _parent));
    } else {
      _push(`<!---->`);
    }
    _push(`</div><div class="col-12 col-lg-4" data-v-7fb37eb8>`);
    if ($options.secondReading) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
        class: "vote-link",
        to: "/votes/" + $options.secondReading.id
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_VoteSummary, { vote: $options.secondReading }, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode(_component_VoteSummary, { vote: $options.secondReading }, null, 8, ["vote"])
            ];
          }
        }),
        _: 1
      }, _parent));
    } else if ($options.bill.dates.second_reading_date) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        reading: 2,
        passed: true,
        date: $options.bill.dates.second_reading_date
      }, null, _parent));
    } else if ($options.bill.dates.defeated_date && $options.bill.defeated_at_reading === 2) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        passed: false,
        reading: 2,
        date: $options.bill.dates.defeated_date
      }, null, _parent));
    } else if (!$options.bill.defeated_at_reading || $options.bill.defeated_at_reading >= 2) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { missing: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h6 class="text-uppercase text-muted" data-v-7fb37eb8${_scopeId}><strong data-v-7fb37eb8${_scopeId}>2nd reading</strong></h6><h6 class="text-muted" data-v-7fb37eb8${_scopeId}>This vote has not yet occurred, or is not yet recorded on WhereTheyStand.</h6>`);
          } else {
            return [
              vue_cjs_prod.createVNode("h6", { class: "text-uppercase text-muted" }, [
                vue_cjs_prod.createVNode("strong", null, "2nd reading")
              ]),
              vue_cjs_prod.createVNode("h6", { class: "text-muted" }, "This vote has not yet occurred, or is not yet recorded on WhereTheyStand.")
            ];
          }
        }),
        _: 1
      }, _parent));
    } else {
      _push(`<!---->`);
    }
    _push(`</div><div class="col-12 col-lg-4" data-v-7fb37eb8>`);
    if ($options.thirdReading) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
        class: "vote-link",
        to: "/votes/" + $options.thirdReading.id
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_VoteSummary, { vote: $options.thirdReading }, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode(_component_VoteSummary, { vote: $options.thirdReading }, null, 8, ["vote"])
            ];
          }
        }),
        _: 1
      }, _parent));
    } else if ($options.bill.dates.third_reading_date) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        reading: 3,
        passed: true,
        date: $options.bill.dates.third_reading_date
      }, null, _parent));
    } else if ($options.bill.dates.defeated_date && $options.bill.defeated_at_reading === 3) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummaryBare, {
        passed: false,
        reading: 3,
        date: $options.bill.dates.defeated_date
      }, null, _parent));
    } else if (!$options.bill.defeated_at_reading || $options.bill.defeated_at_reading >= 3) {
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { missing: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h6 class="text-uppercase text-muted" data-v-7fb37eb8${_scopeId}><strong data-v-7fb37eb8${_scopeId}>3rd reading</strong></h6><h6 class="text-muted" data-v-7fb37eb8${_scopeId}>This vote has not yet occurred, or is not yet recorded on WhereTheyStand.</h6>`);
          } else {
            return [
              vue_cjs_prod.createVNode("h6", { class: "text-uppercase text-muted" }, [
                vue_cjs_prod.createVNode("strong", null, "3rd reading")
              ]),
              vue_cjs_prod.createVNode("h6", { class: "text-muted" }, "This vote has not yet occurred, or is not yet recorded on WhereTheyStand.")
            ];
          }
        }),
        _: 1
      }, _parent));
    } else {
      _push(`<!---->`);
    }
    _push(`</div></div><p class="text-muted" data-v-7fb37eb8>Only reading votes are shown here; these votes determine whether the Bill progresses through Parliament. Other votes, such as votes on whether to amend parts of the Bill, can be seen in Hansard.</p><p class="text-muted" data-v-7fb37eb8>Bill details last synced with the Parliament website ${serverRenderer.exports.ssrInterpolate($options.relativeDate)}. <br data-v-7fb37eb8><small data-v-7fb37eb8>(${serverRenderer.exports.ssrInterpolate($options.formatDateTime($options.bill.last_retrieved))})</small></p></div></div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$h = _sfc_main$h.setup;
_sfc_main$h.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/bills/[id]/index.vue");
  return _sfc_setup$h ? _sfc_setup$h(props, ctx) : void 0;
};
const index$k = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["ssrRender", _sfc_ssrRender$g], ["__scopeId", "data-v-7fb37eb8"]]);
const index$l = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$k
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$g = {};
function _sfc_ssrRender$f(_ctx, _push, _parent, _attrs) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_BillFilter = __nuxt_component_1$5;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)}>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "Bills" }, null, _parent));
  _push(`<div class="container"><div class="row mt-3"><div class="col-12"><h4>Bills are proposed changes to the law, and must each pass through several stages in Parliament before becoming law.</h4><p>Before any bill becomes law, there are three main votes it must pass: these are the first, second and third readings. For most bills, there is a chance for members of the public to make submissions at the select committee stage, which happens between the first and second readings.</p><p>After a bill passes its third reading vote, it is granted Royal Assent by the Governor-General and becomes law, subject to any commencement provisions contained within the bill.</p><p>WhereTheyStand contains all bills from the 51st Parliament and later (2014\u2014present). These are imported from Parliament&#39;s own website on a regular basis and are automatically linked with voting records and MPs&#39; profiles to make it easier for you to find what you are looking for.</p></div><div class="col-12">`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_BillFilter, null, null, _parent));
  _push(`</div></div></div></div>`);
}
const _sfc_setup$g = _sfc_main$g.setup;
_sfc_main$g.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/bills/index.vue");
  return _sfc_setup$g ? _sfc_setup$g(props, ctx) : void 0;
};
const index$i = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["ssrRender", _sfc_ssrRender$f]]);
const index$j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$i
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$f = {
  name: "Electorate",
  setup() {
    const electoratesStore = useElectoratesStore();
    return { electoratesStore };
  },
  data() {
    return {
      showReasons: false
    };
  },
  created() {
    this.electoratesStore.fetch(this.$route.params.id);
    this.electoratesStore.fetchHistory(this.$route.params.id);
    this.electoratesStore.fetchShape(this.$route.params.id);
  },
  computed: {
    electorate() {
      return this.electoratesStore.byIdentifier(this.$route.params.id);
    },
    affiliations() {
      return this.electoratesStore.historyByIdentifier(this.$route.params.id);
    },
    shape() {
      return this.electoratesStore.shapeByIdentifier(this.$route.params.id);
    },
    paths() {
      if (!this.shape || this.shape["wts-comment"] == "noshape") {
        return [];
      }
      var feature = this.shape.features[0];
      if (feature.geometry.type == "Polygon") {
        return this.shape.features[0].geometry.coordinates;
      } else if (feature.geometry.type == "MultiPolygon") {
        var paths = [];
        this.shape.features[0].geometry.coordinates.forEach((polygon) => {
          paths.push(polygon[0]);
        });
        return paths;
      }
    },
    limits() {
      if (!this.shape || this.shape["wts-comment"] == "noshape") {
        return void 0;
      }
      var north = -180;
      var south = 0;
      var east = 0;
      var west = 360;
      this.paths.forEach((polygon) => {
        polygon.forEach((coordinate) => {
          var ewc = coordinate[0];
          var nsc = coordinate[1];
          if (ewc < 0) {
            ewc = ewc + 360;
          }
          if (ewc > east) {
            east = ewc;
          }
          if (ewc < west) {
            west = ewc;
          }
          if (nsc > north) {
            north = nsc;
          }
          if (nsc < south) {
            south = nsc;
          }
        });
      });
      if (east > 180) {
        east = east - 360;
      }
      return {
        north,
        south,
        east,
        west
      };
    },
    center() {
      if (this.limits) {
        var east = this.limits.east;
        if (east < 0) {
          east = east + 360;
        }
        var ewCentre = (east + this.limits.west) / 2;
        if (ewCentre > 180) {
          ewCentre = ewCentre - 360;
        }
        return [ewCentre, (this.limits.north + this.limits.south) / 2];
      } else {
        return [0, 0];
      }
    }
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  },
  watch: {
    $route(to2, from2) {
      if (to2.fullPath.startsWith("/electorates/")) {
        this.electoratesStore.fetch(to2.params.id);
        this.electoratesStore.fetchHistory(to2.params.id);
        this.electoratesStore.fetchShape(to2.params.id);
      }
    }
  },
  mounted() {
  }
};
function _sfc_ssrRender$e(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_mapbox_map = vue_cjs_prod.resolveComponent("mapbox-map");
  const _component_mapbox_geogeometry_polygon = vue_cjs_prod.resolveComponent("mapbox-geogeometry-polygon");
  const _component_PersonCard = __nuxt_component_6;
  const _component_Card = __nuxt_component_2$4;
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_colour_dot = __nuxt_component_3$3;
  const _component_ColourDot = __nuxt_component_3$3;
  if ($options.electorate) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "electorate-view" }, _attrs))} data-v-39bea13c>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:title",
            content: $options.electorate.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:description",
            content: $options.electorate.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "description",
            content: $options.electorate.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:title",
            content: $options.electorate.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:description",
            content: $options.electorate.description
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:title",
              content: $options.electorate.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:description",
              content: $options.electorate.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "description",
              content: $options.electorate.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:title",
              content: $options.electorate.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:description",
              content: $options.electorate.description
            }, null, 8, ["content"])
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
      pageTitle: $options.electorate.name,
      pageSubtitle: $options.electorate.description
    }, null, _parent));
    _push(`<div class="container-fluid hero pt-0" data-v-39bea13c>`);
    if ($options.shape && $options.shape["wts-comment"] != "noshape") {
      _push(serverRenderer.exports.ssrRenderComponent(_component_mapbox_map, {
        accessToken: "pk.eyJ1IjoiamFtZXNjbWFjZXkiLCJhIjoiY2xiN2VhYzVqMGE5YTN2bnhuM3l6d3pxbyJ9.CN_c4Tf7wXMtxyLKWrtvJg",
        height: "500px",
        mapStyle: "mapbox://styles/jamescmacey/clef24lj5000b01mlaqsjy2dl",
        customAttribution: ["Representation Commission", "Stats NZ", "Electoral Commission"],
        center: $options.center,
        zoom: 9,
        autoResize: true
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<!--[-->`);
            serverRenderer.exports.ssrRenderList($options.paths, (path2, i) => {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_mapbox_geogeometry_polygon, {
                key: i,
                path: path2,
                opacity: 0.2
              }, null, _parent2, _scopeId));
            });
            _push2(`<!--]-->`);
          } else {
            return [
              (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($options.paths, (path2, i) => {
                return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_mapbox_geogeometry_polygon, {
                  key: i,
                  path: path2,
                  opacity: 0.2
                }, null, 8, ["path", "opacity"]);
              }), 128))
            ];
          }
        }),
        _: 1
      }, _parent));
    } else {
      _push(`<!---->`);
    }
    _push(`</div><div class="mt-3 container" data-v-39bea13c>`);
    if (($options.electorate.status === "current" || $options.electorate.status === "retiring") && $options.electorate.incumbent) {
      _push(`<div data-v-39bea13c><div class="row" data-v-39bea13c><div class="col-12 col-xl-4" data-v-39bea13c><h4 data-v-39bea13c>Incumbent Member of Parliament</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, {
        person: $options.electorate.incumbent
      }, null, _parent));
      _push(`</div></div></div>`);
    } else {
      _push(`<!---->`);
    }
    if ($options.electorate.status !== "current") {
      _push(`<div data-v-39bea13c><div class="row" data-v-39bea13c><div class="col-12" data-v-39bea13c>`);
      if ($options.electorate.status === "retiring") {
        _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<h5 data-v-39bea13c${_scopeId}>This electorate is retiring`);
              if ($options.electorate.valid_to) {
                _push2(`<span data-v-39bea13c${_scopeId}> on ${serverRenderer.exports.ssrInterpolate($options.formatDate($options.electorate.valid_to))}</span>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`.</h5>`);
              if ($options.electorate.replaced_by) {
                _push2(`<p data-v-39bea13c${_scopeId}>The electorate of ${serverRenderer.exports.ssrInterpolate($options.electorate.name)} will be replaced by `);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/electorates/" + $options.electorate.replaced_by.slug
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${serverRenderer.exports.ssrInterpolate($options.electorate.replaced_by.name)}`);
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_by.name), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
                _push2(`.</p>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, [
                  vue_cjs_prod.createTextVNode("This electorate is retiring"),
                  $options.electorate.valid_to ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, " on " + vue_cjs_prod.toDisplayString($options.formatDate($options.electorate.valid_to)), 1)) : vue_cjs_prod.createCommentVNode("", true),
                  vue_cjs_prod.createTextVNode(".")
                ]),
                $options.electorate.replaced_by ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, [
                  vue_cjs_prod.createTextVNode("The electorate of " + vue_cjs_prod.toDisplayString($options.electorate.name) + " will be replaced by ", 1),
                  vue_cjs_prod.createVNode(_component_NuxtLink, {
                    to: "/electorates/" + $options.electorate.replaced_by.slug
                  }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_by.name), 1)
                    ]),
                    _: 1
                  }, 8, ["to"]),
                  vue_cjs_prod.createTextVNode(".")
                ])) : vue_cjs_prod.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      if ($options.electorate.status === "former") {
        _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<h5 data-v-39bea13c${_scopeId}>This electorate retired`);
              if ($options.electorate.valid_to) {
                _push2(`<span data-v-39bea13c${_scopeId}> on ${serverRenderer.exports.ssrInterpolate($options.formatDate($options.electorate.valid_to))}</span>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`.</h5>`);
              if ($options.electorate.replaced_by) {
                _push2(`<p data-v-39bea13c${_scopeId}>The electorate of ${serverRenderer.exports.ssrInterpolate($options.electorate.name)} has been replaced by `);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/electorates/" + $options.electorate.replaced_by.slug
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${serverRenderer.exports.ssrInterpolate($options.electorate.replaced_by.name)}`);
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_by.name), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
                _push2(`.</p>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vue_cjs_prod.createVNode("h5", null, [
                  vue_cjs_prod.createTextVNode("This electorate retired"),
                  $options.electorate.valid_to ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, " on " + vue_cjs_prod.toDisplayString($options.formatDate($options.electorate.valid_to)), 1)) : vue_cjs_prod.createCommentVNode("", true),
                  vue_cjs_prod.createTextVNode(".")
                ]),
                $options.electorate.replaced_by ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("p", { key: 0 }, [
                  vue_cjs_prod.createTextVNode("The electorate of " + vue_cjs_prod.toDisplayString($options.electorate.name) + " has been replaced by ", 1),
                  vue_cjs_prod.createVNode(_component_NuxtLink, {
                    to: "/electorates/" + $options.electorate.replaced_by.slug
                  }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_by.name), 1)
                    ]),
                    _: 1
                  }, 8, ["to"]),
                  vue_cjs_prod.createTextVNode(".")
                ])) : vue_cjs_prod.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div></div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`<div class="row" data-v-39bea13c><div class="col-12" data-v-39bea13c><h4 data-v-39bea13c>Previous MPs</h4><div class="form-check" data-v-39bea13c><input class="form-check-input" type="checkbox" value=""${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray($data.showReasons) ? serverRenderer.exports.ssrLooseContain($data.showReasons, "") : $data.showReasons) ? " checked" : ""} id="showReasons" data-v-39bea13c><label class="form-check-label" for="showReasons" data-v-39bea13c> Show reasons for commencement and conclusion of terms </label></div></div><div class="col-12" data-v-39bea13c>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<!--[-->`);
          serverRenderer.exports.ssrRenderList($options.affiliations, (affiliation, i) => {
            _push2(`<div data-v-39bea13c${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
              class: "NuxtLink",
              to: "/people/" + affiliation.person.slug
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  if (i == 0 || $options.affiliations[i].person.id != $options.affiliations[i - 1].person.id) {
                    _push3(`<div data-v-39bea13c${_scopeId2}>`);
                    if (affiliation.person.image) {
                      _push3(`<div class="d-flex align-items-center" data-v-39bea13c${_scopeId2}><div class="flex-shrink-0" data-v-39bea13c${_scopeId2}>`);
                      if (affiliation.person.image) {
                        _push3(`<img${serverRenderer.exports.ssrRenderAttr("src", affiliation.person.image)} class="me-3 person-image"${serverRenderer.exports.ssrRenderAttr("alt", affiliation.person.display_name)} data-v-39bea13c${_scopeId2}>`);
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(`</div><div class="flex-grow-1 ms-3" data-v-39bea13c${_scopeId2}><h5 data-v-39bea13c${_scopeId2}><strong data-v-39bea13c${_scopeId2}>${serverRenderer.exports.ssrInterpolate(affiliation.person.display_name)}</strong></h5><p class="text-muted" data-v-39bea13c${_scopeId2}>`);
                      if (affiliation.person.colour) {
                        _push3(serverRenderer.exports.ssrRenderComponent(_component_colour_dot, {
                          colour: affiliation.person.colour
                        }, null, _parent3, _scopeId2));
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(` Currently: ${serverRenderer.exports.ssrInterpolate(affiliation.person.description)}</p></div></div>`);
                    } else {
                      _push3(`<div data-v-39bea13c${_scopeId2}><h6 data-v-39bea13c${_scopeId2}><strong data-v-39bea13c${_scopeId2}>${serverRenderer.exports.ssrInterpolate(affiliation.person.display_name)}</strong></h6><p class="text-muted person-description" data-v-39bea13c${_scopeId2}>`);
                      if (affiliation.person.colour) {
                        _push3(serverRenderer.exports.ssrRenderComponent(_component_ColourDot, {
                          colour: affiliation.person.colour
                        }, null, _parent3, _scopeId2));
                      } else {
                        _push3(`<!---->`);
                      }
                      _push3(` Currently: ${serverRenderer.exports.ssrInterpolate(affiliation.person.description)}</p></div>`);
                    }
                    _push3(`</div>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`<div class="row" data-v-39bea13c${_scopeId2}><div class="col-1" data-v-39bea13c${_scopeId2}></div><div class="col-11" data-v-39bea13c${_scopeId2}><div class="row" data-v-39bea13c${_scopeId2}><div class="col-12 col-md-6" data-v-39bea13c${_scopeId2}><h6 class="affiliation-date-heading" data-v-39bea13c${_scopeId2}>Started:</h6> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.start_date))} `);
                  if ($data.showReasons && affiliation.start_reason_desc) {
                    _push3(`<h6 class="affiliation-date-heading" data-v-39bea13c${_scopeId2}>Reason: </h6>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  if ($data.showReasons && affiliation.start_reason_desc) {
                    _push3(`<span data-v-39bea13c${_scopeId2}>${serverRenderer.exports.ssrInterpolate(affiliation.start_reason_desc)}</span>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`</div>`);
                  if (affiliation.end_date) {
                    _push3(`<div class="col-12 col-md-6" data-v-39bea13c${_scopeId2}><h6 class="affiliation-date-heading" data-v-39bea13c${_scopeId2}>Ended:</h6> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.end_date))} `);
                    if ($data.showReasons && affiliation.end_reason_desc) {
                      _push3(`<h6 class="affiliation-date-heading" data-v-39bea13c${_scopeId2}>Reason: </h6>`);
                    } else {
                      _push3(`<!---->`);
                    }
                    if ($data.showReasons && affiliation.end_reason_desc) {
                      _push3(`<span data-v-39bea13c${_scopeId2}>${serverRenderer.exports.ssrInterpolate(affiliation.end_reason_desc)}</span>`);
                    } else {
                      _push3(`<!---->`);
                    }
                    _push3(`</div>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`</div>`);
                  if (i < $options.affiliations.length - 1 && $options.affiliations[i].person.id == $options.affiliations[i + 1].person.id) {
                    _push3(`<hr data-v-39bea13c${_scopeId2}>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`</div></div>`);
                  if (i < $options.affiliations.length - 1 && $options.affiliations[i].person.id != $options.affiliations[i + 1].person.id) {
                    _push3(`<hr data-v-39bea13c${_scopeId2}>`);
                  } else {
                    _push3(`<!---->`);
                  }
                } else {
                  return [
                    i == 0 || $options.affiliations[i].person.id != $options.affiliations[i - 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                      affiliation.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                        key: 0,
                        class: "d-flex align-items-center"
                      }, [
                        vue_cjs_prod.createVNode("div", { class: "flex-shrink-0" }, [
                          affiliation.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("img", {
                            key: 0,
                            src: affiliation.person.image,
                            class: "me-3 person-image",
                            alt: affiliation.person.display_name
                          }, null, 8, ["src", "alt"])) : vue_cjs_prod.createCommentVNode("", true)
                        ]),
                        vue_cjs_prod.createVNode("div", { class: "flex-grow-1 ms-3" }, [
                          vue_cjs_prod.createVNode("h5", null, [
                            vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(affiliation.person.display_name), 1)
                          ]),
                          vue_cjs_prod.createVNode("p", { class: "text-muted" }, [
                            affiliation.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                              key: 0,
                              colour: affiliation.person.colour
                            }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                            vue_cjs_prod.createTextVNode(" Currently: " + vue_cjs_prod.toDisplayString(affiliation.person.description), 1)
                          ])
                        ])
                      ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
                        vue_cjs_prod.createVNode("h6", null, [
                          vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(affiliation.person.display_name), 1)
                        ]),
                        vue_cjs_prod.createVNode("p", { class: "text-muted person-description" }, [
                          affiliation.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ColourDot, {
                            key: 0,
                            colour: affiliation.person.colour
                          }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                          vue_cjs_prod.createTextVNode(" Currently: " + vue_cjs_prod.toDisplayString(affiliation.person.description), 1)
                        ])
                      ]))
                    ])) : vue_cjs_prod.createCommentVNode("", true),
                    vue_cjs_prod.createVNode("div", { class: "row" }, [
                      vue_cjs_prod.createVNode("div", { class: "col-1" }),
                      vue_cjs_prod.createVNode("div", { class: "col-11" }, [
                        vue_cjs_prod.createVNode("div", { class: "row" }, [
                          vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6" }, [
                            vue_cjs_prod.createVNode("h6", { class: "affiliation-date-heading" }, "Started:"),
                            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.start_date)) + " ", 1),
                            $data.showReasons && affiliation.start_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h6", {
                              key: 0,
                              class: "affiliation-date-heading"
                            }, "Reason: ")) : vue_cjs_prod.createCommentVNode("", true),
                            $data.showReasons && affiliation.start_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, vue_cjs_prod.toDisplayString(affiliation.start_reason_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                          ]),
                          affiliation.end_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                            key: 0,
                            class: "col-12 col-md-6"
                          }, [
                            vue_cjs_prod.createVNode("h6", { class: "affiliation-date-heading" }, "Ended:"),
                            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.end_date)) + " ", 1),
                            $data.showReasons && affiliation.end_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h6", {
                              key: 0,
                              class: "affiliation-date-heading"
                            }, "Reason: ")) : vue_cjs_prod.createCommentVNode("", true),
                            $data.showReasons && affiliation.end_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, vue_cjs_prod.toDisplayString(affiliation.end_reason_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                          ])) : vue_cjs_prod.createCommentVNode("", true)
                        ]),
                        i < $options.affiliations.length - 1 && $options.affiliations[i].person.id == $options.affiliations[i + 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", { key: 0 })) : vue_cjs_prod.createCommentVNode("", true)
                      ])
                    ]),
                    i < $options.affiliations.length - 1 && $options.affiliations[i].person.id != $options.affiliations[i + 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", { key: 1 })) : vue_cjs_prod.createCommentVNode("", true)
                  ];
                }
              }),
              _: 2
            }, _parent2, _scopeId));
            _push2(`</div>`);
          });
          _push2(`<!--]--><hr data-v-39bea13c${_scopeId}><p class="text-muted" data-v-39bea13c${_scopeId}>These dates correspond to when an MP was eligible to sit and vote in the House of Representatives, not when they were declared elected. This list only includes MPs with profiles on WhereTheyStand, so it may contain some gaps.</p>`);
        } else {
          return [
            (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($options.affiliations, (affiliation, i) => {
              return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                key: affiliation.id
              }, [
                vue_cjs_prod.createVNode(_component_NuxtLink, {
                  class: "NuxtLink",
                  to: "/people/" + affiliation.person.slug
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    i == 0 || $options.affiliations[i].person.id != $options.affiliations[i - 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                      affiliation.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                        key: 0,
                        class: "d-flex align-items-center"
                      }, [
                        vue_cjs_prod.createVNode("div", { class: "flex-shrink-0" }, [
                          affiliation.person.image ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("img", {
                            key: 0,
                            src: affiliation.person.image,
                            class: "me-3 person-image",
                            alt: affiliation.person.display_name
                          }, null, 8, ["src", "alt"])) : vue_cjs_prod.createCommentVNode("", true)
                        ]),
                        vue_cjs_prod.createVNode("div", { class: "flex-grow-1 ms-3" }, [
                          vue_cjs_prod.createVNode("h5", null, [
                            vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(affiliation.person.display_name), 1)
                          ]),
                          vue_cjs_prod.createVNode("p", { class: "text-muted" }, [
                            affiliation.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_colour_dot, {
                              key: 0,
                              colour: affiliation.person.colour
                            }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                            vue_cjs_prod.createTextVNode(" Currently: " + vue_cjs_prod.toDisplayString(affiliation.person.description), 1)
                          ])
                        ])
                      ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
                        vue_cjs_prod.createVNode("h6", null, [
                          vue_cjs_prod.createVNode("strong", null, vue_cjs_prod.toDisplayString(affiliation.person.display_name), 1)
                        ]),
                        vue_cjs_prod.createVNode("p", { class: "text-muted person-description" }, [
                          affiliation.person.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ColourDot, {
                            key: 0,
                            colour: affiliation.person.colour
                          }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                          vue_cjs_prod.createTextVNode(" Currently: " + vue_cjs_prod.toDisplayString(affiliation.person.description), 1)
                        ])
                      ]))
                    ])) : vue_cjs_prod.createCommentVNode("", true),
                    vue_cjs_prod.createVNode("div", { class: "row" }, [
                      vue_cjs_prod.createVNode("div", { class: "col-1" }),
                      vue_cjs_prod.createVNode("div", { class: "col-11" }, [
                        vue_cjs_prod.createVNode("div", { class: "row" }, [
                          vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6" }, [
                            vue_cjs_prod.createVNode("h6", { class: "affiliation-date-heading" }, "Started:"),
                            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.start_date)) + " ", 1),
                            $data.showReasons && affiliation.start_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h6", {
                              key: 0,
                              class: "affiliation-date-heading"
                            }, "Reason: ")) : vue_cjs_prod.createCommentVNode("", true),
                            $data.showReasons && affiliation.start_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, vue_cjs_prod.toDisplayString(affiliation.start_reason_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                          ]),
                          affiliation.end_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                            key: 0,
                            class: "col-12 col-md-6"
                          }, [
                            vue_cjs_prod.createVNode("h6", { class: "affiliation-date-heading" }, "Ended:"),
                            vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.end_date)) + " ", 1),
                            $data.showReasons && affiliation.end_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h6", {
                              key: 0,
                              class: "affiliation-date-heading"
                            }, "Reason: ")) : vue_cjs_prod.createCommentVNode("", true),
                            $data.showReasons && affiliation.end_reason_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 1 }, vue_cjs_prod.toDisplayString(affiliation.end_reason_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                          ])) : vue_cjs_prod.createCommentVNode("", true)
                        ]),
                        i < $options.affiliations.length - 1 && $options.affiliations[i].person.id == $options.affiliations[i + 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", { key: 0 })) : vue_cjs_prod.createCommentVNode("", true)
                      ])
                    ]),
                    i < $options.affiliations.length - 1 && $options.affiliations[i].person.id != $options.affiliations[i + 1].person.id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", { key: 1 })) : vue_cjs_prod.createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["to"])
              ]);
            }), 128)),
            vue_cjs_prod.createVNode("hr"),
            vue_cjs_prod.createVNode("p", { class: "text-muted" }, "These dates correspond to when an MP was eligible to sit and vote in the House of Representatives, not when they were declared elected. This list only includes MPs with profiles on WhereTheyStand, so it may contain some gaps.")
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div>`);
    if ($options.electorate.replaced_electorate) {
      _push(`<div data-v-39bea13c><div class="row" data-v-39bea13c><div class="col-12" data-v-39bea13c><h4 data-v-39bea13c>History</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h5 data-v-39bea13c${_scopeId}>This electorate replaced the `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
              to: "/electorates/" + $options.electorate.replaced_electorate.slug
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate($options.electorate.replaced_electorate.name)}`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_electorate.name), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(` electorate on ${serverRenderer.exports.ssrInterpolate($options.formatDate($options.electorate.valid_from))}.</h5><p data-v-39bea13c${_scopeId}>See `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
              to: "/electorates/" + $options.electorate.replaced_electorate.slug
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate($options.electorate.replaced_electorate.name)}`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_electorate.name), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(` for more former MPs.</p>`);
          } else {
            return [
              vue_cjs_prod.createVNode("h5", null, [
                vue_cjs_prod.createTextVNode("This electorate replaced the "),
                vue_cjs_prod.createVNode(_component_NuxtLink, {
                  to: "/electorates/" + $options.electorate.replaced_electorate.slug
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_electorate.name), 1)
                  ]),
                  _: 1
                }, 8, ["to"]),
                vue_cjs_prod.createTextVNode(" electorate on " + vue_cjs_prod.toDisplayString($options.formatDate($options.electorate.valid_from)) + ".", 1)
              ]),
              vue_cjs_prod.createVNode("p", null, [
                vue_cjs_prod.createTextVNode("See "),
                vue_cjs_prod.createVNode(_component_NuxtLink, {
                  to: "/electorates/" + $options.electorate.replaced_electorate.slug
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.electorate.replaced_electorate.name), 1)
                  ]),
                  _: 1
                }, 8, ["to"]),
                vue_cjs_prod.createTextVNode(" for more former MPs.")
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div></div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$f = _sfc_main$f.setup;
_sfc_main$f.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/electorates/[id]/index.vue");
  return _sfc_setup$f ? _sfc_setup$f(props, ctx) : void 0;
};
const index$g = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["ssrRender", _sfc_ssrRender$e], ["__scopeId", "data-v-39bea13c"]]);
const index$h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$g
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$e = {
  name: "Electorates",
  setup() {
    const groupsStore = useGroupsStore();
    return { groupsStore };
  },
  created() {
    this.groupsStore.fetchElectorates("allCurrent");
    this.groupsStore.fetchElectorates("allHistoric");
  },
  computed: {
    electorates() {
      return (this.groupsStore.byName("allCurrent", "electorates") || []).sort((a, b) => {
        if (a.slug.toLowerCase() < b.slug.toLowerCase()) {
          return -1;
        }
        return 1;
      });
    },
    historicElectorates() {
      return (this.groupsStore.byName("allHistoric", "electorates") || []).sort((a, b) => {
        if (a.slug.toLowerCase() < b.slug.toLowerCase()) {
          return -1;
        }
        return 1;
      });
    }
  },
  components: { ElectorateCard: __nuxt_component_2$3 }
};
function _sfc_ssrRender$d(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_ExternalLinkButton = __nuxt_component_0$2;
  const _component_ElectorateCard = __nuxt_component_2$3;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)}>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "Electorates" }, null, _parent));
  _push(`<div class="container"><div class="row mt-3"><div class="col-12"><h4>New Zealand has 72 electoral districts, commonly known as electorates.</h4><p>There are 65 general electorates and 7 M\u0101ori electorates. The number, sizes, shapes, and names of these electorates are determined by the Representation Commission after each Census in accordance with requirements set out in the Electoral Act 1993. Generally, this means that the electorate boundaries are reviewed every eight years, or after every second general election.</p><p>At an election, voters cast a vote for a candidate who is contesting the electorate they live in. Whichever candidate receives the most votes (a plurality) becomes that electorate&#39;s Member of Parliament. In a general election, voters also cast a vote for their preferred political party; this vote determines how the remaining seats in Parliament (usually another 48 seats) are filled.</p>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
    link: "https://vote.nz/enrolling/get-ready-to-enrol/find-your-electorate-on-a-map/",
    text: "Find your electorate on a map"
  }, null, _parent));
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
    link: "https://elections.nz/democracy-in-nz/historical-events/boundary-review-2019-2020/",
    text: "Learn about the 2019-2020 Electorate Boundary Review"
  }, null, _parent));
  _push(`<p>By-elections are special, one-off elections that take place in an electorate outside the normal election cycle. These happen when an electorate MP leaves Parliament early, usually by resigning, and a new electorate MP needs to be elected to replace them. In 2020, there were two by-elections: one in Tauranga, and one in Hamilton West.</p>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
    link: "https://tauranga.election.wheretheystand.nz/",
    text: "View Tauranga by-election results (June 2022)"
  }, null, _parent));
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
    link: "https://election.wheretheystand.nz/",
    text: "View Hamilton West by-election results (December 2022)"
  }, null, _parent));
  _push(`<h5 class="mt-3">Current electorates</h5><div class="row"><!--[-->`);
  serverRenderer.exports.ssrRenderList($options.electorates, (electorate, i) => {
    _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_ElectorateCard, { electorate }, null, _parent));
    _push(`</div>`);
  });
  _push(`<!--]--></div><h5 class="mt-3">Former electorates</h5><p class="mt-0">Only electorates that have existed since 2014 have profiles on WhereTheyStand.</p><div class="row"><!--[-->`);
  serverRenderer.exports.ssrRenderList($options.historicElectorates, (electorate, i) => {
    _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_ElectorateCard, { electorate }, null, _parent));
    _push(`</div>`);
  });
  _push(`<!--]--></div></div></div></div></div>`);
}
const _sfc_setup$e = _sfc_main$e.setup;
_sfc_main$e.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/electorates/index.vue");
  return _sfc_setup$e ? _sfc_setup$e(props, ctx) : void 0;
};
const index$e = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["ssrRender", _sfc_ssrRender$d]]);
const index$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$e
}, Symbol.toStringTag, { value: "Module" }));
const __default__ = {
  name: "Home",
  components: {},
  methods: {
    relativeDate(date2) {
      return formatDistanceToNow(parse$2(date2, "yyyy-MM-dd", new Date())) + " ago";
    },
    formattedDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d.M.yyyy");
    },
    formattedDateFull(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  }
};
const _sfc_main$d = /* @__PURE__ */ Object.assign(__default__, {
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const { data: homepageData } = ([__temp, __restore] = vue_cjs_prod.withAsyncContext(() => useFetch(API_BASE + "client/homepage/")), __temp = await __temp, __restore(), __temp);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Card = __nuxt_component_2$4;
      const _component_SearchBar = __nuxt_component_1$4;
      const _component_RandomResource = __nuxt_component_2$2;
      const _component_NuxtLink = __nuxt_component_1$7;
      const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
      const _component_ExternalLinkInline = __nuxt_component_3$4;
      _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-6091f714><div id="cover-image" class="container-fluid text-start py-5" data-v-6091f714><div class="container" data-v-6091f714><div class="row" data-v-6091f714><div class="col-12 col-xl-8 py-xl-5 py-2" data-v-6091f714><h1 class="display-4" data-v-6091f714>Wondering where they stand?</h1><hr data-v-6091f714><h3 data-v-6091f714> WhereTheyStand aggregates voting data, financial information, biographical information, and more. </h3></div><div id="onboarding" class="col-12 col-xl-4 py-xl-5 py-2" data-v-6091f714>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { frosted: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<h4 class="mt-2" data-v-6091f714${_scopeId}>Find your MP, electorate or party</h4> All MPs who&#39;ve been in Parliament since 2014 have profiles. `);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SearchBar, { class: "mt-2" }, null, _parent2, _scopeId));
            _push2(serverRenderer.exports.ssrRenderComponent(_component_RandomResource, null, null, _parent2, _scopeId));
          } else {
            return [
              vue_cjs_prod.createVNode("h4", { class: "mt-2" }, "Find your MP, electorate or party"),
              vue_cjs_prod.createTextVNode(" All MPs who've been in Parliament since 2014 have profiles. "),
              vue_cjs_prod.createVNode(_component_SearchBar, { class: "mt-2" }),
              vue_cjs_prod.createVNode(_component_RandomResource)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></div><div class="container mt-3" data-v-6091f714><div class="row" data-v-6091f714><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Recent votes</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vue_cjs_prod.unref(homepageData)) {
              _push2(`<div data-v-6091f714${_scopeId}><ul class="homepage-resource-list" data-v-6091f714${_scopeId}><!--[-->`);
              serverRenderer.exports.ssrRenderList(vue_cjs_prod.unref(homepageData).votes, (vote, i) => {
                _push2(`<li class="mb-3 vote-list" data-v-6091f714${_scopeId}><h6 class="mb-0" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(vote.name)}</h6><small class="me-1" data-v-6091f714${_scopeId}>`);
                if (vote.type_desc) {
                  _push2(`<span class="badge bg-primary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(vote.type_desc)}</span>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</small><small class="text-muted text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(_ctx.formattedDateFull(vote.date))}</small><br data-v-6091f714${_scopeId}><div class="text-start" data-v-6091f714${_scopeId}>`);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/votes/" + vote.id,
                  class: "vote-link mt-1"
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`View vote `);
                      _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent3, _scopeId2));
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode("View vote "),
                        vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
                _push2(`</div>`);
                if (i < 4) {
                  _push2(`<hr class="mt-1" data-v-6091f714${_scopeId}>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</li>`);
              });
              _push2(`<!--]--></ul></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vue_cjs_prod.unref(homepageData) ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                vue_cjs_prod.createVNode("ul", { class: "homepage-resource-list" }, [
                  (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList(vue_cjs_prod.unref(homepageData).votes, (vote, i) => {
                    return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                      key: vote.id,
                      class: "mb-3 vote-list"
                    }, [
                      vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(vote.name), 1),
                      vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                        vote.type_desc ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          class: "badge bg-primary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(vote.type_desc), 1)) : vue_cjs_prod.createCommentVNode("", true)
                      ]),
                      vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(_ctx.formattedDateFull(vote.date)), 1),
                      vue_cjs_prod.createVNode("br"),
                      vue_cjs_prod.createVNode("div", { class: "text-start" }, [
                        vue_cjs_prod.createVNode(_component_NuxtLink, {
                          to: "/votes/" + vote.id,
                          class: "vote-link mt-1"
                        }, {
                          default: vue_cjs_prod.withCtx(() => [
                            vue_cjs_prod.createTextVNode("View vote "),
                            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                          ]),
                          _: 2
                        }, 1032, ["to"])
                      ]),
                      i < 4 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", {
                        key: 0,
                        class: "mt-1"
                      })) : vue_cjs_prod.createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Recently updated bills</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vue_cjs_prod.unref(homepageData)) {
              _push2(`<div data-v-6091f714${_scopeId}><ul class="homepage-resource-list" data-v-6091f714${_scopeId}><!--[-->`);
              serverRenderer.exports.ssrRenderList(vue_cjs_prod.unref(homepageData).bills, (bill, i) => {
                _push2(`<li class="mb-3 bill-list" data-v-6091f714${_scopeId}><h6 class="mb-0" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.name)}</h6><small class="me-1" data-v-6091f714${_scopeId}>`);
                if (bill.progress == "inp") {
                  _push2(`<span class="badge bg-primary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "pas") {
                  _push2(`<span class="badge bg-success text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "ena") {
                  _push2(`<span class="badge bg-success text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "dis") {
                  _push2(`<span class="badge bg-warning text-dark text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "def") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "lap") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "unx") {
                  _push2(`<span class="badge bg-danger text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "div") {
                  _push2(`<span class="badge bg-info text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else if (bill.progress == "wit") {
                  _push2(`<span class="badge bg-warning text-dark text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                } else {
                  _push2(`<span class="badge bg-secondary text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.progress_desc)}</span>`);
                }
                _push2(`</small><small class="text-muted text-uppercase" data-v-6091f714${_scopeId}>${serverRenderer.exports.ssrInterpolate(bill.type_desc)}</small><div class="text-start" data-v-6091f714${_scopeId}>`);
                _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                  to: "/bills/" + bill.id,
                  class: "bill-link mt-1"
                }, {
                  default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`View bill `);
                      _push3(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent3, _scopeId2));
                    } else {
                      return [
                        vue_cjs_prod.createTextVNode("View bill "),
                        vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
                _push2(`</div>`);
                if (i < 4) {
                  _push2(`<hr class="mt-1" data-v-6091f714${_scopeId}>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</li>`);
              });
              _push2(`<!--]--></ul></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vue_cjs_prod.unref(homepageData) ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                vue_cjs_prod.createVNode("ul", { class: "homepage-resource-list" }, [
                  (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList(vue_cjs_prod.unref(homepageData).bills, (bill, i) => {
                    return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", {
                      key: bill.id,
                      class: "mb-3 bill-list"
                    }, [
                      vue_cjs_prod.createVNode("h6", { class: "mb-0" }, vue_cjs_prod.toDisplayString(bill.name), 1),
                      vue_cjs_prod.createVNode("small", { class: "me-1" }, [
                        bill.progress == "inp" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 0,
                          class: "badge bg-primary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "pas" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 1,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "ena" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 2,
                          class: "badge bg-success text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "dis" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 3,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "def" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 4,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "lap" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 5,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "unx" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 6,
                          class: "badge bg-danger text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "div" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 7,
                          class: "badge bg-info text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : bill.progress == "wit" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 8,
                          class: "badge bg-warning text-dark text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1)) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                          key: 9,
                          class: "badge bg-secondary text-uppercase"
                        }, vue_cjs_prod.toDisplayString(bill.progress_desc), 1))
                      ]),
                      vue_cjs_prod.createVNode("small", { class: "text-muted text-uppercase" }, vue_cjs_prod.toDisplayString(bill.type_desc), 1),
                      vue_cjs_prod.createVNode("div", { class: "text-start" }, [
                        vue_cjs_prod.createVNode(_component_NuxtLink, {
                          to: "/bills/" + bill.id,
                          class: "bill-link mt-1"
                        }, {
                          default: vue_cjs_prod.withCtx(() => [
                            vue_cjs_prod.createTextVNode("View bill "),
                            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] })
                          ]),
                          _: 2
                        }, 1032, ["to"])
                      ]),
                      i < 4 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", {
                        key: 0,
                        class: "mt-1"
                      })) : vue_cjs_prod.createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ])) : vue_cjs_prod.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div><div class="col-12 col-xl-4" data-v-6091f714><h4 data-v-6091f714>Elections</h4>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="election" data-v-6091f714${_scopeId}><h5 data-v-6091f714${_scopeId}>2022 Hamilton West by-election</h5><span data-v-6091f714${_scopeId}>10 December 2022</span><br data-v-6091f714${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Interactive results`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode("Interactive results")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div><hr data-v-6091f714${_scopeId}><div class="election" data-v-6091f714${_scopeId}><h5 data-v-6091f714${_scopeId}>2022 Tauranga by-election</h5><span data-v-6091f714${_scopeId}>18 June 2022</span><br data-v-6091f714${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Interactive results `);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode("Interactive results ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div>`);
          } else {
            return [
              vue_cjs_prod.createVNode("div", { class: "election" }, [
                vue_cjs_prod.createVNode("h5", null, "2022 Hamilton West by-election"),
                vue_cjs_prod.createVNode("span", null, "10 December 2022"),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode("Interactive results")
                  ]),
                  _: 1
                })
              ]),
              vue_cjs_prod.createVNode("hr"),
              vue_cjs_prod.createVNode("div", { class: "election" }, [
                vue_cjs_prod.createVNode("h5", null, "2022 Tauranga by-election"),
                vue_cjs_prod.createVNode("span", null, "18 June 2022"),
                vue_cjs_prod.createVNode("br"),
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode("Interactive results ")
                  ]),
                  _: 1
                })
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div></div>`);
    };
  }
});
const _sfc_setup$d = _sfc_main$d.setup;
_sfc_main$d.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/index.vue");
  return _sfc_setup$d ? _sfc_setup$d(props, ctx) : void 0;
};
const index$c = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-6091f714"]]);
const index$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$c
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$c = {
  name: "PartyDocuments",
  setup() {
    const partiesStore = usePartiesStore();
    return { partiesStore };
  },
  created() {
  },
  methods: {
    formatCurrency(amount) {
      var formatter = new Intl.NumberFormat("en-NZ", {
        style: "currency",
        currency: "NZD"
      });
      if (amount != null) {
        return formatter.format(amount);
      } else {
        return "-";
      }
    }
  },
  computed: {
    party() {
      return this.partiesStore.byIdentifier(this.$route.params.id);
    }
  }
};
function _sfc_ssrRender$c(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}><div class="row mt-3"><div class="col-12"><h4>Documents</h4></div></div></div>`);
}
const _sfc_setup$c = _sfc_main$c.setup;
_sfc_main$c.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/parties/[id]/documents.vue");
  return _sfc_setup$c ? _sfc_setup$c(props, ctx) : void 0;
};
const documents = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["ssrRender", _sfc_ssrRender$c]]);
const documents$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": documents
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$b = {
  name: "PersonHome",
  setup() {
    const partiesStore = usePartiesStore();
    return { partiesStore };
  },
  created() {
    this.partiesStore.fetchMembers(this.$route.params.id);
    this.partiesStore.fetchLeaders(this.$route.params.id);
  },
  computed: {
    members() {
      var members = this.partiesStore.membersByIdentifier(this.$route.params.id);
      if (members === void 0) {
        members = [];
      }
      return members.filter((member) => {
        if (this.leaders.find((leader) => leader.id == member.id) === void 0) {
          return true;
        } else {
          return false;
        }
      });
    },
    leaders() {
      return this.partiesStore.leadersByIdentifier(this.$route.params.id);
    },
    party() {
      return this.partiesStore.byIdentifier(this.$route.params.id);
    }
  }
};
function _sfc_ssrRender$b(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_PersonList = __nuxt_component_7;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}><div class="row mt-3"><div class="col-12">`);
  if ($options.leaders && $options.leaders.length == 1) {
    _push(`<h4>${serverRenderer.exports.ssrInterpolate($options.party.party_leader_role)}</h4>`);
  } else if ($options.leaders && $options.leaders.length > 1) {
    _push(`<h4>${serverRenderer.exports.ssrInterpolate($options.party.party_leader_role_plural)}</h4>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.leaders && $options.leaders.length >= 1) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { people: $options.leaders }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_PersonList, { people: $options.leaders }, null, 8, ["people"])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(`<!---->`);
  }
  if ($options.members && $options.members.length == 1) {
    _push(`<h4>Member</h4>`);
  } else if ($options.members && $options.members.length > 1) {
    _push(`<h4>Members</h4>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.members && $options.members.length >= 1) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { people: $options.members }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_PersonList, { people: $options.members }, null, 8, ["people"])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(`<!---->`);
  }
  _push(`</div></div></div>`);
}
const _sfc_setup$b = _sfc_main$b.setup;
_sfc_main$b.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/parties/[id]/index.vue");
  return _sfc_setup$b ? _sfc_setup$b(props, ctx) : void 0;
};
const index$a = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["ssrRender", _sfc_ssrRender$b]]);
const index$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$a
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$a = {
  name: "Party",
  setup() {
    const partiesStore = usePartiesStore();
    return { partiesStore };
  },
  created() {
    this.partiesStore.fetch(this.$route.params.id);
  },
  computed: {
    links() {
      return [
        {
          to: "/parties/" + this.$route.params.id,
          name: "Overview"
        }
      ];
    },
    party() {
      return this.partiesStore.byIdentifier(this.$route.params.id);
    },
    pageSubtitle() {
      if (this.party.display_name != this.party.legal_name) {
        return this.party.legal_name;
      }
    }
  }
};
function _sfc_ssrRender$a(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_NuxtPage = vue_cjs_prod.resolveComponent("NuxtPage");
  if ($options.party) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "party-view" }, _attrs))}>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:title",
            content: $options.party.display_name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:description",
            content: $options.pageSubtitle
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "description",
            content: $options.pageSubtitle
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:title",
            content: $options.party.display_name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:description",
            content: $options.pageSubtitle
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:title",
              content: $options.party.display_name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:description",
              content: $options.pageSubtitle
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "description",
              content: $options.pageSubtitle
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:title",
              content: $options.party.display_name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:description",
              content: $options.pageSubtitle
            }, null, 8, ["content"])
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
      pageTitle: $options.party.display_name,
      pageSubtitle: $options.pageSubtitle,
      colour: $options.party.colour,
      pageLinks: $options.links
    }, null, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtPage, { party: $options.party }, null, _parent));
    _push(`</div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$a = _sfc_main$a.setup;
_sfc_main$a.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/parties/[id].vue");
  return _sfc_setup$a ? _sfc_setup$a(props, ctx) : void 0;
};
const _id_$2 = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["ssrRender", _sfc_ssrRender$a]]);
const _id_$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _id_$2
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$9 = {
  name: "Parties",
  setup() {
    const groupsStore = useGroupsStore();
    return { groupsStore };
  },
  created() {
    this.groupsStore.fetchParties("allInParliament");
  },
  computed: {
    parties() {
      return (this.groupsStore.byName("allInParliament", "parties") || []).sort((a, b) => {
        if (a.seats > b.seats) {
          return -1;
        }
        return 1;
      });
    },
    outsideParties() {
      return (this.groupsStore.byName("allOutOfParliament", "parties") || []).sort((a, b) => {
        if (a.slug.toLowerCase() < b.slug.toLowerCase()) {
          return -1;
        }
        return 1;
      });
    }
  },
  components: { PartyCard: __nuxt_component_5$2 }
};
function _sfc_ssrRender$9(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_ExternalLinkButton = __nuxt_component_0$2;
  const _component_PartyCard = __nuxt_component_5$2;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)}>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "Parties" }, null, _parent));
  _push(`<div class="container"><div class="row mt-3"><div class="col-12"><h4>Most Members of Parliament belong to a political organisation, called a party.</h4><p>The number of seats a party has in Parliament is determined by the proportion of votes it receives under the party vote at each general election. If any electorate seats are won by a party&#39;s candidates, its seats first go to those candidates. Any leftover seats are then given to list candidates, who are elected according to a ranked list of candidates finalised before the election.</p><p>Political parties and their funding are regulated in New Zealand by the Electoral Commission in accordance with the Electoral Act 1993.</p>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, { link: "https://elections.nz/democracy-in-nz/political-parties-in-new-zealand/" }, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`Learn more about the role of political parties in New Zealand&#39;s democracy`);
      } else {
        return [
          vue_cjs_prod.createTextVNode("Learn more about the role of political parties in New Zealand's democracy")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`<p>Outside of elections, parties play an important role in Parliament and in government. Many votes cast in Parliament on proposed laws are cast as party votes, where a party casts a vote on behalf of all its member MPs. Party membership and size also determines the allocation of Parliamentary resources, like Oral Questions and Select Committee membership. It&#39;s also a major factor in deciding which party or parties form the Government, and who becomes the Prime Minister or a Minister.</p><h5 class="mt-3">Parties with seats in Parliament</h5><div class="row"><!--[-->`);
  serverRenderer.exports.ssrRenderList($options.parties, (party, i) => {
    _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_PartyCard, { party }, null, _parent));
    _push(`</div>`);
  });
  _push(`<!--]--></div><p class="text-muted">For registered parties, their registered name is shown on this page. Some parties may have adopted different names in a Parliamentary context or for marketing purposes.</p></div></div></div></div>`);
}
const _sfc_setup$9 = _sfc_main$9.setup;
_sfc_main$9.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/parties/index.vue");
  return _sfc_setup$9 ? _sfc_setup$9(props, ctx) : void 0;
};
const index$8 = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["ssrRender", _sfc_ssrRender$9]]);
const index$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$8
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$8 = {
  name: "PersonDetails",
  setup() {
    const peopleStore = usePeopleStore();
    return { peopleStore };
  },
  data() {
    return {
      showReasons: false,
      parliamentaryAffiliationCount: 1
    };
  },
  created() {
    this.peopleStore.fetchDetails(this.$route.params.id);
  },
  mounted() {
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    },
    ordinal_suffix_of(i) {
      var j = i % 10;
      var k = i % 100;
      if (j === 1 && k !== 11) {
        return i + "st";
      }
      if (j === 2 && k !== 12) {
        return i + "nd";
      }
      if (j === 3 && k !== 13) {
        return i + "rd";
      }
      return i + "th";
    }
  },
  computed: {
    details() {
      return this.peopleStore.detailsByIdentifier(this.$route.params.id);
    },
    currentAge() {
      return "TODO years";
    },
    ageAtDeath() {
      return "TODO years";
    }
  }
};
function _sfc_ssrRender$8(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_NuxtLink = __nuxt_component_1$7;
  const _component_DisplayControlButton = __nuxt_component_2$1;
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_ColourDot = __nuxt_component_3$3;
  const _component_twitter_user_Card = __nuxt_component_4;
  const _component_SocialMediaLink = __nuxt_component_5$1;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}>`);
  if ($options.details) {
    _push(`<div class="row mt-3"><div class="col-12 col-md-6"><h4>Parliamentary history</h4><div class="form-check"><input class="form-check-input" type="checkbox" value=""${serverRenderer.exports.ssrIncludeBooleanAttr(Array.isArray($data.showReasons) ? serverRenderer.exports.ssrLooseContain($data.showReasons, "") : $data.showReasons) ? " checked" : ""} id="showReasons"><label class="form-check-label" for="showReasons"> Show reasons </label></div>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<!--[-->`);
          serverRenderer.exports.ssrRenderList($options.details.parliamentary_affiliations.slice(0, $data.parliamentaryAffiliationCount), (affiliation, i) => {
            _push2(`<div${_scopeId}>`);
            if (affiliation.electorate) {
              _push2(`<h5${_scopeId}>MP for `);
              _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
                to: "/electorates/" + affiliation.electorate.slug
              }, {
                default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${serverRenderer.exports.ssrInterpolate(affiliation.electorate.name)}`);
                  } else {
                    return [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(affiliation.electorate.name), 1)
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(`</h5>`);
            } else if (affiliation.fallback_electorate_slug) {
              _push2(`<h5${_scopeId}>MP for <span class="text-uppercase text-muted"${_scopeId}>${serverRenderer.exports.ssrInterpolate(affiliation.fallback_electorate_slug)}</span></h5>`);
            } else {
              _push2(`<h5${_scopeId}>List MP</h5>`);
            }
            _push2(`<h6${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
              to: "/parliaments/" + affiliation.parliament.number
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate($options.ordinal_suffix_of(affiliation.parliament.number))} Parliament`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.ordinal_suffix_of(affiliation.parliament.number)) + " Parliament", 1)
                  ];
                }
              }),
              _: 2
            }, _parent2, _scopeId));
            _push2(`</h6><div class="row"${_scopeId}><div class="col-12 col-md-6"${_scopeId}><strong${_scopeId}>Started:</strong> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.start_date))}<br${_scopeId}>`);
            if (affiliation.start_reason_desc && $data.showReasons) {
              _push2(`<span${_scopeId}><strong${_scopeId}>Reason:</strong> ${serverRenderer.exports.ssrInterpolate(affiliation.start_reason_desc)}</span>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
            if (affiliation.end_date) {
              _push2(`<div class="col-12 col-md-6"${_scopeId}><strong${_scopeId}>Ended:</strong> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.end_date))}<br${_scopeId}>`);
              if (affiliation.end_reason_desc && $data.showReasons) {
                _push2(`<span${_scopeId}><strong${_scopeId}>Reason:</strong> ${serverRenderer.exports.ssrInterpolate(affiliation.end_reason_desc)}</span>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><hr${_scopeId}></div>`);
          });
          _push2(`<!--]--><p class="text-muted"${_scopeId}>These dates correspond to when an MP was eligible to sit and vote in the House of Representatives, not when they were declared elected.</p>`);
        } else {
          return [
            (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($options.details.parliamentary_affiliations.slice(0, $data.parliamentaryAffiliationCount), (affiliation, i) => {
              return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: i }, [
                affiliation.electorate ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", { key: 0 }, [
                  vue_cjs_prod.createTextVNode("MP for "),
                  vue_cjs_prod.createVNode(_component_NuxtLink, {
                    to: "/electorates/" + affiliation.electorate.slug
                  }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(affiliation.electorate.name), 1)
                    ]),
                    _: 2
                  }, 1032, ["to"])
                ])) : affiliation.fallback_electorate_slug ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", { key: 1 }, [
                  vue_cjs_prod.createTextVNode("MP for "),
                  vue_cjs_prod.createVNode("span", { class: "text-uppercase text-muted" }, vue_cjs_prod.toDisplayString(affiliation.fallback_electorate_slug), 1)
                ])) : (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("h5", { key: 2 }, "List MP")),
                vue_cjs_prod.createVNode("h6", null, [
                  vue_cjs_prod.createVNode(_component_NuxtLink, {
                    to: "/parliaments/" + affiliation.parliament.number
                  }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString($options.ordinal_suffix_of(affiliation.parliament.number)) + " Parliament", 1)
                    ]),
                    _: 2
                  }, 1032, ["to"])
                ]),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6" }, [
                    vue_cjs_prod.createVNode("strong", null, "Started:"),
                    vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.start_date)), 1),
                    vue_cjs_prod.createVNode("br"),
                    affiliation.start_reason_desc && $data.showReasons ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, [
                      vue_cjs_prod.createVNode("strong", null, "Reason:"),
                      vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString(affiliation.start_reason_desc), 1)
                    ])) : vue_cjs_prod.createCommentVNode("", true)
                  ]),
                  affiliation.end_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                    key: 0,
                    class: "col-12 col-md-6"
                  }, [
                    vue_cjs_prod.createVNode("strong", null, "Ended:"),
                    vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.end_date)), 1),
                    vue_cjs_prod.createVNode("br"),
                    affiliation.end_reason_desc && $data.showReasons ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, [
                      vue_cjs_prod.createVNode("strong", null, "Reason:"),
                      vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString(affiliation.end_reason_desc), 1)
                    ])) : vue_cjs_prod.createCommentVNode("", true)
                  ])) : vue_cjs_prod.createCommentVNode("", true)
                ]),
                vue_cjs_prod.createVNode("hr")
              ]);
            }), 128)),
            vue_cjs_prod.createVNode("p", { class: "text-muted" }, "These dates correspond to when an MP was eligible to sit and vote in the House of Representatives, not when they were declared elected.")
          ];
        }
      }),
      _: 1
    }, _parent));
    if ($options.details.parliamentary_affiliations.length > $data.parliamentaryAffiliationCount) {
      _push(`<div>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
        onClick: ($event) => $data.parliamentaryAffiliationCount = $options.details.parliamentary_affiliations.length
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }, null, _parent2, _scopeId));
            _push2(` Show all Parliamentary affiliations `);
          } else {
            return [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }),
              vue_cjs_prod.createTextVNode(" Show all Parliamentary affiliations ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
    } else if ($data.parliamentaryAffiliationCount === $options.details.parliamentary_affiliations.length && $data.parliamentaryAffiliationCount > 1) {
      _push(`<div>`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
        onClick: ($event) => $data.parliamentaryAffiliationCount = 1
      }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }, null, _parent2, _scopeId));
            _push2(` Show fewer Parliamentary affiliations `);
          } else {
            return [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }),
              vue_cjs_prod.createTextVNode(" Show fewer Parliamentary affiliations ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div><div class="col-12 col-md-6"><h4>Party history</h4>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<!--[-->`);
          serverRenderer.exports.ssrRenderList($options.details.party_affiliations, (affiliation, i) => {
            _push2(`<div${_scopeId}><h5${_scopeId}>`);
            if (affiliation.party.colour) {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_ColourDot, {
                colour: affiliation.party.colour
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(serverRenderer.exports.ssrRenderComponent(_component_NuxtLink, {
              to: "/parties/" + affiliation.party.slug
            }, {
              default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${serverRenderer.exports.ssrInterpolate(affiliation.party.display_name)}`);
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(affiliation.party.display_name), 1)
                  ];
                }
              }),
              _: 2
            }, _parent2, _scopeId));
            _push2(`</h5><div class="row"${_scopeId}><div class="col-12 col-md-6"${_scopeId}><strong${_scopeId}>Started:</strong> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.start_date))}<br${_scopeId}></div>`);
            if (affiliation.end_date) {
              _push2(`<div class="col-12 col-md-6"${_scopeId}><strong${_scopeId}>Ended:</strong> ${serverRenderer.exports.ssrInterpolate($options.formatDate(affiliation.end_date))}<br${_scopeId}></div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
            if (i !== $options.details.party_affiliations.length - 1) {
              _push2(`<hr${_scopeId}>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
          });
          _push2(`<!--]-->`);
        } else {
          return [
            (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($options.details.party_affiliations, (affiliation, i) => {
              return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: i }, [
                vue_cjs_prod.createVNode("h5", null, [
                  affiliation.party.colour ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_ColourDot, {
                    key: 0,
                    colour: affiliation.party.colour
                  }, null, 8, ["colour"])) : vue_cjs_prod.createCommentVNode("", true),
                  vue_cjs_prod.createVNode(_component_NuxtLink, {
                    to: "/parties/" + affiliation.party.slug
                  }, {
                    default: vue_cjs_prod.withCtx(() => [
                      vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(affiliation.party.display_name), 1)
                    ]),
                    _: 2
                  }, 1032, ["to"])
                ]),
                vue_cjs_prod.createVNode("div", { class: "row" }, [
                  vue_cjs_prod.createVNode("div", { class: "col-12 col-md-6" }, [
                    vue_cjs_prod.createVNode("strong", null, "Started:"),
                    vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.start_date)), 1),
                    vue_cjs_prod.createVNode("br")
                  ]),
                  affiliation.end_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", {
                    key: 0,
                    class: "col-12 col-md-6"
                  }, [
                    vue_cjs_prod.createVNode("strong", null, "Ended:"),
                    vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.formatDate(affiliation.end_date)), 1),
                    vue_cjs_prod.createVNode("br")
                  ])) : vue_cjs_prod.createCommentVNode("", true)
                ]),
                i !== $options.details.party_affiliations.length - 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("hr", { key: 0 })) : vue_cjs_prod.createCommentVNode("", true)
              ]);
            }), 128))
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.details) {
    _push(`<div class="row">`);
    if ($options.details.twitter_user) {
      _push(`<div class="col-12 col-md-6"><h4>Contacts and social media</h4></div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</div>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.details) {
    _push(`<div class="row">`);
    if ($options.details.twitter_user) {
      _push(`<div class="col-12 col-md-6">`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_twitter_user_Card, {
        user: $options.details.twitter_user
      }, null, _parent));
      _push(`</div>`);
    } else {
      _push(`<!---->`);
    }
    _push(`<div class="col-12 col-md-6">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h5${_scopeId}>Bio</h5>`);
          if ($options.details.bio.email_address) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Email address</h6><span class="text-lowercase"${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.details.bio.email_address)}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.birth_date) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Date of Birth</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatDate($options.details.bio.birth_date))}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.birth_date && !$options.details.bio.death_date) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Age</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.currentAge)}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.death_date) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Passed away</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.formatDate($options.details.bio.death_date))}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.death_date && $options.details.bio.birth_date) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Age at death</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.ageAtDeath)}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.wikidata_id) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Wikidata ID</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.details.bio.wikidata_id)}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.turnbull_id) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Alexander Turnbull Library ID</h6><span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.details.bio.turnbull_id)}</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.snapchat_user) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Snapchat</h6><span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SocialMediaLink, {
              username: $options.details.bio.snapchat_user,
              platform: "snapchat"
            }, null, _parent2, _scopeId));
            _push2(`</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.instagram_user) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Instagram</h6><span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SocialMediaLink, {
              username: $options.details.bio.instagram_user,
              platform: "instagram"
            }, null, _parent2, _scopeId));
            _push2(`</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.facebook_page) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Facebook</h6><span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SocialMediaLink, {
              username: $options.details.bio.facebook_page,
              platform: "facebook"
            }, null, _parent2, _scopeId));
            _push2(`</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.details.bio.wikipedia_page) {
            _push2(`<div${_scopeId}><h6${_scopeId}>Wikipedia</h6><span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_SocialMediaLink, {
              username: $options.details.bio.wikipedia_page,
              platform: "wikipedia"
            }, null, _parent2, _scopeId));
            _push2(`</span><hr${_scopeId}></div>`);
          } else {
            _push2(`<!---->`);
          }
        } else {
          return [
            vue_cjs_prod.createVNode("h5", null, "Bio"),
            $options.details.bio.email_address ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
              vue_cjs_prod.createVNode("h6", null, "Email address"),
              vue_cjs_prod.createVNode("span", { class: "text-lowercase" }, vue_cjs_prod.toDisplayString($options.details.bio.email_address), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.birth_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 1 }, [
              vue_cjs_prod.createVNode("h6", null, "Date of Birth"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.formatDate($options.details.bio.birth_date)), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.birth_date && !$options.details.bio.death_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 2 }, [
              vue_cjs_prod.createVNode("h6", null, "Age"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.currentAge), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.death_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 3 }, [
              vue_cjs_prod.createVNode("h6", null, "Passed away"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.formatDate($options.details.bio.death_date)), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.death_date && $options.details.bio.birth_date ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 4 }, [
              vue_cjs_prod.createVNode("h6", null, "Age at death"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.ageAtDeath), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.wikidata_id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 5 }, [
              vue_cjs_prod.createVNode("h6", null, "Wikidata ID"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.details.bio.wikidata_id), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.turnbull_id ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 6 }, [
              vue_cjs_prod.createVNode("h6", null, "Alexander Turnbull Library ID"),
              vue_cjs_prod.createVNode("span", null, vue_cjs_prod.toDisplayString($options.details.bio.turnbull_id), 1),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.snapchat_user ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 7 }, [
              vue_cjs_prod.createVNode("h6", null, "Snapchat"),
              vue_cjs_prod.createVNode("span", null, [
                vue_cjs_prod.createVNode(_component_SocialMediaLink, {
                  username: $options.details.bio.snapchat_user,
                  platform: "snapchat"
                }, null, 8, ["username"])
              ]),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.instagram_user ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 8 }, [
              vue_cjs_prod.createVNode("h6", null, "Instagram"),
              vue_cjs_prod.createVNode("span", null, [
                vue_cjs_prod.createVNode(_component_SocialMediaLink, {
                  username: $options.details.bio.instagram_user,
                  platform: "instagram"
                }, null, 8, ["username"])
              ]),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.facebook_page ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 9 }, [
              vue_cjs_prod.createVNode("h6", null, "Facebook"),
              vue_cjs_prod.createVNode("span", null, [
                vue_cjs_prod.createVNode(_component_SocialMediaLink, {
                  username: $options.details.bio.facebook_page,
                  platform: "facebook"
                }, null, 8, ["username"])
              ]),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.details.bio.wikipedia_page ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 10 }, [
              vue_cjs_prod.createVNode("h6", null, "Wikipedia"),
              vue_cjs_prod.createVNode("span", null, [
                vue_cjs_prod.createVNode(_component_SocialMediaLink, {
                  username: $options.details.bio.wikipedia_page,
                  platform: "wikipedia"
                }, null, 8, ["username"])
              ]),
              vue_cjs_prod.createVNode("hr")
            ])) : vue_cjs_prod.createCommentVNode("", true)
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div>`);
}
const _sfc_setup$8 = _sfc_main$8.setup;
_sfc_main$8.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/[id]/details.vue");
  return _sfc_setup$8 ? _sfc_setup$8(props, ctx) : void 0;
};
const details = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["ssrRender", _sfc_ssrRender$8]]);
const details$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": details
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$7 = {
  name: "PersonExpenses",
  setup() {
    const peopleStore = usePeopleStore();
    return { peopleStore };
  },
  created() {
    this.peopleStore.fetchMpExpenses(this.$route.params.id);
    this.peopleStore.fetchExecExpenses(this.$route.params.id);
    this.peopleStore.fetchReturns(this.$route.params.id);
  },
  methods: {
    formatCurrency(amount) {
      var formatter = new Intl.NumberFormat("en-NZ", {
        style: "currency",
        currency: "NZD"
      });
      if (amount != null) {
        return formatter.format(amount);
      } else {
        return "-";
      }
    }
  },
  computed: {
    person() {
      return this.peopleStore.byIdentifier(this.$route.params.id);
    },
    execExpenses() {
      return this.peopleStore.execExpensesByIdentifier(this.$route.params.id);
    },
    mpExpenses() {
      return this.peopleStore.mpExpensesByIdentifier(this.$route.params.id);
    },
    returns() {
      return this.peopleStore.returnsByIdentifier(this.$route.params.id);
    },
    returnsRows() {
      var rows = [];
      this.returns.forEach((thisReturn) => {
        rows.push([
          thisReturn.election.name,
          thisReturn.electorate.name,
          this.formatCurrency(thisReturn.donations_amount),
          this.formatCurrency(thisReturn.expenses_amount)
        ]);
      });
      return rows;
    },
    execExpensesRows() {
      var rows = [];
      this.execExpenses.forEach((thisReturn) => {
        rows.push([
          thisReturn.report_date,
          this.formatCurrency(thisReturn.wellington_accommodation),
          this.formatCurrency(thisReturn.rest_of_nz_accommodation),
          this.formatCurrency(thisReturn.nz_air_travel),
          this.formatCurrency(thisReturn.nz_surface_travel),
          this.formatCurrency(thisReturn.domestic_total),
          this.formatCurrency(thisReturn.international)
        ]);
      });
      return rows;
    },
    mpExpensesRows() {
      var rows = [];
      this.mpExpenses.forEach((thisReturn) => {
        if (thisReturn.subtotal || thisReturn.interparl) {
          rows.push([
            thisReturn.report_date,
            this.formatCurrency(thisReturn.wellington_accommodation),
            this.formatCurrency(thisReturn.rest_of_nz_accommodation),
            this.formatCurrency(thisReturn.air_travel),
            this.formatCurrency(thisReturn.surface_travel),
            this.formatCurrency(thisReturn.vip_transport),
            this.formatCurrency(thisReturn.subtotal),
            this.formatCurrency(thisReturn.interparl)
          ]);
        }
      });
      return rows;
    }
  }
};
function _sfc_ssrRender$7(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Card = __nuxt_component_2$4;
  const _component_Grid = __nuxt_component_3$2;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}><div class="row mt-3"><div class="col-12"><h4>Expenses and donations</h4></div></div><div class="row"><div class="col-12">`);
  if ($options.mpExpenses && $options.mpExpenses != {}) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h5${_scopeId}>MP expenses</h5><p${_scopeId}>These expenses are those incurred by ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} as a Member of Parliament, and are prepared by the Parliamentary Service. They do not include executive (Ministerial) expenses, since these are prepared by the Department of Internal Affairs and are categorised differently.</p>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Grid, {
            columns: ["Period", "Wellington accommodation", "Rest of New Zealand accommodation", "Air travel", "Surface travel", "VIP Transport", "Grand Total", "Overseas Inter-Parliamentary travel"],
            rows: $options.mpExpensesRows
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode("h5", null, "MP expenses"),
            vue_cjs_prod.createVNode("p", null, "These expenses are those incurred by " + vue_cjs_prod.toDisplayString($options.person.display_name) + " as a Member of Parliament, and are prepared by the Parliamentary Service. They do not include executive (Ministerial) expenses, since these are prepared by the Department of Internal Affairs and are categorised differently.", 1),
            vue_cjs_prod.createVNode(_component_Grid, {
              columns: ["Period", "Wellington accommodation", "Rest of New Zealand accommodation", "Air travel", "Surface travel", "VIP Transport", "Grand Total", "Overseas Inter-Parliamentary travel"],
              rows: $options.mpExpensesRows
            }, null, 8, ["rows"])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, {
      missing: true,
      class: "text-center"
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<p${_scopeId}><strong${_scopeId}>No MP expenses were found for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)}</strong></p>`);
        } else {
          return [
            vue_cjs_prod.createVNode("p", null, [
              vue_cjs_prod.createVNode("strong", null, "No MP expenses were found for " + vue_cjs_prod.toDisplayString($options.person.display_name), 1)
            ])
          ];
        }
      }),
      _: 1
    }, _parent));
  }
  _push(`</div></div><div class="row"><div class="col-12">`);
  if ($options.execExpenses && $options.execExpenses != {}) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h5${_scopeId}>Executive expenses</h5><p${_scopeId}>These expenses are those incurred by ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} as a member of the executive, and are prepared by the Department of Internal Affairs. Expenses relating to when ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} was a Member of Parliament are prepared by the Parliamentary Service and are categorised differently.</p>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Grid, {
            columns: ["Period", "Wellington accommodation", "Rest of New Zealand accommodation", "Domestic air travel", "Domestic surface travel", "Domestic total", "Cabinet-approved overseas travel"],
            rows: $options.execExpensesRows
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode("h5", null, "Executive expenses"),
            vue_cjs_prod.createVNode("p", null, "These expenses are those incurred by " + vue_cjs_prod.toDisplayString($options.person.display_name) + " as a member of the executive, and are prepared by the Department of Internal Affairs. Expenses relating to when " + vue_cjs_prod.toDisplayString($options.person.display_name) + " was a Member of Parliament are prepared by the Parliamentary Service and are categorised differently.", 1),
            vue_cjs_prod.createVNode(_component_Grid, {
              columns: ["Period", "Wellington accommodation", "Rest of New Zealand accommodation", "Domestic air travel", "Domestic surface travel", "Domestic total", "Cabinet-approved overseas travel"],
              rows: $options.execExpensesRows
            }, null, 8, ["rows"])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, {
      missing: true,
      class: "text-center"
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<p${_scopeId}><strong${_scopeId}>No executive expenses were found for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)}</strong></p>`);
        } else {
          return [
            vue_cjs_prod.createVNode("p", null, [
              vue_cjs_prod.createVNode("strong", null, "No executive expenses were found for " + vue_cjs_prod.toDisplayString($options.person.display_name), 1)
            ])
          ];
        }
      }),
      _: 1
    }, _parent));
  }
  _push(`</div></div><div class="row"><div class="col-12">`);
  if ($options.returns && $options.returns != {}) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h5${_scopeId}>Election returns for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)}</h5>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Grid, {
            columns: ["Election", "Electorate", "Donations", "Expenses"],
            rows: $options.returnsRows
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode("h5", null, "Election returns for " + vue_cjs_prod.toDisplayString($options.person.display_name), 1),
            vue_cjs_prod.createVNode(_component_Grid, {
              columns: ["Election", "Electorate", "Donations", "Expenses"],
              rows: $options.returnsRows
            }, null, 8, ["rows"])
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, {
      missing: true,
      class: "text-center"
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<p${_scopeId}><strong${_scopeId}>No election returns were found for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)}</strong></p><p${_scopeId}>WhereTheyStand only has election returns for 2017 and onwards. Only candidates who stand for election in an electorate submit these returns; list only candidates do not.</p>`);
        } else {
          return [
            vue_cjs_prod.createVNode("p", null, [
              vue_cjs_prod.createVNode("strong", null, "No election returns were found for " + vue_cjs_prod.toDisplayString($options.person.display_name), 1)
            ]),
            vue_cjs_prod.createVNode("p", null, "WhereTheyStand only has election returns for 2017 and onwards. Only candidates who stand for election in an electorate submit these returns; list only candidates do not.")
          ];
        }
      }),
      _: 1
    }, _parent));
  }
  _push(`</div></div></div>`);
}
const _sfc_setup$7 = _sfc_main$7.setup;
_sfc_main$7.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/[id]/expenses.vue");
  return _sfc_setup$7 ? _sfc_setup$7(props, ctx) : void 0;
};
const expenses = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["ssrRender", _sfc_ssrRender$7]]);
const expenses$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": expenses
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$6 = {
  name: "PersonHome",
  setup() {
    const peopleStore = usePeopleStore();
    return { peopleStore };
  },
  data() {
    return {
      voteCount: 4,
      billCount: 4
    };
  },
  created() {
    this.peopleStore.fetchVotes(this.$route.params.id);
    this.peopleStore.fetchBills(this.$route.params.id);
    this.peopleStore.fetchVotingSimilarity(this.$route.params.id);
  },
  computed: {
    votes() {
      return this.peopleStore.votesByIdentifier(this.$route.params.id);
    },
    bills() {
      return this.peopleStore.billsByIdentifier(this.$route.params.id);
    },
    person() {
      return this.peopleStore.byIdentifier(this.$route.params.id);
    },
    votingSimilarity() {
      return this.peopleStore.votingSimilarityByIdentifier(this.$route.params.id);
    },
    votesByBill() {
      var votes = {};
      if (!this.votes || this.votes.length === 0) {
        return [];
      }
      this.votes.forEach((vote) => {
        if (!(vote.vote.bill.id in votes)) {
          votes[vote.vote.bill.id] = {
            bill: vote.vote.bill,
            votes: {
              1: {},
              2: {},
              3: {}
            }
          };
        }
        votes[vote.vote.bill.id].votes[vote.vote.reading] = {
          position: vote.position,
          date: vote.date
        };
      });
      return Object.values(votes);
    }
  }
};
function _sfc_ssrRender$6(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_Spinner = __nuxt_component_0$1;
  const _component_PersonPersonalVote = __nuxt_component_1$3;
  const _component_DisplayControlButton = __nuxt_component_2$1;
  const _component_VotingSimilarityDisplay = __nuxt_component_3$1;
  const _component_Card = __nuxt_component_2$4;
  const _component_SmallBill = __nuxt_component_5;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}><div class="row mt-3"><div class="col-12 col-lg-8"><h4>Personal voting history</h4>`);
  if ($options.votes && $options.votes.length === 0) {
    _push(`<p>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "info-circle"] }, null, _parent));
    _push(` WhereTheyStand doesn&#39;t have any votes to show you.</p>`);
  } else if (!$options.votes) {
    _push(`<p>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Spinner, null, null, _parent));
    _push(` Loading...</p>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.votes) {
    _push(`<div class="row"><!--[-->`);
    serverRenderer.exports.ssrRenderList($options.votesByBill.slice(0, $data.voteCount), (value, key) => {
      _push(`<div class="col-12 col-lg-6">`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_PersonPersonalVote, { record: value }, null, _parent));
      _push(`</div>`);
    });
    _push(`<!--]--></div>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.votesByBill.length > $data.voteCount) {
    _push(`<div>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
      onClick: ($event) => $data.voteCount = $options.votesByBill.length
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }, null, _parent2, _scopeId));
          _push2(` Show all votes `);
        } else {
          return [
            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }),
            vue_cjs_prod.createTextVNode(" Show all votes ")
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div>`);
  } else if ($data.voteCount === $options.votesByBill.length && $data.voteCount > 4) {
    _push(`<div>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
      onClick: ($event) => $data.voteCount = 4
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }, null, _parent2, _scopeId));
          _push2(` Show fewer votes `);
        } else {
          return [
            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }),
            vue_cjs_prod.createTextVNode(" Show fewer votes ")
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div>`);
  if ($options.votingSimilarity && $options.votingSimilarity != {}) {
    _push(`<div class="col-12 col-lg-4"><h4>Voting similarity</h4><div class="row"><div class="col-12">`);
    if ($options.votingSimilarity.status == "complete") {
      _push(serverRenderer.exports.ssrRenderComponent(_component_VotingSimilarityDisplay, {
        person: $options.person,
        similarityReport: $options.votingSimilarity
      }, null, _parent));
    } else if ($options.votingSimilarity.status == "insufficient") {
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { gradient: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<p${_scopeId}><strong${_scopeId}>There isn&#39;t enough data to show who ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} votes similarly to.</strong></p><p${_scopeId}>Once ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} has participated in enough personal votes, you will be able to see a list of MPs who tend to vote the same way. Personal votes don&#39;t happen often in New Zealand, so it may be some time.</p>`);
          } else {
            return [
              vue_cjs_prod.createVNode("p", null, [
                vue_cjs_prod.createVNode("strong", null, "There isn't enough data to show who " + vue_cjs_prod.toDisplayString($options.person.display_name) + " votes similarly to.", 1)
              ]),
              vue_cjs_prod.createVNode("p", null, "Once " + vue_cjs_prod.toDisplayString($options.person.display_name) + " has participated in enough personal votes, you will be able to see a list of MPs who tend to vote the same way. Personal votes don't happen often in New Zealand, so it may be some time.", 1)
            ];
          }
        }),
        _: 1
      }, _parent));
    } else {
      _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { gradient: true }, {
        default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<p${_scopeId}><strong${_scopeId}>WhereTheyStand hasn&#39;t checked who ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} votes similarly to.</strong></p><p${_scopeId}>This feature is coming soon, so please check back at a later date.</p><p${_scopeId}>In the meantime, click on any voting record to see more information about that bill and its votes.</p>`);
          } else {
            return [
              vue_cjs_prod.createVNode("p", null, [
                vue_cjs_prod.createVNode("strong", null, "WhereTheyStand hasn't checked who " + vue_cjs_prod.toDisplayString($options.person.display_name) + " votes similarly to.", 1)
              ]),
              vue_cjs_prod.createVNode("p", null, "This feature is coming soon, so please check back at a later date."),
              vue_cjs_prod.createVNode("p", null, "In the meantime, click on any voting record to see more information about that bill and its votes.")
            ];
          }
        }),
        _: 1
      }, _parent));
    }
    _push(`</div></div></div>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div><div class="row"><div class="col-12"><h4>Bills responsible for</h4>`);
  if ($options.bills && $options.bills.length === 0) {
    _push(`<p class="col-12 col-lg-8">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "info-circle"] }, null, _parent));
    _push(` ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} hasn&#39;t sponsored any bills. This doesn&#39;t include any member&#39;s bills that they might have sitting in the &#39;biscut tin&#39; which haven&#39;t been drawn yet.</p>`);
  } else if (!$options.bills) {
    _push(`<p>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Spinner, null, null, _parent));
    _push(` Loading...</p>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.bills) {
    _push(`<div class="row"><!--[-->`);
    serverRenderer.exports.ssrRenderList($options.bills.slice(0, $data.billCount), (bill) => {
      _push(`<div class="col-12 col-md-6">`);
      _push(serverRenderer.exports.ssrRenderComponent(_component_SmallBill, { bill }, null, _parent));
      _push(`</div>`);
    });
    _push(`<!--]--></div>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.bills && $options.bills.length > $data.billCount) {
    _push(`<div>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
      onClick: ($event) => $data.billCount = $options.bills.length
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }, null, _parent2, _scopeId));
          _push2(` Show all bills `);
        } else {
          return [
            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-down"] }),
            vue_cjs_prod.createTextVNode(" Show all bills ")
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div>`);
  } else if ($options.bills && $data.billCount === $options.bills.length && $data.billCount > 4) {
    _push(`<div>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_DisplayControlButton, {
      onClick: ($event) => $data.billCount = 4
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }, null, _parent2, _scopeId));
          _push2(` Show fewer bills `);
        } else {
          return [
            vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "chevron-up"] }),
            vue_cjs_prod.createTextVNode(" Show fewer bills ")
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div></div></div>`);
}
const _sfc_setup$6 = _sfc_main$6.setup;
_sfc_main$6.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/[id]/index.vue");
  return _sfc_setup$6 ? _sfc_setup$6(props, ctx) : void 0;
};
const index$6 = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["ssrRender", _sfc_ssrRender$6]]);
const index$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$6
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$5 = {
  name: "PersonInterests",
  setup() {
    const peopleStore = usePeopleStore();
    return { peopleStore };
  },
  methods: {
    interestsForType(type) {
      return this.interests.interests.filter((element) => {
        return element.type === type.toString();
      });
    },
    interestTypeDescription(type) {
      return {
        1: "Company directorships and controlling interests",
        2: "Other companies and business entities",
        3: "Employment",
        4: "Beneficial interests in, and trusteeships of, trusts",
        5: "Organisations and trusts seeking Government funding",
        6: "Real property",
        7: "Retirement (superannuation) schemes",
        8: "Investment schemes",
        9: "Debtors (those who owe " + this.person.display_name + " money)",
        10: "Creditors (those who " + this.person.display_name + " owes money to)",
        11: "Overseas travel costs",
        12: "Gifts",
        13: "Discharged debts",
        14: "Payments for activities"
      }[type];
    }
  },
  created() {
    this.peopleStore.fetchInterests(this.$route.params.id);
  },
  computed: {
    person() {
      return this.peopleStore.byIdentifier(this.$route.params.id);
    },
    interests() {
      return this.peopleStore.interestsByIdentifier(this.$route.params.id);
    },
    formattedReportDate() {
      return format(parse$2(this.interests.filing_date, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    },
    hasChangedDebt() {
      if (this.interests) {
        return this.interests.interests.filter((element) => {
          return element.description.endsWith("*");
        });
      } else {
        return false;
      }
    }
  }
};
function _sfc_ssrRender$5(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_ExternalLinkButton = __nuxt_component_0$2;
  const _component_Card = __nuxt_component_2$4;
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ class: "container" }, _attrs))}><div class="row mt-3"><div class="col-12"><h4>Financial interests</h4><p>Each year, Members of Parliament are required to declare their financial interests, along with other specified interests.</p><p>This page shows all the interests that ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} declared when the register was last compiled. From time to time, amendments are also made and are incorporated into the list you see here.</p>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
    link: "https://www.parliament.nz/en/mps-and-electorates/mps-financial-interests/",
    text: "Learn more on the Parliament website"
  }, null, _parent));
  if ($options.interests && $options.interests != {}) {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<h5${_scopeId}>Interests for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)} as at ${serverRenderer.exports.ssrInterpolate($options.formattedReportDate)}</h5><!--[-->`);
          serverRenderer.exports.ssrRenderList(12, (i) => {
            _push2(`<div${_scopeId}>`);
            if ($options.interestsForType(i).length) {
              _push2(`<div${_scopeId}><h6${_scopeId}><span class="text-muted"${_scopeId}>${serverRenderer.exports.ssrInterpolate(i)}</span> ${serverRenderer.exports.ssrInterpolate($options.interestTypeDescription(i))}</h6><ul${_scopeId}><!--[-->`);
              serverRenderer.exports.ssrRenderList($options.interestsForType(i), (interest, j) => {
                _push2(`<li${_scopeId}>${serverRenderer.exports.ssrInterpolate(interest.description)} `);
                if (interest.nzbn_match.nzbn) {
                  _push2(`<span${_scopeId}>`);
                  if (interest.nzbn_match.entity_classifications_descs) {
                    _push2(`<br${_scopeId}>`);
                  } else {
                    _push2(`<!---->`);
                  }
                  if (interest.nzbn_match.entity_classifications_descs) {
                    _push2(`<!--[-->`);
                    serverRenderer.exports.ssrRenderList(interest.nzbn_match.entity_classifications_descs, (classification, k) => {
                      _push2(`<span class="text-muted"${_scopeId}>${serverRenderer.exports.ssrInterpolate(classification)}</span>`);
                    });
                    _push2(`<!--]-->`);
                  } else {
                    _push2(`<!---->`);
                  }
                  _push2(`<br${_scopeId}><small${_scopeId}>`);
                  _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
                    link: "https://www.nzbn.govt.nz/mynzbn/nzbndetails/" + interest.nzbn_match.nzbn
                  }, {
                    default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
                      if (_push3) {
                        _push3(`View on NZBN Registry`);
                      } else {
                        return [
                          vue_cjs_prod.createTextVNode("View on NZBN Registry")
                        ];
                      }
                    }),
                    _: 2
                  }, _parent2, _scopeId));
                  _push2(`</small></span>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</li>`);
              });
              _push2(`<!--]--></ul></div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
          });
          _push2(`<!--]-->`);
        } else {
          return [
            vue_cjs_prod.createVNode("h5", null, "Interests for " + vue_cjs_prod.toDisplayString($options.person.display_name) + " as at " + vue_cjs_prod.toDisplayString($options.formattedReportDate), 1),
            (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList(12, (i) => {
              return vue_cjs_prod.createVNode("div", { key: i }, [
                $options.interestsForType(i).length ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("div", { key: 0 }, [
                  vue_cjs_prod.createVNode("h6", null, [
                    vue_cjs_prod.createVNode("span", { class: "text-muted" }, vue_cjs_prod.toDisplayString(i), 1),
                    vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.interestTypeDescription(i)), 1)
                  ]),
                  vue_cjs_prod.createVNode("ul", null, [
                    (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, null, vue_cjs_prod.renderList($options.interestsForType(i), (interest, j) => {
                      return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("li", { key: j }, [
                        vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(interest.description) + " ", 1),
                        interest.nzbn_match.nzbn ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, [
                          interest.nzbn_match.entity_classifications_descs ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("br", { key: 0 })) : vue_cjs_prod.createCommentVNode("", true),
                          interest.nzbn_match.entity_classifications_descs ? (vue_cjs_prod.openBlock(true), vue_cjs_prod.createBlock(vue_cjs_prod.Fragment, { key: 1 }, vue_cjs_prod.renderList(interest.nzbn_match.entity_classifications_descs, (classification, k) => {
                            return vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", {
                              class: "text-muted",
                              key: k
                            }, vue_cjs_prod.toDisplayString(classification), 1);
                          }), 128)) : vue_cjs_prod.createCommentVNode("", true),
                          vue_cjs_prod.createVNode("br"),
                          vue_cjs_prod.createVNode("small", null, [
                            vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
                              link: "https://www.nzbn.govt.nz/mynzbn/nzbndetails/" + interest.nzbn_match.nzbn
                            }, {
                              default: vue_cjs_prod.withCtx(() => [
                                vue_cjs_prod.createTextVNode("View on NZBN Registry")
                              ]),
                              _: 2
                            }, 1032, ["link"])
                          ])
                        ])) : vue_cjs_prod.createCommentVNode("", true)
                      ]);
                    }), 128))
                  ])
                ])) : vue_cjs_prod.createCommentVNode("", true)
              ]);
            }), 64))
          ];
        }
      }),
      _: 1
    }, _parent));
  } else {
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, {
      missing: true,
      class: "text-center"
    }, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(`<p${_scopeId}><strong${_scopeId}>No interests were found for ${serverRenderer.exports.ssrInterpolate($options.person.display_name)}</strong></p><p${_scopeId}>WhereTheyStand doesn&#39;t have interests for recently elected MPs or MPs who left Parliament before the 52nd Parliament opened.</p>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkButton, {
            link: "https://www.parliament.nz/en/mps-and-electorates/mps-financial-interests/",
            text: "View historic or new registers of financial interests on the Parliament website"
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode("p", null, [
              vue_cjs_prod.createVNode("strong", null, "No interests were found for " + vue_cjs_prod.toDisplayString($options.person.display_name), 1)
            ]),
            vue_cjs_prod.createVNode("p", null, "WhereTheyStand doesn't have interests for recently elected MPs or MPs who left Parliament before the 52nd Parliament opened."),
            vue_cjs_prod.createVNode(_component_ExternalLinkButton, {
              link: "https://www.parliament.nz/en/mps-and-electorates/mps-financial-interests/",
              text: "View historic or new registers of financial interests on the Parliament website"
            })
          ];
        }
      }),
      _: 1
    }, _parent));
  }
  if ($options.hasChangedDebt) {
    _push(`<p class="text-muted">An asterisk (*) denotes that the interest rate payable in relation to the debt is less than the normal market interest rate that applied at the time the debt was incurred, or, if the terms of the debt have been amended, at the time of that amendment.</p>`);
  } else {
    _push(`<!---->`);
  }
  if ($options.interests && $options.interests != {}) {
    _push(`<p class="text-muted">Due to the original formatting of this material, some interests might exist on the same line.</p>`);
  } else {
    _push(`<!---->`);
  }
  _push(`</div></div></div>`);
}
const _sfc_setup$5 = _sfc_main$5.setup;
_sfc_main$5.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/[id]/interests.vue");
  return _sfc_setup$5 ? _sfc_setup$5(props, ctx) : void 0;
};
const interests = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["ssrRender", _sfc_ssrRender$5]]);
const interests$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": interests
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$4 = {
  name: "Person",
  setup() {
    const peopleStore = usePeopleStore();
    return { peopleStore };
  },
  created() {
    this.peopleStore.fetch(this.$route.params.id).then(function(response) {
    });
  },
  computed: {
    links() {
      return [
        {
          to: "/people/" + this.$route.params.id,
          name: "Overview"
        },
        {
          to: "/people/" + this.$route.params.id + "/details",
          name: "Details"
        },
        {
          to: "/people/" + this.$route.params.id + "/interests",
          name: "Interests"
        },
        {
          to: "/people/" + this.$route.params.id + "/expenses",
          name: "Expenses"
        }
      ];
    },
    person() {
      return this.peopleStore.byIdentifier(this.$route.params.id);
    }
  }
};
function _sfc_ssrRender$4(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_NuxtPage = vue_cjs_prod.resolveComponent("NuxtPage");
  if ($options.person) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "person-view" }, _attrs))}>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:card",
            content: "summary"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:image",
            content: $options.person.image
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:image:alt",
            content: $options.person.display_name
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:image:alt",
            content: $options.person.display_name
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:image",
            content: $options.person.image
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:card",
            content: "summary"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:site",
            content: "@wherestandnz"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:title",
            content: $options.person.display_name + " - WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:description",
            content: $options.person.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:site_name",
            content: "WhereTheyStand"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:locale",
            content: "en_NZ"
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:description",
            content: $options.person.description
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:title",
            content: $options.person.display_name + " - WhereTheyStand"
          }, null, _parent2, _scopeId));
        } else {
          return [
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:card",
              content: "summary"
            }),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:image",
              content: $options.person.image
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:image:alt",
              content: $options.person.display_name
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:image:alt",
              content: $options.person.display_name
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:image",
              content: $options.person.image
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:card",
              content: "summary"
            }),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:site",
              content: "@wherestandnz"
            }),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:title",
              content: $options.person.display_name + " - WhereTheyStand"
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:description",
              content: $options.person.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:site_name",
              content: "WhereTheyStand"
            }),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:locale",
              content: "en_NZ"
            }),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:description",
              content: $options.person.description
            }, null, 8, ["content"]),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:title",
              content: $options.person.display_name + " - WhereTheyStand"
            }, null, 8, ["content"])
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
      pageTitle: $options.person.display_name,
      pageSubtitle: $options.person.description,
      image: $options.person.image,
      colour: $options.person.colour,
      pageLinks: $options.links
    }, null, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_NuxtPage, { person: $options.person }, null, _parent));
    _push(`</div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$4 = _sfc_main$4.setup;
_sfc_main$4.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/[id].vue");
  return _sfc_setup$4 ? _sfc_setup$4(props, ctx) : void 0;
};
const _id_ = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["ssrRender", _sfc_ssrRender$4]]);
const _id_$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": _id_
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$3 = {
  name: "People",
  setup() {
    const groupsStore = useGroupsStore();
    return { groupsStore };
  },
  data() {
    return {
      filterName: "incumbent"
    };
  },
  created() {
    this.groupsStore.fetchPeople("allLive");
  },
  computed: {
    filter() {
      switch (this.filterName) {
        case "all":
          return ["current", "provisional", "former", "generic"];
        case "incumbent":
          return ["current", "provisional"];
        case "former":
          return ["former"];
        default:
          return [];
      }
    },
    people() {
      return (this.groupsStore.byName("allLive", "people") || []).sort((a, b) => {
        if (a.last_name.toLowerCase() < b.last_name.toLowerCase()) {
          return -1;
        }
        return 1;
      }).filter((person) => {
        if (this.filter.indexOf(person.membership_status) >= 0) {
          return true;
        }
      });
    }
  }
};
function _sfc_ssrRender$3(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_Card = __nuxt_component_2$4;
  const _component_PersonList = __nuxt_component_7;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "people" }, _attrs))} data-v-a3f27900>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
    pageTitle: "People",
    class: "mb-3",
    pageSubtitle: "Current and Former Members of Parliament"
  }, null, _parent));
  _push(`<div class="container" data-v-a3f27900><div class="row" data-v-a3f27900><select class="form-select col-12 mb-3" aria-label="Filter list of people" data-v-a3f27900><option selected value="incumbent" data-v-a3f27900>Current MPs</option><option value="all" data-v-a3f27900>All people</option><option value="former" data-v-a3f27900>Former MPs</option></select></div><div class="row" data-v-a3f27900><h4 class="col-12" data-v-a3f27900>All MPs</h4><div class="col-12" data-v-a3f27900>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { people: $options.people }, null, _parent2, _scopeId));
      } else {
        return [
          vue_cjs_prod.createVNode(_component_PersonList, { people: $options.people }, null, 8, ["people"])
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</div></div></div></div>`);
}
const _sfc_setup$3 = _sfc_main$3.setup;
_sfc_main$3.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/people/index.vue");
  return _sfc_setup$3 ? _sfc_setup$3(props, ctx) : void 0;
};
const index$4 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["ssrRender", _sfc_ssrRender$3], ["__scopeId", "data-v-a3f27900"]]);
const index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$4
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$2 = {
  name: "Terms"
};
function _sfc_ssrRender$2(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_Card = __nuxt_component_2$4;
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  const _component_Grid = __nuxt_component_3$2;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)}>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "Copyright and Privacy" }, null, _parent));
  _push(`<div class="container"><div class="row mt-3"><div class="col-12"><h4>Copyright</h4>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h5${_scopeId}>Original content</h5><p${_scopeId}>Original content on WhereTheyStand is licensed under a `);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://creativecommons.org/licenses/by/4.0/" }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`Creative Commons Attribution 4.0 International Licence.`);
            } else {
              return [
                vue_cjs_prod.createTextVNode("Creative Commons Attribution 4.0 International Licence.")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
        _push2(`</p><p${_scopeId}>This excludes the interactive election results available at `);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`election.wheretheystand.nz`);
            } else {
              return [
                vue_cjs_prod.createTextVNode("election.wheretheystand.nz")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
        _push2(` and at `);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
          default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
            if (_push3) {
              _push3(`tauranga.election.wheretheystand.nz`);
            } else {
              return [
                vue_cjs_prod.createTextVNode("tauranga.election.wheretheystand.nz")
              ];
            }
          }),
          _: 1
        }, _parent2, _scopeId));
        _push2(`. While the election results themselves are not subject to copyright, and the mapping contained in the interactive maps belongs to another copyright holder, copyright is retained in the election results interface.</p><h5${_scopeId}>Third-party content</h5><p${_scopeId}>Much of the content on WhereTheyStand is not original. As a rule, you should assume that full copyright is retained in all non-original content (either by me or the original copyright holder) and ask before reuse.</p><p${_scopeId}>Note that some official information (such as Hansard) does not attract any copyright. This means that the work is not even licensed under the Creative Commons licence; it is free to use without any attribution. You should check this before reusing information.</p>`);
      } else {
        return [
          vue_cjs_prod.createVNode("h5", null, "Original content"),
          vue_cjs_prod.createVNode("p", null, [
            vue_cjs_prod.createTextVNode("Original content on WhereTheyStand is licensed under a "),
            vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://creativecommons.org/licenses/by/4.0/" }, {
              default: vue_cjs_prod.withCtx(() => [
                vue_cjs_prod.createTextVNode("Creative Commons Attribution 4.0 International Licence.")
              ]),
              _: 1
            })
          ]),
          vue_cjs_prod.createVNode("p", null, [
            vue_cjs_prod.createTextVNode("This excludes the interactive election results available at "),
            vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx(() => [
                vue_cjs_prod.createTextVNode("election.wheretheystand.nz")
              ]),
              _: 1
            }),
            vue_cjs_prod.createTextVNode(" and at "),
            vue_cjs_prod.createVNode(_component_ExternalLinkInline, { link: "https://tauranga.election.wheretheystand.nz" }, {
              default: vue_cjs_prod.withCtx(() => [
                vue_cjs_prod.createTextVNode("tauranga.election.wheretheystand.nz")
              ]),
              _: 1
            }),
            vue_cjs_prod.createTextVNode(". While the election results themselves are not subject to copyright, and the mapping contained in the interactive maps belongs to another copyright holder, copyright is retained in the election results interface.")
          ]),
          vue_cjs_prod.createVNode("h5", null, "Third-party content"),
          vue_cjs_prod.createVNode("p", null, "Much of the content on WhereTheyStand is not original. As a rule, you should assume that full copyright is retained in all non-original content (either by me or the original copyright holder) and ask before reuse."),
          vue_cjs_prod.createVNode("p", null, "Note that some official information (such as Hansard) does not attract any copyright. This means that the work is not even licensed under the Creative Commons licence; it is free to use without any attribution. You should check this before reusing information.")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`<h4>Privacy</h4>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
    default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(`<h5${_scopeId}>Privacy for the public</h5><p${_scopeId}> When you use WhereTheyStand, some personal information about you is collected. `);
        _push2(serverRenderer.exports.ssrRenderComponent(_component_Grid, {
          class: "mt-2",
          columns: ["Information", "When you...", "So that..."],
          rows: [
            [
              "Your name and contact information",
              "provide it when you complete a feedback or correction form",
              "you can be contacted regarding your query."
            ],
            [
              "Basic details about your browser and network",
              "access any resource on WhereTheyStand",
              "limited system resources can be protected from abuse and misuse, and to produce aggregated insights into how users access WhereTheyStand.",
              ""
            ],
            [
              "Your activity on WhereTheyStand",
              "interact with WhereTheyStand",
              "the user experience can be understood and improved"
            ],
            [
              "Your searches on WhereTheyStand",
              "search for something",
              "search trends can be understood, and to optimise search functionality"
            ],
            [
              "Your Hansard reader (coming soon) settings",
              "change the default settings in the Hansard reader",
              "they can be automatically set each time you browse Hansard"
            ]
          ]
        }, null, _parent2, _scopeId));
        _push2(` You have the right to correct and access any personal information held about you. However, in the vast majority of cases, identifying you from this information will not be possible; as a result, you won&#39;t be able to access or correct this information. </p><p${_scopeId}>Google Analytics and Google Recaptcha are in use on WhereTheyStand. You may wish to familiarise yourself with Google&#39;s privacy policies.</p><p${_scopeId}>Hosting providers for WhereTheyStand hold your information on behalf of WhereTheyStand. Most information is held by Microsoft in Australia.</p><p${_scopeId}>Occasionally, personal information about you may be contained in Hansard, the written record of Parliamentary debates. This is then republished on WhereTheyStand. Even if this information is wrong, it cannot and will not be corrected. Republished Hansard is a true copy of a document published under the authority of the House and cannot be the subject of a defamation proceeding.</p><h5${_scopeId}>Privacy for Members of Parliament</h5><p${_scopeId}>Information about Members of Parliament is collected from a wide variety of sources</p><h6${_scopeId}>Companies Register matching</h6><p${_scopeId}>WhereTheyStand also accesses the NZBN API to match your pecuniary and other interests in companies to those companies&#39; Companies Register records. To ensure accuracy, the company name must match the listing on the Register of Members&#39; Pecuniary and Other Specified Interests exactly. </p><h6${_scopeId}>Individual (personal or split-party) vote records</h6><p${_scopeId}> When WhereTheyStand updates vote records, it interprets the vote record listed in Hansard on the Parliament website. Hansard only records your surname (and first initial, if necessary) against a voting position. WhereTheyStand must then match this to your profile on WhereTheyStand. </p><p${_scopeId}> Numerous safeguards are in place to ensure the accuracy of this matching. First, names are only matched against a pool of MPs who were Members of Parliament and who had voting rights on the day of the vote (i.e. had been sworn in). Secondly, a vote cannot match to an MP if another vote has already done so for that vote. Finally, after all the individual votes are matched, the totals for each position (ayes, noes, abstentions) are checked against the totals reported by Hansard. These must match for the vote to appear on WhereTheyStand. </p><p${_scopeId}> If you find that you are listed as voting in a way contrary to the way you actually voted, first check that the original Hansard accurately records your position. If it does, and it is still wrong on WhereTheyStand, please get in touch to correct this. </p>`);
      } else {
        return [
          vue_cjs_prod.createVNode("h5", null, "Privacy for the public"),
          vue_cjs_prod.createVNode("p", null, [
            vue_cjs_prod.createTextVNode(" When you use WhereTheyStand, some personal information about you is collected. "),
            vue_cjs_prod.createVNode(_component_Grid, {
              class: "mt-2",
              columns: ["Information", "When you...", "So that..."],
              rows: [
                [
                  "Your name and contact information",
                  "provide it when you complete a feedback or correction form",
                  "you can be contacted regarding your query."
                ],
                [
                  "Basic details about your browser and network",
                  "access any resource on WhereTheyStand",
                  "limited system resources can be protected from abuse and misuse, and to produce aggregated insights into how users access WhereTheyStand.",
                  ""
                ],
                [
                  "Your activity on WhereTheyStand",
                  "interact with WhereTheyStand",
                  "the user experience can be understood and improved"
                ],
                [
                  "Your searches on WhereTheyStand",
                  "search for something",
                  "search trends can be understood, and to optimise search functionality"
                ],
                [
                  "Your Hansard reader (coming soon) settings",
                  "change the default settings in the Hansard reader",
                  "they can be automatically set each time you browse Hansard"
                ]
              ]
            }, null, 8, ["columns", "rows"]),
            vue_cjs_prod.createTextVNode(" You have the right to correct and access any personal information held about you. However, in the vast majority of cases, identifying you from this information will not be possible; as a result, you won't be able to access or correct this information. ")
          ]),
          vue_cjs_prod.createVNode("p", null, "Google Analytics and Google Recaptcha are in use on WhereTheyStand. You may wish to familiarise yourself with Google's privacy policies."),
          vue_cjs_prod.createVNode("p", null, "Hosting providers for WhereTheyStand hold your information on behalf of WhereTheyStand. Most information is held by Microsoft in Australia."),
          vue_cjs_prod.createVNode("p", null, "Occasionally, personal information about you may be contained in Hansard, the written record of Parliamentary debates. This is then republished on WhereTheyStand. Even if this information is wrong, it cannot and will not be corrected. Republished Hansard is a true copy of a document published under the authority of the House and cannot be the subject of a defamation proceeding."),
          vue_cjs_prod.createVNode("h5", null, "Privacy for Members of Parliament"),
          vue_cjs_prod.createVNode("p", null, "Information about Members of Parliament is collected from a wide variety of sources"),
          vue_cjs_prod.createVNode("h6", null, "Companies Register matching"),
          vue_cjs_prod.createVNode("p", null, "WhereTheyStand also accesses the NZBN API to match your pecuniary and other interests in companies to those companies' Companies Register records. To ensure accuracy, the company name must match the listing on the Register of Members' Pecuniary and Other Specified Interests exactly. "),
          vue_cjs_prod.createVNode("h6", null, "Individual (personal or split-party) vote records"),
          vue_cjs_prod.createVNode("p", null, " When WhereTheyStand updates vote records, it interprets the vote record listed in Hansard on the Parliament website. Hansard only records your surname (and first initial, if necessary) against a voting position. WhereTheyStand must then match this to your profile on WhereTheyStand. "),
          vue_cjs_prod.createVNode("p", null, " Numerous safeguards are in place to ensure the accuracy of this matching. First, names are only matched against a pool of MPs who were Members of Parliament and who had voting rights on the day of the vote (i.e. had been sworn in). Secondly, a vote cannot match to an MP if another vote has already done so for that vote. Finally, after all the individual votes are matched, the totals for each position (ayes, noes, abstentions) are checked against the totals reported by Hansard. These must match for the vote to appear on WhereTheyStand. "),
          vue_cjs_prod.createVNode("p", null, " If you find that you are listed as voting in a way contrary to the way you actually voted, first check that the original Hansard accurately records your position. If it does, and it is still wrong on WhereTheyStand, please get in touch to correct this. ")
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</div></div></div></div>`);
}
const _sfc_setup$2 = _sfc_main$2.setup;
_sfc_main$2.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/terms.vue");
  return _sfc_setup$2 ? _sfc_setup$2(props, ctx) : void 0;
};
const terms = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["ssrRender", _sfc_ssrRender$2]]);
const terms$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": terms
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$1 = {
  name: "Vote",
  setup() {
    const votesStore = useVotesStore();
    return { votesStore };
  },
  created() {
    this.votesStore.fetch(this.$route.params.id);
  },
  methods: {
    formatDate(date2) {
      return format(parse$2(date2, "yyyy-MM-dd", new Date()), "d MMMM yyyy");
    }
  },
  data() {
    return {
      listMode: "vote",
      sortFunction: function(a, b) {
        if (a.person && b.person) {
          if (a.person.last_name.toLowerCase() < b.person.last_name.toLowerCase()) {
            return -1;
          } else if (a.person.last_name.toLowerCase() == b.person.last_name.toLowerCase()) {
            return 0;
          } else {
            return 1;
          }
        } else if (a.person && !b.person) {
          return 1;
        } else if (b.person && !a.person) {
          return -1;
        } else if (!a.person && !b.person) {
          if (a.contribution > b.contribution) {
            return -1;
          } else if (a.contribution < b.contribution) {
            return 1;
          } else {
            if (a.party.display_name.toLowerCase() < b.party.display_name.toLowerCase()) {
              return -1;
            } else if (a.party.display_name.toLowerCase() == b.party.display_name.toLowerCase()) {
              return 0;
            } else {
              return 1;
            }
          }
        }
      }
    };
  },
  computed: {
    vote() {
      return this.votesStore.byID(this.$route.params.id);
    },
    readingOrdinal() {
      return this.vote.reading + { 1: "st reading", 2: "nd reading", 3: "rd reading" }[this.vote.reading];
    },
    ayes() {
      return this.vote.positions.filter((pos) => {
        if (pos.position == "y") {
          return true;
        }
      }).sort(this.sortFunction);
    },
    noes() {
      return this.vote.positions.filter((pos) => {
        if (pos.position == "n") {
          return true;
        }
      }).sort(this.sortFunction);
    },
    abstentions() {
      return this.vote.positions.filter((pos) => {
        if (pos.position == "a") {
          return true;
        }
      }).sort(this.sortFunction);
    },
    absences() {
      return this.vote.positions.filter((pos) => {
        if (pos.position == "x") {
          return true;
        }
      }).sort(this.sortFunction);
    },
    relativeDate() {
      return formatDistanceToNow(parseISO(this.vote.last_retrieved)) + " ago";
    }
  }
};
function _sfc_ssrRender$1(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_Head = vue_cjs_prod.resolveComponent("Head");
  const _component_Meta = vue_cjs_prod.resolveComponent("Meta");
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_VoteSummary = __nuxt_component_1$6;
  const _component_Card = __nuxt_component_2$4;
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_ExternalLinkInline = __nuxt_component_3$4;
  const _component_DownloadLink = __nuxt_component_4$1;
  const _component_PartyCard = __nuxt_component_5$2;
  const _component_PersonCard = __nuxt_component_6;
  const _component_PersonList = __nuxt_component_7;
  if ($options.vote) {
    _push(`<div${serverRenderer.exports.ssrRenderAttrs(vue_cjs_prod.mergeProps({ id: "vote-view" }, _attrs))}>`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Head, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            name: "twitter:title",
            content: $options.vote.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          if ($options.vote.question_text) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "twitter:description",
              content: $options.vote.question_text
            }, null, _parent2, _scopeId));
          } else {
            _push2(`<!---->`);
          }
          if ($options.vote.question_text) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              name: "description",
              content: $options.vote.question_text
            }, null, _parent2, _scopeId));
          } else {
            _push2(`<!---->`);
          }
          _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
            property: "og:title",
            content: $options.vote.name + "- WhereTheyStand"
          }, null, _parent2, _scopeId));
          if ($options.vote.question_text) {
            _push2(serverRenderer.exports.ssrRenderComponent(_component_Meta, {
              property: "og:description",
              content: $options.vote.question_text
            }, null, _parent2, _scopeId));
          } else {
            _push2(`<!---->`);
          }
        } else {
          return [
            vue_cjs_prod.createVNode(_component_Meta, {
              name: "twitter:title",
              content: $options.vote.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            $options.vote.question_text ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Meta, {
              key: 0,
              name: "twitter:description",
              content: $options.vote.question_text
            }, null, 8, ["content"])) : vue_cjs_prod.createCommentVNode("", true),
            $options.vote.question_text ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Meta, {
              key: 1,
              name: "description",
              content: $options.vote.question_text
            }, null, 8, ["content"])) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode(_component_Meta, {
              property: "og:title",
              content: $options.vote.name + "- WhereTheyStand"
            }, null, 8, ["content"]),
            $options.vote.question_text ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock(_component_Meta, {
              key: 2,
              property: "og:description",
              content: $options.vote.question_text
            }, null, 8, ["content"])) : vue_cjs_prod.createCommentVNode("", true)
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, {
      pageTitle: $options.vote.bill.name,
      pageSubtitle: $options.readingOrdinal,
      pageDate: $options.vote.vote_date,
      backLink: "/bills/" + $options.vote.bill.id,
      backText: $options.vote.bill.name
    }, null, _parent));
    _push(`<div class="container mt-3">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_VoteSummary, {
      vote: $options.vote,
      countsOnly: true
    }, null, _parent));
    _push(`<h4>Summary</h4><div class="row"><div class="col-12">`);
    _push(serverRenderer.exports.ssrRenderComponent(_component_Card, null, {
      default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
        if (_push2) {
          if ($options.vote.question_text) {
            _push2(`<span${_scopeId}>${serverRenderer.exports.ssrInterpolate($options.vote.question_text)}</span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.vote.outcome_text) {
            _push2(`<strong${_scopeId}><br${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }, null, _parent2, _scopeId));
            _push2(` ${serverRenderer.exports.ssrInterpolate($options.vote.outcome_text)}</strong>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<h5 class="mt-3"${_scopeId}>Vote type</h5>`);
          if ($options.vote.type == "personal") {
            _push2(`<span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "person"] }, null, _parent2, _scopeId));
            _push2(` <strong${_scopeId}>Personal vote: </strong> MPs&#39; votes were cast and recorded individually. </span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.vote.type == "party" && $options.vote.contains_split_votes) {
            _push2(`<span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent2, _scopeId));
            _push2(` <strong${_scopeId}>Split-party vote: </strong> The vote was conducted as a party vote, but one or more parties opted to split their vote across multiple positions. The position of each MP within those parties is recorded individually. </span>`);
          } else {
            _push2(`<!---->`);
          }
          if ($options.vote.type == "party" && !$options.vote.contains_split_votes) {
            _push2(`<span${_scopeId}>`);
            _push2(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent2, _scopeId));
            _push2(` <strong${_scopeId}>Party vote: </strong> Parties cast one vote on behalf of all their MPs. </span>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`<hr${_scopeId}><div class="row"${_scopeId}><div class="col-12 col-xl-6"${_scopeId}>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_ExternalLinkInline, {
            link: "https://www.parliament.nz/en/pb/hansard-debates/rhr/document/" + $options.vote.document_id
          }, {
            default: vue_cjs_prod.withCtx((_2, _push3, _parent3, _scopeId2) => {
              if (_push3) {
                _push3(` View Hansard record`);
              } else {
                return [
                  vue_cjs_prod.createTextVNode(" View Hansard record")
                ];
              }
            }),
            _: 1
          }, _parent2, _scopeId));
          _push2(`</div><div class="col-12 col-xl-6 text-xl-end"${_scopeId}>`);
          _push2(serverRenderer.exports.ssrRenderComponent(_component_DownloadLink, {
            class: "ms-xl-2 me-xl-0",
            resourceType: "vote",
            fileType: "xlsx",
            resourceId: $options.vote.id
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_DownloadLink, {
            class: "ms-xl-2 me-xl-0",
            resourceType: "vote",
            fileType: "csv",
            resourceId: $options.vote.id
          }, null, _parent2, _scopeId));
          _push2(serverRenderer.exports.ssrRenderComponent(_component_DownloadLink, {
            class: "ms-xl-2 me-xl-0",
            resourceType: "vote",
            fileType: "json",
            resourceId: $options.vote.id
          }, null, _parent2, _scopeId));
          _push2(`</div></div>`);
        } else {
          return [
            $options.vote.question_text ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, vue_cjs_prod.toDisplayString($options.vote.question_text), 1)) : vue_cjs_prod.createCommentVNode("", true),
            $options.vote.outcome_text ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("strong", { key: 1 }, [
              vue_cjs_prod.createVNode("br"),
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "arrow-right"] }),
              vue_cjs_prod.createTextVNode(" " + vue_cjs_prod.toDisplayString($options.vote.outcome_text), 1)
            ])) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode("h5", { class: "mt-3" }, "Vote type"),
            $options.vote.type == "personal" ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 2 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "person"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Personal vote: "),
              vue_cjs_prod.createTextVNode(" MPs' votes were cast and recorded individually. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.vote.type == "party" && $options.vote.contains_split_votes ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 3 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Split-party vote: "),
              vue_cjs_prod.createTextVNode(" The vote was conducted as a party vote, but one or more parties opted to split their vote across multiple positions. The position of each MP within those parties is recorded individually. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            $options.vote.type == "party" && !$options.vote.contains_split_votes ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 4 }, [
              vue_cjs_prod.createVNode(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }),
              vue_cjs_prod.createTextVNode(),
              vue_cjs_prod.createVNode("strong", null, "Party vote: "),
              vue_cjs_prod.createTextVNode(" Parties cast one vote on behalf of all their MPs. ")
            ])) : vue_cjs_prod.createCommentVNode("", true),
            vue_cjs_prod.createVNode("hr"),
            vue_cjs_prod.createVNode("div", { class: "row" }, [
              vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-6" }, [
                vue_cjs_prod.createVNode(_component_ExternalLinkInline, {
                  link: "https://www.parliament.nz/en/pb/hansard-debates/rhr/document/" + $options.vote.document_id
                }, {
                  default: vue_cjs_prod.withCtx(() => [
                    vue_cjs_prod.createTextVNode(" View Hansard record")
                  ]),
                  _: 1
                }, 8, ["link"])
              ]),
              vue_cjs_prod.createVNode("div", { class: "col-12 col-xl-6 text-xl-end" }, [
                vue_cjs_prod.createVNode(_component_DownloadLink, {
                  class: "ms-xl-2 me-xl-0",
                  resourceType: "vote",
                  fileType: "xlsx",
                  resourceId: $options.vote.id
                }, null, 8, ["resourceId"]),
                vue_cjs_prod.createVNode(_component_DownloadLink, {
                  class: "ms-xl-2 me-xl-0",
                  resourceType: "vote",
                  fileType: "csv",
                  resourceId: $options.vote.id
                }, null, 8, ["resourceId"]),
                vue_cjs_prod.createVNode(_component_DownloadLink, {
                  class: "ms-xl-2 me-xl-0",
                  resourceType: "vote",
                  fileType: "json",
                  resourceId: $options.vote.id
                }, null, 8, ["resourceId"])
              ])
            ])
          ];
        }
      }),
      _: 1
    }, _parent));
    _push(`</div></div>`);
    if ($options.vote.type == "party") {
      _push(`<div>`);
      if ($options.ayes.length > 0) {
        _push(`<h5 class="mt-3">Ayes</h5>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.ayes.length > 0) {
        _push(`<div class="row"><!--[-->`);
        serverRenderer.exports.ssrRenderList($options.ayes, (position, i) => {
          _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
          if (!position.person) {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PartyCard, {
              party: position.party
            }, {
              default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`${serverRenderer.exports.ssrInterpolate(position.contribution)} vote`);
                  if (position.contribution != 1) {
                    _push2(`<span${_scopeId}>s</span>`);
                  } else {
                    _push2(`<!---->`);
                  }
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(position.contribution) + " vote", 1),
                    position.contribution != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
                  ];
                }
              }),
              _: 2
            }, _parent));
          } else {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, {
              person: position.person
            }, null, _parent));
          }
          _push(`</div>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.noes.length > 0) {
        _push(`<h5 class="mt-3">Noes</h5>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.noes.length > 0) {
        _push(`<div class="row"><!--[-->`);
        serverRenderer.exports.ssrRenderList($options.noes, (position, i) => {
          _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
          if (!position.person) {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PartyCard, {
              party: position.party
            }, {
              default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`${serverRenderer.exports.ssrInterpolate(position.contribution)} vote`);
                  if (position.contribution != 1) {
                    _push2(`<span${_scopeId}>s</span>`);
                  } else {
                    _push2(`<!---->`);
                  }
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(position.contribution) + " vote", 1),
                    position.contribution != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
                  ];
                }
              }),
              _: 2
            }, _parent));
          } else {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, {
              person: position.person
            }, null, _parent));
          }
          _push(`</div>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.abstentions.length > 0) {
        _push(`<h5 class="mt-3">Abstentions</h5>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.abstentions.length > 0) {
        _push(`<div class="row"><!--[-->`);
        serverRenderer.exports.ssrRenderList($options.abstentions, (position, i) => {
          _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
          if (!position.person) {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PartyCard, {
              party: position.party
            }, {
              default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`${serverRenderer.exports.ssrInterpolate(position.contribution)} vote`);
                  if (position.contribution != 1) {
                    _push2(`<span${_scopeId}>s</span>`);
                  } else {
                    _push2(`<!---->`);
                  }
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(position.contribution) + " vote", 1),
                    position.contribution != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
                  ];
                }
              }),
              _: 2
            }, _parent));
          } else {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, {
              person: position.person
            }, null, _parent));
          }
          _push(`</div>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.absences.length > 0) {
        _push(`<h5 class="mt-3">Absences</h5>`);
      } else {
        _push(`<!---->`);
      }
      if ($options.absences.length > 0) {
        _push(`<div class="row"><!--[-->`);
        serverRenderer.exports.ssrRenderList($options.absences, (position, i) => {
          _push(`<div class="col-12 col-md-6 col-lg-4 col-xl-3">`);
          if (!position.person) {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PartyCard, {
              party: position.party
            }, {
              default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`${serverRenderer.exports.ssrInterpolate(position.contribution)} vote`);
                  if (position.contribution != 1) {
                    _push2(`<span${_scopeId}>s</span>`);
                  } else {
                    _push2(`<!---->`);
                  }
                } else {
                  return [
                    vue_cjs_prod.createTextVNode(vue_cjs_prod.toDisplayString(position.contribution) + " vote", 1),
                    position.contribution != 1 ? (vue_cjs_prod.openBlock(), vue_cjs_prod.createBlock("span", { key: 0 }, "s")) : vue_cjs_prod.createCommentVNode("", true)
                  ];
                }
              }),
              _: 2
            }, _parent));
          } else {
            _push(serverRenderer.exports.ssrRenderComponent(_component_PersonCard, {
              person: position.person
            }, null, _parent));
          }
          _push(`</div>`);
        });
        _push(`<!--]--></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    } else {
      _push(`<div>`);
      if ($data.listMode == "vote") {
        _push(`<div>`);
        if ($options.ayes.length > 0) {
          _push(`<h5 class="mt-3">Ayes</h5>`);
        } else {
          _push(`<!---->`);
        }
        _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { class: "col-12" }, {
          default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { positions: $options.ayes }, null, _parent2, _scopeId));
            } else {
              return [
                vue_cjs_prod.createVNode(_component_PersonList, { positions: $options.ayes }, null, 8, ["positions"])
              ];
            }
          }),
          _: 1
        }, _parent));
        if ($options.noes.length > 0) {
          _push(`<h5 class="mt-3">Noes</h5>`);
        } else {
          _push(`<!---->`);
        }
        if ($options.noes.length > 0) {
          _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { class: "col-12" }, {
            default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { positions: $options.noes }, null, _parent2, _scopeId));
              } else {
                return [
                  vue_cjs_prod.createVNode(_component_PersonList, { positions: $options.noes }, null, 8, ["positions"])
                ];
              }
            }),
            _: 1
          }, _parent));
        } else {
          _push(`<!---->`);
        }
        if ($options.abstentions.length > 0) {
          _push(`<h5 class="mt-3">Abstentions</h5>`);
        } else {
          _push(`<!---->`);
        }
        if ($options.abstentions.length > 0) {
          _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { class: "col-12" }, {
            default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { positions: $options.abstentions }, null, _parent2, _scopeId));
              } else {
                return [
                  vue_cjs_prod.createVNode(_component_PersonList, { positions: $options.abstentions }, null, 8, ["positions"])
                ];
              }
            }),
            _: 1
          }, _parent));
        } else {
          _push(`<!---->`);
        }
        if ($options.absences.length > 0) {
          _push(`<h5 class="mt-3">Absences</h5>`);
        } else {
          _push(`<!---->`);
        }
        if ($options.absences.length > 0) {
          _push(serverRenderer.exports.ssrRenderComponent(_component_Card, { class: "col-12" }, {
            default: vue_cjs_prod.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(serverRenderer.exports.ssrRenderComponent(_component_PersonList, { positions: $options.absences }, null, _parent2, _scopeId));
              } else {
                return [
                  vue_cjs_prod.createVNode(_component_PersonList, { positions: $options.absences }, null, 8, ["positions"])
                ];
              }
            }),
            _: 1
          }, _parent));
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    }
    _push(`<div class="col-12"><p class="text-muted">Last updated from Hansard ${serverRenderer.exports.ssrInterpolate($options.relativeDate)}. `);
    if ($options.vote.hansard_status.toLowerCase() == "final") {
      _push(`<span>The Hansard record that contains this vote is final.</span>`);
    } else if ($options.vote.hansard_status.toLowerCase() == "draft") {
      _push(`<span>The Hansard record that contains this vote is in a draft state. Details of the vote are subject to change and the original Hansard will be checked regularly for updates.</span>`);
    } else if ($options.vote.hansard_status.toLowerCase() == "corrected") {
      _push(`<span>The Hansard record that contains this vote is in the &#39;corrected&#39; stage of publication, but it is not yet final. Minor changes are still possible.</span>`);
    } else {
      _push(`<!---->`);
    }
    _push(`</p></div></div></div>`);
  } else {
    _push(`<!---->`);
  }
}
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/votes/[id]/index.vue");
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : void 0;
};
const index$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["ssrRender", _sfc_ssrRender$1]]);
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index$2
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  const _component_PageHeader = __nuxt_component_0$4;
  const _component_FontAwesomeIcon = vue_cjs_prod.resolveComponent("FontAwesomeIcon");
  const _component_VoteFilter = __nuxt_component_1$1;
  _push(`<div${serverRenderer.exports.ssrRenderAttrs(_attrs)} data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_PageHeader, { pageTitle: "Votes" }, null, _parent));
  _push(`<div class="container" data-v-25b873be><div class="row mt-3" data-v-25b873be><div class="col-12" data-v-25b873be><h4 data-v-25b873be>Parliament votes on bills and amendments many times before they become law.</h4><p data-v-25b873be>There are four types of votes that can happen: <ul id="vote-types-list" data-v-25b873be><li data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "person"] }, null, _parent));
  _push(` <strong data-v-25b873be>Personal votes: </strong> MPs&#39; votes were cast and recorded individually. </li><li data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent));
  _push(` <strong data-v-25b873be>Split-party votes: </strong> Votes which are conducted as a party vote, but one or more parties opts to split their vote across multiple positions. The position of each MP within those parties is recorded individually. </li><li data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "people-group"] }, null, _parent));
  _push(` <strong data-v-25b873be>Party votes: </strong> Parties cast one vote on behalf of all their MPs. </li><li data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_FontAwesomeIcon, { icon: ["fas", "microphone-lines"] }, null, _parent));
  _push(` <strong data-v-25b873be>Voice votes: </strong> MPs shout &quot;aye&quot; or &quot;no&quot;, and the Speaker or Chairperson determines the result based on what they hear. The positions of individual MPs or parties aren&#39;t recorded. Any MP can ask for a party or personal vote to be conducted after a voice vote. Voice votes aren&#39;t shown on WhereTheyStand </li></ul></p><p data-v-25b873be>Currently, WhereTheyStand only contains records of &quot;reading votes&quot; (votes for a bill&#39;s first, second or third reading). Over time, this will be expanded to include other votes, like those during the Committee of the whole House stage.</p></div><div class="col-12" data-v-25b873be>`);
  _push(serverRenderer.exports.ssrRenderComponent(_component_VoteFilter, null, null, _parent));
  _push(`</div></div></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = vue_cjs_prod.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/votes/index.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const index = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender], ["__scopeId", "data-v-25b873be"]]);
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": index
}, Symbol.toStringTag, { value: "Module" }));

export { entry$1 as default };
//# sourceMappingURL=server.mjs.map
